"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 27 February 2008 at 10:10:17 am'!!BasicClassOrganizer methodsFor: 'private' stamp: 'Ahe 3/4/2008 21:29'!setSubject: aClassDescription	(aClassDescription name endsWith: Language syntheticNameSeparator)		ifTrue: [self halt].	subject := aClassDescription! !!Class methodsFor: 'accessing class hierarchy' stamp: 'Ahe 12/6/2007 17:16'!subclasses	"Answer a Set containing the receiver's subclasses."	^subclasses == nil		ifTrue: [ self weakSubclasses ]		ifFalse: [ subclasses, self weakSubclasses ]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'Ahe 12/6/2007 16:25'!subclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	subclasses == nil  ifFalse: [ subclasses do: aBlock ].	self weakSubclassesDo: aBlock! !!Class methodsFor: 'accessing class hierarchy' stamp: 'Ahe 12/6/2007 15:50'!subclassesDoGently: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	^self subclassesDo: aBlock! !!Class methodsFor: 'accessing class hierarchy' stamp: 'Ahe 2/19/2008 15:16'!weakSubclasses	^nil = metadata		ifTrue: [#()]		ifFalse: [metadata weakSubclassesOf: self]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'Ahe 2/19/2008 15:16'!weakSubclassesDo: block "<[Class]>"	^nil = metadata		ifFalse: [metadata weakSubclassesOf: self do: block]! !!Class methodsFor: 'organization' stamp: 'Ahe 12/6/2007 00:33'!category: aString 	"Categorize the receiver under the system category, aString, removing it from 	any previous categorization."	| oldCategory |	oldCategory := self basicCategory.	aString isString		ifTrue: [			self basicCategory: aString asSymbol.			self haltIf: 'Irrelevant-Mixin-applications' = aString.			SystemOrganization classify: self name under: self basicCategory ]		ifFalse: [self errorCategoryName].	SystemChangeNotifier uniqueInstance		class: self recategorizedFrom: oldCategory to: self basicCategory! !!ClassBuilder methodsFor: 'class definition' stamp: 'Ahe 12/6/2007 00:43'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	 If unsafe is true do not run any validation checks.	 This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory | 	environ := env.	instVars := Scanner new scanFieldNames: instVarString.	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass := env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse: [oldClass := nil]  "Already checked in #validateClassName:"		ifTrue: [			copyOfOldClass := oldClass copy.			copyOfOldClass superclass addSubclass: copyOfOldClass].			[unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined. \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass := self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.	] ifFalse:[		"Reuse the old class"		newClass := oldClass.	].	"Install the class variables and pool dictionaries... "	force := (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization := environ ifNotNil:[environ organization].	category isNil		ifTrue: [ newCategory := Categorizer nullCategory ]		ifFalse: [			newCategory := category asSymbol.			oldClass isNil ifFalse: [				oldCategory := (organization categoryOfElement: oldClass name) asSymbol			].			organization classify: newClass name under: newCategory		].	newClass environment: environ.	"... recompile ..."	newClass := self recompile: force from: oldClass to: newClass mutate: false.	oldClass == nil ifTrue:		["Create accessors etc for new language classes."		 newClass language processDefinitionOf: newClass].	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[environ at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		Smalltalk flushClassNameCache.	].	newClass doneCompiling.	"... notify interested clients ..."	oldClass isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.		^ newClass].	newCategory ~= oldCategory 		ifTrue: [SystemChangeNotifier uniqueInstance class: newClass recategorizedFrom: oldCategory to: category]		ifFalse: [SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.].] ensure: 		[copyOfOldClass ifNotNil: [copyOfOldClass superclass removeSubclass: copyOfOldClass].		Behavior flushObsoleteSubclasses.		].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'Ahe 12/7/2007 16:44'!recompile: force from: oldClass to: newClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	oldClass == nil ifTrue:[^ newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		^newClass].	currentClassIndex := 0.	maxClassIndex := oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:		[ "Recompile from newClass without mutating"		self			informUserOfActivity: 'Recompiling ', oldClass name			during:				[ newClass isSystemDefined ifFalse:[progress := nil].				newClass withAllSubclassesDo:					[ :cl |					self showProgressFor: cl.					cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	self		informUserOfActivity: 'Recompiling Mutating ', oldClass name		during:			[ newClass isSystemDefined ifFalse:[progress := nil].			self mutate: oldClass to: newClass ].	^oldClass "now mutated to newClass"! !!ClassBuilder methodsFor: 'class mutation' stamp: 'Ahe 12/7/2007 17:13'!mutate: oldClass to: newClass	"Mutate the old class and subclasses into newClass and subclasses.	Note: This method is slightly different from: #mutate:toSuper: since	here we are at the root of reshaping and have two distinct roots."	| newSubclass |	self showProgressFor: oldClass.		"Create accessors etc for new language classes."	newClass language processDefinitionOf: newClass.	"Convert the subclasses"	oldClass subclasses do:[:oldSubclass| 		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.		self mutate: oldSubclass to: newSubclass.	].	"And any obsolete ones"	oldClass obsoleteSubclasses do:[:oldSubclass|		oldSubclass ifNotNil:[			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.			self mutate: oldSubclass to: newSubclass.		].	].	self update: oldClass to: newClass.	^newClass! !
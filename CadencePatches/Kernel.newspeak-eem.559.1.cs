'From nsboot-2011-08-03 of 3 August 2011 [latest update: #10966] on 7 August 2012 at 11:22:29 am'!SharedPool subclass: #ChronologyConstants	instanceVariableNames: 'seconds offset jdn nanos '	classVariableNames: 'DayNames DaysInMonth MonthNames NanosInMillisecond NanosInSecond SecondsInDay SecondsInHour SecondsInMinute SqueakEpoch OneDay MicrosecondsInDay Zero '	poolDictionaries: ''	category: 'Kernel-Chronology'!!ChronologyConstants commentStamp: 'brp 3/12/2004 14:34' prior: 0!ChronologyConstants is a SharedPool for the constants used by the Kernel-Chronology classes.!Magnitude subclass: #DateAndTime	instanceVariableNames: 'seconds offset jdn nanos '	classVariableNames: 'ClockProvider DaysSinceEpoch LastMilliSeconds LastTick LastTickSemaphore LocalTimeZone MilliSecondOffset OffsetsAreValid '	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!DateAndTime commentStamp: 'brp 5/13/2003 08:07' prior: 0!I represent a point in UTC time as defined by ISO 8601. I have zero duration.My implementation uses three SmallIntegers and a Duration:jdn		- julian day number.seconds	- number of seconds since midnight.nanos	- the number of nanoseconds since the second.offset	- duration from UTC.The nanosecond attribute is almost always zero but it defined for full ISO compliance and is suitable for timestamping.!InstructionStream subclass: #ContextPart	instanceVariableNames: 'stackp '	classVariableNames: 'PrimitiveFailToken QuickStep ValueIndex '	poolDictionaries: ''	category: 'Kernel-Methods'!!ContextPart commentStamp: '<historical>' prior: 0!To the instruction parsing ability of InstructionStream I add the actual semantics for execution. The execution state is stored in the indexable fields of my subclasses. This includes temporary variables and a stack of values used in evaluating expressions. The actual semantics of execution can be found in my category "system simulation" and "instruction decode". These methods exactly parallel the operation of the Smalltalk machine itself.	The simulator is a group of my methods that do what the Smalltalk interpreter does: execute Smalltalk bytecodes. By adding code to the simulator, you may take statistics on the running of Smalltalk methods. For example,	Transcript show: (ContextPart runSimulated: [3 factorial]) printString.!!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:37'!tryNamedPrimitive	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:37'!tryNamedPrimitive: arg1	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:37'!tryNamedPrimitive: arg1 with: arg2	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:37'!tryNamedPrimitive: arg1 with: arg2 with: arg3	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7 with: arg8	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:'' error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!ProtoObject methodsFor: 'apply primitives' stamp: 'eem 1/4/2009 09:38'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: errorCode>	^ContextPart primitiveFailTokenFor: errorCode! !!Object methodsFor: 'testing' stamp: 'yk 6/25/2012 16:51'!isAppObject	"Used by an application to figure out if object understand the application specific API"^false! !!Object methodsFor: 'testing' stamp: 'eem 11/2/2011 10:59'!shouldBePrintedAsLiteralVisiting: aSet	^self isLiteral! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 9/16/2011 11:26'!copyWith: aPropertyOrPragma "<Association|Pragma>"	"Answer a copy of the receiver which includes aPropertyOrPragma"	| bs copy |	(Association == aPropertyOrPragma class	 or: [Pragma == aPropertyOrPragma class]) ifFalse:		[self error: self class name, ' instances should hold only Associations or Pragmas.'].	"no need to initialize here; we're copying all inst vars"	copy := self class basicNew: (bs := self basicSize) + 1.	1 to: bs do:		[:i|		copy basicAt: i put: (self basicAt: i) shallowCopy].	copy basicAt: bs + 1 put: aPropertyOrPragma.	1 to: self class instSize do:		[:i| copy instVarAt: i put: (self instVarAt: i)].	^copy! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 9/16/2011 11:27'!copyWithout: aPropertyOrPragma "<Association|Pragma>"	"Answer a copy of the receiver which no longer includes aPropertyOrPragma"	| bs copy offset |	"no need to initialize here; we're copying all inst vars"	copy := self class basicNew: (bs := self basicSize) - ((self includes: aPropertyOrPragma)															ifTrue: [1]															ifFalse: [0]).	offset := 0.	1 to: bs do:		[:i|		(self basicAt: i) = aPropertyOrPragma			ifTrue: [offset := 1]			ifFalse: [copy basicAt: i - offset put: (self basicAt: i) shallowCopy]].	1 to: self class instSize do:		[:i| copy instVarAt: i put: (self instVarAt: i)].	^copy! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 9/14/2011 17:50'!postCopy	"After copying we must duplicate any associations and pragmas so they don't end up being shared."	1 to: self basicSize do:		[:i| self basicAt: i put: (self basicAt: i) shallowCopy]! !!AdditionalMethodState methodsFor: 'printing' stamp: 'eem 9/14/2011 17:18'!printOn: aStream	super printOn: aStream.	aStream space; nextPut: $(; print: self identityHash; nextPut: $)! !!AdditionalMethodState methodsFor: 'printing' stamp: 'eem 9/26/2011 16:59'!printPropertiesOn: aStream	"This is for decompilation."	self propertyKeysAndValuesDo:		[:prop :val|		aStream crtab; nextPut: $<.		prop = #on:in:			ifTrue:				[prop keywords with: val do:					[:k :v | aStream nextPutAll: k; space; nextPutAll: v; space]]			ifFalse:				[prop = #on					ifTrue: [aStream nextPutAll: prop; nextPutAll:': '; nextPutAll: val] 					ifFalse: [aStream nextPutAll: prop; nextPutAll:': '; print: val]]. 		aStream nextPut: $>]! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ul 5/7/2011 02:11'!whichMethodsStoreInto: instVarName 	"Answer a collection of CompiledMethod whose methods access the argument, instVarName, as a named instance variable."		| instVarIndex |	instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^Array new ].	^self methodDict values select: [:eachMethod | eachMethod writesField: instVarIndex ]		"Point whichMethodsStoreInto: 'x'."! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 4/26/2012 10:20'!endPC	^self blockCreationBytecodeMessage arguments last + startpc - 1! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 4/26/2012 11:01'!numTemps	"Answer the number of temporaries for the receiver; this includes	 the number of arguments and the number of copied values."	| blockCreationBytecodeSize |	^self numCopiedValues	 + self numArgs	 + (BlockLocalTempCounter			tempCountForBlockAt: startpc - (blockCreationBytecodeSize := 4)			in: self method)! !!BlockClosure methodsFor: 'testing' stamp: 'eem 4/26/2012 10:21'!hasMethodReturn	"Answer whether the receiver has a method-return ('^') in its code."	| scanner endpc |	scanner := InstructionStream new method: outerContext method pc: startpc.	endpc := self endPC.	scanner scanFor: [:byte | (byte between: 120 and: 124) or: [scanner pc > endpc]].	^scanner pc <= endpc! !!BlockClosure methodsFor: 'testing' stamp: 'eem 4/26/2012 10:42'!isClean	"Answer if the receiver does not close-over any variables other than globals, and does	 not ^-return (does not close over the home context).  Clean blocks are amenable to	 being created at compile-time."	self numCopiedValues > 0 ifTrue:		[^false].	self abstractBytecodeMessagesDo:		[:msg|		(#(	pushReceiver			pushReceiverVariable: popIntoReceiverVariable: storeIntoReceiverVariable:			methodReturnConstant: methodReturnReceiver methodReturnTop)				includes: msg selector) ifTrue:					[^false]].	^true	"clean:"		"[] isClean"		"[:a :b| a < b] isClean"	"unclean"		"[^nil] isClean"		"[self class] isClean"		"| v | v := 0.		 [v class] isClean"! !!BlockClosure methodsFor: 'scanning' stamp: 'eem 4/26/2012 10:45'!abstractBytecodeMessagesDo: aBlock	"Evaluate aBlock with the sequence of abstract bytecodes in the receiver."	self method		abstractBytecodeMessagesFrom: startpc		to: self endPC		do: aBlock	"| msgs |	 msgs := OrderedCollection new.	 (SortedCollection sortBlock: [:a :b| a compare: b caseSensitive: false]) sortBlock		abstractBytecodeMessagesDo: [:msg| msgs add: msg selector].	 msgs"! !!BlockClosure methodsFor: 'scanning' stamp: 'eem 4/26/2012 11:02'!blockCreationBytecodeMessage	"Answer the abstract bytecode message that created the receiver."	| blockCreationBytecodeSize |	^self method abstractBytecodeMessageAt: startpc - (blockCreationBytecodeSize := 4)	"(SortedCollection sortBlock: [:a :b| a compare: b caseSensitive: false]) sortBlock blockCreationBytecodeMessage"! !!BlockClosure methodsFor: 'system simulation' stamp: 'eem 12/7/2011 12:21'!simulateValueWithArguments: anArray caller: aContext	| newContext sz |	(anArray class ~~ Array	 or: [numArgs ~= anArray size]) ifTrue:		[^ContextPart primitiveFailTokenFor: nil].	newContext := (MethodContext newForMethod: outerContext method)						setSender: aContext						receiver: outerContext receiver						method: outerContext method						closure: self						startpc: startpc.	sz := self basicSize.	newContext stackp: sz + numArgs.	1 to: numArgs do:		[:i| newContext at: i put: (anArray at: i)].	1 to: sz do:		[:i| newContext at: i + numArgs put: (self at: i)].	^newContext! !!Class methodsFor: 'testing' stamp: 'nice 5/6/2011 22:54'!whichMethodsStoreInto: varName 	"Answer a collection of CompiledMethod whose methods access the argument, varName, as a named class variable. Or let super try with a named instance variable."	| ref |	ref := self classPool		associationAt: varName		ifAbsent: [ ^ super whichMethodsStoreInto: varName ].	^self methodDict values select: [:eachMethod | eachMethod writesRef: ref ]! !!AdditionalMethodState class methodsFor: 'instance creation' stamp: 'eem 9/16/2011 11:25'!forMethod: aMethod selector: aSelector	^(self new: 0)		selector: aSelector;		setMethod: aMethod;		yourself! !!AdditionalMethodState class methodsFor: 'instance creation' stamp: 'eem 9/16/2011 11:26'!selector: aSelector with: aPropertyOrPragma	^(self new: 1)		selector: aSelector;		basicAt: 1 put: aPropertyOrPragma;		yourself! !!ChronologyConstants class methodsFor: 'class initialization' stamp: 'eem 7/19/2012 16:36'!initialize	"ChronologyConstants initialize" 				SqueakEpoch := 2415386. 		"Julian day number of 1 Jan 1901" 	SecondsInDay := 86400.	MicrosecondsInDay := SecondsInDay * 1000 * 1000..	SecondsInHour := 3600.	SecondsInMinute := 60.	NanosInSecond := 10 raisedTo: 9.	NanosInMillisecond := 10 raisedTo: 6.	DayNames := #(Sunday Monday Tuesday Wednesday Thursday Friday Saturday).			MonthNames := #(January February March April May June July 			August September October November December).	DaysInMonth := #(31 28 31 30 31 30 31 31 30 31 30 31)! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 9/15/2011 17:04'!properties	"Answer the method properties of the receiver."	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector]		ifFalse: [self class methodPropertiesClass forMethod: self selector: propertiesOrSelector]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 4/12/2012 18:05'!voidCogVMState	"Tell the VM to remove all references to any machine code form of the method.	 This primitive must be called whenever a method is in use and modified.  This is	 more aggressive (and *much* more costly) than flushCache since it must search	 through all context objects, making sure that none have a (hidden) machine code pc	 in the receiver.  Since modifying a method will likely change the generated machine code,	 modifying a method (rather than redefining it) requires this more aggressive flush."	<primitive: 215>	^self primitiveFailed! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 9/26/2011 17:25'!decompile	"Return the decompiled parse tree that represents self"	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	^class decompilerClass new decompile: selector in: class method: self methodForDecompile! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 9/26/2011 17:26'!decompileWithTemps	"Return the decompiled parse tree that represents self, but get the temp names	 by compiling the sourcecode..."	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	(self fileIndex > 0 and: [(SourceFiles at: self fileIndex) isNil]) ifTrue: [			"Emergency or no source file -- decompile without temp names "			^self decompile.	].	^((self decompilerClass new withTempNames: self methodNode schematicTempNamesString)						decompile: selector						in: class						method: self methodForDecompile)! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 9/26/2011 17:24'!methodForDecompile	"This is a hook to allow recursive methods like MwMethodWrapper to avoid infinite recursion."	^self! !!CompiledMethod methodsFor: 'initialize-release' stamp: 'eem 9/14/2011 17:33'!copyWithTrailerBytes: trailer"Testing:	(CompiledMethod compiledMethodAt: #copyWithTrailerBytes:)		tempNamesPut: 'copy end '"	| copy end start penultimateLiteral |	start := self initialPC.	end := self endPC.	copy := trailer createMethod: end - start + 1 class: self class header: self header.	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].	(penultimateLiteral := self penultimateLiteral) isMethodProperties ifTrue:		[copy penultimateLiteral: (penultimateLiteral copy									setMethod: copy;									yourself)].	start to: end do: [:i | copy at: i put: (self at: i)].	^copy! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 1/4/2012 11:28'!timeStamp	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"	| file preamble stamp tokens tokenCount |	self fileIndex = 0 ifTrue: [^ String new].  "no source pointer for this method"	file := SourceFiles at: self fileIndex.	file ifNil: [^ String new].  "sources file not available"	"file does not exist happens in secure mode"	file := [file readOnlyCopy] on: FileDoesNotExistException do:[:ex| nil].	file ifNil: [^ String new].	preamble := self getPreambleFrom: file at: (0 max: self filePosition - 3).	stamp := String new.	tokens := (preamble findString: 'methodsFor:' startingAt: 1) > 0					ifTrue: [Scanner new scanTokens: preamble]					ifFalse: [Array new  "ie cant be back ref"].	((tokenCount := tokens size) > 6	 and: [(tokens at: tokenCount - 5) = #methodsFor:	 and: [(tokens at: tokenCount - 3) = #stamp:]]) ifTrue:		["New format gives change stamp and unified prior pointer"		stamp := tokens at: tokenCount - 2].	(tokenCount > 4	 and: [(tokens at: tokenCount - 3) = #methodsFor:	 and: [(tokens at: tokenCount - 1) = #stamp:]]) ifTrue:		["New format gives change stamp and unified prior pointer"		stamp := tokens at: tokenCount].	file close.	^stamp! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 12/6/2011 13:47'!abstractBytecodeMessageAt: pc	"Answer the abstract bytecode message at pc in the receiver."	^[(InstructionStream new method: self pc: pc) interpretNextInstructionFor: nil]		on: MessageNotUnderstood		do: [:ex| ex message]! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 12/6/2011 13:35'!abstractBytecodeMessagesDo: aBlock	"Evaluate aBlock with the sequence of abstract bytecodes in the receiver"	self abstractBytecodeMessagesFrom: self initialPC		to: self endPC		do: aBlock	"| msgs |	 msgs := OrderedCollection new.	 CompiledMethod >> #abstractBytecodeMessagesFrom:to: abstractBytecodeMessagesDo:		[:msg| msgs add: msg selector].	 msgs"! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 12/6/2011 13:23'!abstractBytecodeMessagesFrom: startpc to: endpc do: aBlock	"Evaluate aBlock with the sequence of abstract bytecodes from startpc through endpc in the receiver"	| scanner |	scanner := InstructionStream new method: self pc: startpc.	[scanner pc <= endpc] whileTrue:		[[scanner interpretNextInstructionFor: nil]			on: MessageNotUnderstood			do: [:ex| aBlock value: ex message]]	"| m msgs |	 msgs := OrderedCollection new.	 (m := CompiledMethod >> #abstractBytecodeMessagesFrom:to:)		abstractBytecodeMessagesFrom: m initialPC		to: m endPC		do: [:msg| msgs add: msg selector].	 msgs"! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 9/26/2011 17:25'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| trailer source |	(self properties includesKey: #source) ifTrue:		[^self properties at: #source].	trailer := self trailer.	trailer tempNames ifNotNil: [:namesString | 		"Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: namesString)				decompile: selector in: class method: self methodForDecompile)			decompileString].		trailer sourceCode ifNotNil: [:code | ^ code ].		trailer hasSourcePointer ifFalse: [		"No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self methodForDecompile)			decompileString].	"Situation normal;  read the sourceCode from the file"	source := [self getSourceFromFileAt: trailer sourcePointer]				on: Error		"An error can happen here if, for example, the changes file has been truncated by an aborted download.  The present solution is to ignore the error and fall back on the decompiler.  A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling into this error case, random source code will get returned."				do: [ :ex | ex return: nil].			^source ifNil: [			"Something really wrong -- decompile blind (no temps)"			 (class decompilerClass new decompile: selector in: class method: self methodForDecompile)				decompileString]! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 9/29/2011 14:06'!setSourcePointer: srcPointer	"We can't change the trailer of existing method, since it could have a	 completely different format. Therefore we need to generate a copy	 with new trailer, containing a srcPointer, and then #become it."	| trailer copy start |	trailer := srcPointer = 0				ifTrue: "catch the common case of setting the source pointer to 0 when already 0"					[self sourcePointer = 0 ifTrue:						[^self].					 CompiledMethodTrailer empty]				ifFalse:					[CompiledMethodTrailer new sourcePointer: srcPointer].	copy := self copyWithTrailerBytes: trailer.	"ar 3/31/2010: Be a bit more clever since #become: is slow.	If the old and the new trailer have the same size, just replace it."	(self trailer class == trailer class and:[self size = copy size])		ifTrue:			[start := self endPC + 1.			self replaceFrom: start to: self size with: copy startingAt: start]		ifFalse:			[self becomeForward: copy].	^self "will be copy if #become was needed"! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 9/15/2011 17:04'!propertyValueAt: propName put: propValue	"Set or add the property with key propName and value propValue.	 If the receiver does not yet have a method properties create one and replace	 the selector with it.  Otherwise, either relace propValue in the method properties	 or replace method properties with one containing the new property."	| propertiesOrSelector |	(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifFalse:		[self penultimateLiteral: ((self class methodPropertiesClass									selector: propertiesOrSelector									with: (Association											key: propName asSymbol											value: propValue))									setMethod: self;									yourself).		^propValue].	(propertiesOrSelector includesProperty: propName) ifTrue:		[^propertiesOrSelector at: propName put: propValue].	self penultimateLiteral: (propertiesOrSelector								copyWith: (Association												key: propName asSymbol												value: propValue)).	^propValue! !!CompiledMethod methodsFor: 'as-yet-unclassified' stamp: 'eem 11/4/2011 14:36'!pcPreviousTo: pc	| scanner client prevPc |	self flag: 'belongs in DebuggerMethodMap?'.	(pc isNil or: [pc > self endPC]) ifTrue: [^self endPC].	scanner := InstructionStream on: self.	client := InstructionClient new.	[scanner pc < pc] whileTrue:		[prevPc := scanner pc.		 scanner interpretNextInstructionFor: client].	^prevPc! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 9/14/2011 10:53'!new	"This will not make a meaningful method, but it could be used	to invoke some otherwise useful method in this class."	^self newMethod: 2 header: 1024! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 9/13/2011 15:16'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits |	nTemps > 63 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		nLits > 255 ifTrue:		[^ self error: 'Cannot compile -- too many literals variables'].		largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits := primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high bit of primitive no. is in the 29th bit of header"				primitiveIndex > 16r3FF ifTrue: [self error: 'prim num too large'].				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19)].	^trailer		createMethod: numberOfBytes		class: self		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 9/13/2011 15:18'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex flag: flag	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits flagBit |	nTemps > 63 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		nLits > 255 ifTrue:		[^ self error: 'Cannot compile -- too many literals variables'].		largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	"For now the high bit of the primitive no. is in a high bit of the header"	primBits := (primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19).	flagBit := flag ifTrue: [ 1 ] ifFalse: [ 0 ].	"Copy the source code trailer to the end"	^trailer		createMethod: numberOfBytes		class: self		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits +				(flagBit bitShift: 29)! !!CompiledMethod class methodsFor: 'accessing class hierarchy' stamp: 'eem 9/16/2011 11:12'!methodPropertiesClass	"Answer the class to use to create a method's properties, which can be a poor man's way	 to add instance variables to subclassses of CompiledMethod.  Subclasses of CompiledMethod	 should define a corresponding subclass of AdditionalMethodState that adds any instance variables	 required, and override this method to answer that class."	^AdditionalMethodState! !!CompiledMethodTrailer methodsFor: 'creating a method' stamp: 'eem 9/13/2011 15:14'!createMethod: numberOfBytesForAllButTrailer class: aCompiledMethodClass header: headerWord 	| meth |	encodedData ifNil: [self encode].		meth := aCompiledMethodClass newMethod: numberOfBytesForAllButTrailer + size header: headerWord.	"copy the encoded trailer data"	1 to: size do:		[:i | meth at: meth size - size + i put: (encodedData at: i)].	^meth! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'IgorStasenko 5/10/2011 13:21'!encodeVarLengthSourcePointer	"source pointer must be >=0"	[data >= 0] assert.		encodedData := 		data = 0 ifTrue: [ #[0] ] 		ifFalse: [ ByteArray streamContents: [:str |		| value |		value := data.		[value > 0] whileTrue: [			value > 127 ifTrue: [ str nextPut: 128 + (value bitAnd: 16r7F) ]				ifFalse: [ str nextPut: value. ].			value := value >> 7.			].		]].	encodedData := encodedData reversed copyWith: (self kindAsByte)! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'eem 7/19/2012 16:05'!now	"Answer an instance of me in local time."	| local days usecs |	local := Time localMicrosecondClock.	days := local // MicrosecondsInDay.	usecs := local \\ MicrosecondsInDay.	^self basicNew			setJdn: days + SqueakEpoch			seconds: (usecs // 1000000)			nano: (usecs \\ 1000000 * 1000) 			offset: self localOffset! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'eem 7/19/2012 18:14'!milliSecondsSinceMidnight	^Time milliSecondsSinceMidnight! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'eem 7/19/2012 16:36'!nowWithOffset: aDuration	"Answer an instance of me in local time offset by the argument."	| local days usecs |	local := Time localMicrosecondClock.	days := local // MicrosecondsInDay.	usecs := local \\ MicrosecondsInDay.	^self basicNew			setJdn: days + SqueakEpoch			seconds: (usecs // 1000000)			nano: (usecs \\ 1000000 * 1000) 			offset: aDuration! !!DateAndTime class methodsFor: 'clock provider' stamp: 'eem 7/19/2012 18:22'!clock 	 "the provider of real time seconds/milliseconds."	^Time! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 6/8/2012 15:30'!pushExplicitOuter: n "<Integer>"	"Push the enclosing object at level n."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 6/8/2012 15:30'!pushImplicitReceiverForMessage: selector "<Symbol>"	"Push Implicit Receiver for Selector bytecode."! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 6/8/2012 15:31'!sendToDynamicSuperclass: selector numArgs: numArgs "<Integer>" 	"Send Message With Selector, selector to the dynamic superclass.	 The arguments of the message are found in the top numArgs locations	 on the stack and the receiver just below them."! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 5/16/2012 17:06'!selectorToSendOrSelf	"If this instruction is a send, answer the selector, otherwise answer self."	| byte byte2 |	byte := self method at: pc.	byte < 126 ifTrue:		[^self].	byte >= 176		ifTrue: 			["special byte or short send"			 ^byte >= 208				ifTrue: [self method literalAt: (byte bitAnd: 15) + 1]				ifFalse: [Smalltalk specialSelectorAt: byte - 176 + 1]]		ifFalse: 			[byte <= 134 ifTrue: 				[byte = 126 ifTrue: "sendDynamicSuper"					[byte2 := self method at: pc + 2.					 ^self method literalAt: byte2 + 1].				 byte2 := self method at: pc + 1.				 byte = 131 ifTrue: [^self method literalAt: byte2 \\ 32 + 1].				 byte = 132 ifTrue: [byte2 < 64 ifTrue: [^self method literalAt: (self method at: pc + 2) + 1]].				 byte = 133 ifTrue: [^self method literalAt: byte2 \\ 32 + 1].				 byte = 134 ifTrue: [^self method literalAt: byte2 \\ 64 + 1]]]! !!InstructionStream methodsFor: 'testing' stamp: 'eem 12/7/2011 10:03'!willReallySend	"Answer whether the next bytecode is a real message-send,	not blockCopy:."	| byte |	byte := self method at: pc.	^byte = 126 "sendDynamicSuper"	  or: [byte >= 131		 and: [byte ~= 200		 and: [byte >= 176   "special send or short send"			or: [byte <= 134 "long sends"					and: [| litIndex |					"long form support demands we check the selector"					litIndex := byte = 132								ifTrue: [(self method at: pc + 1) // 32 > 1 ifTrue: [^false].										self method at: pc + 2]								ifFalse: [byte = 134											ifTrue: [(self method at: pc + 1) bitAnd: 2r111111]											ifFalse: [(self method at: pc + 1) bitAnd: 2r11111]].					(self method literalAt: litIndex + 1) ~~ #blockCopy:]]]]]! !!InstructionStream methodsFor: 'testing' stamp: 'eem 12/7/2011 10:03'!willSend	"Answer whether the next bytecode is a message-send."	| byte |	byte := self method at: pc.	^byte = 126					"sendDynamicSuper"	  or: [byte >= 131		  and: [byte >= 176 		"special send or short send"			or: [byte <= 134]]]	"long sends"! !!ContextPart methodsFor: 'controlling' stamp: 'eem 5/12/2009 21:23'!quickSend: selector to: receiver with: arguments super: superFlag	"Send the given selector with arguments in an environment which closely resembles	 the non-simulating environment, with an interjected unwind-protected block to catch	 nonlocal returns.  Attention: don't get lost!!  This beautiful method is due to	 Hans-Martin Mosner.  Eliot Miranda merely added the mirror primitive code."	| oldSender contextToReturnTo result lookupClass |	contextToReturnTo := self.	lookupClass := superFlag					ifTrue: [self method methodClassAssociation value superclass]					ifFalse: [self objectClass: self receiver].	[oldSender := thisContext sender swapSender: self.	result := self object: receiver perform: selector withArguments: arguments inClass: lookupClass.	thisContext sender swapSender: oldSender] ifCurtailed:		[contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"		contextToReturnTo jump: -1.	"skip to front of return bytecode causing this unwind"		contextToReturnTo nextByte = 16r7C ifTrue:			"If it was a returnTop, push the value to be returned.			Otherwise the value is implicit in the bytecode"			[contextToReturnTo push: (thisContext sender tempAt: 1)].		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"		contextToReturnTo].	contextToReturnTo push: result.	^contextToReturnTo! !!ContextPart methodsFor: 'controlling' stamp: 'eem 12/5/2011 14:14'!runUntilErrorOrReturnFrom: aSender 	"ASSUMES aSender is a sender of self.  Execute self's stack until aSender returns or an unhandled exception is raised.  Return a pair containing the new top context and a possibly nil exception.  The exception is not nil if it was raised before aSender returned and it was not handled.  The exception is returned rather than openning the debugger, giving the caller the choice of how to handle it."	"Self is run by jumping directly to it (the active process abandons thisContext and executes self).  However, before jumping to self we insert an ensure block under aSender that jumps back to thisContext when evaluated.  We also insert an exception handler under aSender that jumps back to thisContext when an unhandled exception is raised.  In either case, the inserted ensure and exception handler are removed once control jumps back to thisContext."	| error ctxt here topContext aSendersSender |	here := thisContext.	aSendersSender := aSender sender.	"Insert ensure and exception handler contexts under aSender"	error := nil.	ctxt := aSender insertSender: (ContextPart		contextOn: UnhandledError do: [:ex |			error ifNil: [				error := ex exception.				topContext := thisContext.				ex resumeUnchecked: here jump]			ifNotNil: [ex pass]		]).	ctxt := ctxt insertSender: (ContextPart		contextEnsure: [error ifNil: [				topContext := thisContext.				here jump]		]).	self jump.  "Control jumps to self"	"Control resumes here once above ensure block or exception handler is executed"	^ error ifNil: [		"No error was raised, remove ensure context by stepping until popped"		[ctxt isDead or: [aSender isDead]] whileFalse: [topContext := topContext stepToCallee].		^{aSender isDead			ifTrue:				[| retValue |				retValue := (ctxt method == (BlockClosure >> #ensure:)							or: [ctxt method == (BlockClosure >> #ifCurtailed:)]) ifTrue:								[ctxt tempAt: 3]. "returnValue in ensure: and result in ifCurtailed:"				aSendersSender push: retValue.				aSendersSender]			ifFalse: [topContext].		     nil}	] ifNotNil: [		"Error was raised, remove inserted above contexts then return signaler context"		aSender terminateTo: ctxt sender.  "remove above ensure and handler contexts"		{topContext. error}	].! !!ContextPart methodsFor: 'controlling' stamp: 'eem 12/8/2011 10:26'!send: selector to: rcvr with: args lookupIn: lookupClass	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, lookupClass, is the class in	which to lookup the message.  This is the receiver's class for normal messages,	but for super messages it will be some specific class related to the source method."	| meth val ctxt |	meth := lookupClass lookupSelector: selector.	meth == nil ifTrue:		[^self send: #doesNotUnderstand:				to: rcvr				with: (Array with: (Message selector: selector arguments: args))				lookupIn: lookupClass].	val := self tryPrimitiveFor: meth				receiver: rcvr				args: args.	(val isArray	 and: [val size = 2	 and: [val first == PrimitiveFailToken]]) ifFalse:		[^val].	(selector == #doesNotUnderstand: and: [lookupClass == ProtoObject]) ifTrue:		[^ self error: 'Simulated message ' , (args at: 1) selector , ' not understood'].	ctxt := self activateMethod: meth withArgs: args receiver: rcvr.	(val isArray	 and: [val size = 2	 and: [val first == PrimitiveFailToken	 and: [val last notNil	 and: [(ctxt method at: ctxt pc) = 129 "long store temp"]]]]) ifTrue:		[ctxt at: ctxt stackPtr put: val last].	^ctxt! !!ContextPart methodsFor: 'controlling' stamp: 'eem 12/8/2011 11:05'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."	^self		send: selector		to: rcvr		with: args		lookupIn: (superFlag					ifTrue: [self method methodClass superclass]					ifFalse: [self objectClass: rcvr])! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 11:58'!popIntoLiteralVariable: value 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into a literal variable of my method."	self object: value instVarAt: ValueIndex put: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 12:00'!popIntoReceiverVariable: offset 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into an instance variable of my receiver."	self object: self receiver instVarAt: offset + 1 put: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 13:07'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that removes the top of the stack and  stores	 it into an offset in one of my local variables being used as a remote temp vector."	self object: (self at: tempVectorIndex + 1) basicAt: remoteTempIndex + 1 put: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 11:59'!pushLiteralVariable: value 	"Simulate the action of bytecode that pushes the contents of the literal 	variable whose index is the argument, index, on the top of the stack."	self push: (self object: value instVarAt: ValueIndex)! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 12:00'!pushReceiverVariable: offset 	"Simulate the action of bytecode that pushes the contents of the receiver's 	instance variable whose index is the argument, index, on the top of the 	stack."	self push: (self object: self receiver instVarAt: offset + 1)! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 13:07'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that pushes the value at remoteTempIndex	 in one of my local variables being used as a remote temp vector."	self push: (self object: (self at: tempVectorIndex + 1) basicAt: remoteTempIndex + 1)! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 11:58'!storeIntoLiteralVariable: value 	"Simulate the action of bytecode that stores the top of the stack into a 	literal variable of my method."	self object: value instVarAt: ValueIndex put: self top! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 12:00'!storeIntoReceiverVariable: offset 	"Simulate the action of bytecode that stores the top of the stack into an 	instance variable of my receiver."	self object: self receiver instVarAt: offset + 1 put: self top! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/12/2009 13:05'!storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that stores the top of the stack at	 an offset in one of my local variables being used as a remote temp vector."	self object: (self at: tempVectorIndex + 1) basicAt: remoteTempIndex + 1 put: self top! !!ContextPart methodsFor: 'printing' stamp: 'eem 12/7/2011 14:06'!printOn: aStream 	| selector class mclass |	self method == nil ifTrue:		[^super printOn: aStream].	class := self objectClass: self receiver.	mclass := self methodClass.	aStream nextPutAll: class name.	mclass == class ifFalse: 		[aStream nextPut: $(; nextPutAll: mclass name; nextPut: $)].	selector := self selector ifNil: [self method defaultSelector].	aStream		nextPutAll: '>>';		nextPutAll: selector.	selector = #doesNotUnderstand: ifTrue:		[aStream space.		(self tempAt: 1) selector printOn: aStream]! !!ContextPart methodsFor: 'system simulation' stamp: 'eem 12/7/2011 10:04'!stepToSendOrReturn	"Simulate the execution of bytecodes until either sending a message or 	 returning a value to the receiver (that is, until switching contexts)."	| ctxt |	[self willReallySend or: [self willReturn or: [self willStore]]] whileFalse:		[ctxt := self step.		 ctxt == self ifFalse:			[self halt. 			 "Caused by mustBeBoolean handling"			 ^ctxt]]! !!ContextPart methodsFor: 'private' stamp: 'eem 2/27/2012 10:29'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver	 and arguments are given as arguments to this message. Any primitive which provokes	 execution needs to be intercepted and simulated to avoid execution running away."	| value |	"If successful, push result and return resuming context, else ^ { PrimitiveFailToken. errorCode }"	(primitiveIndex = 19) ifTrue:		[ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	"ContextPart>>blockCopy:; simulated to get startpc right"	(primitiveIndex = 80 and: [(self objectClass: receiver) includesBehavior: ContextPart]) 		ifTrue: [^self push: ((BlockContext newForMethod: receiver method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [(self objectClass: receiver) == BlockContext]) "BlockContext>>value[:value:...]"		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [(self objectClass: receiver) == BlockContext]) "BlockContext>>valueWithArguments:"		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50" "Object>>perform:[with:...]"		ifTrue: [^self send: arguments first					to: receiver					with: arguments allButFirst					lookupIn: (self objectClass: receiver)].	primitiveIndex = 84 "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"		ifTrue: [^self send: arguments first					to: receiver					with: (arguments at: 2)					lookupIn: (self objectClass: receiver)].	primitiveIndex = 100 "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"		ifTrue: [^self send: arguments first					to: receiver					with: (arguments at: 2)					lookupIn: (arguments at: 3)].	"Mutex>>primitiveEnterCriticalSection	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSection"	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:		[| active effective |		 active := Processor activeProcess.		 effective := active effectiveProcess.		 "active == effective"		 value := primitiveIndex = 186					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].		 ^(value isArray		    and: [value size = 2		    and: [value first == PrimitiveFailToken]])			ifTrue: [value]			ifFalse: [self push: value]].	primitiveIndex = 188 ifTrue: "eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"		[^MethodContext			sender: self			receiver: receiver			method: (arguments at: 2)			arguments: (arguments at: 1)].	"Closure primitives"	(primitiveIndex = 200 and: [self == receiver]) ifTrue:		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"		[^self push: (BlockClosure						outerContext: receiver						startpc: pc + 2						numArgs: arguments first						copiedValues: arguments last)].	((primitiveIndex between: 201 and: 205)			 "BlockClosure>>value[:value:...]"	or: [primitiveIndex between: 221 and: 222]) ifTrue: "BlockClosure>>valueNoContextSwitch[:]"		[^receiver simulateValueWithArguments: arguments caller: self].	primitiveIndex = 206 ifTrue:						"BlockClosure>>valueWithArguments:"		[^receiver simulateValueWithArguments: arguments first caller: self].	primitiveIndex = 118 ifTrue: "tryPrimitive:withArgs:; avoid recursing in the VM"		[(arguments size = 2		 and: [arguments first isInteger		 and: [arguments last class == Array]]) ifFalse:			[^ContextPart primitiveFailTokenFor: nil].		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].	value := primitiveIndex = 120 "FFI method"				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]				ifFalse:					[primitiveIndex = 117 "named primitives"						ifTrue: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]						ifFalse:							[receiver tryPrimitive: primitiveIndex withArgs: arguments]].	^(value isArray	    and: [value size = 2	    and: [value first == PrimitiveFailToken]])		ifTrue: [value]		ifFalse: [self push: value]! !!ContextPart methodsFor: 'private' stamp: 'eem 5/12/2009 21:12'!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	| selector theMethod spec receiverClass |	<primitive: 218 error: ec>	ec ifNotNil:		["If ec is an integer other than -1 there was a problem with primitive 218,		  not with the external primitive itself.  -1 indicates a generic failure (where		  ec should be nil) but ec = nil means primitive 218 is not implemented.  So		  interpret -1 to mean the external primitive failed with a nil error code."		 ec isInteger ifTrue:			[ec = -1				ifTrue: [ec := nil]				ifFalse: [self primitiveFailed]].		^{PrimitiveFailToken. ec}].	"Assume a nil error code implies the primitive is not implemented and fall back on the old code."	"Hack. Attempt to execute the named primitive from the given compiled method"	arguments size > 8 ifTrue:		[^{PrimitiveFailToken. nil}].	selector := #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	receiverClass := self objectClass: aReceiver.	theMethod := receiverClass lookupSelector: selector.	theMethod == nil ifTrue:		[^{PrimitiveFailToken. nil}].	spec := theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	Smalltalk unbindExternalPrimitives.	^self object: aReceiver perform: selector withArguments: arguments inClass: receiverClass! !!ContextPart methodsFor: 'private' stamp: 'eem 1/4/2009 09:54'!tryPrimitiveFor: method receiver: receiver args: arguments 	"If this method has a primitive index, then run the primitive and return its result.	Otherwise (and also if the primitive fails) return PrimitiveFailToken,	as an indication that the method should be activated and run as bytecodes."	| primIndex |	(primIndex := method primitive) = 0 ifTrue: [^{PrimitiveFailToken. nil}].	^ self doPrimitive: primIndex method: method receiver: receiver args: arguments! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!objectClass: anObject	"Answer the class of the argument anObject without sending it a message.	 This mimics the action of the VM when it fetches an object's class.  Used to	 simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!ContextPart class methodsFor: 'simulation' stamp: 'eem 1/4/2009 09:32'!primitiveFailTokenFor: errorCode	^{PrimitiveFailToken. errorCode}! !!ContextPart class methodsFor: 'class initialization' stamp: 'eem 12/7/2011 12:32'!initialize	ValueIndex := 2.	self assert: (Association instVarNameForIndex:ValueIndex) = 'value'.	PrimitiveFailToken class ~~ Object ifTrue:		[PrimitiveFailToken := Object new]! !!Metaclass methodsFor: 'testing' stamp: 'nice 5/7/2011 14:27'!whichMethodsStoreInto: varName 	"Answer a collection of CompiledMethod which store into the argument, varName, as a named class variable. Or let super try with a named instance variable."	| ref |	ref := self classPool		associationAt: varName		ifAbsent: [ ^ super whichMethodsStoreInto: varName ].	^self methodDict values select: [:eachMethod | eachMethod writesRef: ref ]! !!MethodContext methodsFor: 'accessing' stamp: 'eem 4/26/2012 10:51'!numArgs	"Answer the number of arguments for this activation."	^closureOrNil		ifNil: [method numArgs]		ifNotNil: [closureOrNil numArgs]! !!MethodContext methodsFor: 'accessing' stamp: 'eem 4/26/2012 10:58'!numTemps	"Answer the number of temporaries for this activation; this includes	 the number of arguments, and for blocks, the number of copied values."	^closureOrNil		ifNil: [method numTemps]		ifNotNil: [closureOrNil numTemps]! !!MethodContext methodsFor: 'private' stamp: 'eem 11/4/2011 14:14'!blockCreationValuesInto: aTrinaryBlock	"Answer the evaluation of aTrinaryBlock with numCopied numArgs & blockSize,	assuming the receiver is a block activation."	| blockCreationArgs blockCreationBytecodeSize |	blockCreationBytecodeSize := 4.	blockCreationArgs := [(InstructionStream new									method: method									pc: closureOrNil startpc - blockCreationBytecodeSize)										interpretNextInstructionFor: nil]									on: MessageNotUnderstood									do: [:ex|										self assert: ex message selector = #pushClosureCopyNumCopiedValues:numArgs:blockSize:.										ex message arguments].	^aTrinaryBlock valueWithArguments: blockCreationArgs! !!MethodContext methodsFor: 'private' stamp: 'eem 4/26/2012 10:17'!endPC	^closureOrNil		ifNil:	[self method endPC]		ifNotNil: [closureOrNil endPC]! !!MethodProperties methodsFor: 'printing' stamp: 'eem 9/26/2011 16:59'!printPropertiesOn: aStream	"This is for decompilation."	self propertyKeysAndValuesDo:		[:prop :val|		aStream crtab; nextPut: $<.		prop = #on:in:			ifTrue:				[prop keywords with: val do:					[:k :v | aStream nextPutAll: k; space; nextPutAll: v; space]]			ifFalse:				[prop = #on					ifTrue: [aStream nextPutAll: prop; nextPutAll:': '; nextPutAll: val] 					ifFalse: [aStream nextPutAll: prop; nextPutAll:': '; print: val]]. 		aStream nextPut: $>]! !!Process methodsFor: 'changing suspended state' stamp: 'eem 3/5/2012 12:44'!complete: aContext errorInto: errorBlock	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger).  If an unhandled error is raised pass it into errorBlock."		| ctxt pair error |	ctxt := suspendedContext.	suspendedContext := nil.  "disable this process while running its stack in active process below"	pair := ctxt runUntilErrorOrReturnFrom: aContext.	suspendedContext := pair first.	error := pair second.	error ifNotNil:		[errorBlock value: error.		 ^error signalerContext].	^ suspendedContext! !!Process methodsFor: 'changing suspended state' stamp: 'eem 3/5/2012 12:45'!completeStep: aContext errorInto: errorBlock	"Resume self until aContext is on top, or if already on top, complete next step.  If an unhandled error is raised pass it into errorBlock."	| callee |	self suspendedContext == aContext ifFalse:		[^self complete: (self calleeOf: aContext) errorInto: errorBlock].	callee := self step.	callee == aContext ifTrue: [^callee].	aContext isDead ifTrue: [^self suspendedContext].  "returned"	^self complete: callee errorInto: errorBlock "finish send"! !!Time class methodsFor: 'ansi protocol' stamp: 'eem 7/19/2012 18:13'!milliSecondsSinceMidnight	^self localMicrosecondClock \\ MicrosecondsInDay // 1000! !!Time class methodsFor: 'ansi protocol' stamp: 'eem 7/19/2012 13:17'!now	"Answer a Time representing the time right now - this is a 24 hour clock."	| localUsecs localUsecsToday |	localUsecs := self localMicrosecondClock.	localUsecsToday := localUsecs \\ MicrosecondsInDay.	^ self		seconds: localUsecsToday // 1000000		nanoSeconds: localUsecsToday \\ 1000000 * 1000! !!Time class methodsFor: 'clock' stamp: 'eem 9/28/2009 08:19'!localMicrosecondClock	"Answer the number of microseconds since the start of the 20th century in local time."	<primitive: 241>	^0! !!Time class methodsFor: 'clock' stamp: 'eem 9/28/2009 08:18'!utcMicrosecondClock	"Answer the number of microseconds since the start of the 20th century in UTC."	<primitive: 240>	^0! !ContextPart initialize!InstructionStream subclass: #ContextPart	instanceVariableNames: 'stackp'	classVariableNames: 'PrimitiveFailToken QuickStep ValueIndex'	poolDictionaries: ''	category: 'Kernel-Methods'!DateAndTime class removeSelector: #initialize!DateAndTime class removeSelector: #initializeOffsets!DateAndTime class removeSelector: #startUp:!DateAndTime class removeSelector: #todayAtMilliSeconds:!DateAndTime class removeSelector: #todayAtNanoSeconds:!DateAndTime class removeSelector: #waitForOffsets!Magnitude subclass: #DateAndTime	instanceVariableNames: 'seconds offset jdn nanos'	classVariableNames: 'LocalTimeZone'	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!ChronologyConstants initialize!SharedPool subclass: #ChronologyConstants	instanceVariableNames: 'seconds offset jdn nanos'	classVariableNames: 'DayNames DaysInMonth MicrosecondsInDay MonthNames NanosInMillisecond NanosInSecond OneDay SecondsInDay SecondsInHour SecondsInMinute SqueakEpoch Zero'	poolDictionaries: ''	category: 'Kernel-Chronology'!
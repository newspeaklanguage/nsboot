'From nsboot-2011-08-03 of 3 August 2011 [latest update: #10966] on 12 June 2012 at 9:37:45 pm'!Object subclass: #MwClassA	instanceVariableNames: 'x'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!!MwClassA commentStamp: '<historical>' prior: 0!Instance Variables:	x	<Integer>!MwClassA subclass: #MwClassB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!CompiledMethod variableByteSubclass: #MwMethodWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Base'!!MwMethodWrapper commentStamp: 'eem 9/16/2011 15:46' prior: 0!Method wrappers can add "hidden" behavior to the ordinary method. They can change what is executed before or after the method. For example, a count method wrapper would increment a counter when the method is called, and then forward the call onto the original method.While this class is not abstract (i.e., there are no subclassResponsibilities), these method wrappers don't do anything if you install them. Look at the subclasses for example uses.To create a new type of method wrapper, you must create a subclass of MwMethodWrapper and redefine the #beforeMethod and/or #afterMethod as necessary. If you only need to redefine the #beforeMethod, you can redefine the #valueWithReceiver:arguments: method instead (see the count method wrapper). This will give you some added performance since it doesn't need to create two blocks and send the #ensure: message.To use a method wrapper, send the class a #on:inClass: message. This will return a new method wrapper (or nil if this method shouldn't be wrapped). You can then install the method wrapper by sending the #install message and uninstall by sending the #uninstall message.WARNING: Incorrectly using the wrappers can crash your image, so you should save your image before using them. Most problems occur as a result of installing them on methods that are called either in the #beforeMethod or #afterMethod. (Note: In VisualWorks the #value method in Association (VariableBinding in VW2.5) is automatically called by the VM when you refer to a global, class, or pool variable so you should probably never wrap it. I advise against wrapping primitives also.)Class Instance Variables:	protoMethods		<Dictionary								key: SmallInteger								value: MwMethodWrapper>							Prototype wrappers that are copied when installing new wrappers.!MwMethodWrapper variableByteSubclass: #MwBlockHandlerMethodWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Base'!!MwBlockHandlerMethodWrapper commentStamp: 'eem 9/16/2011 15:53' prior: 0!MwBlockHandlerMethodWrapper allows one to wrap methods with an exception handler.!MwMethodWrapper variableByteSubclass: #MwBlockMethodWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Base'!!MwBlockMethodWrapper commentStamp: 'eem 9/16/2011 16:03' prior: 0!A MwBlockMethodWrapper allows wrapping a method with optional before and after blocks that take the receiver and arguments as their arguments.  For example,	| indent wrapper |	indent := 0.	wrapper := MwBlockMethodWrapper on: #benchFib inClass: Integer.	wrapper		beforeBlock: [:rcvr :args|					Transcript crtab: indent; print: rcvr; space; nextPutAll: #benchFib; flush.					indent := indent + 1];		afterBlock: [:rcvr :args| indent := indent - 1].	[wrapper install.	 7 benchFib] ensure: [wrapper uninstall]!MwBlockMethodWrapper variableByteSubclass: #MwBlockMethodResultWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Base'!!MwBlockMethodResultWrapper commentStamp: 'eem 9/21/2011 14:01' prior: 0!A MwBlockMethodResultWrapper allows wrapping a method with optional before, after and curtailed blocks.  The before and curtailed blocks take the receiver and arguments as their arguments, whereas the after block takes the receiver arguments and result as arguments.  For example,	| indent wrapper |	indent := 0.	wrapper := MwBlockMethodResultWrapper on: #benchFib inClass: Integer.	wrapper		beforeBlock: [:rcvr :selector :args|					Transcript crtab: indent; print: rcvr; space; nextPutAll: selector; flush.					indent := indent + 1];		afterBlock: [:rcvr :selector :args :result| indent := indent - 1. Transcript crtab: indent; print: rcvr; space; nextPutAll: selector; nextPutAll: ' -> '; print: result; flush].	[wrapper install.	 7 benchFib] ensure: [wrapper uninstall]!MwMethodWrapper variableByteSubclass: #MwCalledMethodWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwCalledMethodWrapper commentStamp: 'eem 9/16/2011 15:48' prior: 0!A called method wrapper is a special method wrapper that uninstalls itself once it has been called. Although this is initially slower than the count method wrapper, it will speed up to be the same speed as the unwrapped code.Class Instance Variables:	installing	<Boolean>					Are we installing the wrappers? During installation, some of the					methods might be called, but we shouldn't tag them as being called,					since it results from the installation process, not normal code execution.!MwMethodWrapper variableByteSubclass: #MwCountMethodWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwCountMethodWrapper commentStamp: 'eem 9/16/2011 15:48' prior: 0!A count method wrapper counts the number of times the method is called.!MwMethodWrapper variableByteSubclass: #MwMethodBreakpointWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwMethodBreakpointWrapper commentStamp: 'eem 10/7/2011 13:02' prior: 0!A MwMethodBreakpointWrapper arranges to raise the Halt signal on entry to its wrapped or client method, removing the intervening MwMethodBreakpointWrapper activations as it does so, typically leaving execution suspended on entry to the wrapped method.  It is careful to avoid breakpointing a quick method (^self,^inst var et al), creating a substitute non-quick version if necessary.  The debugger machinery can't execute a quick method and so to support breakpointing and continuing a quick method this subterfuge is required.Whether the breakpoint is shown for the clientMethod (which may be a method wrapper oif there are multiple wrappers) or the unwraped method is controlled by the variable breakInUnwrapped, which is true and hence breaks for the unwrapped method by default.N.B.  We do not implement nonQuickClientMethod: since this is a cache that reflects clientMethod, not an independent variable.  We do not implement nonQuickUnwrappedMethod: because if the unwrapped method changes the wrapper wil have been replaced in whatever method dictionary it was in and will be obsolete.Instance Variables	breakInUnwrapped <Boolean>	nonQuickClientMethod <CompiledMethod|nil>	nonQuickUnwrappedMethod <CompiledMethod|nil>!MwMethodWrapper class	instanceVariableNames: 'protoMethods'!MwCalledMethodWrapper class	instanceVariableNames: 'installing'!AdditionalMethodState variableSubclass: #MwMethodWrapperInstVars	instanceVariableNames: 'clientSelector clientMethod definingClass wrappedClass wrappingWrapper wasActive'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Base'!!MwMethodWrapperInstVars commentStamp: '<historical>' prior: 0!Instance Variables:	clientSelector		<Symbol>	clientMethod		<CompiledMethod>	definingClass		<Class>	wrappedClass		<Class>	wrappingWrapper	<MwMethodWrapper>!MwMethodWrapperInstVars variableSubclass: #MwBlockHandlerMethodWrapperInstVars	instanceVariableNames: 'exception handlerBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Base'!!MwBlockHandlerMethodWrapperInstVars commentStamp: 'eem 9/16/2011 15:47' prior: 0!Instance Variables:	exception		<Exception class>	handlerBlock	<BlockClosure>!MwMethodWrapperInstVars variableSubclass: #MwBlockMethodWrapperInstVars	instanceVariableNames: 'beforeBlock afterBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Base'!!MwBlockMethodWrapperInstVars commentStamp: 'eem 9/16/2011 15:46' prior: 0!Instance Variables:	beforeBlock	<BlockClosure>	afterBlock		<BlockClosure>!MwBlockMethodWrapperInstVars variableSubclass: #MwBlockMethodResultWrapperInstVars	instanceVariableNames: 'curtailedBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Base'!!MwBlockMethodResultWrapperInstVars commentStamp: 'eem 9/19/2011 13:55' prior: 0!Instance Variables:	curtailedBlock		<BlockClosure>!MwMethodWrapperInstVars variableSubclass: #MwCalledMethodWrapperInstVars	instanceVariableNames: 'called'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwCalledMethodWrapperInstVars commentStamp: '<historical>' prior: 0!Instance Variables:	called	<Boolean>!MwMethodWrapperInstVars variableSubclass: #MwCountMethodWrapperInstVars	instanceVariableNames: 'count'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwCountMethodWrapperInstVars commentStamp: '<historical>' prior: 0!Instance Variables:	count	<Integer>!MwMethodWrapperInstVars variableSubclass: #MwMethodBreakpointWrapperInstVars	instanceVariableNames: 'breakInUnwrapped nonQuickClientMethod nonQuickUnwrappedMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!MwMethodWrapper variableByteSubclass: #MwSynchronizationWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwSynchronizationWrapper commentStamp: 'eem 9/16/2011 15:50' prior: 0!A synchronization wrapper synchronizes method calls by using a recursion lock. The call to the original method is protected by the Monitor>>critical: method.!MwMethodWrapperInstVars variableSubclass: #MwSynchronizationWrapperInstVars	instanceVariableNames: 'recursionLock'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwSynchronizationWrapperInstVars commentStamp: 'eem 9/16/2011 15:50' prior: 0!Instance Variables:	recursionLock	<Monitor>!TestCase subclass: #MwTestCase	instanceVariableNames: 'result'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!MwTestCase subclass: #MwBlockHandlerMethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!MwTestCase subclass: #MwBlockMethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!MwTestCase subclass: #MwBreakpointMethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!MwTestCase subclass: #MwCalledMethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!MwTestCase subclass: #MwCountMethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!MwTestCase subclass: #MwMethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!MwTestCase subclass: #MwSynchronizationWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!MwCountMethodWrapper variableByteSubclass: #MwTimeMethodWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwTimeMethodWrapper commentStamp: 'eem 9/16/2011 15:51' prior: 0!A time method wrapper counts the number of times the method has been called, along with the total execution time this method has taken.!MwCountMethodWrapperInstVars variableSubclass: #MwTimeMethodWrapperInstVars	instanceVariableNames: 'time'	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Examples'!!MwTimeMethodWrapperInstVars commentStamp: '<historical>' prior: 0!Instance Variables:	time	<Integer>!MwTestCase subclass: #MwTimeMethodWrapperTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MethodWrappers-Tests'!!Object methodsFor: '*methodwrappers' stamp: 'rhi 4/9/2001 21:22'!isMwMethodWrapper	^ false! !!Object methodsFor: '*methodwrappers' stamp: 'rhi 3/27/2001 09:55'!synchronize	MwSynchronizationWrapper installOnObject: self.! !!Object methodsFor: '*methodwrappers' stamp: 'rhi 3/27/2001 09:54'!unsynchronize	^ self! !!CompiledMethod methodsFor: '*methodwrappers' stamp: 'rhi 4/29/2001 09:33'!unwrappedMethod	^ self! !!MwClassA methodsFor: 'debugging' stamp: 'rhi 6/18/2001 14:17'!methodDelay	(Delay forMilliseconds: 1) wait.! !!MwClassA methodsFor: 'debugging' stamp: 'rhi 6/17/2001 22:48'!methodOne	"Transcript cr; show: 'MwClassA>>methodOne'."! !!MwClassA methodsFor: 'debugging' stamp: 'rhi 4/19/2001 23:33'!methodTwo	"Transcript cr; show: 'MwClassA>>methodTwo'."! !!MwClassA methodsFor: 'debugging' stamp: 'rhi 4/19/2001 13:43'!methodWithArgument: anInteger	self x: self x + anInteger.	^ self x! !!MwClassA methodsFor: 'debugging' stamp: 'md 10/14/2004 18:55'!methodWithException	Warning new  signal: 'Ouch'.! !!MwClassA methodsFor: 'debugging' stamp: 'rhi 4/19/2001 23:29'!methodWithoutException	^ 69! !!MwClassA methodsFor: 'accessing' stamp: 'rhi 3/30/2001 10:43'!x	"^ <Integer>"	^ x! !!MwClassA methodsFor: 'accessing' stamp: 'DF 4/19/2006 00:00'!x: anInteger	x := anInteger.! !!MwClassB methodsFor: 'debugging' stamp: 'rhi 4/19/2001 23:33'!methodThree	"Transcript cr; show: 'MwClassB>>methodThree'."! !!MwClassB methodsFor: 'debugging' stamp: 'rhi 4/19/2001 23:33'!methodTwo	"Transcript cr; show: 'MwClassB>>methodTwo'."! !!MwMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 3/19/2001 21:17'!afterMethod! !!MwMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 3/19/2001 21:17'!beforeMethod! !!MwMethodWrapper methodsFor: 'evaluating' stamp: 'eem 9/15/2011 15:39'!valueWithReceiver: anObject arguments: anArrayOfObjects	"This is the general case where you want both a before and after method, but if you	want just a before method, you might want to override this method for optimization."	self wasActive: true.	self beforeMethod.	^[self clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects]		ensure: [self afterMethod]! !!MwMethodWrapper methodsFor: 'initialization' stamp: 'eem 9/14/2011 11:20'!class: aClass selector: aSymbol	self		objectAt: self methodPosition put: self;		wrappedClass: aClass;		clientSelector: aSymbol! !!MwMethodWrapper methodsFor: 'initialization' stamp: 'eem 9/16/2011 11:51'!copyWithTrailerBytes: trailer	| copy |	copy := super copyWithTrailerBytes: trailer.	copy objectAt: self methodPosition put: copy.	^copy! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!clientMethod	^self properties clientMethod! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!clientMethod: aCompiledMethod	^self properties clientMethod: aCompiledMethod! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!clientSelector	^self properties clientSelector! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!clientSelector: aSymbol	^self properties clientSelector: aSymbol! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!definingClass	^self properties definingClass! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!definingClass: aClass	^self properties definingClass: aClass! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'rhi 2/26/2001 21:28'!unwrappedMethod	^ self clientMethod ifNotNil: [self clientMethod unwrappedMethod]! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!wrappedClass	^self properties wrappedClass! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!wrappedClass: aClass	^self properties wrappedClass: aClass! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!wrappingWrapper	^self properties wrappingWrapper! !!MwMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!wrappingWrapper: aMwMethodWrapper	^self properties wrappingWrapper: aMwMethodWrapper! !!MwMethodWrapper methodsFor: 'installation' stamp: 'DF 4/19/2006 00:00'!install	| holdingClass method |	self flag: #rhi. "KLUDGE: Einwegwrapper."	self wasActive ifTrue: [self error: 'Einwegwrapper!!'].	holdingClass := self wrappedClass whichClassIncludesSelector: self clientSelector.	holdingClass isNil ifTrue: [^ self].	method := holdingClass compiledMethodAt: self clientSelector.	method == self ifTrue: [^ self].	self		clientMethod: method;		setSourcePointer: method sourcePointer.	method isMwMethodWrapper		ifTrue: [			method wrappingWrapper: self.			self definingClass: method definingClass]		ifFalse: [self definingClass: holdingClass].	self wrappedClass addSelector: self clientSelector withMethod: self.! !!MwMethodWrapper methodsFor: 'installation' stamp: 'pmm 8/25/2006 17:34'!uninstall	self flag: #rhi. "The #uninstall should actually become #destroy!!"	self clientMethod ifNil: [^ self].	(self wrappedClass compiledMethodAt: self clientSelector ifAbsent: [nil]) == self		ifTrue: [self wrappedClass == self definingClass			ifTrue: [self wrappedClass				addSelector: self clientSelector				withMethod: self clientMethod]			ifFalse: [self wrappedClass removeSelector: self clientSelector]].	self clientMethod isMwMethodWrapper		ifTrue: [self clientMethod wrappingWrapper: self wrappingWrapper].	self wrappingWrapper		ifNotNil: [			self wrappingWrapper				clientMethod: self clientMethod;				definingClass: self definingClass.			self wrappingWrapper: nil].	self		definingClass: nil;		clientMethod: nil.! !!MwMethodWrapper methodsFor: 'testing' stamp: 'rhi 4/9/2001 21:21'!isMwMethodWrapper	^ true! !!MwMethodWrapper methodsFor: 'testing' stamp: 'eem 9/16/2011 10:59'!wasActive	^self properties wasActive! !!MwMethodWrapper methodsFor: 'testing' stamp: 'eem 9/16/2011 10:59'!wasActive: aBoolean	^self properties wasActive: aBoolean! !!MwMethodWrapper methodsFor: 'decompiling' stamp: 'eem 9/26/2011 17:28'!methodForDecompile	"Answer a wrapper *without* itself in the methodPosition to avoid infinite	 recursion in the attempt to print the literal method in wrapper position."	^self copy		objectAt: self methodPosition put: self class methodWrapperSymbol;		yourself! !!MwMethodWrapper methodsFor: 'private' stamp: 'DF 4/19/2006 00:00'!methodPosition	^ (2 to: self numLiterals + 1) detect: [:i |			| each |			each := self realObjectAt: i.			each == self class methodWrapperSymbol or: [each == self]]		ifNone: [self error: 'Cannot find position to insert wrapper']! !!MwMethodWrapper methodsFor: 'private' stamp: 'DF 4/19/2006 00:00'!objectAt: anIndex 	"Lie about what's in our literal frame. This has the bad side-effect that we can't	view the correct information in inspectors, but the good news is that we stop	infinite recursion. Good thing the VM doesn't use the basicAt: method :)."	| object |	object := self realObjectAt: anIndex.	^ object == self ifTrue: [self clientMethod] ifFalse: [object]! !!MwMethodWrapper methodsFor: 'private' stamp: 'rhi 2/26/2001 09:03'!realObjectAt: anIndex	^ super objectAt: anIndex! !!MwMethodWrapper methodsFor: 'accessing' stamp: 'eem 9/16/2011 10:55'!properties	"Answer the method properties of the receiver.  Override to create the properties if none already exist."	| propertiesOrSelector |	(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifFalse:		[propertiesOrSelector := self class methodPropertiesClass									forMethod: self									selector: propertiesOrSelector.		 self penultimateLiteral: propertiesOrSelector].	^propertiesOrSelector! !!MwBlockHandlerMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 4/7/2001 20:20'!afterMethod	self shouldNotImplement.! !!MwBlockHandlerMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 4/7/2001 20:20'!beforeMethod	self shouldNotImplement.! !!MwBlockHandlerMethodWrapper methodsFor: 'evaluating' stamp: 'eem 9/15/2011 15:39'!valueWithReceiver: anObject arguments: anArrayOfObjects	self wasActive: true.	^[self clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects]		on: self exception		do: [:ex | self handlerBlock value: anObject value: anArrayOfObjects value: ex]! !!MwBlockHandlerMethodWrapper methodsFor: 'initialization' stamp: 'rhi 6/17/2001 21:48'!class: aClass selector: aSymbol	super class: aClass selector: aSymbol.	self		exception: Error;		handlerBlock: [:receiver :arguments :ex | ].! !!MwBlockHandlerMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!exception	^self properties exception! !!MwBlockHandlerMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!exception: anExceptionClass	^self properties exception: anExceptionClass! !!MwBlockHandlerMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!handlerBlock	^self properties handlerBlock! !!MwBlockHandlerMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!handlerBlock: aBlockClosure	^self properties handlerBlock: aBlockClosure! !!MwBlockMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!afterBlock	^self properties afterBlock! !!MwBlockMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!afterBlock: aBlockClosure	^self properties afterBlock: aBlockClosure! !!MwBlockMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!beforeBlock	^self properties beforeBlock! !!MwBlockMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!beforeBlock: aBlockClosure	^self properties beforeBlock: aBlockClosure! !!MwBlockMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 3/30/2001 10:37'!afterMethod	self shouldNotImplement.! !!MwBlockMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 3/30/2001 10:37'!beforeMethod	self shouldNotImplement.! !!MwBlockMethodWrapper methodsFor: 'evaluating' stamp: 'eem 9/16/2011 15:57'!valueWithReceiver: anObject arguments: anArrayOfObjects	"Optionally evaluate beforeBlock before evaluating clientMethod if beforeBlock is non-nil.	 Optionally evaluate afterBlock afterwards if afterBlock is non-nil."	self wasActive: true.	self beforeBlock ifNotNil:		[:beforeBlock| beforeBlock value: anObject value: anArrayOfObjects].	^self afterBlock		ifNil: [self clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects]		ifNotNil:			[:afterBlock|			[self clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects]				ensure: [afterBlock value: anObject value: anArrayOfObjects]]! !!MwBlockMethodWrapper methodsFor: 'initialization' stamp: 'eem 9/19/2011 10:24'!class: aClass selector: aSymbol	super class: aClass selector: aSymbol.	self beforeBlock: nil; afterBlock: nil! !!MwBlockMethodResultWrapper methodsFor: 'initialization' stamp: 'eem 9/19/2011 10:24'!class: aClass selector: aSymbol	super class: aClass selector: aSymbol.	self curtailedBlock: nil! !!MwBlockMethodResultWrapper methodsFor: 'derived accessing' stamp: 'eem 9/19/2011 10:23'!curtailedBlock	^self properties curtailedBlock! !!MwBlockMethodResultWrapper methodsFor: 'derived accessing' stamp: 'eem 9/19/2011 10:23'!curtailedBlock: aBlockClosure	^self properties curtailedBlock: aBlockClosure! !!MwBlockMethodResultWrapper methodsFor: 'evaluating' stamp: 'eem 9/21/2011 14:03'!valueWithReceiver: anObject arguments: anArrayOfObjects	"Optionally evaluate beforeBlock before evaluating clientMethod if beforeBlock is non-nil.	 Optionally evaluate afterBlock afterwards if a result is returned and afterBlock is non-nil.	 Optionally evaluate curtailedBlock if evaluation of the method is curtailed and curtailedBlock is non-nil."	| clientSelector |	self wasActive: true.	clientSelector := self clientSelector.	self beforeBlock ifNotNil:		[:beforeBlock|		 beforeBlock value: anObject value: clientSelector value: anArrayOfObjects].	^[| result |	   result := self clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects.	   self afterBlock ifNotNil:		[:afterBlock|		 afterBlock value: anObject value: clientSelector value: anArrayOfObjects value: result].	   result]		ifCurtailed:			[self curtailedBlock ifNotNil:				[:curtailedBlock|				 curtailedBlock value: anObject value: clientSelector value: anArrayOfObjects]]! !!MwCalledMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 3/30/2001 18:49'!afterMethod	self called ifTrue: [self uninstall].! !!MwCalledMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 3/30/2001 18:48'!beforeMethod	(self called or: [self installing])		ifFalse: [self called: true].! !!MwCalledMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!called	^self properties called! !!MwCalledMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!called: aBoolean	^self properties called: aBoolean! !!MwCalledMethodWrapper methodsFor: 'derived accessing' stamp: 'rhi 3/21/2001 12:56'!installing	^ self class installing! !!MwCalledMethodWrapper methodsFor: 'initialization' stamp: 'rhi 3/30/2001 14:06'!class: aClass selector: aSymbol	self called: false.	^ super class: aClass selector: aSymbol! !!MwCountMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 6/18/2001 12:06'!beforeMethod	self count: self count + 1.! !!MwCountMethodWrapper methodsFor: 'initialization' stamp: 'rhi 3/21/2001 15:07'!class: aClass selector: aSymbol	self count: 0.	^ super class: aClass selector: aSymbol! !!MwCountMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!count	^self properties count! !!MwCountMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!count: anInteger	^self properties count: anInteger! !!MwMethodBreakpointWrapper methodsFor: 'derived accessing' stamp: 'eem 10/7/2011 12:57'!breakInUnwrapped	^self properties breakInUnwrapped! !!MwMethodBreakpointWrapper methodsFor: 'derived accessing' stamp: 'eem 10/7/2011 12:57'!breakInUnwrapped: aBoolean	^self properties breakInUnwrapped: aBoolean! !!MwMethodBreakpointWrapper methodsFor: 'derived accessing' stamp: 'eem 9/27/2011 16:02'!clientMethod: aCompiledMethod	"Override to void the nonQuickClientMethod cache when the client method is changed."	self properties nonQuickClientMethod: nil.	^super clientMethod: aCompiledMethod! !!MwMethodBreakpointWrapper methodsFor: 'derived accessing' stamp: 'eem 9/27/2011 16:03'!nonQuickClientMethod	"Answer the cached nonQuickClientMethod, computing it if required." 	^self properties nonQuickClientMethod ifNil:		[self properties nonQuickClientMethod:			(self clientMethod isQuick				ifTrue:					[(self definingClass compilerClass new							compile: self clientMethod getSource							in: self definingClass							notifying: nil							ifFail: [self error: 'could not compile non-quick method'])						ensureNotQuick;						generate: self clientMethod trailer using: self clientMethod class]				ifFalse:					[self clientMethod])]! !!MwMethodBreakpointWrapper methodsFor: 'derived accessing' stamp: 'eem 10/7/2011 11:33'!nonQuickUnwrappedMethod	"Answer the cached nonQuickUnwrappedMethod, computing it if required." 	^self properties nonQuickUnwrappedMethod ifNil:		[self properties nonQuickUnwrappedMethod:			(self unwrappedMethod isQuick				ifTrue:					[(self definingClass compilerClass new							compile: self unwrappedMethod getSource							in: self definingClass							notifying: nil							ifFail: [self error: 'could not compile non-quick method'])						ensureNotQuick;						generate: self unwrappedMethod trailer using: self unwrappedMethod class]				ifFalse:					[self unwrappedMethod])]! !!MwMethodBreakpointWrapper methodsFor: 'private' stamp: 'eem 10/5/2011 13:34'!findInnerWrapperActivationFrom: startContext	| unwrappedMethod wrapperContext |	unwrappedMethod := self unwrappedMethod.	wrapperContext := startContext.	[wrapperContext method unwrappedMethod == unwrappedMethod	 and: [wrapperContext method isMwMethodWrapper]] whileFalse:		[wrapperContext := wrapperContext sender].	^wrapperContext! !!MwMethodBreakpointWrapper methodsFor: 'private' stamp: 'eem 10/5/2011 13:21'!findOuterWrapperActivationFrom: startContext unwrappedMethod: unwrappedMethod	| wrapperContext |	wrapperContext := startContext.	[wrapperContext isNil ifTrue: [^nil].	 wrapperContext method unwrappedMethod == unwrappedMethod	 and: [wrapperContext method isMwMethodWrapper]] whileFalse:		[wrapperContext := wrapperContext sender].	^(self		findOuterWrapperActivationFrom: wrapperContext sender		unwrappedMethod: unwrappedMethod)			ifNil: [wrapperContext]			ifNotNil: [:outerContext| outerContext]! !!MwMethodBreakpointWrapper methodsFor: 'private' stamp: 'eem 10/7/2011 12:58'!nonQuickMethodToHaltIn	"Answer the non-quick version of either the unwrapped (default) or client method,	 depending on breakInUnwrapped."	^self breakInUnwrapped		ifTrue: [self nonQuickUnwrappedMethod]		ifFalse: [self nonQuickClientMethod]! !!MwMethodBreakpointWrapper methodsFor: 'evaluating' stamp: 'eem 10/7/2011 12:43'!valueWithReceiver: anObject arguments: anArrayOfObjects	"Raise the Halt signal on entry to the wrapped method, while removing any activations	 associated with the wrapper.  Do this by a) creating an activation of the wrapped method	 and making its sender the sender of the  message that invoked this wrapper, and b) by	 creating an activation of Object>>halt whose sender is the wrapped method activation,	 and returning (eventually to the halt activation), there-by raising the Halt signal."	| wrapperContext haltContext methodContext |	self wasActive: true.	wrapperContext := self findInnerWrapperActivationFrom: thisContext sender.	"create an activation of the client method, safe for debugging (i.e. not quick, if quick)"	methodContext := MethodContext							sender: wrapperContext sender							receiver: anObject							method: self nonQuickMethodToHaltIn							arguments: anArrayOfObjects.	"create a Halt activation above it that will raise the halt signal."	haltContext := MethodContext							sender: methodContext							receiver: anObject							method: Object >> #halt							arguments: #().	wrapperContext swapSender: haltContext.	^self! !!MwMethodWrapper class methodsFor: 'monticello compatibility' stamp: 'DF 4/19/2006 01:18'!asClassDefinition	| mcClassDefinition |		mcClassDefinition := Smalltalk at: #MCClassDefinition ifAbsent: [^self error: 'This message is implemented for Monticello compatibility, but MCClassDefinition is not installed in the image. Possible causes: MC is not installed or you are using a different version of MC' ].		^mcClassDefinition		name: self name		superclassName: self superclass name		traitComposition: self traitComposition asString		classTraitComposition: self class traitComposition asString		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: #bytes		comment: self organization classComment	 asString		commentStamp: self organization commentStamp! !!MwMethodWrapper class methodsFor: 'testing' stamp: 'eem 9/13/2011 15:22'!canWrap: aSelector inClass: aClass	"Test if a method can be wrapped without causing infinite recursion."	| class method |	(aClass includesBehavior: MwMethodWrapper) ifTrue: [^ false].	((aClass includesBehavior: CompiledMethod)		and: [aSelector == #valueWithReceiver:arguments:])			ifTrue: [^ false].	((aClass includesBehavior: BlockClosure)		and: [#(ensure: value) includes: aSelector])			ifTrue: [^ false].	class := aClass whichClassIncludesSelector: aSelector.	class isNil ifTrue: [^ false].	method := class compiledMethodAt: aSelector ifAbsent: [nil].	^ method notNil and: [(self primitives includes: method primitive) not]! !!MwMethodWrapper class methodsFor: 'private' stamp: 'eem 9/19/2011 10:31'!checkClassFormat	"Make sure the receiver has the format of a CompiledMethod.  In Squeak, as in	 Smalltalk-80 V2, CompiledMethods are special format objects, half pointers, half bytes)."	self instSpec ~= CompiledMethod instSpec ifTrue:		[self setFormat: (self format bitOr: (CompiledMethod instSpec bitShift: 7))].! !!MwMethodWrapper class methodsFor: 'private' stamp: 'eem 9/14/2011 11:17'!codeStringFor: numArgs	^String streamContents:		[:s|		numArgs = 0			ifTrue: [s nextPutAll: 'value']			ifFalse:				[(1 to: numArgs)					do: [:i| s nextPutAll: 'value: t'; print: i]					separatedBy: [s space]].		s	crtab;			nextPut: $^;			print: self methodWrapperSymbol;			nextPutAll: ' valueWithReceiver: self arguments: {'.		(1 to: numArgs)			do: [:i| s nextPut: $t; print: i]			separatedBy: [s nextPut: $.; space].		s nextPut: $}]				"(0 to: 2) collect: [:na| self codeStringFor: na]"! !!MwMethodWrapper class methodsFor: 'private' stamp: 'eem 9/19/2011 10:28'!createMethodFor: numArgs	self checkClassFormat.	^(Compiler new			compile: (self codeStringFor: numArgs)			in: self			notifying: nil			ifFail: [])		generate: CompiledMethodTrailer empty		using: self! !!MwMethodWrapper class methodsFor: 'private' stamp: 'eem 9/16/2011 11:10'!methodPropertiesClass	^MwMethodWrapperInstVars! !!MwMethodWrapper class methodsFor: 'private' stamp: 'rhi 3/21/2001 19:09'!methodWrapperSymbol	^ #'The method wrapper should be inserted in this position!!'! !!MwMethodWrapper class methodsFor: 'private' stamp: 'eem 9/14/2011 11:55'!nuke	"doIt: [self nuke]"	"doIt: [self withAllSubclassesDo: [:mwc| mwc nuke]]"	self		uninstallAllWrappers;		initialize! !!MwMethodWrapper class methodsFor: 'private' stamp: 'rhi 2/25/2001 21:31'!primitives	^ #(		61		"at:put:"		71		"new:"		81		"value"	)! !!MwMethodWrapper class methodsFor: 'private' stamp: 'rhi 6/18/2001 14:41'!uninstallAllWrappers	"doIt: [self uninstallAllWrappers]"	self allSubInstancesDo: [:inst | inst uninstall].! !!MwMethodWrapper class methodsFor: 'CHECKS' stamp: 'DF 4/19/2006 00:00'!checkClassFormats	"doIt: [self checkClassFormats]"	| allFormatsOk |	allFormatsOk := true.	Smalltalk garbageCollect.	Transcript cr.	self withAllSubclassesDo: [:each |		| formatOk |		formatOk := (each format bitAnd: 16r200) = 16r200.		allFormatsOk := allFormatsOk & formatOk.		Transcript cr; show: each name, ' -> ', formatOk printString].	Transcript cr; show: '=== ALL FORMATS OK -> ', allFormatsOk printString.! !!MwMethodWrapper class methodsFor: 'CHECKS' stamp: 'DF 4/19/2006 00:00'!countAllInstances	"doIt: [self countAllInstances]"	| totalCount |	totalCount := 0.	Smalltalk garbageCollect.	Transcript cr.	self withAllSubclassesDo: [:each |		| count |		count := each allInstances size.		totalCount := totalCount + count.		Transcript cr; show: each name, ' -> ', count printString].	Transcript cr; show: '=== TOTAL COUNT -> ', totalCount printString.! !!MwMethodWrapper class methodsFor: 'class initialization' stamp: 'eem 9/16/2011 16:22'!initialize	"doIt: [self initialize]"	self protoMethods: Dictionary new! !!MwMethodWrapper class methodsFor: 'class initialization' stamp: 'rhi 3/24/2001 08:07'!initializeWithAllSubclasses	"doIt: [self initializeWithAllSubclasses]"	self withAllSubclassesDo: [:each | each initialize].! !!MwMethodWrapper class methodsFor: 'instance creation' stamp: 'eem 9/16/2011 11:05'!on: aSymbol inClass: aClass	| wrapper |	self flag: #rhi. "How about signaling an exception instead of returning nil?"	(self canWrap: aSymbol inClass: aClass) ifFalse: [^ nil].	wrapper := (self protoMethods						at: aSymbol numArgs						ifAbsentPut: [self createMethodFor: aSymbol numArgs])					copyWithTrailerBytes: CompiledMethodTrailer empty.	self assert: wrapper ~~ (self protoMethods at: aSymbol numArgs).	self assert: wrapper properties ~~ (self protoMethods at: aSymbol numArgs) properties.	wrapper class: aClass selector: aSymbol.	self assert: (wrapper realObjectAt: wrapper methodPosition) == wrapper.	^ wrapper! !!MwMethodWrapper class methodsFor: 'accessing' stamp: 'eem 9/19/2011 10:27'!protoMethods	"^<Dictionary key: SmallInteger value: MwMethodWrapper>"	^protoMethods ifNil: [protoMethods := Dictionary new]! !!MwMethodWrapper class methodsFor: 'accessing' stamp: 'DF 4/19/2006 00:00'!protoMethods: aDictionary	protoMethods := aDictionary.! !!MwBlockHandlerMethodWrapper class methodsFor: 'class initialization' stamp: 'rhi 4/7/2001 14:55'!initialize	"doIt: [self initialize]"	super initialize.! !!MwBlockHandlerMethodWrapper class methodsFor: 'private' stamp: 'eem 9/16/2011 11:10'!methodPropertiesClass	^MwBlockHandlerMethodWrapperInstVars! !!MwBlockMethodWrapper class methodsFor: 'class initialization' stamp: 'rhi 3/30/2001 10:03'!initialize	"doIt: [self initialize]"	super initialize.! !!MwBlockMethodWrapper class methodsFor: 'private' stamp: 'eem 9/16/2011 11:10'!methodPropertiesClass	^MwBlockMethodWrapperInstVars! !!MwBlockMethodResultWrapper class methodsFor: 'private' stamp: 'eem 9/19/2011 10:01'!methodPropertiesClass	^MwBlockMethodResultWrapperInstVars! !!MwCalledMethodWrapper class methodsFor: 'class initialization' stamp: 'rhi 3/30/2001 14:09'!initialize	"doIt: [self initialize]"	super initialize.	self installing: false.! !!MwCalledMethodWrapper class methodsFor: 'accessing' stamp: 'rhi 3/30/2001 14:10'!installing	"^ <Boolean>"	^ installing! !!MwCalledMethodWrapper class methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!installing: aBoolean	^installing := aBoolean! !!MwCalledMethodWrapper class methodsFor: 'private' stamp: 'eem 9/16/2011 11:10'!methodPropertiesClass	^MwCalledMethodWrapperInstVars! !!MwCountMethodWrapper class methodsFor: 'class initialization' stamp: 'rhi 3/30/2001 13:51'!initialize	"doIt: [self initialize]"	super initialize.! !!MwCountMethodWrapper class methodsFor: 'private' stamp: 'eem 9/16/2011 11:10'!methodPropertiesClass	^MwCountMethodWrapperInstVars! !!MwMethodBreakpointWrapper class methodsFor: 'private' stamp: 'eem 9/27/2011 15:55'!methodPropertiesClass	^MwMethodBreakpointWrapperInstVars! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/17/2001 23:45'!clientMethod	"^ <CompiledMethod>"	^ clientMethod! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!clientMethod: aCompiledMethod	^clientMethod := aCompiledMethod! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/17/2001 23:45'!clientSelector	"^ <Symbol>"	^ clientSelector! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!clientSelector: aSymbol	^clientSelector := aSymbol! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/17/2001 23:46'!definingClass	"^ <Class>"	^ definingClass! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!definingClass: aClass	^definingClass := aClass! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'pmm 8/25/2006 17:47'!wasActive	"^ <Boolean>"	^wasActive! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!wasActive: aBoolean	^wasActive := aBoolean! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/17/2001 23:46'!wrappedClass	"^ <Class>"	^ wrappedClass! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!wrappedClass: aClass	^wrappedClass := aClass! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 4/9/2001 15:36'!wrappingWrapper	"^ <MwMethodWrapper>"	^ wrappingWrapper! !!MwMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!wrappingWrapper: aMwMethodWrapper	^wrappingWrapper := aMwMethodWrapper! !!MwMethodWrapperInstVars methodsFor: 'initialize-release' stamp: 'pmm 8/25/2006 17:58'!initialize	super initialize.	self wasActive: false.! !!MwBlockHandlerMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 4/7/2001 20:28'!exception	"^ <Exception class>"	^ exception! !!MwBlockHandlerMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!exception: anExceptionClass	^exception := anExceptionClass! !!MwBlockHandlerMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 4/7/2001 15:05'!handlerBlock	"^ <BlockContext>"	^ handlerBlock! !!MwBlockHandlerMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!handlerBlock: aBlockContext	^handlerBlock := aBlockContext! !!MwBlockMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/30/2001 22:38'!afterBlock	"^ <BlockContext>"	^ afterBlock! !!MwBlockMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!afterBlock: aBlockContext	^afterBlock := aBlockContext! !!MwBlockMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/13/2011 15:39'!beforeBlock "^<BlockClosure>"	^beforeBlock! !!MwBlockMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!beforeBlock: aBlockContext	^beforeBlock := aBlockContext! !!MwBlockMethodResultWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/19/2011 10:02'!curtailedBlock	"Answer the value of curtailedBlock"	^curtailedBlock! !!MwBlockMethodResultWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/19/2011 10:02'!curtailedBlock: anObject	"Set the value of curtailedBlock"	^curtailedBlock := anObject! !!MwCalledMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/30/2001 14:02'!called	"^ <Boolean>"	^ called! !!MwCalledMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!called: aBoolean	^called := aBoolean! !!MwCountMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/30/2001 13:38'!count	"^ <Integer>"	^ count! !!MwCountMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!count: anInteger	^count := anInteger! !!MwMethodBreakpointWrapperInstVars methodsFor: 'accessing' stamp: 'eem 10/7/2011 12:56'!breakInUnwrapped	"Answer the value of breakInUnwrapped"	^ breakInUnwrapped! !!MwMethodBreakpointWrapperInstVars methodsFor: 'accessing' stamp: 'eem 10/7/2011 12:57'!breakInUnwrapped: anObject	"Set the value of breakInUnwrapped"	^breakInUnwrapped := anObject! !!MwMethodBreakpointWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/27/2011 15:33'!nonQuickClientMethod	"Answer the value of nonQuickClientMethod"	^ nonQuickClientMethod! !!MwMethodBreakpointWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/27/2011 15:33'!nonQuickClientMethod: anObject	"Set the value of nonQuickClientMethod"	^nonQuickClientMethod := anObject! !!MwMethodBreakpointWrapperInstVars methodsFor: 'accessing' stamp: 'eem 10/7/2011 11:35'!nonQuickUnwrappedMethod	"Answer the value of nonQuickUnwrappedMethod"	^ nonQuickUnwrappedMethod! !!MwMethodBreakpointWrapperInstVars methodsFor: 'accessing' stamp: 'eem 10/7/2011 11:35'!nonQuickUnwrappedMethod: anObject	"Set the value of nonQuickUnwrappedMethod"	^nonQuickUnwrappedMethod := anObject! !!MwMethodBreakpointWrapperInstVars methodsFor: 'initialize-release' stamp: 'eem 10/7/2011 12:58'!initialize	super initialize.	breakInUnwrapped := true! !!MwSynchronizationWrapper methodsFor: 'evaluating' stamp: 'rhi 3/30/2001 19:09'!afterMethod	self shouldNotImplement.! !!MwSynchronizationWrapper methodsFor: 'evaluating' stamp: 'rhi 3/30/2001 19:09'!beforeMethod	self shouldNotImplement.! !!MwSynchronizationWrapper methodsFor: 'evaluating' stamp: 'eem 9/15/2011 15:39'!valueWithReceiver: anObject arguments: anArrayOfObjects	self flag: #rhi. "Need to ensure RecursionLock semantics!!"	^self recursionLock critical:		[self wasActive: true.		 self clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects]! !!MwSynchronizationWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!recursionLock	^self properties recursionLock! !!MwSynchronizationWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 15:50'!recursionLock: aMonitor	^self properties recursionLock: aMonitor! !!MwSynchronizationWrapper class methodsFor: 'testing' stamp: 'rhi 3/27/2001 09:58'!canWrap: aSelector inClass: aClass	self flag: #rhi. "Verify that Object>>primitiveChangeClassTo: will not fail!!"	"^ super canWrap: aSelector inClass: aClass"	"This could cause infinite recursion if wrapping classes."	^ true! !!MwSynchronizationWrapper class methodsFor: 'class initialization' stamp: 'rhi 3/30/2001 14:55'!initialize	"doIt: [self initialize]"	super initialize.! !!MwSynchronizationWrapper class methodsFor: 'installation' stamp: 'eem 9/16/2011 15:50'!installOn: aClass	| lock wrappers |	lock := Monitor new.	self flag: #rhi. "Shouldn't that be #allSelectors?!!"	wrappers := aClass selectors asOrderedCollection collect: [:each |		(self on: each inClass: aClass)			recursionLock: lock;			install;			yourself].	^wrappers! !!MwSynchronizationWrapper class methodsFor: 'installation' stamp: 'eem 9/16/2011 15:49'!installOnObject: anObject	| oldClass newBehavior lock |	oldClass := anObject class.	newBehavior := Behavior new.	newBehavior instVarNamed: 'format' put: oldClass format.	newBehavior superclass: oldClass.	newBehavior methodDictionary: MethodDictionary new.	self flag: #rhi. "Call self>>#installOn: instead!! (#allSelectors vs. #selectors?!!)"	lock := Monitor new.	newBehavior allSelectors asOrderedCollection collect: [:each |		(self on: each inClass: newBehavior)			recursionLock: lock;			install;			yourself].	newBehavior		addSelector: #synchronize		withMethod: (self class compiledMethodAt: #synchronize).	newBehavior		addSelector: #unsynchronize		withMethod: (self class compiledMethodAt: #unsynchronize).	anObject primitiveChangeClassTo: newBehavior basicNew! !!MwSynchronizationWrapper class methodsFor: 'installation' stamp: 'DF 4/19/2006 00:00'!uninstallOn: aClass	aClass selectors do: [:each |			| method |			method := aClass compiledMethodAt: each.			method isMwMethodWrapper ifTrue: [method uninstall]].! !!MwSynchronizationWrapper class methodsFor: 'installation' stamp: 'rhi 3/27/2001 09:47'!uninstallOnObject: anObject	anObject primitiveChangeClassTo: anObject class superclass basicNew.! !!MwSynchronizationWrapper class methodsFor: 'private' stamp: 'eem 9/16/2011 11:10'!methodPropertiesClass	^MwSynchronizationWrapperInstVars! !!MwSynchronizationWrapper class methodsFor: 'private' stamp: 'rhi 3/27/2001 09:49'!synchronize! !!MwSynchronizationWrapper class methodsFor: 'private' stamp: 'rhi 3/30/2001 15:36'!unsynchronize	self uninstallOnObject: self.! !!MwSynchronizationWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/30/2001 14:22'!recursionLock	"^ <Semaphore>"	^ recursionLock! !!MwSynchronizationWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!recursionLock: aSemaphore	^recursionLock := aSemaphore! !!MwTestCase methodsFor: 'accessing' stamp: 'rhi 6/18/2001 14:31'!result	"^ <Integer>"	^ result! !!MwTestCase methodsFor: 'accessing' stamp: 'DF 4/19/2006 00:00'!result: anInteger	result := anInteger.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'running' stamp: 'rhi 6/18/2001 14:32'!setUp	self result: 0.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'tests' stamp: 'pmm 8/25/2006 17:43'!testClassInstVars	self assert: self wrapperClass class instVarNames size = 0.	self assert: self wrapperClass classVarNames size = 0.	self assert: self wrapperClass protoMethods ~~ nil.	self assert: self wrapperClass protoMethods class == Dictionary.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testException	| wrapper instance |	instance := MwClassA new.	self should: [self result: instance methodWithException] raise: Warning.	self assert: self result = 0.	wrapper := self wrapperClass on: #methodWithException inClass: MwClassA.	wrapper		exception: Warning;		handlerBlock: [:receiver :arguments :ex | 42];		install.	self shouldnt: [self result: instance methodWithException] raise: Warning.	wrapper uninstall.	self assert: self result = 42.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testInstallUninstall	| wrapper |	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	wrapper install.	self assert: (MwClassA compiledMethodAt: #methodOne) class == self wrapperClass.	wrapper uninstall.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testNoException	| wrapper instance |	instance := MwClassA new.	self shouldnt: [self result: instance methodWithoutException] raise: Warning.	self assert: self result = 69.	wrapper := self wrapperClass on: #methodWithoutException inClass: MwClassA.	wrapper		exception: Warning;		handlerBlock: [:receiver :arguments :ex | 42];		install.	self shouldnt: [self result: instance methodWithoutException] raise: Warning.	wrapper uninstall.	self assert: self result = 69.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 01:02'!testNoProtoInstanceCount	| allInstCount protoInstCount |	Smalltalk garbageCollect.	allInstCount := self wrapperClass allInstances size.	protoInstCount := self wrapperClass protoMethods size.	self assert: (allInstCount - protoInstCount) = 0.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testOtherException	| wrapper instance |	instance := MwClassA new.	self should: [instance methodWithException] raise: Warning.	self assert: self result = 0.	wrapper := self wrapperClass on: #methodWithException inClass: MwClassA.	wrapper		exception: Error;		handlerBlock: [:receiver :arguments :ex | 42];		install.	self should: [self result: instance methodWithException] raise: Warning.	wrapper uninstall.	self assert: self result = 0.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'tests' stamp: 'rhi 4/7/2001 21:51'!testTweakClassFormat	self assert: (self wrapperClass format bitAnd: 16r200) = 16r200.! !!MwBlockHandlerMethodWrapperTest methodsFor: 'private' stamp: 'rhi 4/7/2001 21:41'!wrapperClass	^ MwBlockHandlerMethodWrapper! !!MwBlockMethodWrapperTest methodsFor: 'running' stamp: 'rhi 6/18/2001 14:32'!setUp	self result: 0.! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testAfter	| wrapper instance |	instance := MwClassA new.	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	wrapper		afterBlock: [:receiver :arguments | self result: self result + 4];		install.	instance methodOne.	wrapper uninstall.	self assert: self result = 4.! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testBefore	| wrapper instance |	instance := MwClassA new.	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	wrapper		beforeBlock: [:receiver :arguments | self result: self result + 3];		install.	instance methodOne.	wrapper uninstall.	self assert: self result = 3.! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testBeforeAfter	| wrapper instance |	instance := MwClassA new.	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	wrapper		beforeBlock: [:receiver :arguments | self result: self result + 3];		afterBlock: [:receiver :arguments | self result: self result + 4];		install.	instance methodOne.	wrapper uninstall.	self assert: self result = 7.! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testBeforeAfterWithChangedArgument	| wrapper instance |	instance := MwClassA new.	instance x: 0.	wrapper := self wrapperClass on: #methodWithArgument: inClass: MwClassA.	wrapper		beforeBlock: [:receiver :arguments | arguments at: 1 put: (arguments first raisedTo: 4)];		afterBlock: [:receiver :arguments | receiver x: receiver x + (arguments first raisedTo: 3)];		install.	self result: (instance methodWithArgument: 2).	wrapper uninstall.	self assert: self result = 16. "0 + 2^4"	self assert: instance x = 4112. "0 + 2^4+ (2^4)^3"! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testBeforeAfterWithReceiver	| wrapper instance |	instance := MwClassA new.	instance x: 0.	wrapper := self wrapperClass on: #methodWithArgument: inClass: MwClassA.	wrapper		beforeBlock: [:receiver :arguments | receiver x: receiver x + 3];		afterBlock: [:receiver :arguments | receiver x: receiver x + 4];		install.	self result: (instance methodWithArgument: 2).	wrapper uninstall.	self assert: self result = 5.	self assert: instance x = 9.! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testBeforeAfterWithReceiverAndArgument	| wrapper instance |	instance := MwClassA new.	instance x: 0.	wrapper := self wrapperClass on: #methodWithArgument: inClass: MwClassA.	wrapper		beforeBlock: [:receiver :arguments | receiver x: receiver x + (arguments first raisedTo: 2)];		afterBlock: [:receiver :arguments | receiver x: receiver x + (arguments first raisedTo: 3)];		install.	self result: (instance methodWithArgument: 2).	wrapper uninstall.	self assert: self result = 6. "0 + 2^2 + 2"	self assert: instance x = 14. "0 + 2^2 + 2 + 2^3"! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/16/2011 11:04'!testClassInstVars	self assert: self wrapperClass class instVarNames size = 0.	self assert: self wrapperClass classVarNames size = 0.	self assert: self wrapperClass methodPropertiesClass == MwBlockMethodWrapperInstVars.	self assert: self wrapperClass protoMethods ~~ nil.	self assert: self wrapperClass protoMethods class == Dictionary.! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testInstallUninstall	| wrapper |	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	wrapper install.	self assert: (MwClassA compiledMethodAt: #methodOne) class == self wrapperClass.	wrapper uninstall.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 01:03'!testNoProtoInstanceCount	| allInstCount protoInstCount |	Smalltalk garbageCollect.	allInstCount := self wrapperClass allInstances size.	protoInstCount := self wrapperClass protoMethods size.	self assert: (allInstCount - protoInstCount) = 0.! !!MwBlockMethodWrapperTest methodsFor: 'tests' stamp: 'rhi 3/29/2001 21:26'!testTweakClassFormat	self assert: (self wrapperClass format bitAnd: 16r200) = 16r200.! !!MwBlockMethodWrapperTest methodsFor: 'private' stamp: 'rhi 3/29/2001 21:01'!wrapperClass	^ MwBlockMethodWrapper! !!MwBreakpointMethodWrapperTest methodsFor: 'tests' stamp: 'eem 10/5/2011 14:14'!testBreakpointsAndTracepoints	"Test that breakpoints play well with others		- the wrapped method is run only once		- the other wrapper action occurs		- the breakpoint is above the right method."	| instance bptWrapper blkWrapper blkWrapperInvoked signallerSenderMethod |	instance := MwClassA new.	instance x: 0.	self shouldnt: [self result: instance x] raise: Halt.	self assert: self result = 0.	blkWrapperInvoked := false.	bptWrapper := self wrapperClass on: #methodWithArgument: inClass: MwClassA.	blkWrapper := MwBlockMethodWrapper on: #methodWithArgument: inClass: MwClassA.	blkWrapper beforeBlock: [:rcvr :args| blkWrapperInvoked := true].	bptWrapper install.	blkWrapper install.	self should: [self result: (instance methodWithArgument: 1)] raise: Halt.	self assert: instance x = 0. "method should not have meen evaluated because we stopped execution at the Halt."	self assert: blkWrapperInvoked. "but tracing wrapper should have run"	instance x: 0.	blkWrapperInvoked := false.	"now proceed through the halt and check that		- the breakpoint is above the unwrapped method (not the block wrapper method)		- the unwrapped method is run"	[self result: (instance methodWithArgument: 1)]		on: Halt		do: [:ex|			signallerSenderMethod := ex signalerContext sender method.			ex resume].	self assert: signallerSenderMethod == bptWrapper unwrappedMethod.	blkWrapper uninstall.	bptWrapper uninstall.	self assert: self result = 1. "method should have been run precisely once."	self assert: blkWrapperInvoked. "and tracing wrapper should have run"! !!MwBreakpointMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/27/2011 16:35'!testNonQuickMethodBreakpoints	| wrapper instance |	instance := MwClassA new.	self shouldnt: [self result: instance methodWithoutException] raise: Halt.	self assert: self result = 69.	wrapper := self wrapperClass on: #methodWithoutException inClass: MwClassA.	wrapper install.	self assert: wrapper clientMethod isQuick not.	self result: nil.	self should: [self result: instance methodWithoutException] raise: Halt.	self assert: self result isNil.	[self result: instance methodWithoutException]		on: Halt		do: [:ex| ex resume].	wrapper uninstall.	self assert: self result = 69! !!MwBreakpointMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/27/2011 16:36'!testQuickMethodBreakpoints	| wrapper instance |	instance := MwClassA new.	instance x: 0.	self shouldnt: [self result: instance x] raise: Halt.	self assert: self result = 0.	wrapper := self wrapperClass on: #x inClass: MwClassA.	wrapper install.	self assert: wrapper clientMethod isQuick.	self should: [self result: instance x] raise: Halt.	[instance x: 42.	 self result: instance x]		on: Halt		do: [:ex| ex resume].	wrapper uninstall.	self assert: self result = 42! !!MwBreakpointMethodWrapperTest methodsFor: 'tests' stamp: 'eem 10/5/2011 14:14'!testTracepointsAndBreakpoints	"Test that breakpoints play well with others		- the wrapped method is run only once		- the other wrapper action occurs		- the breakpoint is above the right method."	| instance bptWrapper blkWrapper blkWrapperInvoked signallerSenderMethod |	instance := MwClassA new.	instance x: 0.	self shouldnt: [self result: instance x] raise: Halt.	self assert: self result = 0.	blkWrapperInvoked := false.	bptWrapper := self wrapperClass on: #methodWithArgument: inClass: MwClassA.	blkWrapper := MwBlockMethodWrapper on: #methodWithArgument: inClass: MwClassA.	blkWrapper beforeBlock: [:rcvr :args| blkWrapperInvoked := true].	blkWrapper install.	bptWrapper install.	self should: [self result: (instance methodWithArgument: 1)] raise: Halt.	self assert: instance x = 0. "method should not have meen evaluated because we stopped execution at the Halt."	self assert: blkWrapperInvoked not. "but tracing wrapper should not have run"	instance x: 0.	blkWrapperInvoked := false.	"now proceed through the halt and check that		- the breakpoint is above the unwrapped method (not the block wrapper method)		- the unwrapped method is run"	[self result: (instance methodWithArgument: 1)]		on: Halt		do: [:ex|			signallerSenderMethod := ex signalerContext sender method.			ex resume].	self assert: signallerSenderMethod == bptWrapper unwrappedMethod.	blkWrapper uninstall.	bptWrapper uninstall.	self assert: self result = 1. "method should have been run precisely once."	self assert: blkWrapperInvoked. "and tracing wrapper should have run"! !!MwBreakpointMethodWrapperTest methodsFor: 'private' stamp: 'eem 9/27/2011 16:35'!wrapperClass	^MwMethodBreakpointWrapper! !!MwCalledMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testCalledWasActive	| wrapper instance |	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	wrapper install.	instance := MwClassA new.	self assert: wrapper called not.	self assert: wrapper wasActive not.	instance methodOne.	self assert: wrapper wasActive.	wrapper uninstall.! !!MwCalledMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/16/2011 11:04'!testClassInstVars	self assert: self wrapperClass class instVarNames size = 1.	self assert: self wrapperClass classVarNames size = 0.	self assert: self wrapperClass installing == false.	self assert: self wrapperClass methodPropertiesClass == MwCalledMethodWrapperInstVars.	self assert: self wrapperClass protoMethods ~~ nil.	self assert: self wrapperClass protoMethods class == Dictionary.! !!MwCalledMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 01:03'!testNoProtoInstanceCount	| allInstCount protoInstCount |	Smalltalk garbageCollect.	allInstCount := self wrapperClass allInstances size.	protoInstCount := self wrapperClass protoMethods size.	self assert: (allInstCount - protoInstCount) = 0.! !!MwCalledMethodWrapperTest methodsFor: 'tests' stamp: 'rhi 3/29/2001 21:27'!testTweakClassFormat	self assert: (self wrapperClass format bitAnd: 16r200) = 16r200.! !!MwCalledMethodWrapperTest methodsFor: 'private' stamp: 'rhi 3/29/2001 21:02'!wrapperClass	^ MwCalledMethodWrapper! !!MwCountMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/16/2011 11:04'!testClassInstVars	self assert: self wrapperClass class instVarNames size = 0.	self assert: self wrapperClass classVarNames size = 0.	self assert: self wrapperClass methodPropertiesClass == MwCountMethodWrapperInstVars.	self assert: self wrapperClass protoMethods ~~ nil.	self assert: self wrapperClass protoMethods class == Dictionary.! !!MwCountMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testCounts	| wrapper instance |	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	wrapper install.	instance := MwClassA new.	self assert: wrapper count = 0.	instance methodOne.	self assert: wrapper count = 1.	instance methodOne.	self assert: wrapper count = 2.	wrapper uninstall.! !!MwCountMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 01:03'!testNoProtoInstanceCount	| allInstCount protoInstCount |	Smalltalk garbageCollect.	allInstCount := self wrapperClass allInstances size.	protoInstCount := self wrapperClass protoMethods size.	self assert: (allInstCount - protoInstCount) = 0.! !!MwCountMethodWrapperTest methodsFor: 'tests' stamp: 'rhi 3/29/2001 21:17'!testTweakClassFormat	self assert: (self wrapperClass format bitAnd: 16r200) = 16r200.! !!MwCountMethodWrapperTest methodsFor: 'private' stamp: 'rhi 3/29/2001 21:03'!wrapperClass	^ MwCountMethodWrapper! !!MwMethodWrapperTest methodsFor: 'running' stamp: 'eem 9/15/2011 15:43'!tearDown	"make sure the wrappers are properly torn down or all hell breaks loose running these tests."	{MwClassA. MwClassB} do:		[:c|		c selectorsAndMethodsDo:			[:s :m|			m class ~~ CompiledMethod ifTrue:				[m clientMethod == m					ifTrue: [self halt] "This definitely should not happen, and prevents correct uninstallation"					ifFalse:						[Transcript							ensureCr;							nextPutAll: 'warning, '; print: thisContext home;							nextPutAll: ' had to uninstall '; print: c; nextPut: $>; nextPutAll: s;							nextPutAll: ' after test '; print: self class; nextPut: $>; print: testSelector]]]]! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/13/2011 15:20'!testCanWrapInClass	"Method wrappers can NOT be wrapped."	self deny: (self wrapperClass canWrap: #spunk inClass: self wrapperClass).	"BlockContext>>ensure: can NOT be wrapped."	self deny: (self wrapperClass canWrap: #ensure: inClass: BlockClosure).	"CompiledMethod>>valueWithReceiver:arguments: can NOT be wrapped."	self deny: (self wrapperClass		canWrap: #valueWithReceiver:arguments: inClass: CompiledMethod).	"A method that is not implemented by a class/object can NOT be wrapped."	self assert: ((Object canUnderstand: #ensure:) not		and: [(self wrapperClass canWrap: #ensure: inClass: Object) not]).	"Certain primitives may NOT be wrapped."	self assert: ((Object includesSelector: #at:put:)		and: [(self wrapperClass canWrap: #at:put: inClass: Object) not]).	self assert: ((BlockClosure includesSelector: #value)		and: [(self wrapperClass canWrap: #value inClass: BlockClosure) not]).! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testChainRemoveLastFirst	| wrapperOne wrapperTwo |	wrapperOne := self wrapperClass on: #methodOne inClass: MwClassA.	wrapperTwo := self wrapperClass on: #methodOne inClass: MwClassA.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	wrapperOne install.	self assert: wrapperOne wrappingWrapper == nil.	self assert: wrapperOne clientMethod ~~ nil.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperOne.	wrapperTwo install.	self assert: wrapperOne wrappingWrapper == wrapperTwo.	self assert: wrapperTwo wrappingWrapper == nil.	self assert: wrapperTwo clientMethod == wrapperOne.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperTwo.	wrapperTwo uninstall.	self assert: wrapperOne wrappingWrapper == nil.	self assert: wrapperOne clientMethod ~~ nil.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperOne.	self assert: wrapperTwo clientMethod == nil.	wrapperOne uninstall.	self assert: wrapperOne clientMethod == nil.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testChainRemoveLastFirstHierarchy	| wrapperOne wrapperTwo |	wrapperOne := self wrapperClass on: #methodOne inClass: MwClassA.	wrapperTwo := self wrapperClass on: #methodOne inClass: MwClassB.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	wrapperOne install.	self assert: wrapperOne wrappingWrapper == nil.	self assert: wrapperOne clientMethod ~~ nil.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperOne.	wrapperTwo install.	self assert: wrapperOne wrappingWrapper == wrapperTwo.	self assert: wrapperTwo wrappingWrapper == nil.	self assert: wrapperTwo clientMethod == wrapperOne.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperOne.	self assert: (MwClassB compiledMethodAt: #methodOne) == wrapperTwo.	wrapperTwo uninstall.	self assert: wrapperOne wrappingWrapper == nil.	self assert: wrapperOne clientMethod ~~ nil.	self assert: wrapperTwo clientMethod == nil.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperOne.	self assert: (MwClassB compiledMethodAt: #methodOne ifAbsent: [nil]) == nil.	wrapperOne uninstall.	self assert: wrapperOne clientMethod == nil.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testChainRemoveMiddleFirst	| wrapperOne wrapperTwo |	wrapperOne := self wrapperClass on: #methodOne inClass: MwClassA.	wrapperTwo := self wrapperClass on: #methodOne inClass: MwClassA.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	wrapperOne install.	self assert: wrapperOne wrappingWrapper == nil.	self assert: wrapperOne clientMethod ~~ nil.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperOne.	wrapperTwo install.	self assert: wrapperOne wrappingWrapper == wrapperTwo.	self assert: wrapperTwo wrappingWrapper == nil.	self assert: wrapperTwo clientMethod == wrapperOne.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperTwo.	wrapperOne uninstall.	self assert: wrapperOne wrappingWrapper == nil.	self assert: wrapperTwo clientMethod ~~ nil.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperTwo.	self assert: wrapperOne clientMethod == nil.	wrapperTwo uninstall.	self assert: wrapperTwo clientMethod == nil.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testChainRemoveMiddleFirstHierarchy	| wrapperOne wrapperTwo |	wrapperOne := self wrapperClass on: #methodOne inClass: MwClassA.	wrapperTwo := self wrapperClass on: #methodOne inClass: MwClassB.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	wrapperOne install.	self assert: wrapperOne wrappingWrapper == nil.	self assert: wrapperOne clientMethod ~~ nil.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperOne.	wrapperTwo install.	self assert: wrapperOne wrappingWrapper == wrapperTwo.	self assert: wrapperTwo wrappingWrapper == nil.	self assert: wrapperTwo clientMethod == wrapperOne.	self assert: (MwClassA compiledMethodAt: #methodOne) == wrapperOne.	self assert: (MwClassB compiledMethodAt: #methodOne) == wrapperTwo.	wrapperOne uninstall.	self assert: wrapperOne wrappingWrapper == nil.	self assert: wrapperOne clientMethod == nil.	self assert: wrapperTwo clientMethod ~~ nil.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	self assert: (MwClassB compiledMethodAt: #methodOne) == wrapperTwo.	wrapperTwo uninstall.	self assert: wrapperTwo clientMethod == nil.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	self assert: (MwClassB compiledMethodAt: #methodOne ifAbsent: [nil]) == nil.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'pmm 8/25/2006 17:44'!testClassInstVars	self assert: self wrapperClass class instVarNames size = 1.	self assert: self wrapperClass classVarNames size = 0.	self assert: self wrapperClass protoMethods ~~ nil.	self assert: self wrapperClass protoMethods class == Dictionary.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/14/2011 13:10'!testCodeString0	| expected actual |	expected := 'value	^#''The method wrapper should be inserted in this position!!'' valueWithReceiver: self arguments: {}'.	actual := self wrapperClass codeStringFor: 0.	self assert: expected = actual! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/14/2011 13:12'!testCodeString1	| expected actual |	expected := 'value: t1	^#''The method wrapper should be inserted in this position!!'' valueWithReceiver: self arguments: {t1}'.	actual := self wrapperClass codeStringFor: 1.	self assert: expected = actual! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/14/2011 13:11'!testCodeString2	| expected actual |	expected := 'value: t1 value: t2	^#''The method wrapper should be inserted in this position!!'' valueWithReceiver: self arguments: {t1. t2}'.	actual := self wrapperClass codeStringFor: 2.	self assert: expected = actual! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testDefiningWrappedDifferent	| wrapper clientSelector wrappedClass |	clientSelector := #methodOne.	wrappedClass := MwClassB.	wrapper := self wrapperClass on: clientSelector inClass: wrappedClass.	wrapper install.	self assert: wrapper definingClass == MwClassA.	self assert: wrapper wrappedClass == wrappedClass.	wrapper uninstall.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testDefiningWrappedSame	| wrapper clientSelector wrappedClass |	clientSelector := #methodOne.	wrappedClass := MwClassA.	wrapper := self wrapperClass on: clientSelector inClass: wrappedClass.	wrapper install.	self assert: wrapper definingClass == wrappedClass.	self assert: wrapper wrappedClass == wrappedClass.	wrapper uninstall.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testDefiningWrappedSame2	| wrapper clientSelector wrappedClass |	clientSelector := #methodTwo.	wrappedClass := MwClassA.	wrapper := self wrapperClass on: clientSelector inClass: wrappedClass.	wrapper install.	self assert: wrapper definingClass == wrappedClass.	self assert: wrapper wrappedClass == wrappedClass.	wrapper uninstall.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testDefiningWrappedSame3	| wrapper clientSelector wrappedClass |	clientSelector := #methodTwo.	wrappedClass := MwClassB.	wrapper := self wrapperClass on: clientSelector inClass: wrappedClass.	wrapper install.	self assert: wrapper definingClass == wrappedClass.	self assert: wrapper wrappedClass == wrappedClass.	wrapper uninstall.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testDefiningWrappedSame4	| wrapper clientSelector wrappedClass |	clientSelector := #methodThree.	wrappedClass := MwClassB.	wrapper := self wrapperClass on: clientSelector inClass: wrappedClass.	wrapper install.	self assert: wrapper definingClass == wrappedClass.	self assert: wrapper wrappedClass == wrappedClass.	wrapper uninstall.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testDerivedInstVars	| wrapper |	wrapper := self wrapperClass new.	self assert: wrapper clientSelector == nil.	self assert: wrapper clientMethod == nil.	self assert: wrapper definingClass == nil.	self assert: wrapper wrappedClass == nil.	self assert: wrapper wrappingWrapper == nil.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testInstallInstantiateUninstall	| wrapper instance |	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	wrapper install.	instance := MwClassA new.	instance methodOne.	wrapper uninstall.	instance methodOne.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testInstallUninstall	| wrapper |	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.	wrapper install.	self assert: (MwClassA compiledMethodAt: #methodOne) class == self wrapperClass.	wrapper uninstall.	self assert: (MwClassA compiledMethodAt: #methodOne) class == CompiledMethod.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testInstantiateInstallUninstall	| wrapper instance |	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	instance := MwClassA new.	instance methodOne.	wrapper install.	instance methodOne.	wrapper uninstall.	instance methodOne.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/14/2011 13:14'!testMethodPosition0	| expected actual |	expected := 3.	actual := (self wrapperClass createMethodFor: 0) methodPosition.	self assert: expected = actual! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/14/2011 13:14'!testMethodPosition1	| expected actual |	expected := 3.	actual := (self wrapperClass createMethodFor: 1) methodPosition.	self assert: expected = actual! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/14/2011 13:14'!testMethodPosition2	| expected actual |	expected := 3.	actual := (self wrapperClass createMethodFor: 2) methodPosition.	self assert: expected = actual! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 01:03'!testNoProtoInstanceCount	| allInstCount protoInstCount |	Smalltalk garbageCollect.	allInstCount := self wrapperClass allInstances size.	protoInstCount := self wrapperClass protoMethods size.	self assert: (allInstCount - protoInstCount) = 0.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/14/2011 11:21'!testOnInClass	| wrapper clientSelector wrappedClass |	clientSelector := #methodOne.	wrappedClass := MwClassA.	wrapper := self wrapperClass on: clientSelector inClass: wrappedClass.	self assert: wrapper clientSelector == clientSelector.	self assert: wrapper clientMethod == nil.	self assert: wrapper definingClass == nil.	self assert: wrapper wrappedClass == wrappedClass.	self assert: wrapper wrappingWrapper == nil.	self assert: (wrapper realObjectAt: wrapper methodPosition) == wrapper.	wrapper uninstall.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'rhi 3/29/2001 21:27'!testTweakClassFormat	self assert: (self wrapperClass format bitAnd: 16r200) = 16r200.! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/19/2011 10:19'!testTweakClassFormatAllSubclasses	self wrapperClass withAllSubclassesDo: [:each |		self assert: each instSpec = CompiledMethod instSpec].! !!MwMethodWrapperTest methodsFor: 'tests' stamp: 'eem 9/16/2011 11:53'!testWasActive	| wrapper |	wrapper := self wrapperClass on: #methodOne inClass: MwClassA.	self deny: wrapper wasActive.	wrapper install.	self deny: wrapper wasActive.	wrapper uninstall.	self deny: wrapper wasActive.	self shouldnt: [wrapper install] raise: Error.	wrapper uninstall! !!MwMethodWrapperTest methodsFor: 'private' stamp: 'rhi 3/29/2001 20:50'!wrapperClass	^ MwMethodWrapper! !!MwSynchronizationWrapperTest methodsFor: 'tests' stamp: 'pmm 8/25/2006 17:43'!testClassInstVars	self assert: self wrapperClass class instVarNames size = 0.	self assert: self wrapperClass classVarNames size = 0.	self assert: self wrapperClass protoMethods ~~ nil.	self assert: self wrapperClass protoMethods class == Dictionary.! !!MwSynchronizationWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 01:03'!testNoProtoInstanceCount	| allInstCount protoInstCount |	Smalltalk garbageCollect.	allInstCount := self wrapperClass allInstances size.	protoInstCount := self wrapperClass protoMethods size.	self assert: (allInstCount - protoInstCount) = 0.! !!MwSynchronizationWrapperTest methodsFor: 'tests' stamp: 'rhi 3/29/2001 21:27'!testTweakClassFormat	self assert: (self wrapperClass format bitAnd: 16r200) = 16r200.! !!MwSynchronizationWrapperTest methodsFor: 'private' stamp: 'rhi 3/29/2001 21:03'!wrapperClass	^ MwSynchronizationWrapper! !!MwTimeMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 3/30/2001 19:03'!afterMethod	self shouldNotImplement.! !!MwTimeMethodWrapper methodsFor: 'evaluating' stamp: 'rhi 3/30/2001 19:03'!beforeMethod	self shouldNotImplement.! !!MwTimeMethodWrapper methodsFor: 'evaluating' stamp: 'eem 9/15/2011 15:40'!valueWithReceiver: anObject arguments: argumentsArray	"This method was overriden so that recursive calls will have a different beginTime."	| beginTime |	self wasActive: true.	beginTime := Time millisecondClockValue.	self count: self count + 1.	^[self clientMethod valueWithReceiver: anObject arguments: argumentsArray]		ensure: [self time: self time + (Time millisecondClockValue - beginTime max: 0)]! !!MwTimeMethodWrapper methodsFor: 'derived accessing' stamp: 'rhi 2/23/2001 14:34'!averageTime	^ self count == 0		ifTrue: [0]		ifFalse: [self totalTime / self count asFloat]! !!MwTimeMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!time	^self properties time! !!MwTimeMethodWrapper methodsFor: 'derived accessing' stamp: 'eem 9/16/2011 10:59'!time: anInteger	^self properties time: anInteger! !!MwTimeMethodWrapper methodsFor: 'derived accessing' stamp: 'rhi 3/21/2001 15:20'!totalTime	^ self time! !!MwTimeMethodWrapper methodsFor: 'initialization' stamp: 'rhi 3/21/2001 15:22'!class: aClass selector: aSymbol	self time: 0.	^ super class: aClass selector: aSymbol! !!MwTimeMethodWrapper class methodsFor: 'class initialization' stamp: 'rhi 3/30/2001 13:55'!initialize	"doIt: [self initialize]"	super initialize.! !!MwTimeMethodWrapper class methodsFor: 'private' stamp: 'eem 9/16/2011 11:10'!methodPropertiesClass	^MwTimeMethodWrapperInstVars! !!MwTimeMethodWrapperInstVars methodsFor: 'accessing' stamp: 'rhi 3/30/2001 13:39'!time	"^ <Integer>"	^ time! !!MwTimeMethodWrapperInstVars methodsFor: 'accessing' stamp: 'eem 9/16/2011 12:03'!time: anInteger	^time := anInteger! !!MwTimeMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testAverageTime	| wrapper instance count |	count := 10.	wrapper := self wrapperClass on: #methodDelay inClass: MwClassA.	wrapper install.	instance := MwClassA new.	count timesRepeat: [instance methodDelay].	self assert: wrapper count = count.	self assert: (wrapper time / count asFloat) = wrapper averageTime.	wrapper uninstall.! !!MwTimeMethodWrapperTest methodsFor: 'tests' stamp: 'pmm 8/25/2006 17:43'!testClassInstVars	self assert: self wrapperClass class instVarNames size = 0.	self assert: self wrapperClass classVarNames size = 0.	self assert: self wrapperClass protoMethods ~~ nil.	self assert: self wrapperClass protoMethods class == Dictionary.! !!MwTimeMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testCounts	| wrapper instance |	wrapper := self wrapperClass on: #methodDelay inClass: MwClassA.	wrapper install.	instance := MwClassA new.	self assert: wrapper count = 0.	instance methodDelay.	self assert: wrapper count = 1.	instance methodDelay.	self assert: wrapper count = 2.	wrapper uninstall.! !!MwTimeMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testCountsAndTimes	| wrapper instance |	wrapper := self wrapperClass on: #methodDelay inClass: MwClassA.	wrapper install.	instance := MwClassA new.	self assert: wrapper count = 0.	self assert: wrapper time = 0.	instance methodDelay.	self assert: wrapper count = 1.	self assert: wrapper time > 0.	instance methodDelay.	self assert: wrapper count = 2.	self assert: wrapper time > 0.	wrapper uninstall.! !!MwTimeMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 01:03'!testNoProtoInstanceCount	| allInstCount protoInstCount |	Smalltalk garbageCollect.	allInstCount := self wrapperClass allInstances size.	protoInstCount := self wrapperClass protoMethods size.	self assert: (allInstCount - protoInstCount) = 0.! !!MwTimeMethodWrapperTest methodsFor: 'tests' stamp: 'DF 4/19/2006 00:00'!testTimes	| wrapper instance previousTime |	wrapper := self wrapperClass on: #methodDelay inClass: MwClassA.	wrapper install.	instance := MwClassA new.	self assert: wrapper time = 0.	previousTime := wrapper time.	instance methodDelay.	self assert: wrapper time > previousTime.	previousTime := wrapper time.	instance methodDelay.	self assert: wrapper time > previousTime.	wrapper uninstall.! !!MwTimeMethodWrapperTest methodsFor: 'tests' stamp: 'rhi 3/29/2001 21:27'!testTweakClassFormat	self assert: (self wrapperClass format bitAnd: 16r200) = 16r200.! !!MwTimeMethodWrapperTest methodsFor: 'private' stamp: 'rhi 3/29/2001 21:04'!wrapperClass	^ MwTimeMethodWrapper! !MwTimeMethodWrapper initialize!MwSynchronizationWrapper initialize!MwCountMethodWrapper initialize!MwCalledMethodWrapper initialize!MwBlockMethodWrapper initialize!MwBlockHandlerMethodWrapper initialize!MwMethodWrapper initialize!
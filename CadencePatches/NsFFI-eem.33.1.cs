'From nsboot-2011-08-03 of 3 August 2011 [latest update: #10966] on 12 June 2012 at 9:34:01 pm'!Object subclass: #Callback	instanceVariableNames: 'block thunk argsProxy resultProxy argsProxyClass evaluator numEvaluatorArgs '	classVariableNames: 'FlushThunkToCallbackMap ThunkToCallbackMap ABI '	poolDictionaries: ''	category: 'NsFFI'!!Callback commentStamp: '<historical>' prior: 0!Callbacks encapsulate callbacks from the outside world.  They allow Smalltalk blocks to be evaluated and answer their results to external (e.g. C) callees.Instance Variables:block <BlockContext> - The Smalltalk code to be run in response to external code invoking the callback.thunk <FFICallbackThunk> - the wrapper around the machine-code thunk that initiates the callback and whose address should be passed to CargsProxy <Alien> - the wrapper around the thunk's incomming stack pointer, used to extract arguments from the stack.resultProxy <FFICalbackReturnValue> - the specification of the block's return value and its C type so that the result can be passed back in the right low-level form.Class Variables:ThunkToCallbackMap <Dictionary of: thunkAddress <Integer> -> callback <Callback>> - used to lookup the Callback associated with a specific thunk address on callback.  See FFICallbackThunk.   Copyright 2008 Cadence Design Systems, Inc.      Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0!!Alien methodsFor: 'accessing' stamp: 'John M McIntosh 11/23/2008 23:41'!strcpyUTF8From: startIndex "<Integer> ^<String>"	| length bytes |	length := self strlenStartingAt: startIndex.	self copyInto: (bytes := ByteArray new: length)		from: 1 to: length		in: self startingAt: startIndex.	^bytes utf8ToIso! !!Alien methodsFor: 'primitives-accessing' stamp: 'John M McIntosh 12/5/2008 09:41'!signedLongLongAt: index "<Integer> ^<Integer>"	<primitive: 'primSignedLongLongAt' module: 'IA32ABI' error: errorCode>	^self primitiveFailed! !!Alien methodsFor: 'primitives-accessing' stamp: 'John M McIntosh 12/5/2008 09:41'!signedLongLongAt: index "<Integer>" put: value "<Integer> ^<Integer>"	<primitive: 'primSignedLongLongAtPut' module: 'IA32ABI' error: errorCode>	^self primitiveFailed! !!Alien methodsFor: 'printing' stamp: 'eem 10/14/2010 16:39'!storeOn: aStream	| sizeField |	(sizeField := self sizeField) > 0	ifTrue:		[aStream nextPut: $(].	aStream nextPut: $(; print: self class.	sizeField = 0		ifTrue:			[aStream				nextPutAll: ' forPointer: '; nextPutAll: self addressField storeStringHex]		ifFalse:			[aStream				nextPutAll: ' basicNew: '; print: sizeField + 4; nextPut: $);				crtab; nextPutAll: 'sizeFieldPut: '; print: sizeField.			 sizeField > 0 ifTrue:				[1 to: sizeField by: 4 do:					[:i| | v |					(v := self unsignedLongAt: i) ~= 0 ifTrue:						[aStream							nextPut: $;; crtab;							nextPutAll: 'unsignedLongAt: '; print: i;							nextPutAll: ' put: '; print: v]]].				aStream nextPut: $;; crtab; nextPutAll: #yourself].	aStream nextPut: $)! !!Alien class methodsFor: 'instance creation' stamp: 'eem 12/2/2008 12:01'!newGC	"Answer a new instance of the default size whose data resides on the external C heap,	 and whose data will be reclaimed automatically when the instance is garbage collected."	^self newGC: self dataSize! !!Alien class methodsFor: 'instance creation' stamp: 'eem 12/2/2008 12:01'!newGC: byteSize	"Answer a new instance of the given byte size whose data resides on the external C heap,	 and whose data will be reclaimed automatically when the instance is garbage collected.	 As with instances residing on the Smalltalk heap the data is zero-filled."	| alien address |	(alien := self basicNew: 8)		sizeFieldPut: byteSize negated.	address := self Ccalloc: byteSize.	GCMallocedAliens add: alien finalizing: address.	^alien		addressFieldPut: address;		initialize! !!Alien class methodsFor: 'libraries' stamp: 'eem 5/19/2012 13:53'!lookup: symbol "<String>" inLibrary: libraryNameOrAlien "<String|Alien> ^<Alien>"	^self forPointer: ((libraryNameOrAlien isString						ifTrue: [self ensureLoaded: libraryNameOrAlien]						ifFalse: [libraryNameOrAlien])							primFindSymbol: symbol)! !!Alien class methodsFor: 'callbacks' stamp: 'eem 10/15/2010 10:45'!invokeCallbackContext: vmCallbackContextAddress "<Integer>" "^<FFICallbackReturnValue>"	"The low-level entry-point for callbacks sent from the VM/IA32ABI plugin.	 Return via primReturnFromContext:through:.  thisContext's sender is the	 call-out context."	| callbackAlien type |	callbackAlien := (Smalltalk wordSize = 4						ifTrue: [VMCallbackContext32]						ifFalse: [VMCallbackContext64])							atAddress: vmCallbackContextAddress.	[type := Callback evaluateCallbackForContext: callbackAlien]		ifCurtailed: [self error: 'attempt to non-local return across a callback'].	type ifNil:		[type := 1. callbackAlien wordResult: -1].	callbackAlien primReturnAs: type fromContext: thisContext! !!Alien class methodsFor: 'examples' stamp: 'eem 5/21/2012 12:34'!libcName	| platform |	platform := SmalltalkImage current platformName.	platform = 'Mac OS' ifTrue:		[^SmalltalkImage current osVersion asInteger >= 1050			ifTrue: ['libgcc_s.1.dylib']			ifFalse: ['libc.dylib']].	platform = 'unix' ifTrue:		[SmalltalkImage current osVersion = 'linux-gnu' ifTrue:			[^'libc.so.6'].		 ^'libc.so'].	platform = 'Win32' ifTrue:		[^'msvcrt.dll'].	^nil! !!AlienDemo methodsFor: 'examples' stamp: 'eem 5/21/2012 12:41'!libcName	| platform |	platform := SmalltalkImage current platformName.	platform = 'Mac OS' ifTrue:		[^SmalltalkImage current osVersion asInteger >= 1050			ifTrue: ['libgcc_s.1.dylib']			ifFalse: ['libc.dylib']].	platform = 'unix' ifTrue:		[SmalltalkImage current osVersion = 'linux-gnu' ifTrue:			[^'libc.so.6'].		 ^'libc.so'].	platform = 'Win32' ifTrue:		[^'msvcrt.dll'].	^nil! !!Callback methodsFor: 'instance initialization' stamp: 'eem 10/15/2010 10:51'!block: aBlock "<BlockClosure>" thunk: thunkWrapper "<FFICallbackThunk>" argsProxyClass: argsWrapperClass "<Alien class>"	<legacy>	block := aBlock.	thunk := thunkWrapper.	argsProxyClass := argsWrapperClass.	self addToThunkTable! !!Callback methodsFor: 'instance initialization' stamp: 'eem 10/15/2010 10:51'!signature: signature "<String>" block: aBlock "<BlockClosure>"	| method |	method := self evaluatorForSignature: signature.	block := aBlock.	thunk := (method pragmaAt: #calleepops:)				ifNil: [FFICallbackThunk newCCall]				ifNotNil:					[:pragma|					FFICallbackThunk newStdCall: (pragma argumentAt: 1)].	numEvaluatorArgs := (evaluator := method selector) numArgs.	self addToThunkTable! !!Callback methodsFor: 'evaluation' stamp: 'eem 10/15/2010 10:10'!valueInContext: callbackContext "<VMCallbackContext32|VMCallbackContext64> ^<Integer>"	numEvaluatorArgs = 2 ifTrue:		[^self perform: evaluator			with: callbackContext			with: callbackContext stackp].	numEvaluatorArgs = 3 ifTrue:		[^self perform: evaluator			with: callbackContext			with: callbackContext stackp			with: callbackContext intregargsp].	numEvaluatorArgs = 4 ifTrue:		[^self perform: evaluator			with: callbackContext			with: callbackContext stackp			with: callbackContext intregargsp			with: callbackContext floatregargsp].	self error: 'invalid evaluator argument count'! !!Callback methodsFor: 'private' stamp: 'eem 10/15/2010 10:50'!addToThunkTable	FlushThunkToCallbackMap ifTrue:		[FlushThunkToCallbackMap := false.		 ThunkToCallbackMap keys do:			[:k| (ThunkToCallbackMap at: k) ifNil: [ThunkToCallbackMap removeKey: k]]].	ThunkToCallbackMap at: thunk addressField put: self! !!Callback methodsFor: 'private' stamp: 'eem 10/15/2010 10:49'!evaluatorForSignature: signature "<String>"	Pragma withPragmasIn: self class do:		[:pragma|		(pragma key == #signature:abi:		and: [(pragma argumentAt: 2) = ABI		and: [(pragma argumentAt: 1) = signature]]) ifTrue:			[^pragma method]].	self error: 'could not find Callback signature'! !!Callback methodsFor: 'signatures' stamp: 'eem 11/1/2010 16:40'!intcharstarRetint: callbackContext sp: spAlien	<signature: 'int (*)(int, char *)' abi: 'IA32'>	^callbackContext wordResult:		((block			value: (spAlien signedLongAt: 1) ~= 0			value: (Alien forPointer: (spAlien unsignedLongAt: 5)) strcpyUTF8)				ifNil: [0]				ifNotNil:					[:result|					result isInteger						ifTrue: [result]						ifFalse: [result == true ifTrue: [1] ifFalse: [0]]])! !!Callback methodsFor: 'signatures' stamp: 'eem 11/1/2010 11:49'!voidstarvoidstarRetint: callbackContext sp: spAlien	<signature: 'int (*)(const void *, const void *)' abi: 'IA32'>	^callbackContext wordResult:		(block			value: (Alien forPointer: (spAlien unsignedLongAt: 1))			value: (Alien forPointer: (spAlien unsignedLongAt: 5)))! !!Callback class methodsFor: 'instance creation' stamp: 'eem 10/15/2010 10:41'!signature: signature "<String>" block: aBlock "<BlockClosure> ^<Callback>"	"Answer a Callback that evaluates aBlock whose C signature is signature 	 and whose thunk should conform to the C calling convention."	^self new signature: signature block: aBlock! !!Callback class methodsFor: 'evaluation' stamp: 'eem 10/17/2010 15:06'!evaluateCallbackForContext: callbackContext "<VMCallbackContext32|VMCallbackContext64> ^<FFICallbackReturnValue>"	(ThunkToCallbackMap		at: callbackContext thunkp		ifAbsent: [^self error: 'could not locate Callback instance corresponding to thunk address'])		ifNil: [self error: 'Callback instance for this thunk address has been garbage collected']		ifNotNil:			[:callback|			^callback valueInContext: callbackContext]! !!Callback class methodsFor: 'class initialization' stamp: 'eem 10/15/2010 09:42'!initialize	"Callback initialize"	[self setup: false] "Monticello... grrr...."		on: Error		do: [:ex| ]! !!Callback class methodsFor: 'class initialization' stamp: 'eem 10/15/2010 09:42'!setup: resuming	"Callback setup"	| prevMap |	ABI := 'IA32'. "for now; value needs to be answered by a primitive or system attribute etc"	FlushThunkToCallbackMap := false.	(WeakArray hasWeakDependent: self) ifFalse:		[WeakArray addWeakDependent: self].	prevMap := resuming ifFalse: [ThunkToCallbackMap].	ThunkToCallbackMap := WeakValueDictionary new.	prevMap ifNotNil:		[prevMap keysAndValuesDo:			[:thunkAddress :callback|			ThunkToCallbackMap at: thunkAddress put: callback]]! !Callback initialize!Callback class removeSelector: #setup!Object subclass: #Callback	instanceVariableNames: 'block thunk argsProxy resultProxy argsProxyClass evaluator numEvaluatorArgs'	classVariableNames: 'ABI FlushThunkToCallbackMap ThunkToCallbackMap'	poolDictionaries: ''	category: 'NsFFI'!
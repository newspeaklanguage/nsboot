'From nsboot-2011-08-03 of 3 August 2011 [latest update: #10966] on 12 June 2012 at 9:36:54 pm'!!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 12/21/2011 17:04'!pushExplicitOuter: n "<Integer>"	"Push the enclosing object at level n."	stackPointer := stackPointer + 1! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 12/21/2011 17:01'!sendToDynamicSuperclass: selector numArgs: numArgs "<Integer>" 	"Send Message With Selector, selector to the dynamic superclass.	 The arguments of the message are found in the top numArgs locations	 on the stack and the receiver just below them."	stackPointer := stackPointer - numArgs! !!BlockNode methodsFor: 'converting' stamp: 'eem 9/27/2011 15:23'!ensureNotQuick: encoder	"If the receiver is quick (can be generated as a Quick method, ^self,^inst var or ^ special constant)	 make it not so.  This is used to create break-pointable versions of quick methods.   Answer if the	 receiver was quick."	self isQuick ifFalse:		[^false].	"Making statements size > 1 is sufficient to cause isQuick to answer false (see BlockNode>>isQuick).	 N.B. This is a no-op since statements generate via emitCodeForEffect: and VariableNodes have no effect."	statements addFirst: (encoder encodeVariable: 'self').	^true! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 12/13/2011 13:47'!sizePushImplicitReceiverFor: literalIndex	^self sizeOpcodeSelector: #genPushImplicitReceiverFor: withArguments: {literalIndex}! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 10/21/2011 11:31'!doPop	stack isEmpty ifTrue:		["Ignore pop in first leg of ifNil for value"		^ self].	(stack last == CaseFlag	or: [stack last == CascadeFlag] "NS3 compiler bugette")		ifTrue: [stack removeLast]		ifFalse: [statements addLast: stack removeLast].! !!Decompiler methodsFor: 'public access' stamp: 'eem 9/27/2011 08:49'!decompile: aSelector in: aClass 	"See Decompiler|decompile:in:method:. The method is found by looking up 	the message, aSelector, in the method dictionary of the class, aClass."	^self		decompile: aSelector		in: aClass		method: (aClass compiledMethodAt: aSelector) methodForDecompile! !!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 12/13/2011 13:50'!genPushImplicitReceiverFor: literalIndex	(literalIndex < 0 or: [literalIndex > 255]) ifTrue: 		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	"127 	01111111 kkkkkkkk 	Push Implicit Receiver For Selector (self literalAt: kkkkkkkk)"	stream		nextPut: 127;		nextPut: literalIndex! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:01'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^self generate: CompiledMethodTrailer empty using: CompiledMethod! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:00'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is arbitrary but is typically either the reference	 to the source code that is stored with every CompiledMethod, or an	 encoding of the method's temporary names."	^self generate: trailer using: CompiledMethod! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:01'!generate: trailer ifQuick: methodBlock	^self generate: trailer using: CompiledMethod ifQuick: methodBlock! !!MethodNode methodsFor: 'code generation' stamp: 'eem 5/8/2012 11:21'!generate: trailer using: aCompiledMethodClass	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.	 The argument, trailer, is arbitrary but is typically either the reference to the source code	 that is stored with every CompiledMethod, or an encoding of the method's temporary names."	| primErrNode blkSize nLits literals stack method |	self generate: trailer		using: aCompiledMethodClass		ifQuick:			[:m |			  m	literalAt: 2 put: encoder associationForClass;				properties: properties.			^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	encoder supportsClosureOpcodes ifTrue:		[self ensureClosureAnalysisDone.		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].	blkSize := (block sizeCodeForEvaluatedValue: encoder)				+ (primErrNode					ifNil: [0]					ifNotNil:						[primErrNode							index: arguments size + temporaries size;							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).	method := aCompiledMethodClass				newBytes: blkSize				trailerBytes: trailer 				nArgs: arguments size				nTemps: (encoder supportsClosureOpcodes							ifTrue: [| locals |									locals := arguments,											  temporaries,											  (primErrNode												ifNil: [#()]												ifNotNil: [{primErrNode}]).									encoder										noteBlockExtent: block blockExtent										hasLocals: locals.									locals size]							ifFalse: [encoder maxTemp])				nStack: 0				nLits: (nLits := (literals := encoder allLiterals) size)				primitive: primitive.	nLits > 255 ifTrue:		[^self error: 'Too many literals referenced'].	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].	stack position: method numTemps.	[block emitCodeForEvaluatedValue: stack encoder: encoder]		on: Error "If an attempt is made to write too much code the method will be asked"		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"			ex signalerContext sender method = (CompiledMethod class>>#new:)				ifTrue: [^self error: 'Compiler code size discrepancy']				ifFalse: [ex pass]].	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 14:59'!generate: trailer using: aCompiledMethodClass ifQuick: methodBlock	| v |	(primitive = 0 and: [arguments size = 0 and: [block isQuick]]) ifFalse:		[^self].	v := block code.	v < 0 ifTrue:		[^self].	v = LdSelf ifTrue:		[^methodBlock value: (aCompiledMethodClass toReturnSelfTrailerBytes: trailer)].	(v between: LdTrue and: LdMinus1 + 3) ifTrue:		[^methodBlock value: (aCompiledMethodClass toReturnConstant: v - LdSelf trailerBytes: trailer)].	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType)) ifTrue:		[^methodBlock value: (aCompiledMethodClass toReturnField: v trailerBytes: trailer)].	v // 256 = 1 ifTrue:		[^methodBlock value: (aCompiledMethodClass toReturnField: v \\ 256 trailerBytes: trailer)]! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:01'!generateWithTempNames	"Answer a CompiledMethod with temps names encoded in trailer"	^self		generate: (CompiledMethodTrailer new tempNames: self schematicTempNamesString)		using: CompiledMethod! !!MethodNode methodsFor: 'printing' stamp: 'eem 9/26/2011 17:02'!printPropertiesOn: aStream	properties ifNotNil:		[:props| props printPropertiesOn: aStream]! !!MethodNode methodsFor: 'converting' stamp: 'eem 9/27/2011 15:15'!ensureNotQuick	"If the receiver is quick (can be generated as a Quick method, ^self,^inst var or ^ special constant)	 make it not so.  This is used to create break-pointable versions of quick methods.   Answer if the	 receiver was quick."	^block ensureNotQuick: encoder! !
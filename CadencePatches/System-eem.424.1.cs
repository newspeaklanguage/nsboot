'From nsboot-2011-08-03 of 3 August 2011 [latest update: #10966] on 7 August 2012 at 11:20:42 am'!Magnitude subclass: #MessageTally	instanceVariableNames: 'class method process tally receivers senders time gcStats maxClassNameSize maxClassPlusSelectorSize maxTabs reportOtherProcesses endTime preHibernationCopy time0 startTime '	classVariableNames: 'DefaultPollPeriod ShowProcesses Timer '	poolDictionaries: ''	category: 'System-Tools'!!MessageTally commentStamp: 'StephaneDucasse 9/27/2009 10:42' prior: 0!My instances observe and report the amount of time spent in methods.NOTE: a higher-level user interface (combining the MessageTally result tree with a method browser) is available from TimeProfileBrowser. Note that TimeProfileBrowser was not fancy with the different setting possibilities.	TimeProfileBrowser spyOn:  [20 timesRepeat: 			[Transcript show: 100 factorial printString]]	Strategies-----------MessageTally provides two different strategies available for profiling:* spyOn: and friends use a high-priority Process to interrupt the block or process being spied on at periodic intervals. The interrupted call stack is then examined for caller information. See below for an example showing different settings* tallySends: and friends use the interpreter simulator to run the block, recording every method call.The two give you different results:	* spyOn: gives you a view of where the time is being spent in your program, at least on a rough statistical level (assuming you've run the 	block for long enough and have a high enough poll rate). If you're trying to optimize your code, start here and optimize the methods where 	most of the time is being spent first.	* tallySends: gives you accurate counts of how many times methods get called, and by exactly which route. If you're debugging, or trying to 	figure out if a given method is getting called too many times, this is your tool.Q: How do you interpret MessageTally>>tallySendsA: The methods #tallySends and #spyOn: measure two very different quantities, but broken down in the same who-called-who format.  #spyOn: is approximate, but more indicative of real time spent, whereas #tallySends is exact and a precise record of how many times each method got executed.Examples----------Here you can see all the processes computation time			[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.		[1000 timesRepeat: [30 factorial. Processor yield]] fork.		[1000 timesRepeat: [30 factorial. Processor yield]] fork.		MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait] Settings---------You can change the printing format (that is, the whitespace and string compression) by using these instance methods: 	maxClassNameSize:	maxClassPlusSelectorSize:	maxTabs:You can change the default polling period (initially set to 1) by calling	MessageTally defaultPollPeriod: numberOfMillisecondsTo understand the difference----------------------------------Here we see all the processes	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyAllOn: [10000 timesRepeat: [1.23 printString]]		Here we only see the execution of the expression [10000 timesRepeat: [1.23 printString]	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]]	Here we only check the exact message sends: this is not a pc-sampling approach	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally tallySends: [10000 timesRepeat: [1.23 printString]]	!!ChangeRecord methodsFor: 'access' stamp: 'eem 1/4/2012 16:26'!methodClass	| methodClassName methodClass |	(#(method #classComment) includes: type) ifFalse: [ ^ nil ].	methodClassName := class subStrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	methodClass := (Smalltalk globals includesKey: methodClassName)						ifTrue: [ Smalltalk at: methodClassName. ]						ifFalse: [MixinManager uniqueInstance definingClasses									detect: [:ea| ea name = class ]									ifNone: [ ^nil ] ].	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!MessageTally methodsFor: 'initialize-release' stamp: 'eem 7/13/2012 15:30'!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[true] whileTrue: [			| observedProcess |			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self				tally: observedProcess suspendedContext				in: observedProcess				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		self class terminateTimerProcess.		self computeGCStats.		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'eem 7/13/2012 15:31'!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay observedProcess |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess := Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	time0 := Time millisecondClockValue.	Timer := [		[ true ] whileTrue: [			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		self class terminateTimerProcess.		self computeGCStats.		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'eem 7/13/2012 15:32'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess := aProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	endTime := time0 + msecDuration.	sem := Semaphore new.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [			[				startTime := Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess 						ifTrue: [ observedProcess ]						ifFalse: [ nil ])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	self computeGCStats.	time := Time millisecondClockValue - time0! !!MessageTally methodsFor: 'private' stamp: 'eem 7/13/2012 15:35'!computeGCStats	"Compute the deltas in the GC stats.  Serves for reporting, hibernating and unhibernating."	SmalltalkImage current getVMParameters keysAndValuesDo:		[ :idx :gcVal |		gcVal ifNotNil: [gcStats at: idx put: (gcVal - (gcStats at: idx))]]! !!MessageTally methodsFor: 'private' stamp: 'eem 7/13/2012 16:55'!convertToOrFromDeltaForHibernation	"Convert between absolute and relative times and stats (and back!!)."	| now |	now := Time millisecondClockValue.	startTime ifNotNil: [startTime := now - startTime].	time0 ifNotNil: [time0 := now - time0].	endTime ifNotNil: [endTime := now - endTime].	self computeGCStats! !!MessageTally methodsFor: 'private' stamp: 'eem 7/13/2012 16:57'!hibernate	"Sent before snapshot.  Convert absolute times and stats into relative times and stats	 Also copy the receiver for the non-snapshot path."	preHibernationCopy := self shallowCopy.	gcStats := gcStats copy. "So as to leave preHibernationCopy's alone."	self convertToOrFromDeltaForHibernation! !!MessageTally methodsFor: 'private' stamp: 'eem 7/13/2012 16:59'!unhibernate: resuming	"Sent after snapshot.  If resuming (starting a shapshot), then convert relative	 times back into absolute times.  If not, revert to pre-hibernation state."	resuming		ifTrue: [self convertToOrFromDeltaForHibernation]		ifFalse: [self copyFrom: preHibernationCopy]! !!MessageTally class methodsFor: 'spying' stamp: 'ul 2/22/2010 16:47'!terminateTimerProcess	Timer ifNotNil: [		Timer terminate.		Timer := nil ].! !!MessageTally class methodsFor: 'class initialization' stamp: 'eem 7/13/2012 16:15'!initialize	"MessageTally initialize"	"By default, show each process separately"	ShowProcesses ifNil: [ShowProcesses := true].	Smalltalk		addToShutDownList: self after: Delay; "i.e. convert to relative times & stats after Delay sleeps."		addToStartUpList: self before: Delay "i.e. convert back to absolute stats before Delay wakes."! !!MessageTally class methodsFor: 'system startup' stamp: 'eem 7/13/2012 16:04'!runningInstance	"Answer the running instance if the Timer is running."	^Timer ifNotNil:		[((Timer == Processor activeProcess			ifTrue: [thisContext]			ifFalse: [Timer suspendedContext]) findContextSuchThat:				[:ctxt| ctxt receiver isKindOf: self]) ifNotNil:					[:ctxt| ctxt receiver]]! !!MessageTally class methodsFor: 'system startup' stamp: 'eem 7/13/2012 15:14'!shutDown: quitting	"This message is sent on system shutdown to registered classes"	self runningInstance ifNotNil: [:runningInstance| runningInstance hibernate]! !!MessageTally class methodsFor: 'system startup' stamp: 'eem 7/13/2012 16:58'!startUp: resuming	"This message is sent to registered classes when the system is coming up."	self runningInstance ifNotNil: [:runningInstance| runningInstance unhibernate: resuming]! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'yk 10/5/2011 17:38'!quitPrimitive: status	"Primitive. Exit to another operating system on the host machine, if one	exists. All state changes in the object space since the last snapshot are lost.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 113>	self primitiveFailed! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'yk 5/25/2012 14:55'!openSourceFiles	Preferences inPackagedImage ifTrue: [^self].	self imageName = LastImageName ifFalse:		["Reset the author initials to blank when the image gets moved"		LastImageName := self imageName.		"Prevent empty initials - causes a pop-up during debug that may		cause the UI to get stuck"		Utilities setAuthorInitials: 'Unknown'].	FileDirectory		openSources: self sourcesName		andChanges: self changesName		forImage: LastImageName.	SourceFileArray install! !!SmalltalkImage methodsFor: 'startup list' stamp: 'MarcusDenker 4/16/2011 23:09'!add: aClass toList: startUpOrShutDownList after: predecessor	"Add the name of aClass to the startUp or shutDown list.	Add it after the name of predecessor"	(Smalltalk globals includes: aClass) 		ifFalse: [self error: aClass name , ' cannot be found in Smalltalk dictionary.'].	"Add after predecessor, moving it if already there."	(Smalltalk globals includes: predecessor)  		ifFalse: [self error: predecessor name , ' cannot be found in Smalltalk dictionary.'].	(startUpOrShutDownList includes: predecessor name) 		ifFalse: [self error: predecessor name , ' cannot be found in the list.'].	startUpOrShutDownList remove: aClass name ifAbsent:[].	startUpOrShutDownList add: aClass name after: predecessor name! !!SmalltalkImage methodsFor: 'startup list' stamp: 'MarcusDenker 4/16/2011 23:09'!add: aClass toList: startUpOrShutDownList before: successor	"Add the name of aClass to the startUp or shutDown list.	Add it before the name of successor"	(Smalltalk globals includes: aClass) 		ifFalse: [self error: aClass name , ' cannot be found in Smalltalk dictionary.'].			"Add before successor, moving it if already there."	(Smalltalk globals includes: successor)  		ifFalse: [self error: successor name , ' cannot be found in Smalltalk dictionary.'].	(startUpOrShutDownList includes: successor name) 		ifFalse: [self error: successor name , ' cannot be found in the list.'].	startUpOrShutDownList remove: aClass name ifAbsent: [].	startUpOrShutDownList add: aClass name before: successor name.! !!SmalltalkImage methodsFor: 'startup list' stamp: 'MarcusDenker 4/16/2011 23:07'!addToShutDownList: aClass	"This will add a ref to this class at the BEGINNING of the shutDown list."	"No-op if already in the list."		(ShutDownList includes: aClass name) ifFalse: [ShutDownList addFirst: aClass name]! !!SmalltalkImage methodsFor: 'startup list' stamp: 'MarcusDenker 4/16/2011 22:36'!addToShutDownList: aClass before: predecessor	self add: aClass toList: ShutDownList before: predecessor! !!SmalltalkImage methodsFor: 'startup list' stamp: 'MarcusDenker 4/16/2011 23:08'!addToStartUpList: aClass	"This will add a ref to this class at the END of the startUp list."	"No-op if already in the list."	(StartUpList includes: aClass name) ifFalse: [StartUpList addLast: aClass name]! !!SmalltalkImage methodsFor: 'startup list' stamp: 'MarcusDenker 4/16/2011 22:36'!addToStartUpList: aClass before: predecessor	self add: aClass toList: StartUpList before: predecessor! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 11/4/2011 09:22'!browseAllStoresInto: varName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."	"self new browseAllStoresInto: 'contents' from: Collection."	^ self		browseMessageList: (self allStoresInto: varName from: aClass)		name: 'Stores into ' , varName		autoSelect: varName! !!SystemNavigation methodsFor: 'browse' stamp: 'cmm 5/2/2011 09:55'!browseVariableAssignments: aClass 	aClass chooseVarThenDo:		[ : aVar | self			browseAllStoresInto: aVar			from: aClass ]! !!SystemNavigation methodsFor: 'browse' stamp: 'cmm 5/2/2011 09:43'!browseVariableReferences: aClass	aClass chooseVarThenDo:		[ : aVar | (aClass allInstVarNames includes: aVar)			ifTrue:				[ self					browseAllAccessesTo: aVar					from: aClass ]			ifFalse: [ self browseAllCallsOn: aVar ] ]! !!SystemNavigation methodsFor: 'query' stamp: 'eem 11/4/2011 09:20'!allAccessesTo: instVarName from: aClass	"Return a sequence of MethodReferences of all methods of aClass or it's sub/superclass that refer to the instance variable instVarName."		| result |	result := OrderedCollection new.	aClass withAllSubAndSuperclassesDo:		[ :class | 		(class whichSelectorsAccess: instVarName) do:			[ :selector |			result add: (MethodReference class: class selector: selector) ] ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/13/2011 20:23'!allCallsOn: aLiteral fromBehaviors: behaviors sorted: sorted	"Answer a collection of all the methods implemented by behaviors that call on aLiteral even deeply embedded in literal array."		| result special thorough byte |	result := OrderedCollection new.	special := Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: [ :b | byte := b ].	"Possibly search for symbols imbedded in literal arrays"	thorough := aLiteral isSymbol and: [ Preferences thoroughSenders ].	behaviors do: [ :behavior |		| list | 		list := behavior whichSelectorsReferTo: aLiteral special: special byte: byte thorough: thorough.		list do: [ :selector |			result add: (MethodReference class: behavior selector: selector) ] ].	sorted ifTrue: [ result sort ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/12/2011 14:53'!allSelectorsAndMethodsDo: aBlock 	"Evaluate aBlock for all selectors and methods of all behaviors in this image."		self allBehaviorsDo: [ :behavior |		behavior selectorsAndMethodsDo: [ :selector :method |			aBlock value: behavior value: selector value: method ] ]! !!SystemNavigation methodsFor: 'query' stamp: 'eem 11/4/2011 09:21'!allStoresInto: varName from: aClass 	"Answer a sequence of MewthodReferences for all the receiver's methods 	 or any methods of a subclass/superclass that assign to the instance variable name."	"self new allStoresInto: 'contents' from: Collection."	| result |	result := OrderedCollection new.	aClass withAllSubAndSuperclassesDo:		[ : class |		(class whichMethodsStoreInto: varName) do:			[ : eachMethod |			result add: eachMethod methodReference ] ].	^result! !SystemDictionary removeSelector: #recreateSpecialObjectsArray!MessageTally initialize!Magnitude subclass: #MessageTally	instanceVariableNames: 'class method process tally receivers senders time gcStats maxClassNameSize maxClassPlusSelectorSize maxTabs reportOtherProcesses time0 startTime endTime preHibernationCopy'	classVariableNames: 'DefaultPollPeriod ShowProcesses Timer'	poolDictionaries: ''	category: 'System-Tools'!
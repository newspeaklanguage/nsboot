'From nsboot-2014-12-30 of 30 December 2014 [latest update: #11860] on 30 December 2014 at 6:12 pm'!!EncoderForNewsqueakV4 class methodsFor: 'as yet unclassified' stamp: 'rmacnak 10/27/2014 21:34'!isStoreAt: pc in: method	"Answer whether the bytecode at pc is a store or store-pop."	"	176-183	10110 i i i						Pop and Store Receiver Variable #iii		184-191	10111 i i i						Pop and Store Temporary Variable #iii	 *	224		11100000	aaaaaaaa			Extend A (Ext A = Ext A prev * 256 + Ext A)	 *	232		11101000	i i i i i i i i			Store Receiver Variable #iiiiiii (+ Extend A * 256)	 *	233		11101001	i i i i i i i i			Store Literal Variable #iiiiiiii (+ Extend A * 256)		234		11101010	i i i i i i i i			Store Temporary Variable #iiiiiiii	 *	235		11101011	i i i i i i i i			Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)	 *	236		11101100	i i i i i i i i			Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)		237		11101101	i i i i i i i i			Pop and Store Temporary Variable #iiiiiiii		251		11111011 kkkkkkkk	jjjjjjjj	Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj		252		11111100 kkkkkkkk	jjjjjjjj	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"	| byte |	byte := self nonExtensionBytecodeAt: pc in: method.	^byte >= 176	  and: [byte <= 191		 or: [(byte between: 232 and: 237)		 or: [(byte between: 251 and: 252)]]]! !!EncoderForV3 class methodsFor: 'as yet unclassified' stamp: 'rmacnak 10/27/2014 21:35'!isStoreAt: pc in: method	"Answer whether the bytecode at pc is a store or store-pop."	| byte |	byte := method at: pc.	^(byte between: 96 and: 132)		and: [byte <= 111				"96 103	storeAndPopReceiverVariableBytecode"										"104 111	storeAndPopTemporaryVariableBytecode"			or: [byte >= 129			"129		extendedStoreBytecode"				and: [byte <= 130		"130		extendedStoreAndPopBytecode"					or: [byte = 132		"132		doubleExtendedDoAnythingBytecode"						and: [(method at: pc+1) >= 160]]]]]! !!EncoderForV3 class methodsFor: 'as yet unclassified' stamp: 'rmacnak 10/27/2014 21:35'!nonExtensionBytecodeAt: pc in: method	"Answer the actual bytecode at pc in method, skipping past any preceeding extensions."	^method at: pc! !!EncoderForV3PlusClosures class methodsFor: 'as yet unclassified' stamp: 'rmacnak 10/27/2014 21:33'!isStoreAt: pc in: method	"Answer whether the bytecode at pc is a store or store-pop."	| byte |	byte := method at: pc.	^(byte between: 96 and: 142)		and: [byte <= 111				"96 103	storeAndPopReceiverVariableBytecode"										"104 111	storeAndPopTemporaryVariableBytecode"			or: [byte >= 129			"129		extendedStoreBytecode"				and: [byte <= 130		"130		extendedStoreAndPopBytecode"					or: [(byte = 132	"132		doubleExtendedDoAnythingBytecode"						and: [(method at: pc+1) >= 160])					or: [byte = 141		"141		storeRemoteTempLongBytecode"					or: [byte = 142		"142		storeAndPopRemoteTempLongBytecode"]]]]]]! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'rmacnak 10/27/2014 20:02'!pushEnclosingObject: n "<Integer>"	"Push the enclosing object at level n."! !!InstructionClient methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/13/2014 23:38'!sendToAbsentDynamicSuperclass: selector "<Symbol>" numArgs: numArgs "<SmallInteger>"	"Perform a Newspeak super send. The arguments of the message are found in the top	 numArgs locations on the stack, and the receiver is implicitly the receiver of the current	 method activation."! !!InstructionClient methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/13/2014 23:43'!sendToAbsentImplicitReceiver: selector "<ByteSymbol>" numArgs: numArgs "<SmallInteger>"	"Perform a Newspeak implicit receiver send. The arguments of the message are found in	 the top numArgs locations on the stack, and the receiver is the result of an implicit	 receiver lookup."! !!InstructionClient methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/13/2014 23:43'!sendToAbsentOuter: selector "<ByteSymbol>" numArgs: numArgs "<SmallInteger>" depth: depth "<SmallInteger>"	"Perform a Newspeak outer send. The arguments of the message are found in the top	 numArgs locations on the stack, and the receiver is implicitly the depth'th enclosing	 object with respect to the mixin application of the current method activation."! !!InstructionClient methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/13/2014 23:43'!sendToAbsentSelf: selector "<ByteSymbol>" numArgs: numArgs "<SmallInteger>"	"Perform a Newspeak self send. The arguments of the message are found in the top	 numArgs locations on the stack, and the receiver is implicitly the receiver of the current	 method activation."! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'rmacnak 10/27/2014 20:01'!pushEnclosingObject: n "<Integer>"	"Push the enclosing object at level n."	stackPointer := stackPointer + 1! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'bootstrapping 6/20/2011 15:24'!pushImplicitReceiverForMessage: selector "<Symbol>"	"Push Implicit Receiver for Selector bytecode."	stackPointer := stackPointer + 1! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'GB 6/5/2008 12:35'!sendToDynamicSuperclass: selector numArgs: numArgs "<Integer>" 	self print: 'sendDynamicSuper: ', selector printString! !!InstructionPrinter methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/27/2014 20:02'!pushEnclosingObject: n 	"Print the Push Active Context's Receiver for an outer send of aSymbol on Top Of Stack bytecode."	self print: 'pushEnclosingObject: ', n asString! !!InstructionPrinter methodsFor: '*NsSystem-instruction decoding' stamp: 'GB 10/8/2008 11:55'!pushImplicitReceiverForMessage: aSymbol 	"Print the Push Active Context's Receiver for an outer send of aSymbol on Top Of Stack bytecode."	self print: 'pushImplicitReceiverFor: ', aSymbol asString! !!InstructionPrinter methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/13/2014 23:43'!sendToAbsentImplicitReceiver: selector "<Symbol>" numArgs: numArgs "<SmallInteger>"	self print: '(absent receiver) implicitReceiverSend: ' , selector.! !!InstructionPrinter methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/13/2014 23:43'!sendToAbsentOuter: selector "<Symbol>" numArgs: numArgs "<SmallInteger>" depth: depth "<SmallInteger>"	self print: '(absent receiver) outerSend: ' , selector , ' depth: ', depth printString.! !!InstructionPrinter methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/13/2014 23:43'!sendToAbsentSelf: selector "<Symbol>" numArgs: numArgs "<SmallInteger>"	self print: '(absent receiver) selfSend: ' , selector.! !!InstructionStream methodsFor: 'decoding' stamp: 'rmacnak 10/27/2014 20:01'!alternateInterpretExtendedPush: extB for: client	"Implement the extended push for non-zero extensions."	"77			01001101				Push false [* 1:true, 2:nil, 3:thisContext, ..., -N: pushExplicitOuter: N, N = Extend B]"	extB < 0 ifTrue:		[^client pushEnclosingObject: extB negated].	extB < 2 ifTrue:		[^client pushConstant: extB = 1].	extB = 2 ifTrue:		[^client pushConstant: nil].	extB = 3 ifTrue:		[^client pushActiveContext].	self error: 'undefined extended push'! !!InstructionStream methodsFor: 'decoding' stamp: 'rmacnak 10/14/2014 22:39'!alternateInterpretNext2ByteInstruction: bytecode for: client extA: extA extB: extB	"Send to the argument, client, a message that specifies the next instruction.	 This method handles the two-byte codes.	 For a table of the bytecode set, see EncoderForNewsqueakV2's class comment."	| byte method |	method := self method.	byte := self method at: pc.	pc := pc + 1.	"We do an inline quasi-binary search on bytecode"	bytecode < 235 ifTrue:		[bytecode < 231 ifTrue:			[bytecode < 229 ifTrue:				[| literal |				 bytecode = 226 ifTrue:					[^client pushReceiverVariable: (extA bitShift: 8) + byte].				 literal := method literalAt: (extA bitShift: 8) + byte + 1.				 bytecode = 227 ifTrue:					[^client pushLiteralVariable: literal].				 ^client pushConstant: literal].			bytecode = 229 ifTrue:				[^client pushConstant: (extB bitShift: 8) + byte].			^client pushTemporaryVariable: byte].		bytecode = 231 ifTrue:			[^byte < 128				ifTrue: [client pushNewArrayOfSize: byte]				ifFalse: [client pushConsArrayWithElements: byte - 128]].		bytecode = 232 ifTrue:			[^client storeIntoReceiverVariable: (extA bitShift: 8) + byte].		bytecode = 233 ifTrue:			[^client storeIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].		^client storeIntoTemporaryVariable: byte].	bytecode < 238 ifTrue:		[bytecode = 235 ifTrue:			[^client popIntoReceiverVariable: (extA bitShift: 8) + byte].		 bytecode = 236 ifTrue:			[^client popIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].		 ^client popIntoTemporaryVariable: byte].	bytecode < 242 ifTrue:		[| selector numArgs |		 selector := method literalAt: (extA bitShift: 5) + (byte // 8) + 1.		 numArgs := (extB bitShift: 3) + (byte \\ 8).		 bytecode = 238 ifTrue:			[^client send: selector super: false numArgs: numArgs].		 bytecode = 239 ifTrue:			[^client send: selector super: true numArgs: numArgs].		 bytecode = 240 ifTrue:			[^client sendToAbsentImplicitReceiver: selector numArgs: numArgs].		 ^client sendToAbsentDynamicSuperclass: selector numArgs: numArgs].	bytecode < 245 ifTrue:		[bytecode = 242 ifTrue:			[^client jump: (extB bitShift: 8) + byte].		 ^client jump: (extB bitShift: 8) + byte if: bytecode = 243].	bytecode = 245 ifTrue:		[| selector numArgs |		 selector := method literalAt: (extA bitShift: 5) + (byte // 8) + 1.		 numArgs := (extB bitShift: 3) + (byte \\ 8).		 ^client sendToAbsentSelf: selector numArgs: numArgs].	"246-247	1111011 i	xxxxxxxx	UNASSIGNED	 248-249	1111100 i	xxxxxxxx	UNASSIGNED"	^self unusedBytecode: client! !!InstructionStream methodsFor: 'decoding' stamp: 'rmacnak 10/14/2014 22:39'!alternateInterpretNext2ByteInstruction: bytecode for: client extA: extA extB: extB startPC: startPC	"Send to the argument, client, a message that specifies the next instruction.	 This method handles the two-byte codes.	 For a table of the bytecode set, see EncoderForNewsqueakV2's class comment."	| byte method |	method := self method.	byte := self method at: pc.	pc := pc + 1.	"We do an inline quasi-binary search on bytecode"	bytecode < 235 ifTrue:		[bytecode < 231 ifTrue:			[bytecode < 229 ifTrue:				[| literal |				 bytecode = 226 ifTrue:					[^client pushReceiverVariable: (extA bitShift: 8) + byte].				 literal := method literalAt: (extA bitShift: 8) + byte + 1.				 bytecode = 227 ifTrue:					[^client pushLiteralVariable: literal].				 ^client pushConstant: literal].			bytecode = 229 ifTrue:				[^client pushConstant: (extB bitShift: 8) + byte].			^client pushTemporaryVariable: byte].		bytecode = 231 ifTrue:			[^byte < 128				ifTrue: [client pushNewArrayOfSize: byte]				ifFalse: [client pushConsArrayWithElements: byte - 128]].		bytecode = 232 ifTrue:			[^client storeIntoReceiverVariable: (extA bitShift: 8) + byte].		bytecode = 233 ifTrue:			[^client storeIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].		^client storeIntoTemporaryVariable: byte].	bytecode < 238 ifTrue:		[bytecode = 235 ifTrue:			[^client popIntoReceiverVariable: (extA bitShift: 8) + byte].		 bytecode = 236 ifTrue:			[^client popIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].		 ^client popIntoTemporaryVariable: byte].	bytecode < 242 ifTrue:		[| selector numArgs |		 selector := method literalAt: (extA bitShift: 5) + (byte // 8) + 1.		 numArgs := (extB bitShift: 3) + (byte \\ 8).		 bytecode = 238 ifTrue:			[^client send: selector super: false numArgs: numArgs].		 bytecode = 239 ifTrue:			[^client send: selector super: true numArgs: numArgs].		 bytecode = 240 ifTrue:			[^client sendToAbsentImplicitReceiver: selector numArgs: numArgs].		 ^client sendToAbsentDynamicSuperclass: selector numArgs: numArgs].	bytecode < 245 ifTrue:		[bytecode = 242 ifTrue:			[^client jump: (extB bitShift: 8) + byte].		 ^client jump: (extB bitShift: 8) + byte if: bytecode = 243].	bytecode = 245 ifTrue:		[| selector numArgs |		 selector := method literalAt: (extA bitShift: 5) + (byte // 8) + 1.		 numArgs := (extB bitShift: 3) + (byte \\ 8).		 ^client sendToAbsentSelf: selector numArgs: numArgs].	"246-247	1111011 i	xxxxxxxx	UNASSIGNED	 248-249	1111100 i	xxxxxxxx	UNASSIGNED"	^self unusedBytecode: client at: startPC! !!InstructionStream methodsFor: 'decoding' stamp: 'rmacnak 10/14/2014 22:41'!alternateInterpretNext3ByteInstruction: bytecode for: client extA: extA extB: extB	"Send to the argument, client, a message that specifies the next instruction.	 This method handles the three-byte codes.	 For a table of the bytecode set, see EncoderForNewsqueakV2's class comment."	| method byte2 byte3 |	method := self method.	byte2 := method at: pc.	byte3 := method at: pc + 1.	pc := pc + 2.	"we search the bytecodes by static frequency"	bytecode = 253 ifTrue:		["253		11111101 eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ Ext A // 16 * 8) Num Args kkk (+ Ext A \\ 16 * 8) BlockSize jjjjjjjj (+ Ext B * 256). ee = num extensions"		 ^client			pushClosureCopyNumCopiedValues: ((byte2 bitShift: -3) bitAnd: 7) + (extA // 16 bitShift: 3)			numArgs: (byte2 bitAnd: 7) + (extA \\ 16 bitShift: 3)			blockSize: byte3 + (extB bitShift: 8)].	bytecode = 250 ifTrue:		[^client pushRemoteTemp: byte2 inVectorAt: byte3].	bytecode = 252 ifTrue:		[^client popIntoRemoteTemp: byte2 inVectorAt: byte3].	bytecode = 251 ifTrue:		[^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].	bytecode = 249 ifTrue:			[^client callPrimitive: byte2 + (byte3 bitShift: 8)].	bytecode = 254 ifTrue:		[| selector numArgs depth |		 selector := method literalAt: (extA bitShift: 5) + (byte2 // 8) + 1.		 numArgs := (extB bitShift: 3) + (byte2 \\ 8).		depth := byte3.		 ^client sendToAbsentOuter: selector numArgs: numArgs depth: depth].	"255	11111111	xxxxxxxx	yyyyyyyy	UNASSIGNED"	^self unusedBytecode: client! !!InstructionStream methodsFor: 'decoding' stamp: 'rmacnak 10/14/2014 22:40'!alternateInterpretNext3ByteInstruction: bytecode for: client extA: extA extB: extB startPC: startPC	"Send to the argument, client, a message that specifies the next instruction.	 This method handles the three-byte codes.	 For a table of the bytecode set, see EncoderForNewsqueakV2's class comment."	| method byte2 byte3 |	method := self method.	byte2 := method at: pc.	byte3 := method at: pc + 1.	pc := pc + 2.	"we search the bytecodes by static frequency"	bytecode = 253 ifTrue:		["253		11111101 eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ Ext A // 16 * 8) Num Args kkk (+ Ext A \\ 16 * 8) BlockSize jjjjjjjj (+ Ext B * 256). ee = num extensions"		 ^client			pushClosureCopyNumCopiedValues: ((byte2 bitShift: -3) bitAnd: 7) + (extA // 16 bitShift: 3)			numArgs: (byte2 bitAnd: 7) + (extA \\ 16 bitShift: 3)			blockSize: byte3 + (extB bitShift: 8)].	bytecode = 250 ifTrue:		[^client pushRemoteTemp: byte2 inVectorAt: byte3].	bytecode = 252 ifTrue:		[^client popIntoRemoteTemp: byte2 inVectorAt: byte3].	bytecode = 251 ifTrue:		[^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].	bytecode = 249 ifTrue:		[^client callPrimitive: byte2 + (byte3 bitShift: 8)].	bytecode = 254 ifTrue:		[| selector numArgs depth |		 selector := method literalAt: (extA bitShift: 5) + (byte2 // 8) + 1.		 numArgs := (extB bitShift: 3) + (byte2 \\ 8).		depth := byte3.		 ^client sendToAbsentOuter: selector numArgs: numArgs depth: depth].	"255	11111111	xxxxxxxx	yyyyyyyy	UNASSIGNED"	^self unusedBytecode: client at: startPC! !!InstructionStream methodsFor: 'decoding' stamp: 'GB 6/5/2008 11:48'!interpretNextInstructionFor: client 	"Send to the argument, client, a message that specifies the type of the 	next instruction."	| byte type offset method |	method := self method.  	byte := method at: pc.	type := byte // 16.  	offset := byte \\ 16.  	pc := pc+1.	"We do an inline binary search on each of the possible 16 values of type:	The old, cleaner but slowe code is retained as a comment below"	type < 8	ifTrue: [type < 4				ifTrue: [type < 2						ifTrue: [type < 1								ifTrue: ["type = 0"									^ client pushReceiverVariable: offset]								ifFalse: ["type = 1"									^ client pushTemporaryVariable: offset]]						ifFalse: [type < 3								ifTrue: ["type = 2"									^ client										pushConstant: (method literalAt: offset + 1)]								ifFalse: ["type = 3"									^ client										pushConstant: (method literalAt: offset + 17)]]]				ifFalse: [type < 6						ifTrue: [type < 5								ifTrue: ["type = 4"									^ client										pushLiteralVariable: (method literalAt: offset + 1)]								ifFalse: ["type = 5"									^ client										pushLiteralVariable: (method literalAt: offset + 17)]]						ifFalse: [type < 7								ifTrue: ["type = 6"									offset < 8										ifTrue: [^ client popIntoReceiverVariable: offset]										ifFalse: [^ client popIntoTemporaryVariable: offset - 8]]								ifFalse: ["type = 7"									offset = 0										ifTrue: [^ client pushReceiver].									offset < 8										ifTrue: [^ client												pushConstant: (SpecialConstants at: offset)].									offset = 8										ifTrue: [^ client methodReturnReceiver].									offset < 12										ifTrue: [^ client												methodReturnConstant: (SpecialConstants at: offset - 8)].									offset = 12										ifTrue: [^ client methodReturnTop].									offset = 13										ifTrue: [^ client blockReturnTop].									offset = 14 ifTrue:										[| byte2 |										 byte := method at: pc.										 pc := pc+1.										byte2 := method at: pc.										 pc := pc+1.										^client sendToDynamicSuperclass: (method literalAt: byte2 + 1)												numArgs: byte].									offset = 15 ifTrue:										[byte := method at: pc.										 pc := pc+1.										^client pushImplicitReceiverForMessage: (method literalAt: byte + 1)].									^self error: 'unusedBytecode']]]]		ifFalse: [type < 12				ifTrue: [type < 10						ifTrue: [type < 9								ifTrue: ["type = 8"									^ self										interpretExtension: offset										in: method										for: client]								ifFalse: ["type = 9 (short jumps)"									offset < 8										ifTrue: [^ client jump: offset + 1].									^ client jump: offset - 8 + 1 if: false]]						ifFalse: [type < 11								ifTrue: ["type = 10 (long jumps)"									byte := method at: pc.									pc := pc + 1.									offset < 8										ifTrue: [^ client jump: offset - 4 * 256 + byte].									^ client jump: (offset bitAnd: 3)											* 256 + byte if: offset < 12]								ifFalse: ["type = 11"									^ client										send: (Smalltalk specialSelectorAt: offset + 1)										super: false										numArgs: (Smalltalk specialNargsAt: offset + 1)]]]				ifFalse: [type = 12						ifTrue: [^ client								send: (Smalltalk specialSelectorAt: offset + 17)								super: false								numArgs: (Smalltalk specialNargsAt: offset + 17)]						ifFalse: ["type = 13, 14 or 15"							^ client								send: (method literalAt: offset + 1)								super: false								numArgs: type - 13]]]."    old code 	type=0 ifTrue: [^client pushReceiverVariable: offset].	type=1 ifTrue: [^client pushTemporaryVariable: offset].	type=2 ifTrue: [^client pushConstant: (method literalAt: offset+1)].	type=3 ifTrue: [^client pushConstant: (method literalAt: offset+17)].	type=4 ifTrue: [^client pushLiteralVariable: (method literalAt: offset+1)].	type=5 ifTrue: [^client pushLiteralVariable: (method literalAt: offset+17)].	type=6 		ifTrue: [offset<8					ifTrue: [^client popIntoReceiverVariable: offset]					ifFalse: [^client popIntoTemporaryVariable: offset-8]].	type=7		ifTrue: [offset=0 ifTrue: [^client pushReceiver].				offset<8 ifTrue: [^client pushConstant: (SpecialConstants at: offset)].				offset=8 ifTrue: [^client methodReturnReceiver].				offset<12 ifTrue: [^client methodReturnConstant: 												(SpecialConstants at: offset-8)].				offset=12 ifTrue: [^client methodReturnTop].				offset=13 ifTrue: [^client blockReturnTop].				offset>13 ifTrue: [^self error: 'unusedBytecode']].	type=8 ifTrue: [^self interpretExtension: offset in: method for: client].	type=9		ifTrue:  short jumps			[offset<8 ifTrue: [^client jump: offset+1].			^client jump: offset-8+1 if: false].	type=10 		ifTrue:  long jumps			[byte:= method at: pc.  pc:= pc+1.			offset<8 ifTrue: [^client jump: offset-4*256 + byte].			^client jump: (offset bitAnd: 3)*256 + byte if: offset<12].	type=11 		ifTrue: 			[^client 				send: (Smalltalk specialSelectorAt: offset+1) 				super: false				numArgs: (Smalltalk specialNargsAt: offset+1)].	type=12 		ifTrue: 			[^client 				send: (Smalltalk specialSelectorAt: offset+17) 				super: false				numArgs: (Smalltalk specialNargsAt: offset+17)].	type>12		ifTrue: 			[^client send: (method literalAt: offset+1) 					super: false					numArgs: type-13]"! !!InstructionStream methodsFor: 'private' stamp: 'bootstrapping 6/20/2011 14:40'!interpretExtension: offset in: method for: client	| type offset2 byte2 byte3 byte4 |	offset <= 6 ifTrue: 		["Extended op codes 128-134"		byte2 := method at: pc. pc := pc + 1.		offset <= 2 ifTrue:			["128-130:  extended pushes and pops"			type := byte2 // 64.			offset2 := byte2 \\ 64.			offset = 0 ifTrue: 				[type = 0 ifTrue: [^client pushReceiverVariable: offset2].				type = 1 ifTrue: [^client pushTemporaryVariable: offset2].				type = 2  ifTrue: [^client pushConstant: (method literalAt: offset2 + 1)].				type = 3 ifTrue: [^client pushLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 1 ifTrue: 				[type = 0 ifTrue: [^client storeIntoReceiverVariable: offset2].				type = 1 ifTrue: [^client storeIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 2 ifTrue: 				[type = 0 ifTrue: [^client popIntoReceiverVariable: offset2].				type = 1 ifTrue: [^client popIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3  ifTrue: [^client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].		"131-134: extended sends"		offset = 3 ifTrue:  "Single extended send"			[^client send: (method literalAt: byte2 \\ 32 + 1)					super: false numArgs: byte2 // 32].		offset = 4 ifTrue:    "Double extended do-anything"			[byte3 := method at: pc. pc := pc + 1.			type := byte2 // 32.			type = 0 ifTrue: [^client send: (method literalAt: byte3 + 1)									super: false numArgs: byte2 \\ 32].			type = 1 ifTrue: [^client send: (method literalAt: byte3 + 1)									super: true numArgs: byte2 \\ 32].			type = 2 ifTrue: [^client pushReceiverVariable: byte3].			type = 3 ifTrue: [^client pushConstant: (method literalAt: byte3 + 1)].			type = 4 ifTrue: [^client pushLiteralVariable: (method literalAt: byte3 + 1)].			type = 5 ifTrue: [^client storeIntoReceiverVariable: byte3].			type = 6 ifTrue: [^client popIntoReceiverVariable: byte3].			type = 7 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].		offset = 5 ifTrue:  "Single extended send to super"			[^client send: (method literalAt: byte2 \\ 32 + 1)					super: true numArgs: byte2 // 32].		offset = 6 ifTrue:   "Second extended send"			[^client send: (method literalAt: byte2 \\ 64 + 1)					super: false numArgs: byte2 // 64]].	offset = 7 ifTrue: [^client doPop].	offset = 8 ifTrue: [^client doDup].	offset = 9 ifTrue: [^client pushActiveContext].	byte2 := method at: pc. pc := pc + 1.	offset = 10 ifTrue:		[^byte2 < 128			ifTrue: [client pushNewArrayOfSize: byte2]			ifFalse: [client pushConsArrayWithElements: byte2 - 128]].	offset = 11 ifTrue: "139: pushExplicitOuter"		[^client pushExplicitOuter: (method literalAt: byte2 + 1)].	byte3 := method at: pc.  pc := pc + 1.	offset = 12 ifTrue: [^client pushRemoteTemp: byte2 inVectorAt: byte3].	offset = 13 ifTrue: [^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].	offset = 14 ifTrue: [^client popIntoRemoteTemp: byte2 inVectorAt: byte3].	"offset = 15"	byte4 := method at: pc.  pc := pc + 1.	^client		pushClosureCopyNumCopiedValues: (byte2 bitShift: -4)		numArgs: (byte2 bitAnd: 16rF)		blockSize: (byte3 * 256) + byte4! !!InstructionStream methodsFor: 'private' stamp: 'bootstrapping 6/20/2011 14:36'!nextPc: currentByte	"Answer the pc of the next bytecode following the current one, given the current bytecode.."	| type |	type := currentByte // 16.	^type = 7		ifTrue:			[(currentByte >= 126 and: [currentByte <= 127]) "dynamic super - malplaced at 126"				ifTrue: [pc + 2]				ifFalse: [pc + 1]]		ifFalse:			[type = 8 "extensions"					ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 1 3 3 3 4) at: currentByte \\ 16 + 1)]					ifFalse: [type = 10 "long jumps"								ifTrue: [pc + 2]								ifFalse: [pc + 1]]]! !!InstructionStream methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/27/2014 20:02'!pushEnclosingObject: n "<Integer>"	self subclassResponsibility! !!InstructionStream methodsFor: '*NsSystem-instruction decoding' stamp: 'Ahe 5/2/2008 01:31'!pushImplicitReceiverForMessage: selector "<Symbol>" 	self subclassResponsibility! !!InstructionStream methodsFor: '*NsSystem-instruction decoding' stamp: 'eem 6/20/2011 14:54'!sendToDynamicSuperclass: selector numArgs: numArgs "<Integer>" 	self subclassResponsibility! !!ContextPart methodsFor: 'controlling' stamp: 'bootstrapping 6/20/2011 15:08'!activateMethod: newMethod withArgs: args receiver: rcvr	"Answer a ContextPart initialized with the arguments."	^MethodContext 		sender: self		receiver: rcvr		method: newMethod		arguments: args! !!ContextPart methodsFor: 'controlling' stamp: 'bootstrapping 6/20/2011 15:09'!send: selector to: rcvr with: args lookupIn: lookupClass	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, lookupClass, is the class in	which to lookup the message.  This is the receiver's class for normal messages,	but for super messages it will be some specific class related to the source method."	| meth val |	meth := lookupClass lookupSelector: selector.	meth == nil ifTrue:		[^self send: #doesNotUnderstand:				to: rcvr				with: (Array with: (Message selector: selector arguments: args))				lookupIn: lookupClass].	val := self tryPrimitiveFor: meth				receiver: rcvr				args: args.	val == PrimitiveFailToken ifFalse: [^ val].	(selector == #doesNotUnderstand: and: [lookupClass == ProtoObject]) ifTrue:		[^ self error: 'Simulated message ' , (args at: 1) selector , ' not understood'].	^self		activateMethod: meth		withArgs: args		receiver: rcvr! !!ContextPart methodsFor: 'controlling' stamp: 'bootstrapping 6/20/2011 15:11'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."	^self		send: selector		to: rcvr		with: args		lookupIn: (superFlag					ifTrue: [(self method literalAt: self method numLiterals) value superclass]					ifFalse: [rcvr class])! !!ContextPart methodsFor: 'controlling' stamp: 'eem 7/5/2007 11:18'!sendAttemptToAssign: value to: assignee withIndex: index	self push: assignee.	self push: value.	self push: index.	^self send: #attemptToAssign:withIndex: super: false numArgs: 2! !!ContextPart methodsFor: 'instruction decoding' stamp: 'GB 6/5/2008 12:46'!sendToDynamicSuperclass: selector numArgs: numArgs "<Integer>" 		"Simulate the action of bytecodes that send a message with selector, 	selector to the dynamic superclass. The arguments 	of the message are found in the top numArgs locations on the stack and 	the receiver just below them."	| receiver arguments answer |	arguments := Array new: numArgs.	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].	receiver := self pop.	selector == #doPrimitive:method:receiver:args:		ifTrue: [answer := receiver 					doPrimitive: (arguments at: 1)					method: (arguments at: 2)					receiver: (arguments at: 3)					args: (arguments at: 4).				self push: answer.				^self].	^self		send: selector		to: receiver		with: arguments		lookupIn: (self dynamicSuperClassOfReceiver: receiver)! !!ContextPart methodsFor: '*NsSystem-private' stamp: 'rmacnak 10/15/2014 22:06'!dynamicSuperClassOfReceiver: rcvr "<Object> ^<Class>"	^self superclassOf: (self findApplicationOf: self methodClass startingAt: (self objectClass: rcvr))! !!ContextPart methodsFor: '*NsSystem-private' stamp: 'rmacnak 10/15/2014 21:56'!enclosingMixinOf: class "<Class> ^<Class | nil>"	^self object: class instVarAt: 4 "Class instVarIndexFor: 'mixinSlot'"! !!ContextPart methodsFor: '*NsSystem-private' stamp: 'rmacnak 10/27/2014 21:12'!enclosingObjectAt: depth "<Integer>" for: methodReceiver "<Object>" in: methodMixin "<Mixin> ^<Object>"	| enclosingObject mixinApplication targetMixin count |	enclosingObject := methodReceiver.	targetMixin := methodMixin.	count := 0.	[count < depth] whileTrue:		[count := count + 1.		mixinApplication := self							findApplicationOf: targetMixin							startingAt: (self objectClass: enclosingObject).		enclosingObject := self enclosingObjectOf: mixinApplication.			targetMixin := self enclosingMixinOf: targetMixin].		^enclosingObject! !!ContextPart methodsFor: '*NsSystem-private' stamp: 'rmacnak 10/15/2014 21:56'!enclosingObjectOf: class "<Class> ^<Class | nil>"	^self object: class instVarAt: 5 "Class instVarIndexFor: 'enclosingObjectSlot'"! !!ContextPart methodsFor: '*NsSystem-private' stamp: 'rmacnak 10/27/2014 19:58'!findApplicationOf: targetMixin startingAt: aClass	"This is used to implement implicit receiver and enclosing object lookup	 for Newspeak. Find the mixin applcation of which aClass is a subclass that	 is an application of targetMixin."	| mixinApplication |	mixinApplication := aClass.	[mixinApplication == nil	 or: [mixinApplication == targetMixin	 or: [(self mixinOf: mixinApplication) == targetMixin]]] whileFalse:		[mixinApplication := self superclassOf: mixinApplication].	^mixinApplication! !!ContextPart methodsFor: '*NsSystem-private' stamp: 'rmacnak 10/27/2014 19:55'!superclassOf: class "<Class> ^<Class | nil>"	^self object: class instVarAt: 1! !!ContextPart methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/27/2014 20:02'!pushEnclosingObject: depth "<Integer>"	| enclosingObject |	enclosingObject := self		enclosingObjectAt: depth		for: self receiver		in: self methodClass.	self push: enclosingObject! !!ContextPart methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/14/2014 22:45'!pushImplicitReceiverForMessage: selector "<Symbol>"	| implicitReceiver |	implicitReceiver := self		implicitReceiverFor: self receiver		in: self methodClass		implementing: selector.	self push: implicitReceiver! !!ContextPart methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/14/2014 22:27'!sendToAbsentDynamicSuperclass: selector "<Symbol>" numArgs: numArgs "<Integer>"		| receiver arguments |	arguments := Array new: numArgs.	numArgs to: 1 by: -1 do: [:i | arguments at: i put: self pop].	receiver := self receiver.	^self		send: selector		to: receiver		with: arguments		lookupIn: (self dynamicSuperClassOfReceiver: receiver)! !!ContextPart methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/14/2014 22:29'!sendToAbsentImplicitReceiver: selector "<Symbol>" numArgs: numArgs "<Integer>"	| receiver arguments |	receiver := self		implicitReceiverFor: self receiver		in: self methodClass		implementing: selector.	arguments := Array new: numArgs.	numArgs to: 1 by: -1 do: [:i | arguments at: i put: self pop].	QuickStep == self ifTrue:		[QuickStep := nil.		^self quickSend: selector to: receiver with: arguments super: false].	^self send: selector to: receiver with: arguments super: false! !!ContextPart methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/14/2014 22:53'!sendToAbsentOuter: selector "<Symbol>" numArgs: numArgs "<SmallInteger>" depth: depth "<SmallInteger>"	| receiver arguments |	arguments := Array new: numArgs.	numArgs to: 1 by: -1 do: [:i | arguments at: i put: self pop].	receiver := self		enclosingObjectAt: depth		for: self receiver		in: self methodClass.	QuickStep == self ifTrue:		[QuickStep := nil.		^self quickSend: selector to: receiver with: arguments super: false].	^self send: selector to: receiver with: arguments super: false! !!ContextPart methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/14/2014 22:27'!sendToAbsentSelf: selector "<Symbol>" numArgs: numArgs "<Integer>"	| receiver arguments |	arguments := Array new: numArgs.	numArgs to: 1 by: -1 do: [:i | arguments at: i put: self pop].	receiver := self receiver.	QuickStep == self ifTrue:		[QuickStep := nil.		^self quickSend: selector to: receiver with: arguments super: false].	^self send: selector to: receiver with: arguments super: false! !!ContextPart methodsFor: 'as-yet-unclassified' stamp: 'rmacnak 10/27/2014 21:12'!implicitReceiverFor: methodReceiver "<Object>" in: methodMixin "<Behavior>" implementing: selector "<Symbol> ^<Object>"	| candidateReceiver candidateMixin candidateMixinApplication |	candidateReceiver := methodReceiver.	candidateMixin := methodMixin.	[candidateMixinApplication := self		findApplicationOf: candidateMixin		startingAt: (self objectClass: candidateReceiver).	(candidateMixinApplication methodDictionary includesKey: selector)		ifTrue: [^candidateReceiver].	candidateMixin := self enclosingMixinOf: candidateMixin.	nil == candidateMixin]		whileFalse:			[candidateReceiver := self enclosingObjectOf: candidateMixinApplication].	^methodReceiver ! !!Decompiler methodsFor: '*NsSystem-instruction decoding' stamp: 'rmacnak 10/27/2014 20:02'!pushEnclosingObject: n "<Integer>"	stack addLast: (ExplicitOuterNode new depth: n)! !!Decompiler methodsFor: '*NsSystem-instruction decoding' stamp: 'Ahe 5/2/2008 01:11'!pushImplicitReceiverForMessage: selector "<Symbol>" 	stack addLast: (ImplicitVariableNode new name: 'outer'; selector: selector)! !!Decompiler methodsFor: '*NsSystem-instruction decoding' stamp: 'GB 6/10/2008 16:08'!sendToDynamicSuperclass: selector "<Symbol>" numArgs: numArgs "<Integer>"| args |	args := Array new: numArgs.	(numArgs to: 1 by: -1) do:		[:i | args at: i put: stack removeLast].	stack removeLast. "remove receiver, which is self" 	stack addLast:  (DynamicSuperSendNode new arguments: args; selector: selector)! !Decompiler removeSelector: #pushExplicitOuter:!ContextPart removeSelector: #pushExplicitOuter:!InstructionStream removeSelector: #pushExplicitOuter:!InstructionPrinter removeSelector: #pushExplicitOuter:!
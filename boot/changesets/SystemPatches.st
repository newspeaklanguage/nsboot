"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From nsboot-2008-05-19.00 of 20 May 2008 [latest update: #0] on 20 May 2008 at 2:02:58 am'!!CodeLoader class methodsFor: 'utilities' stamp: 'Ahe 5/14/2008 15:57'!compressFileNamed: aFileName in: aDirectory	"Compress the currently selected file"	| zipped buffer unzipped zipFileName |	unzipped := aDirectory readOnlyFileNamed: (aDirectory fullNameFor: aFileName).	unzipped binary.	zipFileName := aFileName copyUpToLast: $. .	zipped := aDirectory newFileNamed: (zipFileName, FileDirectory dot, ImageSegment compressedFileExtension).	zipped binary.	zipped := GZipWriteStream on: zipped.	buffer := ByteArray new: 50000.	[ :bar |		[unzipped atEnd] whileFalse: [			bar value: unzipped position of: unzipped size.			zipped nextPutAll: (unzipped nextInto: buffer)].		zipped close.		unzipped close] displayingProgress: 'Compressing ', zipFileName! !!CodeLoader class methodsFor: 'utilities' stamp: 'Ahe 5/14/2008 16:01'!signFilesFrom: sourceNames to: destNames key: privateKey	"Sign all the given files using the private key.	This will add an 's' to the extension of the file."	"| fd oldNames newNames |	fd _ FileDirectory default directoryNamed:'unsigned'.	oldNames _ fd fileNames.	newNames _ oldNames collect:[:name| 'signed', FileDirectory slash, name].	oldNames _ oldNames collect:[:name| 'unsigned', FileDirectory slash, name].	CodeLoader		signFilesFrom: oldNames		to: newNames		key: DOLPrivateKey."	| dsa |	dsa := DigitalSignatureAlgorithm new.	dsa initRandomNonInteractively.	[ :bar |		1 to: sourceNames size do: [ :i |		bar value: i of: sourceNames size.		self signFile: (sourceNames at: i) renameAs: (destNames at: i) key: privateKey dsa: dsa]	] displayingProgress: 'Signing files...'! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'eem 1/11/2008 10:59'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		SmalltalkImage current vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount mcMisses mcHits icHits rtSz rtOvf upTime sendCount tms tmSize upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := self getVMParameters.	oldSpaceEnd		:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount		:= params at: 11.	mcMisses			:= params at: 15.	mcHits				:= params at: 16.	icHits				:= params at: 17.	rtSz				:= params at: 21.	rtOvf				:= params at: 22.	upTime := Time millisecondClockValue.	sendCount := mcMisses + mcHits + icHits.	tms := TranslatedMethod allSubInstances.	tmSize := tms inject: 0 into: [:sum :tm | sum + (tm size * 4)].	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str cr; nextPutAll: '	root table size	'; print: rtSz.	str cr; nextPutAll: '	root table overflows	'; print: rtOvf.	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	sendCount > 0 ifTrue: [		str	nextPutAll: 'sends			';			nextPutAll: sendCount asStringWithCommas; cr.		str	nextPutAll: '	full			';			nextPutAll: mcMisses asStringWithCommas;			nextPutAll: ' ('; print: ((mcMisses / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	m-cache	';			nextPutAll: mcHits asStringWithCommas;			nextPutAll: ' ('; print: ((mcHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	i-cache		';			nextPutAll: icHits asStringWithCommas;			nextPutAll: ' ('; print: ((icHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr].	icHits > 0 ifTrue: [		str	nextPutAll: 'methods			';			nextPutAll: tms size asStringWithCommas; nextPutAll: ' translated'; cr.		str	nextPutAll: '	size			';			nextPutAll: tmSize asStringWithCommas; nextPutAll: ' bytes, avg ';			print: ((tmSize / tms size) roundTo: 0.1); nextPutAll: ' bytes/method'; cr.		str	nextPutAll: '	memory		';			print: ((tmSize / youngSpaceEnd * 100) roundTo: 0.1); nextPutAll: '% of used, ';			print: ((tmSize / memoryEnd * 100) roundTo: 0.1); nextPutAll: '% of available'; cr].	^ str contents! !!ChangeSet class methodsFor: 'scanning' stamp: 'Ahe 4/30/2008 02:42'!scanFile: file from: startPosition to: stopPosition	| itemPosition item prevChar changeList |	changeList := OrderedCollection new.	file position: startPosition.	[file position < stopPosition] whileTrue:[		[file atEnd not and: [file peek isSeparator]]			whileTrue: [prevChar := file next].		(file peekFor: $!!) ifTrue:[			(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [changeList addAll: (self scanCategory: file)].		] ifFalse:[			itemPosition := file position.			item := file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[changeList add: (ChangeRecord new file: file position: itemPosition type: #doIt)]]].	^changeList! !!FilePackage methodsFor: 'reading' stamp: 'Ahe 4/30/2008 02:50'!fileInFrom: aStream	| changes |	changes := ChangeSet scanFile: aStream from: 0 to: aStream size.	aStream close.	changes do: [ :chgRec | self perform: (chgRec type copyWith: $:) asSymbol with: chgRec]! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'Ahe 5/15/2008 01:02'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes := OrderedCollection new.	t := TypeMap := Dictionary new: 80. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: ByteString put: 5.   refTypes add: 1.	t at: ByteSymbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.self flag: #ByteArray.	t at: ByteString put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"	t at: WordArrayForSegment put: 19.  refTypes add: 1.		"bitmap-like"	t at: CompiledMethod put: 21.  refTypes add: 1.	"special creation method"	"t at:  put: 22.  refTypes add: 0."	ReferenceStream refTypes: refTypes.		"save it"	"For all classes that are like WordArrays, store them the way ColorArray is stored.  As bits, and able to change endianness."	Smalltalk do: [:cls |		cls isInMemory ifTrue: [			cls isBehavior ifTrue: [				cls isPointers not & cls isVariable & cls isWords ifTrue: [					(t includesKey: cls) ifFalse: [t at: cls put: 20]]]]].! !!TextDiffBuilder methodsFor: 'private' stamp: 'eem 3/23/2007 17:42'!attributesOf: type	"Private.	Answer the TextAttributes that are used to display text of the given type."	^type caseOf: {		[#insert] -> [ {TextColor red} ].		[#remove] -> [ {TextEmphasis underlined. TextColor blue}].	} otherwise: [ {TextEmphasis normal} ].! !DataStream initialize!Smalltalk organization removeSystemCategory: 'System-Serial Port'!
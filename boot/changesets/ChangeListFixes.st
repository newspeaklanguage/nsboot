"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 27 February 2008 at 4:46:03 pm'!!ClassDescription methodsFor: 'fileIn/Out' stamp: 'Ahe 10/4/2007 12:30'!hasChangedMethods	"Answer if any of the receiver's methods would appear on the changes file	if it were condensed."	self methodDict keys do:		[:sel | (self compiledMethodAt: sel) fileIndex > 1 ifTrue: [^true]].	^false! !!ChangeRecord methodsFor: 'access' stamp: 'eem 4/23/2007 10:37'!commentClass 	| commentClass |	type == #classComment ifFalse: [^ nil].	(Smalltalk includesKey: class asSymbol) ifFalse: [^ nil].	commentClass := Smalltalk at: class asSymbol.	^meta ifTrue: [commentClass class]		ifFalse: [commentClass]! !!ChangeRecord methodsFor: 'access' stamp: 'Ahe 2/14/2008 16:58'!methodSelector	type == #method		ifFalse: [^ nil].	^(Smalltalk at: class ifAbsent: [self class]) parserClass new parseSelector: self string! !!ChangeSet methodsFor: 'class changes' stamp: 'eem 4/23/2007 11:30'!fatDefForClass: class	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |		class isBehavior ifFalse: [^class definition].		newDef := class definition.	oldDef := (self changeRecorderFor: class) priorDefinition.	oldDef ifNil: [^ newDef].	oldDef = newDef ifTrue: [^ newDef].	oldStrm := ReadStream on: oldDef.	newStrm := ReadStream on: newDef.	outStrm := WriteStream on: (String new: newDef size * 2).	"Merge inst vars from old and new defs..."	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.	outStrm 		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 		nextPutAll: 'instanceVariableNames:'.	newStrm peek = $: ifTrue: [newStrm next].	"may or may not be there, but already written"	outStrm		nextPutAll: (newStrm upTo: $'); nextPut: $'.	oldVars := (oldStrm upTo: $') findTokens: Character separators.	newVars := (newStrm upTo: $') findTokens: Character separators.	addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.	oldVars , addedVars		do: [:var | outStrm nextPutAll: var]		separatedBy: [outStrm space].	outStrm nextPut: $'.	class isMeta ifFalse:		["Merge class vars from old and new defs..."		oldStrm upToAll: 'classVariableNames:'; upTo: $'.		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';			nextPutAll: (newStrm upTo: $'); nextPut: $'.		oldVars := (oldStrm upTo: $') findTokens: Character separators.		newVars := (newStrm upTo: $') findTokens: Character separators.		addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.		oldVars , addedVars			do: [:var | outStrm nextPutAll: var]			separatedBy: [outStrm space].		outStrm nextPut: $'].	outStrm nextPutAll: newStrm upToEnd.	^ outStrm contents! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'Ahe 10/5/2007 15:29'!condenseChanges	"Move all the changes onto a compacted sources file."	"Smalltalk condenseChanges"	| f oldChanges count |	f := FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.	'Condensing Changes File...'		displayProgressAt: Sensor cursorPoint		from: 0		to: self classNames size		during: [:bar | 			count := 0.			self				allClassesDo: [:cls | 					bar value: (count := count + 1).					cls hasChangedMethods ifTrue:						[f nextChunkPut: cls definition].					cls moveChangesTo: f.					cls putClassCommentToCondensedChangesFile: f.					cls classSide hasChangedMethods ifTrue:						[f nextChunkPut: cls classSide definition].					cls classSide moveChangesTo: f]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges := SourceFiles at: 2.	oldChanges close.	FileDirectory default deleteFileNamed: oldChanges name , '.old';		 rename: oldChanges name toBe: oldChanges name , '.old';		 rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles		at: 2		put: (StandardFileStream oldFileNamed: oldChanges name)! !!FilePackage methodsFor: 'conflict checker' stamp: 'Ahe 9/21/2007 21:08'!conflictsWithUpdatedMethods	"Check this package for conflicts with methods in the image which are in newer updates."	| localFileName stream updateNumberString updateNumber imageUpdateNumber updateNumberChangeSet conflicts fileStream |	localFileName := FileDirectory localNameFor: fullName.	stream := ReadStream on: sourceSystem.	stream upToAll: 'latest update: #'.	updateNumberString := stream upTo: $].	stream close.		fileStream := FileStream readOnlyFileNamed: fullName.	(fileStream contentsOfEntireFile includes: Character linefeed)		ifTrue: [self notifyWithLabel:  'The changeset file ', localFileName, ' contains linefeeds.  Proceed if...you know that this is okay (e.g. the file contains raw binary data).'].	fileStream close.	updateNumberString isEmpty ifFalse:		"remove prepended junk, if any"		[updateNumberString := (updateNumberString findTokens: Character space) last].	updateNumberString asInteger ifNil:		[(self confirm: 'Error: ', localFileName, ' has no valid Latest Update number in its header.Do you want to enter an update number for this file?')			ifFalse: [^ self]			ifTrue: [updateNumberString := FillInTheBlank						request: 'Please enter the estimated update number (e.g. 4332).']].	updateNumberString asInteger ifNil: [self inform: 'Conflict check cancelled.'. ^ self].	updateNumber := updateNumberString asInteger.	imageUpdateNumber := SystemVersion current highestUpdate.	updateNumber > imageUpdateNumber ifTrue:		[(self confirm: 'Warning: The update number for this file (#', updateNumberString, ')is greater than the highest update number for this image (#', imageUpdateNumber asString, ').This probably means you need to update your image.Should we proceed anyway as if the file update number is #', imageUpdateNumber asString, '?')			ifTrue:				[updateNumber := imageUpdateNumber.				updateNumberString := imageUpdateNumber asString]			ifFalse: [^ self]].	updateNumberChangeSet := self findUpdateChangeSetMatching: updateNumber.	updateNumberChangeSet ifNil: [^ self].	"Smalltalk isMorphic ifTrue: [self currentWorld findATranscript: self currentEvent]."	self class logCr; logCr; log: 'Checking ', localFileName, ' (#', updateNumberString, ') for method conflicts with changesets after ', updateNumberChangeSet name, ' ...'.	conflicts := OrderedCollection new.	self classes values do: [:pseudoClass |		(Array with: pseudoClass with: pseudoClass metaClass) do: [:classOrMeta |			classOrMeta selectors do: [:selector | | conflict |				conflict := self							checkForMoreRecentUpdateThanChangeSet: updateNumberChangeSet							pseudoClass: classOrMeta							selector: selector.				conflict ifNotNil: [conflicts add: conflict].			].		].	].	self class logCr; log: conflicts size asString, (' conflict' asPluralBasedOn: conflicts), ' found.'; logCr.	self class closeLog.	^ conflicts! !
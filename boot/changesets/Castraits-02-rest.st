"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From nsboot-2008-05-23.01 of 23 May 2008 [latest update: #0] on 2 June 2008 at 5:14:08 pm'!!Browser methodsFor: 'accessing' stamp: 'Ahe 10/2/2007 18:33'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be	 updated. The information can be a variety of things, depending on	 the list selections (such as templates for class or message definition,	 methods) or the user menu commands (such as definition, comment,	 hierarchy).  Answer the result of updating the source."	| aString aText theClass |	self changed: #annotation.	aString := input asString.	aText := input asText.	editSelection == #editSystemCategories ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment		ifTrue: 			[theClass := self selectedClass.			theClass				ifNil: 					[self inform: 'You must select a classbefore giving it a comment.'.					^ false].			theClass comment: aText stamp: Utilities changeStamp.			self changed: #classCommentText.			^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage)		ifTrue:			[^ self okayToAccept				ifFalse:					[false]				ifTrue:					[self compileMessage: aText notifying: aController]].	editSelection == #none		ifTrue: 			[self inform: 'This text cannot be acceptedin this part of the browser.'.			^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'class functions' stamp: 'GB 11/8/2007 15:08'!defineClass: defString notifying: aController  	"The receiver's textual content is a request to define a new class. The	source code is defString. If any errors occur in compilation, notify	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass := self selectedClassOrMetaClass.	defTokens := defString findTokens: Character separators.	envt := Smalltalk.	keywdIx := defTokens findFirst: [:x | '*subclass*' match: x].	keywdIx ~= 0 ifTrue: [ newClassName := (defTokens at: keywdIx+1) copyWithoutAll: '#()' ]		ifFalse: [ newClassName := self findClassNameIn: defString languageNamed: defTokens first ].	((oldClass isNil or: [oldClass theNonMetaClass name asString ~= newClassName])		and: [envt includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass := oldClass superclass].	class := oldClass subclassDefinerClass new				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: [self changed: #systemCategoryList.				self changed: #classList.				self clearUserEditFlag.				self setClass: class selector: nil.				"self clearUserEditFlag; editClass."				^ true]		ifFalse: [^ false]! !!Browser methodsFor: 'metaclass' stamp: 'Ahe 10/8/2007 10:21'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	| cls |	^self metaClassIndicated		ifTrue: [(cls := self selectedClass) ifNil: [nil] ifNotNil: [cls classSide]]		ifFalse: [self selectedClass]! !!SystemNavigation methodsFor: 'query' stamp: 'Ahe 5/28/2008 14:18'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses).	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous	behaviors for which the following should be executed:		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].	but what follows is way faster than enumerating all objects."	aBlock value: ProtoObject.	ProtoObject allSubclassesDoGently: [ :cls | "don't bring in ImageSegments"		cls isMixinApplication ifFalse: [aBlock value: cls]].	"Classes outside the ProtoObject hierarchy"	Class subclassesDo: [:aClass |		(aClass == ProtoObject class			or: [aClass isInMemory not			or: [aClass isMeta not			or: [aClass isMixinApplication]]]) ifFalse:			["Enumerate the non-meta class and its subclasses"			aBlock value: aClass soleInstance.			aClass soleInstance allSubclassesDoGently: aBlock]]! !!Behavior methodsFor: 'adding/removing methods' stamp: 'Ahe 5/5/2008 13:31'!addSelectorSilently: selector withMethod: compiledMethod	self basicAddSelector: selector withMethod: compiledMethod! !!Behavior methodsFor: 'adding/removing methods' stamp: 'Ahe 10/3/2007 20:06'!removeSelector: aSelector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	self basicRemoveSelector: aSelector! !!Behavior methodsFor: 'initialization' stamp: 'Ahe 10/3/2007 20:05'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary]! !!Behavior methodsFor: 'initialize-release' stamp: 'Ahe 10/3/2007 20:06'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := aClass.	format := fmt.	methodDict := mDict! !!Browser methodsFor: 'message functions' stamp: 'Ahe 10/3/2007 20:07'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName := self selectedMessageName.	confirmation := self systemNavigation   confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation == 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.	"In case organization not cached"	confirmation == 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'Ahe 10/3/2007 20:07'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classes list |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self inform: 'Warning: no changes to file out'].			classes := self changedClasses select: [:each | each isBehavior].	list := self class superclassOrder: classes asOrderedCollection.		"First put out rename, max classDef and comment changes."	list do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	list do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	list reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSorter methodsFor: 'class list' stamp: 'Ahe 10/5/2007 23:03'!selectedClassOrMetaClass	"Careful, the class may have been removed!!"	| cName |	currentClassName ifNil: [^ nil].	(currentClassName endsWith: ' class')		ifTrue: [cName := (currentClassName copyFrom: 1 to: currentClassName size-6) asSymbol.				^ (Smalltalk at: cName ifAbsent: [^nil]) class].	cName := currentClassName asSymbol.	^ Smalltalk at: cName ifAbsent: [nil]! !!ClassBuilder methodsFor: 'class definition' stamp: 'Ahe 6/2/2008 11:13'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newFormat newClass |	newClass := Language newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass using: self.	newClass == nil ifFalse: [^newClass].	"Compute the format of the new class"	newFormat := 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: MethodDictionary new		format: newFormat;		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'Ahe 10/3/2007 21:54'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod := self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol := self whichCategoryIncludesSelector: selector.	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 		doSilently: [ self organization removeElement: selector ].	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'Ahe 10/3/2007 20:09'!definitionST80	"Answer a String that defines the receiver."	| aStream |	aStream := WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [aStream nextPutAll: superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'Ahe 10/3/2007 20:10'!fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| selectors |	aFileStream cr.	selectors := (aSymbol asString = ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].	"Overridden to preserve author stamps in sources file regardless"	selectors do: [:sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'Ahe 10/3/2007 20:11'!moveChangesTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	changes := self methodDict keys select:		[:sel | (self compiledMethodAt: sel) fileIndex > 1].	self		fileOutChangedMessages: changes		on: newFile		moveSource: true		toFile: 2! !!Class methodsFor: '*monticello' stamp: 'Ahe 10/3/2007 20:08'!asClassDefinition	| defClass |	defClass := MCClassDefinition.	Smalltalk at: #Language ifPresent:		[ :ignored |		self language writer new mcClassDefinitionClass ifNotNil:			[ :mcClassDefinitionClass |			 defClass := mcClassDefinitionClass]].	^defClass		name: self name		superclassName: self superclass name		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: self typeOfClass		comment: self organization classComment	 asString		commentStamp: self organization commentStamp! !!ClassDescription methodsFor: 'accessing' stamp: 'Ahe 10/8/2007 10:26'!version	self flag: #BOGUS. "This method could be a leftover from Traits"	^ self classVersion! !!Debugger methodsFor: 'accessing' stamp: 'Ahe 10/3/2007 21:33'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be  	updated. In this case, the retrieved information is the method of the  	selected context."	| selector classOfMethod category h ctxt |	contextStackIndex = 0		ifTrue: [^ false].	self selectedContext isExecutingBlock		ifTrue: [h := self selectedContext finalBlockHome.			h				ifNil: [self inform: 'Method not found for block, can''t edit'.					^ false].			(self confirm: 'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifTrue: [self resetContext: h]				ifFalse: [^ false]].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	selector == self selectedMessageName		ifFalse: [self inform: 'can''t change selector'.			^ false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector		ifNil: [^ false].	"compile cancelled"	contents := aText.	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext ifFalse: [		self inform: 'Method saved, but current context unchangedbecause of unwind error. Click OK to see error'.	] ifTrue: [		interruptedProcess			restartTopWith: (classOfMethod compiledMethodAt: selector);		 	stepToSendOrReturn.		contextVariablesInspector object: nil.		theMethodNode := Preferences browseWithPrettyPrint			ifTrue: [ctxt methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting]			ifFalse: [ctxt methodNode].		sourceMap := theMethodNode sourceMap.		tempNames := theMethodNode tempNames.	].	self resetContext: ctxt.	^ true! !!Compiler class methodsFor: 'utilities' stamp: 'Ahe 10/5/2007 15:18'!recompileAll	"Recompile all classes, starting with given name."	Smalltalk forgetDoIts.	Smalltalk allClasses do: [ :each | each compileAll] displayingProgress: 'Recompiling all classes'! !!FilePackage methodsFor: '*monticello' stamp: 'Ahe 10/3/2007 20:12'!classDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	"tokens size = 11 ifFalse:[^doIts add: chgRec]."	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!MCClassDefinition methodsFor: 'visiting' stamp: 'programmatic 10/4/2007 09:49'!= aDefinition	^((super = aDefinition)		and: [superclassName = aDefinition superclassName])		and: [category = aDefinition category]		and: [type = aDefinition type]		and: [variables = aDefinition variables]		and: [comment = aDefinition comment]! !!MCClassDefinition methodsFor: 'installing' stamp: 'Ahe 10/3/2007 20:14'!createClass	| superClass class |	superClass := Smalltalk at: superclassName.	class := (ClassBuilder new)			name: name 			inEnvironment: superClass environment 			subclassOf: superClass			type: type 			instanceVariableNames: self instanceVariablesString 			classVariableNames: self classVariablesString 			poolDictionaries: self sharedPoolsString			category: category.	Smalltalk at: #SmalltalkLanguage ifPresent:		[ :stLanguage | stLanguage new becomeLanguageFor: class ].	^class! !!MCClassDefinition methodsFor: 'printing' stamp: 'Ahe 10/3/2007 20:14'!printDefinitionOn: stream		stream 			nextPutAll: self superclassName;			nextPutAll: self kindOfSubclass;			nextPut: $# ;			nextPutAll: self className;			cr; tab;			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString;			cr; tab;			nextPutAll: 'classVariableNames: ';			store: self classVariablesString;			cr; tab;			nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString;			cr; tab;			nextPutAll: 'category: ';			store: self category asString! !!MCClassDefinition methodsFor: 'serializing' stamp: 'Ahe 10/3/2007 20:14'!storeDataOn: aDataStream	| instVarSize |	instVarSize := self class instSize.	aDataStream		beginInstance: self class		size: instVarSize.	1 to: instVarSize do: [ :index |		aDataStream nextPut: (self instVarAt: index) ].! !!MCClassDefinition methodsFor: 'visiting' stamp: 'Ahe 10/3/2007 20:13'!accept: aVisitor	aVisitor visitClassDefinition: self.	self hasClassInstanceVariables		ifTrue: [aVisitor visitMetaclassDefinition: self].! !!MCClassDefinition methodsFor: 'visiting' stamp: 'Ahe 10/6/2007 19:06'!initializeWithName: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	superclassName := superclassString ifNil: ['nil'] ifNotNil: [superclassString asSymbol].	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray asSortedCollection ofType: MCClassVariableDefinition.	self addVariables: poolArray ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition! !!MCClassDefinition class methodsFor: 'instance creation' stamp: 'Ahe 10/5/2007 15:22'!name: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampString		^ self instanceLike:		(self new initializeWithName: nameString					superclassName: superclassString					category: categoryString 					instVarNames: ivarArray					classVarNames: cvarArray					poolDictionaryNames: poolArray					classInstVarNames: civarArray					type: typeSymbol					comment: commentString					commentStamp: stampString)! !!MCClassDefinition methodsFor: 'comparing' stamp: 'Ahe 9/26/2007 11:09'!hash	| hash |	hash := String stringHash: name initialHash: 0.	hash := String stringHash: superclassName initialHash: hash.	category = nil ifFalse:		[ hash := String stringHash: category initialHash: hash ].	hash := String stringHash: type initialHash: hash.	variables do:		[ :v | hash := String stringHash: v name initialHash: hash ].	^ hash! !!MCMethodDefinition methodsFor: 'installing' stamp: 'Ahe 10/5/2007 15:20'!postload	self isInitializer ifTrue: [ self actualClass theNonMetaClass initialize ]! !!MCMethodDefinition methodsFor: 'printing' stamp: 'Ahe 10/5/2007 15:20'!fullClassName	"Using #class selector for classes for backwards compatibility"	^ self classIsMeta		ifFalse: [self className]		ifTrue: [			self actualClass isNil				ifFalse: [self className, ' class']				ifTrue: [self className, ' classSide']]! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'Ahe 10/5/2007 15:23'!classDefinitionFrom: aPseudoClass	| tokens lastIndex |	tokens := Scanner new scanTokens: aPseudoClass definition.	lastIndex := tokens size.	^ MCClassDefinition		name: (tokens at: 3)		superclassName: (tokens at: 1)		category: (tokens at: lastIndex)		instVarNames: ((tokens at: lastIndex - 6) findTokens: ' ')		classVarNames: ((tokens at: lastIndex - 4) findTokens: ' ')		poolDictionaryNames: ((tokens at: lastIndex - 2) findTokens: ' ')		classInstVarNames: (self classInstVarNamesFor: aPseudoClass)		type: (self typeOfSubclass: (tokens at: 2))		comment: (self commentFor: aPseudoClass)		commentStamp: (self commentStampFor: aPseudoClass)! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'Ahe 10/3/2007 20:15'!classInstVarNamesFor: aPseudoClass	| tokens |	aPseudoClass metaClass hasDefinition ifFalse: [^ #()].	tokens := Scanner new scanTokens: aPseudoClass metaClass definition.	"tokens size = 4 ifFalse: [self error: 'Unrecognized metaclass definition']."	^ tokens last findTokens: ' '! !!MCStWriter methodsFor: 'writing' stamp: 'Ahe 10/3/2007 20:16'!writeMetaclassDefinition: definition	self chunkContents: [:str |		str	nextPutAll: definition className;			nextPutAll: ' class';			cr; tab;			nextPutAll: 'instanceVariableNames: ''';			nextPutAll: definition classInstanceVariablesString;			nextPut: $']! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'Ahe 10/3/2007 20:16'!definitionST80	"Refer to the comment in ClassDescription|definition."	^ String streamContents: 		[:strm |		strm print: self;			crtab;			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'Ahe 10/3/2007 20:16'!nonTrivial 	"Answer whether the receiver has any methods or instance variables."	^ self instVarNames size > 0 or: [self methodDict size > 0]! !!ModifiedClassDefinitionEvent methodsFor: '*Kernel-Classes' stamp: 'Ahe 10/3/2007 20:17'!anyChanges	^ self isSuperclassModified or: [self areInstVarsModified or: [self areClassVarsModified or: [self areSharedPoolsModified]]]! !!ModifiedClassDefinitionEvent methodsFor: '*Kernel-Classes' stamp: 'Ahe 10/3/2007 20:17'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' Super: ';		print: self isSuperclassModified;		nextPutAll: ' InstVars: ';		print: self areInstVarsModified;		nextPutAll: ' ClassVars: ';		print: self areClassVarsModified;		nextPutAll: ' SharedPools: ';		print: self areSharedPoolsModified.! !!PackageInfo methodsFor: 'listing' stamp: 'Ahe 10/3/2007 20:18'!methods	^ (self extensionMethods, self coreMethods) select: [:method |		method isValid			and: [method methodSymbol isDoIt not]]! !!PackageInfo methodsFor: 'modifying' stamp: 'Ahe 10/3/2007 20:17'!externalBehaviors	^self externalClasses! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'Ahe 10/5/2007 15:24'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry |	self flag: #yoCharCases.	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol := self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry := (Smalltalk					at: aSymbol					ifAbsent:						[ self systemNavigation browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				anEntry isBehavior					ifFalse: [ anEntry := anEntry class ].				ToolSet browse: anEntry selector: nil]			ifFalse:				[self systemNavigation browseAllImplementorsOf: aSymbol]]! !!StringHolder methodsFor: '*Tools' stamp: 'Ahe 10/5/2007 15:25'!browseClassRefs	| cls |	cls := self selectedClass.	cls notNil		ifTrue: [self systemNavigation browseAllCallsOnClass: cls theNonMetaClass]! !!StringHolder methodsFor: '*Tools' stamp: 'Ahe 10/5/2007 15:25'!browseClassVariables	"Browse the class variables of the selected class. 2/5/96 sw"	| cls |	cls := self selectedClass.	cls notNil		ifTrue: [self systemNavigation  browseClassVariables: cls]! !!StringHolder methodsFor: '*Tools' stamp: 'Ahe 10/5/2007 15:25'!browseClassVarRefs	"1/17/96 sw: devolve responsibility to the class, so that the code that does the real work can be shared"	| cls |	cls := self selectedClass.	cls notNil		ifTrue: [self systemNavigation browseClassVarRefs: cls]! !!StringHolder methodsFor: '*Tools' stamp: 'Ahe 10/5/2007 15:26'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks."	| aClass |	(Smalltalk isMorphic and: [Smalltalk includesKey: #Lexicon]) ifFalse: [^ self spawnFullProtocol].	(aClass := self selectedClassOrMetaClass) notNil ifTrue:		[(Smalltalk at: #Lexicon) new openOnClass: aClass inWorld: ActiveWorld showingSelector: self selectedMessageName]! !!StringHolder methodsFor: '*Tools' stamp: 'Ahe 10/5/2007 15:26'!browseInstVarDefs 	| cls |	cls := self selectedClassOrMetaClass.	cls notNil		ifTrue: [self systemNavigation browseInstVarDefs: cls]! !!StringHolder methodsFor: '*Tools' stamp: 'Ahe 10/5/2007 15:26'!browseInstVarRefs	"1/26/96 sw: real work moved to class, so it can be shared"	| cls |	cls := self selectedClassOrMetaClass.	cls notNil		ifTrue: [self systemNavigation browseInstVarRefs: cls]! !!CodeHolder methodsFor: 'classes' stamp: 'Ahe 10/5/2007 15:14'!makeSampleInstance	| aClass nonMetaClass anInstance |	(aClass := self selectedClassOrMetaClass) isNil ifTrue: [^ self].	nonMetaClass := aClass theNonMetaClass.	anInstance := self sampleInstanceOfSelectedClass.	(anInstance isNil and: [nonMetaClass ~~ UndefinedObject]) ifTrue: 		[^ self inform: 'Sorry, cannot make an instance of ', nonMetaClass name].	(Smalltalk isMorphic and: [anInstance isMorph])		ifTrue:			[self currentHand attachMorph: anInstance]		ifFalse:			[anInstance inspectWithLabel: 'An instance of ', nonMetaClass name]! !!CodeHolder methodsFor: 'classes' stamp: 'Ahe 10/5/2007 15:14'!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport |	(cls := self selectedClass) isNil ifTrue: [^ self].	aList := self systemNavigation allUnreferencedClassVariablesOf: cls.	aList size == 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport := String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList)		startUpWithCaption: 'Unreferencedclass variables in ' , cls name! !!CodeHolder methodsFor: 'classes' stamp: 'Ahe 10/5/2007 15:15'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	(cls := self selectedClassOrMetaClass) isNil ifTrue: [^ self].	aList := cls allUnreferencedInstanceVariables.	aList size == 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport := String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferencedinstance variables in ', cls name! !!CodeHolder methodsFor: 'classes' stamp: 'Ahe 10/5/2007 15:15'!spawnHierarchy	"Create and schedule a new hierarchy browser on the currently selected class or meta."	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |	(selectedClassOrMetaClass := self selectedClassOrMetaClass)		ifNil: [^ self].	newBrowser := HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.	((aSymbol := self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])		ifTrue:			[aBehavior := selectedClassOrMetaClass.			messageCatIndex := aBehavior organization numberOfCategoryOfElement: aSymbol.			newBrowser messageCategoryListIndex: messageCatIndex + 1.			newBrowser messageListIndex:				((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol)].	Browser		openBrowserView: (newBrowser openSystemCatEditString: nil)		label: newBrowser labelString.	Smalltalk isMorphic		ifTrue: ["this workaround only needed in morphic"			newBrowser assureSelectionsShow]! !!Browser methodsFor: 'accessing' stamp: 'Ahe 10/5/2007 15:10'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod := currentCompiledMethod.	currentCompiledMethod := nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass := self selectedClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^self classDefinitionText].	editSelection == #editComment 		ifTrue:			[(theClass := self selectedClass) ifNil: [^ ''].			comment := theClass comment.			currentCompiledMethod := theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [^self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue:			[^ (theClass := self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod := latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'message functions' stamp: 'Ahe 10/5/2007 15:12'!inspectInstances	"Inspect all instances of the selected class.  1/26/96 sw"	| myClass |	(myClass := self selectedClassOrMetaClass) isNil		ifFalse: [myClass theNonMetaClass inspectAllInstances]! !!Browser methodsFor: 'message functions' stamp: 'Ahe 10/5/2007 15:12'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses  1/26/96 sw"	| aClass |	(aClass := self selectedClassOrMetaClass) isNil		ifFalse: [			aClass := aClass theNonMetaClass.			aClass inspectSubInstances]! !!Browser methodsFor: 'classes' stamp: 'Ahe 10/5/2007 15:12'!newClass	self editClass.	editSelection := #newClass.	self contentsChanged! !!SystemDictionary methodsFor: 'class names' stamp: 'Ahe 10/5/2007 15:30'!classNamed: className 	"className is either a class name or a class name followed by ' class'.	Answer the class or metaclass it names."	| meta baseName baseClass |	(className endsWith: ' class')		ifTrue: [meta := true.				baseName := className copyFrom: 1 to: className size - 6]		ifFalse: [meta := false.				baseName := className].	baseClass := Smalltalk at: baseName asSymbol ifAbsent: [^ nil].	meta		ifTrue: [^ baseClass classSide]		ifFalse: [^ baseClass]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'Ahe 10/5/2007 15:30'!condenseSources		"Move all the changes onto a compacted sources file."	"Smalltalk condenseSources"	| f dir newVersionString count |	Utilities fixUpProblemsWithAllCategory.	"The above removes any concrete, spurious '-- all --' categories, which mess up the process."	dir := FileDirectory default.	newVersionString := UIManager default request: 'Please designate the versionfor the new source code file...' initialAnswer: SmalltalkImage current sourceFileVersionString.	newVersionString ifNil: [^ self].	newVersionString = SmalltalkImage current sourceFileVersionString ifTrue:		[^ self error: 'The new source file must not be the same as the old.'].	SmalltalkImage current sourceFileVersionString: newVersionString.	"Write all sources with fileIndex 1"	f := FileStream newFileNamed: SmalltalkImage current sourcesName.	f header; timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during:		[:bar | count := 0.		Smalltalk allClassesDo:			[:cls | bar value: (count := count + 1).			cls fileOutOn: f moveSource: true toFile: 1]].	f trailer; close.	"Make a new empty changes file"	SmalltalkImage current closeSourceFiles.	dir rename: SmalltalkImage current changesName		toBe: SmalltalkImage current changesName , '.old'.	(FileStream newFileNamed: SmalltalkImage current changesName)		header; timeStamp; close.	SmalltalkImage current lastQuitLogPosition: 0.	self setMacFileInfoOn: SmalltalkImage current changesName.	self setMacFileInfoOn: SmalltalkImage current sourcesName.	SmalltalkImage current openSourceFiles.	self inform: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'Ahe 10/5/2007 15:30'!reconstructChanges		"Move all the changes and its histories onto another sources file."	"Smalltalk reconstructChanges"	| f oldChanges classCount |	f := FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during:		[:bar | classCount := 0.		Smalltalk allClassesDo:			[:cls | bar value: (classCount := classCount + 1).			cls moveChangesWithVersionsTo: f.			cls putClassCommentToCondensedChangesFile: f.			cls classSide moveChangesWithVersionsTo: f]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges := SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (FileStream oldFileNamed: oldChanges name)! !!SystemNavigation methodsFor: 'browse' stamp: 'Ahe 10/5/2007 15:31'!methodHierarchyBrowserForClass: aClass selector: sel	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	"SystemNavigation default 		methodHierarchyBrowserForClass: ParagraphEditor 		selector: #isControlActive"		| list tab stab aClassNonMeta isMeta theClassOrMeta |	aClass ifNil: [^ self].	sel ifNil: [^ self].	aClassNonMeta := aClass theNonMetaClass.	isMeta := aClassNonMeta ~~ aClass.	list := OrderedCollection new.	tab := ''.	aClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab := tab , '  '].	aClassNonMeta allSubclassesWithLevelDo:		[:cl :level |		theClassOrMeta := isMeta ifTrue: [cl class] ifFalse: [cl].		(theClassOrMeta includesSelector: sel) ifTrue:			[stab := ''.  1 to: level do: [:i | stab := stab , '  '].			list addLast: tab , stab , theClassOrMeta name, ' ', sel]]	 	startingLevel: 0.	self browseMessageList: list name: 'Inheritance of ' , sel! !!SystemNavigation methodsFor: 'query' stamp: 'Ahe 10/5/2007 15:31'!allImplementedMessagesWithout: classesAndMessagesPair 	"Answer a Set of all the messages that are implemented in the system,  	computed in the absence of the supplied classes and messages. Note this  	reports messages that are in the absent selectors set."	| messages absentClasses |	messages := IdentitySet new: CompiledMethod instanceCount.	absentClasses := classesAndMessagesPair first.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:. "sd 29/04/03" 	Cursor execute showWhile: [		Smalltalk classNames			do: [:name | ((absentClasses includes: name)				ifTrue: [{}]				ifFalse: [{Smalltalk at: name. (Smalltalk at: name) classSide}])					do: [:each | messages addAll: each selectors]]].	^ messages! !!SystemNavigation methodsFor: 'query' stamp: 'Ahe 10/5/2007 15:31'!allSentMessagesWithout: classesAndMessagesPair 	"Answer the set of selectors which are sent somewhere in the system,  	computed in the absence of the supplied classes and messages."	| sent absentClasses absentSelectors |	sent := IdentitySet new: CompiledMethod instanceCount.	absentClasses := classesAndMessagesPair first.	absentSelectors := classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute showWhile: [		Smalltalk classNames do: [:name |			((absentClasses includes: name)				ifTrue: [{}]				ifFalse: [{Smalltalk at: name. (Smalltalk at: name) classSide}])					do: [:each | (absentSelectors isEmpty						ifTrue: [each selectors]						ifFalse: [each selectors copyWithoutAll: absentSelectors])						do: [:sel | "Include all sels, but not if sent by self"							(each compiledMethodAt: sel) literals								do: [:m | 									(m isSymbol)										ifTrue: ["might be sent"											m == sel												ifFalse: [sent add: m]].									(m isMemberOf: Array)										ifTrue: ["might be performed"											m												do: [:x | (x isSymbol)														ifTrue: [x == sel																ifFalse: [sent add: x]]]]]]]].			"The following may be sent without being in any literal frame"			1				to: Smalltalk specialSelectorSize				do: [:index | sent						add: (Smalltalk specialSelectorAt: index)]].	Smalltalk presumedSentMessages		do: [:sel | sent add: sel].	^ sent! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'Ahe 10/3/2007 20:18'!fileOutCategory: category on: aFileStream initializing: aBool	"Store on the file associated with aFileStream, all the classes associated 	with the category and any requested shared pools in the right order."	| first poolSet tempClass classes |	classes := self superclassOrder: category.	poolSet := Set new.	classes do:  [:class | class sharedPools do: [:eachPool | poolSet add: eachPool]].	poolSet size > 0 ifTrue: [		tempClass := Class new.		tempClass shouldFileOutPools ifTrue: [			poolSet := poolSet select: [:aPool |				tempClass shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool)].			poolSet do: [:aPool | tempClass fileOutPool: aPool onFileStream: aFileStream]]].	first := true.	classes do: [:each | 		first			ifTrue: [first := false]			ifFalse: [aFileStream cr; nextPut: Character newPage; cr].		each			fileOutOn: aFileStream			moveSource: false			toFile: 0			initializing: false].	aBool ifTrue: [classes do: [:cls | cls fileOutInitializerOn: aFileStream]].! !!SystemOrganizer methodsFor: 'remove' stamp: 'Ahe 10/3/2007 20:19'!removeSystemCategory: category	"remove all the classes associated with the category"	(self superclassOrder: category)		reverseDo: [:each | each removeFromSystem].	self removeCategory: category.! !!Utilities class methodsFor: 'summer97 additions' stamp: 'Ahe 10/5/2007 15:31'!classFromPattern: pattern withCaption: aCaption	"If there is a class whose name exactly given by pattern, return it.	If there is only one class in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores tab, space, & cr characters in the pattern"	| toMatch potentialClassNames classNames exactMatch index |	(toMatch :=  pattern copyWithoutAll:			{Character space.  Character cr.  Character tab})		isEmpty ifTrue: [^ nil].	Symbol hasInterned: toMatch ifTrue:		[:patternSymbol | Smalltalk at: patternSymbol ifPresent:			[:maybeClass | (maybeClass isKindOf: Class) ifTrue: [^ maybeClass]]].	toMatch := (toMatch copyWithout: $.) asLowercase.	potentialClassNames := Smalltalk classNames asOrderedCollection.	classNames := pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ nil].	exactMatch := classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index := classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [UIManager default chooseFrom: classNames lines: #() title: aCaption]			ifNotNil: [classNames addFirst: exactMatch.				UIManager default chooseFrom: classNames lines: #(1) title: aCaption]].	index = 0 ifTrue: [^ nil].	^ Smalltalk at: (classNames at: index) asSymbol"	self classFromPattern: 'CharRecog' withCaption: ''	self classFromPattern: 'rRecog' withCaption: ''	self classFromPattern: 'znak' withCaption: ''	self classFromPattern: 'orph' withCaption: ''	self classFromPattern: 'TCompil' withCaption: ''"! !Behavior removeSelector: #addExclusionOf:to:!Behavior removeSelector: #addToComposition:!Behavior removeSelector: #addTraitSelector:withMethod:!Behavior removeSelector: #applyChangesOfNewTraitCompositionReplacing:!Behavior removeSelector: #basicAddTraitSelector:withMethod:!Behavior removeSelector: #basicLocalSelectors!Behavior removeSelector: #basicLocalSelectors:!Behavior removeSelector: #canPerform:!Behavior removeSelector: #classAndMethodFor:do:ifAbsent:!Behavior removeSelector: #classesComposedWithMe!Behavior removeSelector: #clearSendCaches!Behavior removeSelector: #computeSelfSendersFromInheritedSelfSenders:localSelfSenders:!Behavior removeSelector: #computeTranslationsAndUpdateUnreachableSet:!Behavior removeSelector: #deregisterLocalSelector:!Behavior removeSelector: #ensureLocalSelectors!Behavior removeSelector: #findSelfSendersOf:unreachable:noInheritedSelfSenders:!Behavior removeSelector: #formalParametersAt:!Behavior removeSelector: #hasRequiredSelectors!Behavior removeSelector: #hasTraitComposition!Behavior removeSelector: #includesLocalSelector:!Behavior removeSelector: #isAliasSelector:!Behavior removeSelector: #isDisabledSelector:!Behavior removeSelector: #isLocalAliasSelector:!Behavior removeSelector: #isProvidedSelector:!Behavior removeSelector: #localSelectors!Behavior removeSelector: #methodDictAddSelectorSilently:withMethod:!Behavior removeSelector: #noteChangedSelectors:!Behavior removeSelector: #notifyUsersOfChangedSelector:!Behavior removeSelector: #notifyUsersOfChangedSelectors:!Behavior removeSelector: #providedSelectors!Behavior removeSelector: #purgeLocalSelectors!Behavior removeSelector: #registerLocalSelector:!Behavior removeSelector: #removeAlias:of:!Behavior removeSelector: #removeFromComposition:!Behavior removeSelector: #removeTraitSelector:!Behavior removeSelector: #requiredSelectors!Behavior removeSelector: #requiredSelectorsCache!Behavior removeSelector: #requirements!Behavior removeSelector: #selfSentSelectorsFromSelectors:!Behavior removeSelector: #sendCaches!Behavior removeSelector: #sendCaches:!Behavior removeSelector: #setRequiredStatusOf:to:!Behavior removeSelector: #setTraitComposition:!Behavior removeSelector: #setTraitCompositionFrom:!Behavior removeSelector: #superRequirements!Behavior removeSelector: #traitComposition!Behavior removeSelector: #traitComposition:!Behavior removeSelector: #traitCompositionIncludes:!Behavior removeSelector: #traitCompositionString!Behavior removeSelector: #traitOrClassOfSelector:!Behavior removeSelector: #traitTransformations!Behavior removeSelector: #traitsProvidingSelector:!Behavior removeSelector: #translateReachableSelfSenders:translations:!Behavior removeSelector: #updateMethodDictionarySelector:!Behavior removeSelector: #updateRequiredStatusFor:inSubclasses:!Behavior removeSelector: #updateRequiredStatusFor:inSubclasses:parentSelfSenders:providedInParent:noInheritedSelfSenders:!Behavior removeSelector: #updateRequiredStatusFor:inSubclasses:parentSelfSenders:providedInParent:noInheritedSelfSenders:accumulatingInto:!Behavior removeSelector: #withInheritanceTraitCompositionIncludes:!Browser removeSelector: #addSpecialMenu:!Browser removeSelector: #addTrait!Browser removeSelector: #defineTrait:notifying:!Browser removeSelector: #newTrait!Browser removeSelector: #removeNonLocalSelector:!ChangeSet class removeSelector: #traitsOrder:!Class removeSelector: #applyChangesOfNewTraitCompositionReplacing:!Class removeSelector: #basicLocalSelectors!Class removeSelector: #basicLocalSelectors:!Class removeSelector: #hasTraitComposition!Class removeSelector: #subclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category:!Class removeSelector: #traitComposition!Class removeSelector: #traitComposition:!Class removeSelector: #variableByteSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category:!Class removeSelector: #variableSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category:!Class removeSelector: #variableWordSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category:!Class removeSelector: #weakSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category:!ClassDescription removeSelector: #applyChangesOfNewTraitCompositionReplacing:!ClassDescription removeSelector: #noteRecategorizedSelector:from:to:!ClassDescription removeSelector: #noteRecategorizedSelectors:oldComposition:!ClassDescription removeSelector: #updateOrganizationSelector:oldCategory:newCategory:!CompiledMethod class removeSelector: #conflictMarker!MCClassDefinition class removeSelector: #name:superclassName:traitComposition:classTraitComposition:category:instVarNames:classVarNames:poolDictionaryNames:classInstVarNames:type:comment:commentStamp:!MCClassDefinition removeSelector: #classTraitComposition!MCClassDefinition removeSelector: #classTraitCompositionString!MCClassDefinition removeSelector: #hasClassTraitComposition!MCClassDefinition removeSelector: #hasTraitComposition!MCClassDefinition removeSelector: #initializeWithName:superclassName:traitComposition:classTraitComposition:category:instVarNames:classVarNames:poolDictionaryNames:classInstVarNames:type:comment:commentStamp:!MCClassDefinition removeSelector: #traitComposition!MCClassDefinition removeSelector: #traitCompositionString!MCStWriter removeSelector: #visitClassTraitDefinition:!MCStWriter removeSelector: #visitTraitDefinition:!Metaclass removeSelector: #assertConsistantCompositionsForNew:!Metaclass removeSelector: #basicLocalSelectors!Metaclass removeSelector: #basicLocalSelectors:!Metaclass removeSelector: #hasTraitComposition!Metaclass removeSelector: #noteNewBaseTraitCompositionApplied:!Metaclass removeSelector: #traitComposition!Metaclass removeSelector: #traitComposition:!Metaclass removeSelector: #uses:instanceVariableNames:!MethodReference removeSelector: #isLocalSelector!ModifiedClassDefinitionEvent removeSelector: #isTraitCompositionModified!ModifiedClassDefinitionEvent removeSelector: #oldTraitComposition!ModifiedClassDefinitionEvent removeSelector: #traitComposition!Object removeSelector: #isTrait!Object removeSelector: #traitConflict!PackageInfo removeSelector: #externalTraits!PseudoClass removeSelector: #isTrait!SequenceableCollection removeSelector: #asTraitComposition!SystemChangeNotifier removeSelector: #traitDefinitionChangedFrom:to:!SystemDictionary removeSelector: #allClassesAndTraits!SystemDictionary removeSelector: #allClassesAndTraitsDo:!SystemDictionary removeSelector: #allTraits!SystemDictionary removeSelector: #classOrTraitNamed:!SystemDictionary removeSelector: #traitNames!SystemNavigation removeSelector: #allClassesAndTraits!SystemOrganizer removeSelector: #orderedTraitsIn:!Smalltalk removeClassNamed: #ATestCase!Smalltalk removeClassNamed: #ClassTraitTest!Smalltalk removeClassNamed: #FullMERequiresSpeedTestCase!Smalltalk removeClassNamed: #LocatedMethodTest!Smalltalk removeClassNamed: #PureBehaviorTest!Smalltalk removeClassNamed: #RequiresOriginalTestCase!Smalltalk removeClassNamed: #RequiresSpeedTestCase!Smalltalk removeClassNamed: #RequiresTestCase!Smalltalk removeClassNamed: #SendCachePerformanceTest!Smalltalk removeClassNamed: #SendsInfoTest!Smalltalk removeClassNamed: #SystemTest!Smalltalk removeClassNamed: #TAccessingMethodDictDescription!Smalltalk removeClassNamed: #TAccessingTraitCompositionBehavior!Smalltalk removeClassNamed: #TApplyingOnClassSide!Smalltalk removeClassNamed: #TBasicCategorisingDescription!Smalltalk removeClassNamed: #TBehaviorCategorization!Smalltalk removeClassNamed: #TCommentDescription!Smalltalk removeClassNamed: #TCompilingBehavior!Smalltalk removeClassNamed: #TCompilingDescription!Smalltalk removeClassNamed: #TComposingDescription!Smalltalk removeClassNamed: #TCopyingDescription!Smalltalk removeClassNamed: #TFileInOutDescription!Smalltalk removeClassNamed: #TPrintingDescription!Smalltalk removeClassNamed: #TPureBehavior!Smalltalk removeClassNamed: #TTestingDescription!Smalltalk removeClassNamed: #TTraitsCategorisingDescription!Smalltalk removeClassNamed: #TTransformationCompatibility!Smalltalk removeClassNamed: #TUpdateTraitsBehavior!Smalltalk removeClassNamed: #TimeMeasuringTest!Smalltalk removeClassNamed: #TraitCompositionTest!Smalltalk removeClassNamed: #TraitFileOutTest!Smalltalk removeClassNamed: #TraitMethodDescriptionTest!Smalltalk removeClassNamed: #TraitTest!Smalltalk removeClassNamed: #TraitsResource!Smalltalk removeClassNamed: #TraitsTestCase!Smalltalk removeClassNamed: #Castraits!Smalltalk removeClassNamed: #ClassTrait!Smalltalk removeClassNamed: #MCClassTraitDefinition!Smalltalk removeClassNamed: #MCClassTraitParser!Smalltalk removeClassNamed: #MCTraitDefinition!Smalltalk removeClassNamed: #MCTraitParser!Smalltalk removeClassNamed: #ModifiedTraitDefinitionEvent!Smalltalk removeClassNamed: #Trait!Smalltalk removeClassNamed: #TraitBehavior!Smalltalk removeClassNamed: #TraitDescription!Smalltalk removeClassNamed: #CodeModelExtension!Smalltalk removeClassNamed: #FixedIdentitySet!Smalltalk removeClassNamed: #LocalSends!Smalltalk removeClassNamed: #LocatedMethod!Smalltalk removeClassNamed: #ModelExtension!Smalltalk removeClassNamed: #ProvidedSelectors!Smalltalk removeClassNamed: #QuickIntegerDictionary!Smalltalk removeClassNamed: #QuickStack!Smalltalk removeClassNamed: #RequiredSelectors!Smalltalk removeClassNamed: #RequiredSelectorsChangesCalculator!Smalltalk removeClassNamed: #RequirementsCache!Smalltalk removeClassNamed: #SendCaches!Smalltalk removeClassNamed: #SendInfo!Smalltalk removeClassNamed: #TraitAlias!Smalltalk removeClassNamed: #TraitComposition!Smalltalk removeClassNamed: #TraitCompositionException!Smalltalk removeClassNamed: #TraitException!Smalltalk removeClassNamed: #TraitExclusion!Smalltalk removeClassNamed: #TraitMethodDescription!Smalltalk removeClassNamed: #TraitTransformation!SystemOrganization removeCategory: 'Traits-Composition'!SystemOrganization removeCategory: 'Traits-Kernel'!SystemOrganization removeCategory: 'Traits-Kernel-Traits'!SystemOrganization removeCategory: 'Traits-LocalSends'!SystemOrganization removeCategory: 'Traits-Requires'!SystemOrganization removeCategory: 'Traits-Tests'!(SystemDictionary organization listAtCategoryNamed: 'class and trait names') do:	[ :sym | SystemDictionary organization classify: sym under: 'class names' ]!Class instVarNames at: 7 put: 'unusedTraitSlot1'!Class instVarNames at: 8 put: 'unusedTraitSlot2'!ClassDescription subclass: #Metaclass	instanceVariableNames: 'thisClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!MCDefinition subclass: #MCClassDefinition	instanceVariableNames: 'name superclassName variables category type comment commentStamp'	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello-Modeling'!
'From Squeak4.3 of 22 December 2011 [latest update: #11860] on 11 September 2014 at 3:18:33 pm'!!AColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/3/2009 13:43'!color: aColor	"Set the gradient colors."		super color: aColor asNontranslucentColor.	self fillStyle: self defaultFillStyle! !!AColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:43'!defaultFillStyle	"Answer the hue gradient."	^(GradientFillStyle colors: {self color alpha: 0. self color})		origin: self topLeft;		direction: (self bounds isWide					ifTrue: [self width@0]					ifFalse: [0@self height])! !!AColorSelectorMorph methodsFor: 'drawing' stamp: 'cmm 12/3/2010 11:28'!drawOn: aCanvas 	"Draw a hatch pattern first."	aCanvas		fillRectangle: self innerBounds		fillStyle: (InfiniteForm with: ColorPresenterMorph hatchForm).	super drawOn: aCanvas! !!AColorSelectorMorph methodsFor: 'visual properties' stamp: 'gvc 9/19/2006 15:46'!fillStyle: fillStyle	"If it is a color then override with gradient."		fillStyle isColor		ifTrue: [self color: fillStyle]		ifFalse: [super fillStyle: fillStyle]! !!AColorSelectorMorph methodsFor: 'initialization' stamp: 'gvc 9/26/2006 11:54'!initialize	"Initialize the receiver."	super initialize.	self		value: 1.0;		color: Color black! !!AColorSelectorMorph commentStamp: 'gvc 5/18/2007 13:52' prior: 0!ColorComponentSelector showing an alpha gradient over a hatched background.!!ADPCMCodec methodsFor: 'bit streaming' stamp: 'nice 3/31/2011 01:24'!nextBits: n	"Answer the next n bits of my bit stream as an unsigned integer."	| result remaining shift |	<inline: true>	result := 0.	remaining := n.		[		shift := remaining - bitPosition.		result := result + (currentByte bitShift: shift).		shift > 0			ifTrue: [  "consumed currentByte buffer; fetch next byte"				remaining := remaining - bitPosition.							currentByte := (encodedBytes at: (byteIndex := byteIndex + 1)).				bitPosition := 8]			ifFalse: [  "still some bits left in currentByte buffer"				bitPosition := bitPosition - remaining.				"mask out the consumed bits:"				currentByte := currentByte bitAnd: (255 bitShift: (bitPosition - 8)).				^ result]] repeat! !!ADPCMCodec methodsFor: 'bit streaming' stamp: 'nice 3/31/2011 01:25'!nextBits: n put: anInteger	"Write the next n bits to my bit stream."	| buf bufBits bitsAvailable shift |	<inline: true>	buf := anInteger.	bufBits := n.	[		bitsAvailable := 8 - bitPosition.		shift := bitsAvailable - bufBits.  "either left or right shift"		"append high bits of buf to end of currentByte:"		currentByte := currentByte + (buf bitShift: shift).		shift < 0			ifTrue: [  "currentByte buffer filled; output it"				encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte.				bitPosition := 0.				currentByte := 0.				"clear saved high bits of buf:"				buf := buf bitAnd: (1 bitShift: 0 - shift) - 1.				bufBits := bufBits - bitsAvailable]			ifFalse: [  "still some bits available in currentByte buffer"				bitPosition := bitPosition + bufBits.				^ self]] repeat! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:01'!indexForDeltaFrom: thisSample to: nextSample	"Answer the best index to use for the difference between the given samples."	"Details: Scan stepSizeTable for the first entry >= the absolute value of the difference between sample values. Since indexes are zero-based, the index used during decoding will be the one in the following stepSizeTable entry. Since the index field of a Flash frame header is only six bits, the maximum index value is 63."	"Note: Since there does not appear to be any documentation of how Flash actually computes the indices used in its frame headers, this algorithm was guessed by reverse-engineering the Flash ADPCM decoder."	| diff bestIndex |	<inline: true>	diff := nextSample - thisSample.	diff < 0 ifTrue: [diff := 0 - diff].	bestIndex := 63.	1 to: 62 do: [:j |		bestIndex = 63 ifTrue: [			(stepSizeTable at: j) >= diff ifTrue: [bestIndex := j]]].	^ bestIndex! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:06'!privateDecodeMono: count	| delta step predictedDelta bit |	<primitive: 'primitiveDecodeMono' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predicted := self nextBits: 16.				predicted > 32767 ifTrue: [predicted := predicted - 65536].				index := self nextBits: 6.				samples at: (sampleIndex := sampleIndex + 1) put: predicted]			ifFalse: [				delta := self nextBits: bitsPerSample.				step := stepSizeTable at: index + 1.				predictedDelta := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(delta bitAnd: bit) > 0 ifTrue: [predictedDelta := predictedDelta + step].					step := step bitShift: -1.					bit := bit bitShift: -1].				predictedDelta := predictedDelta + step.				(delta bitAnd: deltaSignMask) > 0					ifTrue: [predicted := predicted - predictedDelta]					ifFalse: [predicted := predicted + predictedDelta].				predicted > 32767					ifTrue: [predicted := 32767]					ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].				index := index + (indexTable at: (delta bitAnd: deltaValueMask) + 1).				index < 0					ifTrue: [index := 0]					ifFalse: [index > 88 ifTrue: [index := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predicted]].! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:07'!privateDecodeStereo: count	| predictedLeft predictedRight indexLeft indexRight deltaLeft deltaRight	 stepLeft stepRight predictedDeltaLeft predictedDeltaRight bit |	<primitive: 'primitiveDecodeStereo' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	<var: #rightSamples declareC: 'short int *rightSamples'>	<var: #predicted declareC: 'short int *predicted'>	<var: #index declareC: 'short int *index'>	"make local copies of decoder state variables"	predictedLeft := predicted at: 1.	predictedRight := predicted at: 2.	indexLeft := index at: 1.	indexRight := index at: 2.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predictedLeft := self nextBits: 16.				indexLeft := self nextBits: 6.				predictedRight := self nextBits: 16.				indexRight := self nextBits: 6.				predictedLeft > 32767 ifTrue: [predictedLeft := predictedLeft - 65536].				predictedRight > 32767 ifTrue: [predictedRight := predictedRight - 65536].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]			ifFalse: [				deltaLeft := self nextBits: bitsPerSample.				deltaRight := self nextBits: bitsPerSample.				stepLeft := stepSizeTable at: indexLeft + 1.				stepRight := stepSizeTable at: indexRight + 1.				predictedDeltaLeft := predictedDeltaRight := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(deltaLeft bitAnd: bit) > 0 ifTrue: [						predictedDeltaLeft := predictedDeltaLeft + stepLeft].					(deltaRight bitAnd: bit) > 0 ifTrue: [						predictedDeltaRight := predictedDeltaRight + stepRight].					stepLeft := stepLeft bitShift: -1.					stepRight := stepRight bitShift: -1.					bit := bit bitShift: -1].				predictedDeltaLeft := predictedDeltaLeft + stepLeft.				predictedDeltaRight := predictedDeltaRight + stepRight.				(deltaLeft bitAnd: deltaSignMask) > 0					ifTrue: [predictedLeft := predictedLeft - predictedDeltaLeft]					ifFalse: [predictedLeft := predictedLeft + predictedDeltaLeft].				(deltaRight bitAnd: deltaSignMask) > 0					ifTrue: [predictedRight := predictedRight - predictedDeltaRight]					ifFalse: [predictedRight := predictedRight + predictedDeltaRight].				predictedLeft > 32767					ifTrue: [predictedLeft := 32767]					ifFalse: [predictedLeft < -32768 ifTrue: [predictedLeft := -32768]].				predictedRight > 32767					ifTrue: [predictedRight := 32767]					ifFalse: [predictedRight < -32768 ifTrue: [predictedRight := -32768]].				indexLeft := indexLeft + (indexTable at: (deltaLeft bitAnd: deltaValueMask) + 1).				indexLeft < 0					ifTrue: [indexLeft := 0]					ifFalse: [indexLeft > 88 ifTrue: [indexLeft := 88]].				indexRight := indexRight + (indexTable at: (deltaRight bitAnd: deltaValueMask) + 1).				indexRight < 0					ifTrue: [indexRight := 0]					ifFalse: [indexRight > 88 ifTrue: [indexRight := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]].	"save local copies of decoder state variables"	predicted at: 1 put: predictedLeft.	predicted at: 2 put: predictedRight.	index at: 1 put: indexLeft.	index at: 2 put: indexRight.! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:07'!privateEncodeMono: count	| step sign diff delta predictedDelta bit p |	<primitive: 'primitiveEncodeMono' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	step := stepSizeTable at: 1.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1 ifTrue: [			predicted := samples at: (sampleIndex := sampleIndex + 1).			(p := predicted) < 0 ifTrue: [p := p + 65536].			self nextBits: 16 put: p.			i < count ifTrue: [				index := self indexForDeltaFrom: predicted to: (samples at: sampleIndex + 1)].			self nextBits: 6 put: index.		] ifFalse: [			"compute sign and magnitude of difference from the predicted sample"			sign := 0.			diff := (samples at: (sampleIndex := sampleIndex + 1)) - predicted.			diff < 0 ifTrue: [				sign := deltaSignMask.				diff := 0 - diff].			"Compute encoded delta and the difference that this will cause in the predicted sample value during decoding. Note that this code approximates:				delta := (4 * diff) / step.				predictedDelta := ((delta + 0.5) * step) / 4;			but in the shift step bits are dropped. Thus, even if you have fast mul/div hardware you cannot use it since you would get slightly different bits what than the algorithm defines."			delta := 0.			predictedDelta := 0.			bit := deltaValueHighBit.			[bit > 0] whileTrue: [				diff >= step ifTrue: [					delta := delta + bit.					predictedDelta := predictedDelta + step.					diff := diff - step].				step := step bitShift: -1.				bit := bit bitShift: -1].			predictedDelta := predictedDelta + step.			"compute and clamp new prediction"			sign > 0				ifTrue: [predicted := predicted - predictedDelta]				ifFalse: [predicted := predicted + predictedDelta].			predicted > 32767				ifTrue: [predicted := 32767]				ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].			"compute new index and step values"			index := index + (indexTable at: delta + 1).			index < 0				ifTrue: [index := 0]				ifFalse: [index > 88 ifTrue: [index := 88]].			step := stepSizeTable at: index + 1.			"output encoded, signed delta"			self nextBits: bitsPerSample put: (sign bitOr: delta)]].	bitPosition > 0 ifTrue: [  "flush the last output byte, if necessary"		encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte].! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:06'!privateEncodeStereo: count	<primitive: 'primitiveEncodeStereo' module: 'ADPCMCodecPlugin'>	<inline: false>	"not yet implemented"	self success: false.! !!AbstractEvent class methodsFor: 'instance creation' stamp: 'laza 11/2/2011 23:50'!protocol: aProtocol class: aClass	| instance |	instance := self item: aProtocol kind: self protocolKind.	instance itemClass: aClass.	^instance! !!AbstractFont methodsFor: 'measuring' stamp: 'ul 11/15/2010 11:17'!approxWidthOfText: aText"Return the width of aText -- quickly, and a little bit dirty. Used by lists morphs containing Text objects to get a quick, fairly accurate measure of the width of a list item."    | w |        (aText isNil or: [aText size = 0 ])        ifTrue:[^0].           w := self        widthOfString: aText asString.     "If the text has no emphasis, just return the string size.  If it is empasized,     just approximate the width by adding about 20% to the width"       (((aText runLengthFor: 1) = aText size)        and: [(aText emphasisAt: 1) = 0 ])            ifTrue:[^w]            ifFalse:[ ^w * 6 // 5 ]. ! !!AbstractFont class methodsFor: 'utilities' stamp: 'nice 3/10/2011 00:30'!emphasisStringFor: emphasisCode	"Answer a translated string that represents the attributes given in emphasisCode."	| emphases |	emphasisCode = 0 ifTrue: [ ^'Normal' translated ].	emphases := #('Bold' 'Italic' 'Underlined' 'Narrow' 'StruckOut').	^String streamContents: [ :s |		1 to: emphases size do: [ :i |			(emphasisCode bitAt: i) isZero ifFalse: [ s nextPutAll: (emphases at: i) translated; space ] ].		s position isZero ifFalse: [ s skip: -1 ] ]! !!AbstractLauncher methodsFor: 'private' stamp: 'ul 8/2/2011 19:51'!parameterAt: parName ifAbsent: aBlock	"Return the parameter named parName.	Evaluate the block if parameter does not exist."	^self parameters		at: parName asUppercase		ifAbsent: aBlock! !!AbstractSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:10'!postCopy	"A sound should copy all of the state needed to play itself, allowing two copies of a sound to play at the same time. These semantics require a recursive copy but only down to the level of immutable data. For example, a SampledSound need not copy its sample buffer. Subclasses overriding this method should include a resend to super."	super postCopy.	self copyEnvelopes! !!AbstractSound methodsFor: 'file i/o' stamp: 'ul 6/17/2011 12:32'!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."	| bufSize stereoBuffer reverseBytes |	self reset.	bufSize := (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"	stereoBuffer := SoundBuffer newStereoSampleCount: bufSize.	reverseBytes := bigEndianFlag ~= (SmalltalkImage current isBigEndian).	'Storing audio...'		displayProgressFrom: 0 to: samplesToStore during: [:bar | | remaining out |			remaining := samplesToStore.			[remaining > 0] whileTrue: [				bar value: samplesToStore - remaining.				stereoBuffer primFill: 0.  "clear the buffer"				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.				out := self isStereo						ifTrue: [stereoBuffer]						ifFalse: [stereoBuffer extractLeftChannel].				reverseBytes ifTrue: [out reverseEndianness].				(aBinaryStream isKindOf: StandardFileStream)					ifTrue: [  "optimization for files: write sound buffer directly to file"						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"					ifFalse: [  "for non-file streams:"						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].				remaining := remaining - bufSize]].! !!AbstractSound methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 09:33'!initialize	super initialize.	envelopes := #().	mSecsSinceStart := 0.	samplesUntilNextControl := 0.	scaledVol := (1.0 * ScaleFactor) rounded.	scaledVolIncr := 0.	scaledVolLimit := scaledVol.! !!AcornFileDirectory methodsFor: 'private' stamp: 'nice 5/8/2011 10:07'!directoryContentsFor: fullPath 	"Return a collection of directory entries for the files and directories in 	the directory with the given path. See primLookupEntryIn:index: for 	further details."	"FileDirectory default directoryContentsFor: ''"	| entries extraPath |	entries := super directoryContentsFor: fullPath.	fullPath isNullPath		ifTrue: [			"For Acorn we also make sure that at least the parent of the current dir 			is added - sometimes this is in a filing system that has not been (or 			cannot be) polled for disc root names"			extraPath := self class default containingDirectory.			"Only add the extra path if we haven't already got the root of the current dir in the list"			(entries anySatisfy: [:ent | extraPath fullName beginsWith: ent name]) 				ifFalse: [entries := entries								copyWith: (DirectoryEntryDirectory										directory: self										name: extraPath fullName										creationTime: 0										modificationTime: 0										fileSize: 0)]].	^ entries! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'eem 12/15/2011 15:07'!currentDirectoryNickname	"Answer the nick-name for the current directory (e.g. '.' on Unix and Windows).	 Who knows what this is on Acorn?"	^nil! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'eem 12/15/2011 15:07'!parentDirectoryNickname	"Answer the nick-name for the parent directory (e.g. '..' on Unix and Windows).	 Who knows what this is on Acorn?"	^nil! !!ActionSequence methodsFor: 'evaluating' stamp: 'nice 9/21/2010 09:32'!value	"Evaluate the elements of the receiver and answer the result of last evaluation."	^self inject: nil into:		[:previousAnswer :each | each value]! !!ActionSequence methodsFor: 'evaluating' stamp: 'nice 9/21/2010 09:33'!valueWithArguments: anArray	"Evaluate the elements of the receiver with provided arguments and answer the result of last evaluation."	^self inject: nil into:		[:previousAnswer :each | each valueWithArguments: anArray]! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 9/16/2011 11:26'!copyWith: aPropertyOrPragma "<Association|Pragma>"	"Answer a copy of the receiver which includes aPropertyOrPragma"	| bs copy |	(Association == aPropertyOrPragma class	 or: [Pragma == aPropertyOrPragma class]) ifFalse:		[self error: self class name, ' instances should hold only Associations or Pragmas.'].	"no need to initialize here; we're copying all inst vars"	copy := self class basicNew: (bs := self basicSize) + 1.	1 to: bs do:		[:i|		copy basicAt: i put: (self basicAt: i) shallowCopy].	copy basicAt: bs + 1 put: aPropertyOrPragma.	1 to: self class instSize do:		[:i| copy instVarAt: i put: (self instVarAt: i)].	^copy! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 9/16/2011 11:27'!copyWithout: aPropertyOrPragma "<Association|Pragma>"	"Answer a copy of the receiver which no longer includes aPropertyOrPragma"	| bs copy offset |	"no need to initialize here; we're copying all inst vars"	copy := self class basicNew: (bs := self basicSize) - ((self includes: aPropertyOrPragma)															ifTrue: [1]															ifFalse: [0]).	offset := 0.	1 to: bs do:		[:i|		(self basicAt: i) = aPropertyOrPragma			ifTrue: [offset := 1]			ifFalse: [copy basicAt: i - offset put: (self basicAt: i) shallowCopy]].	1 to: self class instSize do:		[:i| copy instVarAt: i put: (self instVarAt: i)].	^copy! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 9/14/2011 17:50'!postCopy	"After copying we must duplicate any associations and pragmas so they don't end up being shared."	1 to: self basicSize do:		[:i| self basicAt: i put: (self basicAt: i) shallowCopy]! !!AdditionalMethodState methodsFor: 'printing' stamp: 'eem 9/14/2011 17:18'!printOn: aStream	super printOn: aStream.	aStream space; nextPut: $(; print: self identityHash; nextPut: $)! !!AdditionalMethodState class methodsFor: 'instance creation' stamp: 'eem 9/16/2011 11:25'!forMethod: aMethod selector: aSelector	^(self new: 0)		selector: aSelector;		setMethod: aMethod;		yourself! !!AdditionalMethodState class methodsFor: 'instance creation' stamp: 'eem 9/16/2011 11:26'!selector: aSelector with: aPropertyOrPragma	^(self new: 1)		selector: aSelector;		basicAt: 1 put: aPropertyOrPragma;		yourself! !!AdvancedHelpBrowserDummy methodsFor: 'initialize-release' stamp: 'tbn 5/3/2010 19:34'!initialize	isOpen := false! !!AdvancedHelpBrowserDummy methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:32'!isOpen	^isOpen! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:32'!open	isOpen := true! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:33'!rootTopic	^rootTopic! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:33'!rootTopic: aTopic	rootTopic := aTopic! !!AdvancedHelpBrowserDummy commentStamp: 'tbn 5/3/2010 19:30' prior: 0!This is a dummy for a custom Help browser that can be registered as a replacement for the HelpBrowser class.Instance Variables	rootTopic:		<HelpTopic>rootTopic	- The root help topic!!AlignmentMorph methodsFor: '*Etoys-initialization' stamp: 'nice 12/29/2010 14:38'!addUpDownArrowsFor: aMorph	"Add a column of up and down arrows that serve to send upArrowHit and downArrowHit to aMorph when they're pressed/held down"	| holder downArrow upArrow |	holder := Morph new extent: 16 @ 16; beTransparent.	downArrow := ImageMorph new image: (ScriptingSystem formAtKey: 'DownArrow').	upArrow := ImageMorph new image: (ScriptingSystem formAtKey: 'UpArrow').	upArrow position: holder bounds topLeft + (2 @ 2).	downArrow align: downArrow bottomLeft				with: holder topLeft + (0 @ TileMorph defaultH) + (2 @ -2).	holder addMorph: upArrow.	holder addMorph: downArrow.	self addMorphBack: holder.	upArrow on: #mouseDown send: #upArrowHit to: aMorph.	upArrow on: #mouseStillDown send: #upArrowHit to: aMorph.	downArrow on: #mouseDown send: #downArrowHit to: aMorph.	downArrow on: #mouseStillDown send: #downArrowHit to: aMorph.! !!Archive methodsFor: 'archive operations' stamp: 'ul 8/2/2011 19:51'!addTree: aFileNameOrDirectory removingFirstCharacters: n match: aBlock	| dir fullPath relativePath |	dir := (aFileNameOrDirectory isString)		ifTrue: [ FileDirectory on: aFileNameOrDirectory ]		ifFalse: [ aFileNameOrDirectory ].	fullPath := dir pathName, dir slash.	relativePath := fullPath copyFrom: n + 1 to: fullPath size.	(dir entries select: aBlock)		do: [ :ea | | fullName newMember |		fullName := fullPath, ea name.		newMember := ea isDirectory				ifTrue: [ self memberClass newFromDirectory: fullName ]				ifFalse: [ self memberClass newFromFile: fullName ].		newMember localFileName: relativePath, ea name.		self addMember: newMember.		ea isDirectory ifTrue: [ self addTree: fullName removingFirstCharacters: n match: aBlock].	].! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'ar 9/2/2010 08:50'!commentArchive	| newName |	archive ifNil: [ ^self ].	newName := UIManager default			request: 'New comment for archive:'			initialAnswer: archive zipFileComment.	archive zipFileComment: newName.! !!ArchiveViewer methodsFor: 'member operations' stamp: 'ar 9/2/2010 08:49'!addMemberFromClipboard	| string newName |	self canAddMember ifFalse: [ ^self ].	string := Clipboard clipboardText asString.	newName := UIManager default		request: 'New name for member:'		initialAnswer: 'clipboardText'.	newName notEmpty ifTrue: [		(archive addString: string as: newName) desiredCompressionMethod: ZipArchive compressionDeflated.		self memberIndex: self members size.		self changed: #memberList.	]! !!ArchiveViewer methodsFor: 'member operations' stamp: 'ar 9/2/2010 08:50'!commentMember	| newName |	newName := UIManager default			request: 'New comment for member:'			initialAnswer: self selectedMember fileComment.	self selectedMember fileComment: newName.! !!ArchiveViewer methodsFor: 'member operations' stamp: 'ar 9/2/2010 08:50'!renameMember	| newName |	self canRenameMember ifFalse: [ ^self ].	newName := UIManager default		request: 'New name for member:'		initialAnswer: self selectedMember fileName.	newName notEmpty ifTrue: [		self selectedMember fileName: newName.		self changed: #memberList	]! !!Array methodsFor: 'filter streaming' stamp: 'ul 11/23/2010 13:28'!storeOnStream:aStream		self shouldBePrintedAsLiteral 		ifTrue: [ super storeOnStream:aStream ]		ifFalse:[ aStream writeCollection:self ]! !!Array methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28'!printOn: aStream	self shouldBePrintedAsLiteral ifTrue: [^self printAsLiteralFormOn: aStream].	self class = Array ifTrue: [^self printAsBraceFormOn: aStream].	^super printOn: aStream! !!Array methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28'!storeOn: aStream 	"Use the literal form if possible."	self shouldBePrintedAsLiteral		ifTrue: 			[aStream nextPut: $#; nextPut: $(.			self do: 				[:element | 				element storeOn: aStream.				aStream space].			aStream nextPut: $)]		ifFalse: [super storeOn: aStream]! !!Array methodsFor: 'testing' stamp: 'eem 11/2/2011 11:02'!shouldBePrintedAsLiteral	^self class == Array	  and: [self shouldBePrintedAsLiteralVisiting: (IdentitySet new: 8)]! !!Array methodsFor: 'testing' stamp: 'eem 11/2/2011 11:01'!shouldBePrintedAsLiteralVisiting: aSet	self class == Array ifFalse:		[^false].	(aSet includes: self) ifTrue:		[^false].	aSet add: self.	^self allSatisfy: [:each | each shouldBePrintedAsLiteralVisiting: aSet]! !!Array methodsFor: 'private' stamp: 'nice 7/20/2011 09:03'!hasLiteral: literal	"Answer true if literal is identical to any literal in this array, even 	if imbedded in further array structure. This method is only intended 	for private use by CompiledMethod hasLiteralSymbol:"	| lit |	1 to: self size do: 		[:index | 		((lit := self at: index) literalEqual: literal) ifTrue: [^true].		(Array == lit class and: [lit hasLiteral: literal]) ifTrue: [^true]].	^false! !!ArrayedCollection methodsFor: 'sorting' stamp: 'ul 11/13/2011 05:13'!quickSortFrom: from to: to by: sortBlock	"Sort elements i through j of self to be nondescending according to sortBlock using an in-place quicksort with simple median-of-three partitioning with guaranteed O(log(n)) space usage."	| dij k l temp i j di dj n ij |	i := from.	j := to.	[				"The prefix d means the data at that index."		"Sort di,dj."		di := self at: i.		dj := self at: j.		(sortBlock ifNil: [ di <= dj ] ifNotNil: [ sortBlock value: di value: dj ]) ifFalse: [			self at: i put: dj; at: j put: di. temp := dj. dj := di. di := temp "swap di with dj" ].		(n := j + 1 - i) <= 2 ifTrue: [ ^self ].		"More than two elements."		dij := self at: (ij := i + j // 2). "ij is the midpoint of i and j. Sort di,dij,dj. Make dij be their median."		(sortBlock ifNil: [ di <= dij ] ifNotNil: [ sortBlock value: di value: dij ])			ifTrue: [				(sortBlock ifNil: [ dij <= dj ] ifNotNil: [ sortBlock value: dij value: dj ]) ifFalse: [					 "swap dij with dj, we don't need the value of the variable dj anymore"					self at: j put: dij; at: ij put: dj. dij := dj ] ]			ifFalse: [				 "swap di with dij, we don't need the value of the variable di anymore"				self at: i put: dij; at: ij put: di. dij := di ].		n = 3 ifTrue: [ ^self ].		"More than three elements."		"Find k and l such that i<k<l<j and dk,dij,dl are in reverse order. Swap k and l. Repeat this procedure until k and l pass each other."		k := i.		l := j.		[			[ k <= (l := l - 1) and: [ 				sortBlock ifNil: [ dij <= (self at: l) ] ifNotNil: [ sortBlock value: dij value: (self at: l) ] ] ] whileTrue.  "i.e. while dl succeeds dij"			[ (k := k + 1) <= l and: [				sortBlock ifNil: [ (self at: k) <= dij ] ifNotNil: [ sortBlock value: (self at: k) value: dij ] ] ] whileTrue.  "i.e. while dij succeeds dk"			k <= l ] whileTrue: [ temp := self at: k. self at: k put: (self at: l); at: l put: temp. ].		"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk through dj. Sort the larger segment in this method and call another quicksort for the smaller segment. This ensures O(log(n)) space usage."		i < l 			ifFalse: [				k < j					ifFalse: [ ^self ]					ifTrue: [ i := k ] ]			ifTrue: [				k < j					ifFalse: [ j := l ]					ifTrue: [						l - i <  (j - k)							ifTrue: [ 								self quickSortFrom: i to: l by: sortBlock.								i := k ]							ifFalse: [								self quickSortFrom: k to: j by: sortBlock.								j := l ] ] ] ] repeat! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27'!emitCodeForEffect: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStorePop: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27'!emitCodeForValue: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStore: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16'!sizeCodeForEffect: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStorePop: encoder)! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16'!sizeCodeForValue: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStore: encoder)! !!AssignmentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitAssignmentNode: self! !!Association methodsFor: 'testing' stamp: 'nice 7/20/2011 09:00'!literalEqual: otherLiteral	"Answer true if the receiver and otherLiteral represent the same literal.	Variable bindings are literally equals only if identical.	This is how variable sharing works, by preserving identity and changing only the value."	^self == otherLiteral! !!AttributedTextStream methodsFor: 'accessing' stamp: 'nice 12/9/2009 08:26'!contents	| ans |	currentRun > 0 ifTrue:[		attributeValues nextPut: currentAttributes.		attributeRuns nextPut: currentRun.		currentRun := 0].	ans := Text string: characters contents  runs: 		(RunArray runs: attributeRuns contents values: attributeValues contents).	^ans! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ls 6/27/1998 15:09'!currentAttributes	"return the current attributes"	^currentAttributes! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ar 10/16/2001 22:57'!currentAttributes: newAttributes	"set the current attributes"	(currentRun > 0 and:[currentAttributes ~= newAttributes]) ifTrue:[		attributeRuns nextPut: currentRun.		attributeValues nextPut: currentAttributes.		currentRun := 0.	].	currentAttributes := newAttributes.! !!AttributedTextStream methodsFor: 'accessing' stamp: 'nice 3/19/2010 19:03'!nextPut: aChar	currentRun := currentRun + 1.	^characters nextPut: aChar! !!AttributedTextStream methodsFor: 'accessing' stamp: 'nice 3/19/2010 19:12'!nextPutAll: aString	"add an entire string with the same attributes"	currentRun := currentRun + aString size.	^characters nextPutAll: aString.! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ls 9/10/1998 03:36'!size	"number of characters in the stream so far"	^characters size! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ul 11/2/2010 21:57'!withAttribute: attribute do: aBlock	^self withAttributes: { attribute } do: aBlock! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ul 11/2/2010 06:42'!withAttributes: attributes do: aBlock	| previousAttributes |	previousAttributes := currentAttributes.	[		self currentAttributes: attributes.		aBlock value ]			ensure: [ self currentAttributes: previousAttributes ]! !!AttributedTextStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:51'!cr	"Append a carriage return character to the receiver."	self nextPut: Character cr! !!AttributedTextStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:51'!crlf	"Append a carriage return and a line feed to the receiver."	self nextPut: Character cr; nextPut: Character lf! !!AttributedTextStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:45'!lf	"Append a line feed character to the receiver."	self nextPut: Character lf! !!AttributedTextStream methodsFor: 'initialize-release' stamp: 'ul 11/2/2010 21:57'!initialize	characters := String new writeStream.	currentAttributes := #().	currentRun := 0.	attributeValues := (Array new: 50) writeStream.	attributeRuns := (Array new: 50) writeStream! !!BDFFontReader methodsFor: 'initialize' stamp: 'ul 11/3/2010 06:21'!openFileNamed: fileName	file := MultiByteFileStream readOnlyFileNamed: fileName.	file wantsLineEndConversion: true! !!BDFFontReader methodsFor: 'reading' stamp: 'nice 6/11/2010 21:32'!getLine	^file nextLine! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35'!read	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width blt lastAscii pointSize ret stream |	form := encoding := bbx := nil.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth := 0.	minAscii := 9999.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	1 to: charsNum do: [:i |		array := self readOneCharacter.		stream := ReadStream on: array.		form := stream next.		encoding := stream next.		bbx := stream next.		form ifNotNil: [			width := bbx at: 1.			maxWidth := maxWidth max: width.			minAscii := minAscii min: encoding.			maxAscii := maxAscii max: encoding.			strikeWidth := strikeWidth + width.			chars add: array.		].	].	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"	charsNum > 256 ifTrue: [		"it should be 94x94 charset, and should be fixed width font"		strikeWidth := 94*94*maxWidth.		maxAscii := 94*94.		minAscii := 0.		xTable := XTableForFixedFont new.		xTable maxAscii: 94*94.		xTable width: maxWidth.	] ifFalse: [		xTable := (Array new: 258) atAllPut: 0.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	lastAscii := 0.		charsNum > 256 ifTrue: [		1 to: charsNum do: [:i |			stream := ReadStream on: (chars at: i).			form := stream next.			encoding := stream next.			bbx := stream next.			encoding := ((encoding // 256) - 33) * 94 + ((encoding \\ 256) - 33).			blt copy: ((encoding * maxWidth)@0 extent: maxWidth@height)				from: 0@0 in: form.		].	] ifFalse: [		1 to: charsNum do: [:i |			stream := ReadStream on: (chars at: i).			form := stream next.			encoding := stream next.			bbx := stream next.			lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].			blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))					extent: (bbx at: 1)@(bbx at: 2))				from: 0@0 in: form.			xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).			lastAscii := encoding.		]	].	ret := Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35'!readChars	| strikeWidth ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width pointSize stream |	form := encoding := bbx := nil.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth := 0.	minAscii := 9999.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	1 to: charsNum do: [:i |		array := self readOneCharacter.		stream := ReadStream on: array.		form := stream next.		encoding := stream next.		bbx := stream next.		form ifNotNil: [			width := bbx at: 1.			maxWidth := maxWidth max: width.			minAscii := minAscii min: encoding.			maxAscii := maxAscii max: encoding.			strikeWidth := strikeWidth + width.			chars add: array.		].	].	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	^ chars.! !!BDFFontReader class methodsFor: 'resource download' stamp: 'ul 11/3/2010 06:35'!downloadFonts  "BDFFontReader downloadFonts"	"Download a standard set of BDF sources from x.org.  	The combined size of these source files is around 1.2M; after conversion 	to .sf2 format they may be deleted."	| heads tails filenames baseUrl basePath |	heads := #( 'charR' 'courR' 'helvR' 'lubR' 'luRS' 'lutRS' 'ncenR' 'timR' ).	tails := #( '08' '10' '12' '14' '18' '24').	filenames := OrderedCollection new.	heads do: [:head |		filenames addAll: (tails collect: [:tail | head , tail , '.bdf'])	].	baseUrl := 'http://cvsweb.xfree86.org/cvsweb/*checkout*/xc/fonts/bdf/75dpi/' asUrl.	basePath := baseUrl path.	filenames do: [:filename |		| document newPath newUrl |		newUrl := baseUrl clone.		newPath := OrderedCollection newFrom: basePath.		newPath addLast: filename.		newUrl path: newPath.		Utilities informUser: 'Fetching ' , filename during: 			[document := newUrl retrieveContents].		MultiByteFileStream newFileNamed: filename do: [ :f |			f 				wantsLineEndConversion: true;				nextPutAll: document content ]	].! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 12/21/2010 20:11'!read24BmpLine: pixelLine into: formBits startingAt: formBitsIndex width: width	"Swizzles the bytes in a 24bpp scanline and fills in the given 32bpp form bits.	Ensures that color black is represented as 16rFF000001 so that Form paint	works properly."	| pixIndex rgb bitsIndex |	<primitive: 'primitiveRead24BmpLine' module:'BMPReadWriterPlugin'>	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := 			(pixelLine at: (pixIndex := pixIndex+1)) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 8) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 16).		rgb = 0 ifTrue:[rgb := 16rFF000001] ifFalse:[rgb := rgb + 16rFF000000].		formBits at: (bitsIndex := bitsIndex+1) put: rgb.	].! !!BMPReadWriter methodsFor: 'writing' stamp: 'ar 12/21/2010 20:03'!nextPutImage: aForm	| bhSize rowBytes rgb data colorValues depth image ppw scanLineLen pixline |	depth := aForm depth.	depth := #(1 4 8 32 ) detect: [ :each | each >= depth].	image := aForm asFormOfDepth: depth.	image unhibernate.	bhSize := 14.  "# bytes in file header"	biSize := 40.  "info header size in bytes"	biWidth := image width.	biHeight := image height.	biClrUsed := depth = 32 ifTrue: [0] ifFalse:[1 << depth].  "No. color table entries"	bfOffBits := biSize + bhSize + (4*biClrUsed).	rowBytes := ((depth min: 24) * biWidth + 31 // 32) * 4.	biSizeImage := biHeight * rowBytes.	"Write the file header"	stream position: 0.	stream nextLittleEndianNumber: 2 put: 19778.  "bfType = BM"	stream nextLittleEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"	stream nextLittleEndianNumber: 4 put: 0.  "bfReserved"	stream nextLittleEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"	"Write the bitmap info header"	stream position: bhSize.	stream nextLittleEndianNumber: 4 put: biSize.  "info header size in bytes"	stream nextLittleEndianNumber: 4 put: image width.  "biWidth"	stream nextLittleEndianNumber: 4 put: image height.  "biHeight"	stream nextLittleEndianNumber: 2 put: 1.  "biPlanes"	stream nextLittleEndianNumber: 2 put: (depth min: 24).  "biBitCount"	stream nextLittleEndianNumber: 4 put: 0.  "biCompression"	stream nextLittleEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"	stream nextLittleEndianNumber: 4 put: 2800.  "biXPelsPerMeter"	stream nextLittleEndianNumber: 4 put: 2800.  "biYPelsPerMeter"	stream nextLittleEndianNumber: 4 put: biClrUsed.	stream nextLittleEndianNumber: 4 put: 0.  "biClrImportant"	biClrUsed > 0 ifTrue: [		"write color map; this works for ColorForms, too"		colorValues := image colormapIfNeededForDepth: 32.		1 to: biClrUsed do: [:i |			rgb := colorValues at: i.			0 to: 24 by: 8 do: [:j | stream nextPut: (rgb >> j bitAnd: 16rFF)]]].	depth < 32 ifTrue: [		"depth = 1, 4 or 8."		data := image bits asByteArray.		ppw := 32 // depth.		scanLineLen := biWidth + ppw - 1 // ppw * 4.  "# of bytes in line"		1 to: biHeight do: [:i |			stream next: scanLineLen putAll: data startingAt: (biHeight-i)*scanLineLen+1.		].	] ifFalse: [		data := image bits.		pixline := ByteArray new: (((biWidth * 3 + 3) // 4) * 4).		1 to: biHeight do:[:i |			self store24BitBmpLine: pixline from: data startingAt: (biHeight-i)*biWidth+1 width: biWidth.			stream nextPutAll: pixline.		].	].	stream position = (bfOffBits + biSizeImage) ifFalse: [self error:'Write failure'].	stream close.! !!BMPReadWriter methodsFor: 'writing' stamp: 'ar 12/21/2010 20:12'!store24BitBmpLine: pixelLine from: formBits startingAt: formBitsIndex width: width	"Stores a single scanline containing 32bpp RGBA values in a 24bpp scanline.	Swizzles the bytes as needed."	| pixIndex rgb bitsIndex |	<primitive: 'primitiveWrite24BmpLine' module:'BMPReadWriterPlugin'>	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := (formBits at: (bitsIndex := bitsIndex+1)) bitAnd: 16rFFFFFF.		pixelLine at: (pixIndex := pixIndex+1) put: (rgb bitAnd: 255).		pixelLine at: (pixIndex := pixIndex+1) put: ((rgb bitShift: -8) bitAnd: 255).		pixelLine at: (pixIndex := pixIndex+1) put: ((rgb bitShift: -16) bitAnd: 255).	].! !!BMPReadWriterTest methodsFor: 'reading' stamp: 'ar 12/21/2010 19:50'!testBmp24Bit	| reader form |	reader := BMPReadWriter new on: (ReadStream on: self bmpData24bit).	form := reader nextImage.	self assert: (form colorAt: 7@1) = Color red.	self assert: (form colorAt: 1@7) = Color green.	self assert: (form colorAt: 7@7) = Color blue.	self assert: (form colorAt: 4@4) = Color white.	self assert: (form pixelValueAt: 1@1) = 16rFF000001.! !!Bag methodsFor: 'math functions' stamp: 'ul 11/7/2010 01:46'!sum	"Faster than the superclass implementation when you hold many instances of the same value (which you probably do, otherwise you wouldn't be using a Bag)."		| sum first |	first := true.	contents keysAndValuesDo: [ :value :count |		first 			ifTrue: [ sum := value * count. first := false ]			ifFalse: [ sum := sum + (value * count) ] ].	first ifTrue: [ self errorEmptyCollection ].	^sum! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ul 11/15/2010 11:17'!line: pt1 to: pt2 width: w color: c	"Draw a line from pt1 to: pt2"	(aaLevel = 1 and: [self ifNoTransformWithIn:(pt1 rect: pt2)])		ifTrue:[^super line: pt1 to: pt2 width: w color: c].	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!BalloonCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/8/2003 19:03'!fillRoundRect: aRectangle radius: radius fillStyle: fillStyle	| points |	radius asPoint <= (0@0) 		ifTrue:[^self fillRectangle: aRectangle fillStyle: fillStyle].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self fillOval: aRectangle fillStyle: fillStyle].	"decompose aRectangle into bezier form"	points := self makeRoundRectShape: aRectangle radius: radius.	"blast the bezier shape out"	self		drawBezierShape: points		color: fillStyle		borderWidth: 0		borderColor: nil.! !!BalloonCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/8/2003 19:03'!frameRoundRect: aRectangle radius: radius width: borderWidth color: borderColor	| outerPoints innerRect innerRadius innerPoints |	(borderWidth isZero or:[borderColor isTransparent])		ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self frameRectangle: aRectangle width: borderWidth color: borderColor].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self frameOval: aRectangle width: borderWidth color: borderColor].	"decompose inner rectangle into bezier shape"	innerRect := aRectangle insetBy: borderWidth.	innerRect area <= 0 		ifTrue:[^self fillRoundRect: aRectangle radius: radius fillStyle: borderColor].	innerRadius := (radius - borderWidth) asPoint.	innerPoints := self makeRoundRectShape: innerRect radius: innerRadius.	"decompose outer rectangle into bezier shape"	outerPoints := self makeRoundRectShape: aRectangle radius: radius.	self		drawGeneralBezierShape: (Array with: outerPoints with: innerPoints)		color: borderColor		borderWidth: 0		borderColor: nil.! !!BalloonCanvas methodsFor: 'private' stamp: 'nice 12/29/2010 16:10'!makeRoundRectShape: aRectangle radius: radius	"decompose a rounded rectangle into bezier form"	| ovalDiameter rectExtent segments points endPoint seg idx offset rectOffset |	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or: [ovalDiameter y <= 0]) ifTrue: [		"degenerates into rectangle - just hand back four lines"		| topLeft topRight bottomLeft bottomRight |		topLeft := aRectangle topLeft.		topRight := aRectangle topRight.		bottomLeft := aRectangle bottomLeft.		bottomRight := aRectangle bottomRight.		points := Array new: 4 * 3.		points at: 1 put: topLeft.		points at: 2 put: topLeft.		points at: 3 put: topRight.		points at: 4 put: topRight.		points at: 5 put: topRight.		points at: 6 put: bottomRight.		points at: 7 put: bottomRight.		points at: 8 put: bottomRight.		points at: 9 put: bottomLeft.		points at: 10 put: bottomLeft.		points at: 11 put: bottomLeft.		points at: 12 put: topLeft.		^points	].	rectExtent := aRectangle extent - ovalDiameter.	rectOffset := aRectangle origin.	segments := Bezier2Segment makeEllipseSegments: (0 @ 0 extent: ovalDiameter).	"patch up the segments to include lines connecting the oval parts.	we need: 8*3 points for the oval parts + 4*3 points for the connecting lines"	points := Array new: 12 * 3.	idx := 0.	"Tweaked offsets to clean up curves. MAD"	endPoint := segments last end + rectOffset + (0 @ -1).	1 to: 8 by: 2 do: [:i |		i = 1 ifTrue: [offset := rectOffset + (rectExtent x @ 0) + (1 @ -1)]. "top, tr"		i = 3 ifTrue: [offset := rectOffset + rectExtent + (1 @ 1)]. "right, br"		i = 5 ifTrue: [offset := rectOffset + (0 @ rectExtent y) + (0 @ 1)]. "bottom, bl"		i = 7 ifTrue: [offset := rectOffset + (0 @ -1)]."left, tl"		seg := segments at: i.		"insert a line segment for the horizontal part of the round rect"		points at: (idx := idx + 1) put: endPoint.		points at: (idx := idx + 1) put: endPoint.		points at: (idx := idx + 1) put: seg start + offset.		"now the first half-arc"		points at: (idx := idx + 1) put: seg start + offset.		points at: (idx := idx + 1) put: seg via + offset.		points at: (idx := idx + 1) put: seg end + offset.		"the second half-arc"		seg := segments at: i + 1.		points at: (idx := idx + 1) put: seg start + offset.		points at: (idx := idx + 1) put: seg via + offset.		points at: (idx := idx + 1) put: seg end + offset.		endPoint := seg end + offset.	].	^points! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'ul 6/17/2011 12:36'!nextValue	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"	| raw num |	[raw := mimeStream next.	raw ifNil: [^ nil].	"end of stream"	raw == $= ifTrue: [^ nil].	num := FromCharTable at: raw asciiValue + 1.	num ifNotNil: [^ num].	"else ignore space, return, tab, ..."	] repeat! !!BaseSoundSystem methodsFor: 'playing' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!beep	"There is sound support, so we use the default	sampled sound for a beep."	SoundService soundEnabled ifTrue: [		SampledSound beep]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!playSampledSound: samples rate: rate	SoundService soundEnabled ifTrue: [		(SampledSound samples: samples samplingRate: rate) play]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!playSoundNamed: soundName	"There is sound support, so we play the given sound."	SoundService soundEnabled ifTrue: [		SampledSound playSoundNamed: soundName asString]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!playSoundNamed: soundName ifAbsentReadFrom: aifFileName	SoundService soundEnabled ifTrue: [		(SampledSound soundNames includes: soundName) ifFalse: [			(FileDirectory default fileExists: aifFileName) ifTrue: [				SampledSound					addLibrarySoundNamed: soundName					fromAIFFfileNamed: aifFileName]].		(SampledSound soundNames includes: soundName) ifTrue: [			SampledSound playSoundNamed: soundName]]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!playSoundNamedOrBeep: soundName	"There is sound support, so we play the given sound	instead of beeping."	SoundService soundEnabled ifTrue: [		^self playSoundNamed: soundName]! !!BasicTypeTest methodsFor: 'tests' stamp: 'ar 7/21/2010 19:47'!testBasicType		self assert: (true basicType = #Boolean).	self assert: (false basicType = #Boolean).! !!Beeper class methodsFor: 'beeping' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!beepPrimitive	"Make a primitive beep. Only use this if	you want to force this to be a primitive beep.	Otherwise use Beeper class>>beep	since this method bypasses the current	registered playable entity."	SoundService soundEnabled ifTrue: [		self primitiveBeep]! !!Beeper class methodsFor: 'customize' stamp: 'nice 8/27/2010 16:32'!default	"When the default is not defined it is	initialized using #newDefault."	^ default ifNil: [ default := self newDefault ]! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'ul 4/30/2011 01:52'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 	"Walk the tree of subclasses, giving the class and its level"	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	self subclasses		sort: [ :a :b | a name <= b name ];		do: [ :subclass | 			subclass				allSubclassesWithLevelDo: classAndLevelBlock				startingLevel: level + 1 ]! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'ul 11/15/2010 10:09'!inspectAllInstances 	"Inpsect all instances of the receiver.  1/26/96 sw"	| all allSize prefix |	all := self allInstances.	(allSize := all size) = 0 ifTrue: [^ self inform: 'There are no instances of ', self name].	prefix := allSize = 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name)! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'ul 11/15/2010 10:10'!inspectSubInstances 	"Inspect all instances of the receiver and all its subclasses.  CAUTION - don't do this for something as generic as Object!!  1/26/96 sw"	| all allSize prefix |	all := self allSubInstances.	(allSize := all size) = 0 ifTrue: [^ self inform: 'There are no instances of ', self name, 'or any of its subclasses'].	prefix := allSize = 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name, ' & its subclasses')! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'ul 4/27/2011 00:43'!instVarIndexFor: instVarName ifAbsent: aBlock	"Answer the index of the named instance variable."		^self allInstVarNames indexOf: instVarName ifAbsent: aBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 4/30/2011 03:42'!commentsIn: sourceString	"Return the comments as a collection of strings in sourceString. This method along with #nextQuotePosIn:startingFrom: is wrong, because it assumes that all double quote characters are comment delimiters, but even this method has a double quote which is not part of any method comment. Also this method has nothing to do with the Behavior itself. Probably CompiledMethod is the best place for this."		| commentStart nextQuotePos someComments aPos |	(sourceString includes: $") ifFalse: [^#()].	someComments:= OrderedCollection new.	aPos:=1.	nextQuotePos:= 0.	[commentStart := sourceString findString: '"' startingAt: aPos.	nextQuotePos:= self nextQuotePosIn: sourceString startingFrom: commentStart.	(commentStart ~= 0 and: [nextQuotePos >commentStart])] whileTrue: [		commentStart ~= nextQuotePos ifTrue: [			someComments add: ((sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"').].	aPos := nextQuotePos+1].	^someComments! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 8/2/2011 19:52'!compiledMethodAt: selector ifAbsent: aBlock	"Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock"	^ self methodDict at: selector ifAbsent: aBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 4/28/2010 12:29'!compress	"Compact the method dictionary of the receiver."	self methodDict compact! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'nice 2/23/2011 21:37'!compressedSourceCodeAt: selector	"(Paragraph compressedSourceCodeAt: #displayLines:affectedRectangle:) size 721 1921	Paragraph selectors inject: 0 into: [:tot :sel | tot + (Paragraph compressedSourceCodeAt: sel) size] 13606 31450"	| rawText parse |	rawText := (self sourceCodeAt: selector) asString.	parse := self newCompiler parse: rawText in: self notifying: nil.	^ rawText compressWithTable:		((selector keywords ,		parse tempNames ,		self instVarNames ,		#(self super ifTrue: ifFalse:) ,		((0 to: 7) collect:			[:i | String streamContents:				[:s | s cr. i timesRepeat: [s tab]]]) ,		(self compiledMethodAt: selector) literalStrings)			asSortedCollection: [:a :b | a size > b size])! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'nice 2/23/2011 21:44'!firstPrecodeCommentFor:  selector	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"	| parser source tree |	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"	(#(Comment Definition Hierarchy) includes: selector)		ifTrue:			["Not really a selector"			^ nil].	source := self sourceCodeAt: selector asSymbol ifAbsent: [^ nil].	parser := self newParser.	tree := 		parser			parse: (ReadStream on: source)			class: self			noPattern: false			context: nil			notifying: nil			ifFail: [^ nil].	^ (tree comment ifNil: [^ nil]) first! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'nice 2/23/2011 21:44'!formalParametersAt: aSelector	"Return the names of the arguments used in this method."	| source |	source := self sourceCodeAt: aSelector ifAbsent: [^ #()].	"for now"	^self newParser parseParameterNames: source! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'nice 2/23/2011 21:44'!methodHeaderFor: selector 	"Answer the string corresponding to the method header for the given selector"	| sourceString parser |	sourceString := self ultimateSourceCodeAt: selector ifAbsent: [self standardMethodHeaderFor: selector].	(parser := self newParser) parseSelector: sourceString.	^ sourceString asString copyFrom: 1 to: (parser endOfLastToken min: sourceString size)	"Behavior methodHeaderFor: #methodHeaderFor: "! !!Behavior methodsFor: 'testing' stamp: 'nice 10/26/2010 21:14'!isWords	"Answer true if the receiver is made of 32-bit instance variables."	^self isBytes not! !!Behavior methodsFor: 'testing' stamp: 'nice 2/23/2011 21:38'!sourceMatchesBytecodeAt: selector	"Answers true if the source code at the selector compiles to the bytecode at the selector, and false otherwise. Implemented to detect an error where Monticello did not recompile sources when the class shape changed"	"This code was copied from #recompile:from:, with few changes. Several methods would benefit from a method which turned a selector and class into a CompiledMethod, without  installing it into the methodDictionary"	| method trailer methodNode |	method := self compiledMethodAt: selector.	trailer := method trailer.	methodNode := self newCompiler				compile: (self sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ false].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ (methodNode generate: trailer) = method! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ul 3/12/2011 21:31'!thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a 	literal. Dives into the compact literal notation, making it slow but 	thorough "	^self whichSelectorsReferTo: literal special: specialFlag byte: specialByte thorough: true! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ul 5/7/2011 02:11'!whichMethodsStoreInto: instVarName 	"Answer a collection of CompiledMethod whose methods access the argument, instVarName, as a named instance variable."		| instVarIndex |	instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^Array new ].	^self methodDict values select: [:eachMethod | eachMethod writesField: instVarIndex ]		"Point whichMethodsStoreInto: 'x'."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ul 3/14/2011 23:34'!whichSelectorsAccess: instVarName 	"Answer a collection of selectors whose methods access the argument, instVarName, as a named instance variable."	"Point whichSelectorsAccess: 'x'."		| instVarIndex |	instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^Array new ].	^Array streamContents: [ :stream |		self selectorsAndMethodsDo: [ :selector :method |			((method readsField: instVarIndex) or: [				method writesField: instVarIndex ]) ifTrue: [					stream nextPut: selector ] ] ]! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ul 3/12/2011 21:31'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal."	^self whichSelectorsReferTo: literal special: specialFlag byte: specialByte thorough: false! !!Behavior methodsFor: 'testing method dictionary' stamp: 'eem 5/23/2011 17:07'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte thorough: thorough	"Answer a set of selectors whose methods access the argument as a literal. If thorough is true, then dives into the compact literal notation, making it slow but thorough "	| who |	who := IdentitySet new.	self selectorsAndMethodsDo: [ :selector :method |		(((thorough			ifFalse: [ method hasLiteral: literal ]			ifTrue: [ method hasLiteralThorough: literal ]) or: [				specialFlag and: [ method scanFor: specialByte ] ]) and: [			literal isVariableBinding not or: [				"N.B. (method indexOfLiteral: literal) < method numLiterals copes with l;ooking for				Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."				(method indexOfLiteral: literal) ~= 0] ]) ifTrue: [			who add: selector ] ].	^who! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ul 5/7/2011 02:11'!whichSelectorsStoreInto: instVarName 	"Answer a collection of selectors whose methods access the argument, instVarName, as a named instance variable."		| instVarIndex |	instVarIndex := self instVarIndexFor: instVarName ifAbsent: [ ^Array new ].	^ self methodDict keys select: 		[:sel | (self methodDict at: sel) writesField: instVarIndex]	"Point whichSelectorsStoreInto: 'x'."! !!Behavior methodsFor: 'compiling' stamp: 'nice 2/23/2011 21:36'!compile: code classified: category notifying: requestor trailer: bytes ifFail: failBlock	"Compile code without logging the source in the changes file"	| methodNode |	methodNode  := self newCompiler				compile: code				in: self				classified: category 				notifying: requestor				ifFail: failBlock.	^ CompiledMethodWithNode generateMethodFromNode: methodNode trailer: bytes.! !!Behavior methodsFor: 'compiling' stamp: 'nice 2/23/2011 21:36'!newCompiler	"Answer a Compiler suitable for compiling this Behavior"	^self compilerClass new parser: self newParser! !!Behavior methodsFor: 'compiling' stamp: 'nice 2/23/2011 21:36'!newParser	"Answer a Parser suitable for parsing source code in this Behavior"	^self parserClass new! !!Behavior methodsFor: 'compiling' stamp: 'nice 2/23/2011 21:38'!recompileNonResidentMethod: method atSelector: selector from: oldClass	"Recompile the method supplied in the context of this class."	| trailer methodNode |	trailer := method trailer.	methodNode := self newCompiler			compile: (method getSourceFor: selector in: oldClass)			in: self			notifying: nil			ifFail: ["We're in deep doo-doo if this fails (syntax error).				Presumably the user will correct something and proceed,				thus installing the result in this methodDict.  We must				retrieve that new method, and restore the original (or remove)				and then return the method we retrieved."				^ self error: 'see comment'].	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ methodNode generate: trailer! !!Behavior methodsFor: 'compiling' stamp: 'nice 2/23/2011 21:38'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method := oldClass compiledMethodAt: selector.	trailer := method trailer.	methodNode := self newCompiler				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self basicAddSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: 'enumerating' stamp: 'topa 10/25/2010 10:24'!withAllSuperAndSubclassesDo: aBlock	self allSuperclassesDo: aBlock.	aBlock value: self.	self allSubclassesDo: aBlock! !!Behavior methodsFor: 'copying' stamp: 'nice 12/29/2010 12:11'!deepCopy	"Behavior are shared rather than copied."	^ self! !!Behavior methodsFor: 'copying' stamp: 'nice 12/29/2010 10:35'!postCopy	super postCopy.	self methodDict: self methodDict copy! !!Behavior methodsFor: 'copying' stamp: 'nice 12/29/2010 12:00'!veryDeepCopyWith: deepCopier	"Return self.  Must be created, not copied.  Do not record me."! !!Behavior methodsFor: 'instance creation' stamp: 'hsj 2/16/2011 13:44'!adoptInstance: anInstance	"Change the class of anInstance to me.	Primitive (found in Cog and new VMs)  follows the same rules as primitiveChangeClassTo:, but returns the class rather than the modified instance"	<primitive: 160 error: ec>	anInstance primitiveChangeClassTo: self basicNew.	^self! !!Behavior methodsFor: 'queries' stamp: 'ul 5/7/2011 02:43'!whichSelectorsAssign: instVarName 	"Answer a Set of selectors whose methods store into the argument, 	instVarName, as a named instance variable."		self deprecated: 'Use #whichSelectorsStoreInto:.'.	^self whichSelectorsStoreInto: instVarName! !!Behavior methodsFor: 'private' stamp: 'eem 5/23/2011 17:11'!spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| space |	space := 0.	self methodsDo: [:method |		space := space + 16.  "dict and org'n space"		space := space + (method size + 6 "hdr + avg pad").		method literalsDo: [:lit |			(lit isMemberOf: Array) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [space := space + 12].			(lit isMemberOf: ByteString) ifTrue: [space := space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [space := space + ((lit size + 1) * 4)]]].		^ space! !!Behavior methodsFor: '*Tools-Browser-accessors' stamp: 'eem 8/12/2009 11:45'!settersReturnValue	"Determine whether the browser's createInstVarAccessors code will generate	 setters that answer self (the default here) or the value set.  Classes that want	 to answer the value set (e.g. VMStructType) override."	^false! !!Behavior methodsFor: '*System-Support' stamp: 'ul 3/14/2011 20:56'!allCallsOn	"Answer a SortedCollection of all the methods that refer to me by name or as part of an association in a global dict."	^self systemNavigation allCallsOn: self theNonMetaClass name! !!Behavior methodsFor: '*System-Support' stamp: 'ul 3/14/2011 20:49'!allCallsOn: aSymbol	"Answer a sorted collection of all the methods that call on aSymbol."	^self systemNavigation allCallsOn: aSymbol from: self.	! !!Behavior methodsFor: '*System-Support' stamp: 'ul 3/14/2011 20:55'!allLocalCallsOn: aSymbol	"Answer a sorted collection of all the methods that call on aSymbol, anywhere in my class hierarchy."	^self systemNavigation allCallsOn: aSymbol from: self theNonMetaClass! !!Behavior methodsFor: '*System-Support' stamp: 'ul 3/14/2011 20:56'!allUnsentMessages	"Answer an array of all the messages defined by the receiver that are not sent anywhere in the system."	^self systemNavigation allUnSentMessagesIn: self selectors! !!BehaviorTest methodsFor: 'tests' stamp: 'md 2/18/2006 16:42'!testBinding	self assert: Object binding value = Object.	self assert: Object binding key = #Object.		self assert: Object class binding value = Object class.		"returns nil for Metaclasses... like Encoder>>#associationFor:"		self assert: Object class binding key = nil.! !!BehaviorTest methodsFor: 'tests' stamp: 'ul 3/17/2011 02:44'!testFormalParameterNames	| method |	method := #sampleMessageWithFirstArgument:andInterleavedCommentBeforeSecondArgument:.	self assert: (self class formalParametersAt: method) size = 2.	self assert: (self class formalParametersAt: method) asArray = #('firstArgument' 'secondArgument').	CurrentReadOnlySourceFiles cacheDuring: [		Object selectorsDo: [:e |			self assert: (Object formalParametersAt: e) size = e numArgs]].! !!BehaviorTest methodsFor: 'tests' stamp: 'nice 5/7/2011 14:31'!testWhichMethodsStoreInto	ClassForBehaviorTest withAllSubclassesDo: [:eachTestClass |		{eachTestClass. eachTestClass class} do: [:eachTestClassOrMetaclass |						eachTestClassOrMetaclass allInstVarNames do: [:iv |				self assert: ((eachTestClassOrMetaclass whichMethodsStoreInto: iv)						collect: [:eachMethod | eachMethod selector]) sorted					= (eachTestClassOrMetaclass whichSelectorsStoreInto: iv) sorted.				self assert: ((eachTestClassOrMetaclass whichMethodsStoreInto: iv)						allSatisfy: [:eachMethod | eachMethod methodClass = eachTestClassOrMetaclass]) ].							eachTestClassOrMetaclass allClassVarNames do: [:cv |				self assert: ((eachTestClassOrMetaclass whichMethodsStoreInto: cv)						collect: [:eachMethod | eachMethod selector]) sorted					= (eachTestClassOrMetaclass whichSelectorsStoreInto: cv) sorted.				self assert: ((eachTestClassOrMetaclass whichMethodsStoreInto: cv)						allSatisfy: [:eachMethod | eachMethod methodClass = eachTestClassOrMetaclass]) ]]]! !!BehaviorTest methodsFor: 'tests' stamp: 'nice 5/7/2011 14:18'!testWhichSelectorStoreInto	self assert: (ClassForBehaviorTest whichSelectorsStoreInto: 'iv1') sorted = #(#initialize #iv1: #reset ).	self assert: (ClassForBehaviorTest whichSelectorsStoreInto: 'iv2') sorted = #(#iv2: #reset ).	self assert: (ClassForBehaviorTest whichSelectorsStoreInto: 'CV1') sorted =  #(#initialize).	self assert: (ClassForBehaviorTest whichSelectorsStoreInto: 'CV2') sorted =  #().		self assert: (SubClassForBehaviorTest whichSelectorsStoreInto: 'iv1') sorted = #(#resetIV1 ).	self assert: (SubClassForBehaviorTest whichSelectorsStoreInto: 'iv2') sorted = #(#iv2: ).	self assert: (SubClassForBehaviorTest whichSelectorsStoreInto: 'CV1') sorted =  #().	self assert: (SubClassForBehaviorTest whichSelectorsStoreInto: 'CV2') sorted =  #().		self assert: (ClassForBehaviorTest class whichSelectorsStoreInto: 'CV1') sorted =  #(#initialize).	self assert: (ClassForBehaviorTest class whichSelectorsStoreInto: 'CV2') sorted =  #(#initialize).	self assert: (ClassForBehaviorTest class whichSelectorsStoreInto: 'civ1') sorted =  #(#civ1).		self assert: (SubClassForBehaviorTest class whichSelectorsStoreInto: 'CV1') sorted =  #().	self assert: (SubClassForBehaviorTest class whichSelectorsStoreInto: 'CV2') sorted =  #().	self assert: (SubClassForBehaviorTest class whichSelectorsStoreInto: 'civ1') sorted =  #(#install).! !!Bezier3Segment class methodsFor: 'examples' stamp: 'ar 9/1/2010 22:14'!example2	"draws a cubic bezier on the screen"	| c canvas |	c := Bezier3Segment new				from: 0 @ 0				via: 0 @ 100				and: 100 @ 0				to: 100 @ 100.	canvas := Display getCanvas asBalloonCanvas	canvas aaLevel: 4.	canvas		drawBezier3Shape: c asPointArray		color: Color transparent		borderWidth: 1		borderColor: Color black! !!BitBlt methodsFor: 'private' stamp: 'nice 8/27/2010 19:41'!colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix	| srcIndex map mapsForSource mapsForSourceAndDest |	ColorConvertingMaps class == Array 		ifFalse: [ColorConvertingMaps := (1 to: 10) collect: [:i | Array new: 32]].			srcIndex := sourceDepth.	sourceDepth > 8 ifTrue: [ srcIndex := keepSubPix ifTrue: [9] ifFalse: [10] ].	mapsForSource := ColorConvertingMaps at: srcIndex.	mapsForSourceAndDest := (mapsForSource at: destDepth) ifNil: [ mapsForSource at: destDepth put: Dictionary new ].		map := mapsForSourceAndDest at: targetColor ifAbsentPut: [		Color computeColorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix ].	^ map! !!BitBlt methodsFor: 'private' stamp: 'ul 3/30/2011 01:04'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth targetColor |	sourceForm ifNotNil:[lastSourceDepth := sourceForm depth].	sourceForm := aStrikeFont glyphs.	"Ignore any halftone pattern since we use a color map approach here"	halftoneForm := nil.	sourceY := 0.	height := aStrikeFont height.	sourceForm depth = 1 ifTrue: [		self combinationRule: Form paint.		(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse: [			"Set up color map for a different source depth (color font)"			"Uses caching for reasonable efficiency"			colorMap := self cachedFontColormapFrom: sourceForm depth to: destForm depth.			colorMap at: 1 put: (destForm pixelValueFor: backgroundColor)].		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor).	]	ifFalse: [		(self class subPixelRenderFonts and: [ foregroundColor = Color black			"Only use rgbMul with opaque colors as alpha values get lost for translucent colors."			or: [ self class subPixelRenderColorFonts and: [foregroundColor isOpaque] ]]) ifTrue: [			destForm depth > 8 ifTrue: [				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"				self combinationRule: Form rgbMul.				colorMap := (destForm depth = 32 or: [ (foregroundColor = Color black) not ]) ifTrue: [					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)					See #displayString:from:to:at:strikeFont:kern:"					"Note: In 32bpp we always need the second pass, as the source could have transparent pixels, and we need to add to the alpha channel"					self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]]			ifFalse: [				self combinationRule: Form paint.				targetColor := foregroundColor = Color black ifFalse: [ foregroundColor ].				colorMap := self colorConvertingMap: targetColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]		]		ifFalse: [			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"			self combinationRule: (destForm depth = 32 ifTrue: [Form blendAlphaScaled] ifFalse: [Form paint]).			colorMap := self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: false		]	].! !!BitBlt commentStamp: 'ar 8/4/2009 20:19' prior: 0!WARNING: BitBlt's shape cannot be modified since WarpBlt relies on the exact layout.I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a either word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source, or a fully specified ColorMap which may contain a lookup table (ie Bitmap) and/or four separate masks and shifts which are applied to the pixels. For every source pixel, BitBlt will first perform masking and shifting and then index the lookup table, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBlt class methodsFor: 'benchmarks' stamp: 'nice 6/11/2010 21:32'!benchDiffsFrom: before to: afterwards	"Given two outputs of BitBlt>>benchmark show the relative improvements."	| old new log oldLine newLine oldVal newVal improvement |	log := WriteStream on: String new.	old := ReadStream on: before.	new := ReadStream on: afterwards.	[old atEnd or:[new atEnd]] whileFalse:[		oldLine := old nextLine.		newLine := new nextLine.		(oldLine includes: Character tab) ifTrue:[			oldLine := ReadStream on: oldLine.			newLine := ReadStream on: newLine.			Transcript cr; show: (oldLine upTo: Character tab); tab.			log cr; nextPutAll: (newLine upTo: Character tab); tab.			[oldLine skipSeparators. newLine skipSeparators.			oldLine atEnd] whileFalse:[				oldVal := Integer readFrom: oldLine.				newVal := Integer readFrom: newLine.				improvement := oldVal asFloat / newVal asFloat roundTo: 0.01.				Transcript show: improvement printString; tab; tab.				log print: improvement; tab; tab].		] ifFalse:[			Transcript cr; show: oldLine.			log cr; nextPutAll: oldLine.		].	].	^log contents! !!BitBlt class methodsFor: 'preferences' stamp: 'ul 3/30/2011 01:03'!subPixelRenderColorFonts	<preference: 'Subpixel font rendering for color fonts'	category: 'Graphics'	description: 'If true, non-black opaque fonts are rendered using subpixel combination rules by BitBlt. Subpixel font rendering has to be enabled to take effect.'	type: #Boolean>	^SubPixelRenderColorFonts ifNil: [ true ]	! !!BitBlt class methodsFor: 'preferences' stamp: 'ul 3/30/2011 01:03'!subPixelRenderColorFonts: aBoolean	SubPixelRenderColorFonts := aBoolean	! !!BitBlt class methodsFor: 'preferences' stamp: 'ul 3/30/2011 01:01'!subPixelRenderFonts	<preference: 'Subpixel font rendering'	category: 'Graphics'	description: 'If true, black fonts are rendered using subpixel combination rules by BitBlt.'	type: #Boolean>	^SubPixelRenderFonts ifNil: [ true ]	! !!BitBlt class methodsFor: 'preferences' stamp: 'ul 3/30/2011 00:58'!subPixelRenderFonts: aBoolean	SubPixelRenderFonts := aBoolean	! !!Bitmap methodsFor: 'filing' stamp: 'dtl 10/24/2010 12:47'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 'primitiveCompressToByteArray' module: 'MiscPrimitivePlugin'>	<var: #bm declareC: 'int *bm'>	<var: #ba declareC: 'unsigned char *ba'>	size := bm size.	i := self encodeInt: size in: ba at: 1.	k := 1.	[k <= size] whileTrue:		[word := bm at: k.		lowByte := word bitAnd: 16rFF.		eqBytes := ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j := k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j := j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i := self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i := i+1]				ifFalse: [i := self encodeInt: j-k+1*4+2 in: ba at: i.						i := self encodeBytesOf: word in: ba at: i].			k := j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i := self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i := i+1.				k := k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j := j+1].				j = size ifTrue: [j := j + 1].				"We have one or more unmatching words, ending at j-1"				i := self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i := self encodeBytesOf: (bm at: m) in: ba at: i].				k := j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n := rawBytes := myBytes := 0.Form allInstancesDo:	[:f | f unhibernate.	b := f bits.	n := n + 1.	rawBytes := rawBytes + (b size*4).	myBytes := myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'dtl 10/24/2010 12:46'!decompress: bm fromByteArray: ba at: index	"Decompress the body of a byteArray encoded by compressToByteArray (qv)...	The format is simply a sequence of run-coded pairs, {N D}*.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent				(could be used to skip from one raster line to the next)			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows (see decodeIntFrom:)...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"		"NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm."	| i code n anInt data end k pastEnd |	<primitive: 'primitiveDecompressFromByteArray' module: 'MiscPrimitivePlugin'>	<var: #bm declareC: 'int *bm'>	<var: #ba declareC: 'unsigned char *ba'>	i := index.  "byteArray read index"	end := ba size.	k := 1.  "bitmap write index"	pastEnd := bm size + 1.	[i <= end] whileTrue:		["Decode next run start N"		anInt := ba at: i.  i := i+1.		anInt <= 223 ifFalse:			[anInt <= 254				ifTrue: [anInt := (anInt-224)*256 + (ba at: i).  i := i+1]				ifFalse: [anInt := 0.						1 to: 4 do: [:j | anInt := (anInt bitShift: 8) + (ba at: i).  i := i+1]]].		n := anInt >> 2.		(k + n) > pastEnd ifTrue: [^ self primitiveFail].		code := anInt bitAnd: 3.		code = 0 ifTrue: ["skip"].		code = 1 ifTrue: ["n consecutive words of 4 bytes = the following byte"						data := ba at: i.  i := i+1.						data := data bitOr: (data bitShift: 8).						data := data bitOr: (data bitShift: 16).						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 2 ifTrue: ["n consecutive words = 4 following bytes"						data := 0.						1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 3 ifTrue: ["n consecutive words from the data..."						1 to: n do:							[:m | data := 0.							1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].							bm at: k put: data.  k := k+1]]]! !!Bitmap methodsFor: 'filing' stamp: 'dtl 10/24/2010 12:47'!encodeBytesOf: anInt in: ba at: i	"Copy the integer anInt into byteArray ba at index i, and return the next index"	<inline: true>	<var: #ba declareC: 'unsigned char *ba'>	0 to: 3 do:		[:j | ba at: i+j put: (anInt >> (3-j*8) bitAnd: 16rFF)].	^ i+4! !!Bitmap methodsFor: 'filing' stamp: 'dtl 10/24/2010 12:46'!encodeInt: anInt in: ba at: i	"Encode the integer anInt in byteArray ba at index i, and return the next index.	The encoding is as follows...		0-223	0-223		224-254	(0-30)*256 + next byte (0-7935)		255		next 4 bytes"			<inline: true>	<var: #ba declareC: 'unsigned char *ba'>	anInt <= 223 ifTrue: [ba at: i put: anInt. ^ i+1].	anInt <= 7935 ifTrue: [ba at: i put: anInt//256+224. ba at: i+1 put: anInt\\256.  ^ i+2].	ba at: i put: 255.	^ self encodeBytesOf: anInt in: ba at: i+1! !!BitmapBugz methodsFor: 'tests' stamp: 'ar 8/2/2003 19:21'!testBitmapByteAt	| bm |	bm := Bitmap new: 1.	1 to: 4 do:[:i|		self should:[bm byteAt: i put: 1000] raise: Error.	].! !!BitmapBugz methodsFor: 'tests' stamp: 'ul 10/24/2010 06:02'!testWriteOn	| original binary copy |	original := Bitmap new: 1.	original byteAt: 1 put: 42.	binary := ByteArray streamContents: [ :stream |		original writeOn: stream ].	copy := Bitmap newFromStream: binary readStream.	self assert: original = copy! !!BlockClosure methodsFor: 'accessing' stamp: 'mha 9/22/2010 11:40'!size	"Extract this closure's bytecode size (number of bytes) by accessing the closure	creation bytecode in the enclosing method."		^ ((self method at: self startpc - 2) bitShift: 8) + (self method at: self startpc - 1)! !!BlockClosure methodsFor: 'evaluating' stamp: 'nice 9/10/2010 20:54'!bench	"See how many times I can value in 5 seconds.  I'll answer a meaningful description."	| startTime endTime count roundTo3Digits |	roundTo3Digits := [:num |		| rounded lowDigit |		rounded := (num * 1000) rounded. "round to 1/1000"		lowDigit := (rounded numberOfDigitsInBase: 10) - 3. "keep only first 3 digits"		rounded := rounded roundTo:(10 raisedTo: lowDigit).		(lowDigit >= 3 or: [rounded \\ 1000 = 0]) "display fractional part only when needed"			ifTrue: [(rounded // 1000) asStringWithCommas]			ifFalse: [(rounded / 1000.0) printString]].	count := 0.	endTime := Time millisecondClockValue + 5000.	startTime := Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count := count + 1 ].	endTime := Time millisecondClockValue.	^count = 1		ifTrue: [ (roundTo3Digits value: (endTime - startTime) / 1000) , ' seconds.' ]		ifFalse:			[ (roundTo3Digits value: (count * 1000) / (endTime - startTime)) , ' per second.' ]! !!BlockClosure methodsFor: 'evaluating' stamp: 'ul 8/2/2010 19:40'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock cull: ex description cull: ex receiver ]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:52'!once	"Answer and remember my value, answering exactly the same object in any further sends	 of once or value until I become uncached.  This allows one to intern values with the idiom		myResourceMethod			^[expression] once.	 The expression will be evaluated once and its result returned for any subsequent evaluations.	 Originally by Travis Griggs, from whom we copy this idea with thanks."	numArgs ~= 0 ifTrue:		[self error: 'once should only be used with niladic blocks'].	self becomeCached.	^self once! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 11:50'!value	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the copied values to the activation as its copied	 temps. Primitive. Essential."	<primitive: 201>	| newContext |	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:21'!value: firstArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the argument and copied values to the activation	 as its argument and copied temps. Primitive. Essential."	<primitive: 202>	| newContext |	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22'!value: firstArg value: secondArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 203>	| newContext |	numArgs ~= 2 ifTrue:		[self numArgsError: 2].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22'!value: firstArg value: secondArg value: thirdArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 204>	| newContext |	numArgs ~= 3 ifTrue:		[self numArgsError: 3].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:31'!value: firstArg value: secondArg value: thirdArg value: fourthArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 205>	| newContext |	numArgs ~= 4 ifTrue:		[self numArgsError: 4].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			newContext at: 4 put: fourthArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'ul 8/2/2011 19:56'!valueSupplyingAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^self		on: ProvideAnswerNotification		do: [ :notification |			| caption |			caption := notification messageText withSeparatorsCompacted. "to remove new lines"			aListOfPairs				detect:  [ :each |					caption = each first						or: [ (caption includesSubstring: each first caseSensitive: false)						or: [ each first match: caption ] ] ]				ifFound: [ :answer | notification resume: answer second ]				ifNone: [					(ProvideAnswerNotification signal: notification messageText)						ifNil: [ notification resume ]						ifNotNil: [ :outerAnswer | notification resume: outerAnswer ] ] ]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:29'!valueWithArguments: anArray	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments in an anArray and copied values to	 the activation as its arguments and copied temps. Primitive. Essential."	<primitive: 206>	| newContext |	numArgs ~= anArray size ifTrue:		[self numArgsError: anArray size].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			1 to: numArgs do:				[:i| newContext at: i put: (anArray at: i)].			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'ul 12/8/2010 02:47'!valueWithExit 	  self value: [ ^nil ]! !!BlockClosure methodsFor: 'exceptions' stamp: 'ul 8/2/2011 19:52'!on: exc1 do: block1 on: exc2 do: block2	^[		self			on: exc1			do: block1 ]		on: exc2		do: block2! !!BlockClosure methodsFor: 'exceptions' stamp: 'ul 8/2/2011 19:52'!on: exc1 do: block1 on: exc2 do: block2 on: exc3 do: block3	^[		self			on: exc1			do: block1 ]		on: exc2		do: block2		on: exc3		do: block3! !!BlockClosure methodsFor: 'exceptions' stamp: 'ul 8/12/2010 00:07'!onDNU: selector do: handleBlock	"Catch MessageNotUnderstood exceptions but only those of the given selector (DNU stands for doesNotUnderstand:)"	^ self on: MessageNotUnderstood do: [:exception |		exception message selector = selector			ifTrue: [handleBlock cull: exception]			ifFalse: [exception pass]	  ]! !!BlockClosure methodsFor: 'scheduling' stamp: 'ul 12/8/2010 02:47'!newProcessWith: anArray 	"Answer a Process running the code in the receiver. The receiver's block 	arguments are bound to the contents of the argument, anArray. The 	process is not scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self valueWithArguments: anArray.			Processor terminateActive] asContext		priority: Processor activePriority! !!BlockClosure methodsFor: 'private' stamp: 'HenrikSperreJohansen 8/2/2010 04:15'!asContextWithSender: aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^(MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc;		privRefresh! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:23'!becomeCached	self become: ((CachedBlockClosure new: self size)						outerContext: outerContext						startpc: startpc						numArgs: numArgs						cachedValue: self value						copiedValues: self)! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:19'!becomeUncached	"The receiver is already uncached."	^self! !!BlockClosure methodsFor: 'events-support' stamp: 'nice 9/21/2010 10:22'!isReceiverOrAnyArgumentGarbage	"For use in the when:evaluate: protocol, i.e.,		foo when: #bar evaluate:[self handleBar].."	^false! !!BlockClosure methodsFor: 'events-support' stamp: 'nice 9/21/2010 10:18'!valueOtherwise: aBlock	"Send the message and answer the return value"	^self value! !!BlockClosure methodsFor: 'events-support' stamp: 'nice 9/21/2010 10:18'!valueWithArguments: anArray otherwise: aBlock	^ self valueWithArguments: anArray! !!BlockClosure methodsFor: 'events-support' stamp: 'nice 9/21/2010 10:25'!valueWithEnoughArguments: anArray	"call me with enough arguments from anArray"	| args |	(anArray size == self numArgs)		ifTrue: [ ^self valueWithArguments: anArray ].	args := Array new: self numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self valueWithArguments: args! !!BlockContext methodsFor: 'evaluating' stamp: 'nice 10/11/2010 23:31'!cull: firstArg	"Activate the receiver, with one or zero arguments."		self numArgs >= 1 ifTrue: [ ^self value: firstArg ].	^self value! !!BlockContext methodsFor: 'evaluating' stamp: 'nice 10/11/2010 23:32'!cull: firstArg cull: secondArg	"Activate the receiver, with two or less arguments."		self numArgs >= 2 ifTrue: [ ^self value: firstArg value: secondArg ].		self numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!BlockContext methodsFor: 'evaluating' stamp: 'nice 10/11/2010 23:32'!cull: firstArg cull: secondArg cull: thirdArg	"Activate the receiver, with three or less arguments."		self numArgs >= 2 ifTrue: [ 		self numArgs >= 3 ifTrue: [ ^self value: firstArg value: secondArg value: thirdArg ].		^self value: firstArg value: secondArg ].	self numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!BlockContext methodsFor: 'evaluating' stamp: 'nice 10/11/2010 23:32'!cull: firstArg cull: secondArg cull: thirdArg cull: fourthArg	"Activate the receiver, with four or less arguments."		self numArgs >= 3 ifTrue: [		self numArgs >= 4 ifTrue: [			^self value: firstArg value: secondArg value: thirdArg value: fourthArg ].		^self value: firstArg value: secondArg value: thirdArg ].	self numArgs = 2 ifTrue: [ ^self value: firstArg value: secondArg ].		self numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!BlockContext methodsFor: 'evaluating' stamp: 'brp 9/25/2003 13:49'!durationToRun	"Answer the duration taken to execute this block."	^ Duration milliSeconds: self timeToRun! !!BlockContext methodsFor: 'evaluating' stamp: 'HenrikSperreJohansen 6/28/2010 12:12'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock cull: ex description cull: ex receiver]! !!BlockContext methodsFor: 'evaluating' stamp: 'ul 8/2/2011 20:14'!valueSupplyingAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^self		on: ProvideAnswerNotification		do: 			[:notify | | answer caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:each | caption = each first						or: [(caption includesSubstring: each first caseSensitive: false)						or: [each first match: caption]]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!BlockContext methodsFor: 'exceptions' stamp: 'ul 8/2/2011 20:14'!on: exc1 do: block1 on: exc2 do: block2	^[		self			on: exc1			do: block1 ]		on: exc2		do: block2! !!BlockContext methodsFor: 'exceptions' stamp: 'ul 8/2/2011 20:14'!on: exc1 do: block1 on: exc2 do: block2 on: exc3 do: block3	^[		self			on: exc1			do: block1 ]		on: exc2		do: block2		on: exc3		do: block3! !!BlockContext methodsFor: 'scheduling' stamp: 'svp 6/23/2003 10:59'!forkAt: priority named: name	"Create and schedule a Process running the code in the receiver at the	given priority and having the given name. Answer the newly created 	process."	| forkedProcess |	forkedProcess := self newProcess.	forkedProcess priority: priority.	forkedProcess name: name.	^ forkedProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'svp 6/23/2003 10:59'!forkNamed: aString	"Create and schedule a Process running the code in the receiver and	having the given name."	^ self newProcess name: aString; resume! !!BlockContextTest methodsFor: 'running' stamp: 'md 9/6/2005 19:56'!setUp	super setUp.	aBlockContext := [100@100 corner: 200@200].	contextOfaBlockContext := thisContext.! !!BlockLocalTempCounter methodsFor: 'private' stamp: 'eem 1/22/2011 12:48'!doJoin	scanner pc < blockEnd ifTrue:		[stackPointer := joinOffsets at: scanner pc ifAbsent: [scanner followingPc]]	"the ifAbsent: handles a caseOf:otherwise: where all cases return, which results	 in the branch around the otherwise being unreached.  e.g. in the following		jumpTo: L2	 is unreached.		| t |		t caseOf: { [nil] -> [^thisContext method abstractSymbolic] }		  otherwise: ['Oh no Mr Bill!!']		pushTemp: 0		pushConstant: nil		send: #= (1 arg)		jumpFalseTo: L1		pushThisContext: 		send: #method (0 args)		send: #abstractSymbolic (0 args)		returnTop		jumpTo: L2	L1:		pushConstant: 'Oh no Mr Bill!!'	L2:		returnTop"! !!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'nice 8/27/2010 19:42'!tempCountForBlockAt: pc in: method	"Compute the number of local temporaries in a block.	 If the block begins with a sequence of push: nil bytecodes then some of	 These could be initializing local temps.  We can only reliably disambuguate	 them from other uses of nil by parsing the stack and seeing what the offset	 of the stack pointer is at the end of the block.	 There are short-cuts.  The ones we take here are		- if there is no sequence of push nils there can be no local temps		- we follow forward jumps to shorten the amount of scanning"	stackPointer := 0.	scanner := InstructionStream new method: method pc: pc.	scanner interpretNextInstructionFor: self.	blockEnd ifNil:		[self error: 'pc is not that of a block'].	scanner nextByte = Encoder pushNilCode ifTrue:		[joinOffsets := Dictionary new.		 [scanner pc < blockEnd] whileTrue:			[scanner interpretNextInstructionFor: self]].	^stackPointer! !!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'nice 8/27/2010 19:42'!testTempCountForBlockAt: startPc in: method	"Compute the number of local temporaries in a block.	 If the block begins with a sequence of push: nil bytecodes then some of	 These could be initializing local temps.  We can only reliably disambuguate	 them from other uses of nil by parsing the stack and seeing what the offset	 of the stack pointer is at the end of the block.There are short-cuts.  The only	 one we take here is		- if there is no sequence of push nils there can be no local temps"	| symbolicLines line prior thePc |	symbolicLines := Dictionary new.	method symbolicLinesDo:		[:pc :lineForPC| symbolicLines at: pc put: lineForPC].	stackPointer := 0.	scanner := InstructionStream new method: method pc: startPc.	scanner interpretNextInstructionFor: self.	blockEnd ifNil:		[self error: 'pc is not that of a block'].	scanner nextByte = Encoder pushNilCode ifTrue:		[joinOffsets := Dictionary new.		 [scanner pc < blockEnd] whileTrue:			[line := symbolicLines at: scanner pc.			 prior := stackPointer.			 thePc := scanner pc.			 scanner interpretNextInstructionFor: self.			 Transcript cr; print: prior; nextPutAll: '->'; print: stackPointer;  tab; print: thePc; tab; nextPutAll: line; flush]].	^stackPointer! !!BlockLocalTemporariesRemovalTest methodsFor: 'test helper' stamp: 'lw 5/19/2011 18:50'!assert: someCode isChangedDuringParsingTo: someOtherCode withRemovalOfTemporariesNamed: someTempNames	| failBlock |	self sourceCode: someCode.	failBlock := [self fail].	[self class			compile: self sourceCode			classified: nil			notifying: self			trailer: self class defaultMethodTrailer			ifFail: failBlock]		on: UnusedVariable		do: [:aNotification | aNotification				openMenuIn: [:options :emptyCollection :someText | 					(someTempNames anySatisfy: [:tempName | someText startsWith: tempName])						ifTrue: [aNotification resume: true]						ifFalse: [aNotification resume: false]]].	self assert: self sourceCode = someOtherCode! !!BlockLocalTemporariesRemovalTest methodsFor: 'requesting' stamp: 'lw 5/19/2011 18:36'!correctFrom: start to: stop with: aString		| loc |	aString = '#insert period' ifTrue:		[loc := start.		[(loc := loc-1)>0 and: [(self sourceCode at: loc) isSeparator]]			whileTrue: [loc := loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].		self sourceCode: (self sourceCode copyReplaceFrom: start to: stop with: aString)! !!BlockLocalTemporariesRemovalTest methodsFor: 'requesting' stamp: 'lw 5/26/2011 21:09'!deselect! !!BlockLocalTemporariesRemovalTest methodsFor: 'requesting' stamp: 'lw 5/19/2011 18:16'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc |	loc := start + dir.	[(loc between: 1 and: self sourceCode size) and: [(self sourceCode at: loc) isSeparator]]		whileTrue: [loc := loc + dir].	^ loc! !!BlockLocalTemporariesRemovalTest methodsFor: 'requesting' stamp: 'lw 5/26/2011 20:49'!select! !!BlockLocalTemporariesRemovalTest methodsFor: 'requesting' stamp: 'lw 5/26/2011 20:49'!selectFrom: aPoisition to: anotherPosition! !!BlockLocalTemporariesRemovalTest methodsFor: 'requesting' stamp: 'lw 5/26/2011 21:09'!selectInvisiblyFrom: userSelection to: last! !!BlockLocalTemporariesRemovalTest methodsFor: 'requesting' stamp: 'lw 5/19/2011 17:54'!selectionInterval	^ Interval from: 0 to: 0! !!BlockLocalTemporariesRemovalTest methodsFor: 'requesting' stamp: 'lw 5/19/2011 17:57'!text	^ self sourceCode! !!BlockLocalTemporariesRemovalTest methodsFor: 'examples' stamp: 'lw 5/7/2011 12:56'!methodWithBlockVariable	| foo |	[ | bar | ] value! !!BlockLocalTemporariesRemovalTest methodsFor: 'accessing' stamp: 'lw 5/19/2011 17:57'!sourceCode	^ sourceCode! !!BlockLocalTemporariesRemovalTest methodsFor: 'accessing' stamp: 'lw 5/19/2011 17:57'!sourceCode: anObject	sourceCode := anObject! !!BlockLocalTemporariesRemovalTest methodsFor: 'testing' stamp: 'ul 11/15/2011 15:51'!testBlockTemporaries	| someCode someOtherCode |		someCode := 'test	| temp |	[ | foo | ]'.	someOtherCode := 'test	| temp |	[  ]'.	self assert: someCode isChangedDuringParsingTo: someOtherCode withRemovalOfTemporariesNamed: #('foo').		someCode := 'test	[ | foo | ]'.	someOtherCode := 'test	[  ]'.	self assert: someCode isChangedDuringParsingTo: someOtherCode withRemovalOfTemporariesNamed: #('foo').		someCode := 'test	| temp |	[ | foo | ]'.	someOtherCode := 'test	[  ]'.	self assert: someCode isChangedDuringParsingTo: someOtherCode withRemovalOfTemporariesNamed: #('foo' 'temp').! !!BlockLocalTemporariesRemovalTest methodsFor: 'testing' stamp: 'lw 5/27/2011 19:43'!testComplex	| someCode someOtherCode |		someCode := 'removeUnusedTemps: methodNode	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| madeChanges tempsMarkHolder unusedTempNames tempMarkHoldersToChange encoder requestor|	encoder := requestor := 1.	madeChanges := false.	tempMarkHoldersToChange := OrderedCollection new.	tempsMarkHolder := self collectTemporaryDeclarationsFrom: methodNode.	unusedTempNames := encoder unusedTempNames select: 		[ :temp | (encoder lookupVariable: temp ifAbsent: [ ]) isUndefTemp 				and: [ UnusedVariable name: temp ]].	tempsMarkHolder do: [ :currentBlock | ||		tempMarkHoldersToChange add: currentBlock.		unusedTempNames do: 			[ :temp || someAdditionalTemps |			(self 				removeUnusedTemporaryNamed: temp 				from: requestor text asString 				lookingAt: currentBlock				movingTempMarksOf: tempMarkHoldersToChange) ifTrue: [ madeChanges := true ]]].	madeChanges		ifTrue: [ self removeEmptyTempDeclarationsFrom: methodNode.			ReparseAfterSourceEditing signal ]'.	someOtherCode := 'removeUnusedTemps: methodNode	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| madeChanges tempsMarkHolder unusedTempNames tempMarkHoldersToChange encoder requestor|	encoder := requestor := 1.	madeChanges := false.	tempMarkHoldersToChange := OrderedCollection new.	tempsMarkHolder := self collectTemporaryDeclarationsFrom: methodNode.	unusedTempNames := encoder unusedTempNames select: 		[ :temp | (encoder lookupVariable: temp ifAbsent: [ ]) isUndefTemp 				and: [ UnusedVariable name: temp ]].	tempsMarkHolder do: [ :currentBlock | 		tempMarkHoldersToChange add: currentBlock.		unusedTempNames do: 			[ :temp |			(self 				removeUnusedTemporaryNamed: temp 				from: requestor text asString 				lookingAt: currentBlock				movingTempMarksOf: tempMarkHoldersToChange) ifTrue: [ madeChanges := true ]]].	madeChanges		ifTrue: [ self removeEmptyTempDeclarationsFrom: methodNode.			ReparseAfterSourceEditing signal ]'.	self assert: someCode isChangedDuringParsingTo: someOtherCode withRemovalOfTemporariesNamed: #('someAdditionalTemps')! !!BlockLocalTemporariesRemovalTest methodsFor: 'testing' stamp: 'lw 5/27/2011 19:31'!testRegression	| someCode someOtherCode |		someCode := 'test	| temp |'.	someOtherCode := 'test	'.	self assert: someCode isChangedDuringParsingTo: someOtherCode withRemovalOfTemporariesNamed: #('temp').		someCode :=  'test	| temp |'.	someOtherCode := 'test	| temp |'.	self assert: someCode isChangedDuringParsingTo: someOtherCode withRemovalOfTemporariesNamed: #().		someCode :=  'test	| temp temptemp |'.	someOtherCode := 'test	| temp |'.	self assert: someCode isChangedDuringParsingTo: someOtherCode withRemovalOfTemporariesNamed: #('temptemp').	! !!BlockLocalTemporariesRemovalTest commentStamp: 'ul 11/15/2011 04:22' prior: 0!I test if the parser can remove unused temporaries properly from methods and blocks. I implement several methods to be able to act like a TextEditor.!!BlockNode methodsFor: 'accessing' stamp: 'eem 8/31/2010 12:31'!arguments	^arguments ifNil: [#()]! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/31/2010 12:30'!temporaries	^temporaries ifNil: [#()]! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark	^tempsMark! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark: anInteger	tempsMark := anInteger! !!BlockNode methodsFor: 'code generation' stamp: 'eem 6/2/2008 13:29'!emitCodeExceptLast: stack encoder: encoder	| position nextToLast |	position := stack position.	nextToLast := statements size - 1.	1 to: nextToLast do:		[:i | | statement |		statement := statements at: i.		statement emitCodeForEffect: stack encoder: encoder.		self assert: stack position = position].! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:28'!emitCodeForEvaluatedEffect: stack encoder: encoder	| position |	position := stack position.	self returns		ifTrue: 			[self emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1]		ifFalse: 			[self emitCodeExceptLast: stack encoder: encoder.			statements last emitCodeForEffect: stack encoder: encoder].	self assert: stack position = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:36'!emitCodeForEvaluatedValue: stack encoder: encoder	| position |	position := stack position.	self emitCodeExceptLast: stack encoder: encoder.	statements last emitCodeForBlockValue: stack encoder: encoder.	self assert: stack position - 1 = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55'!emitCodeForValue: stack encoder: encoder	self generateAsClosure ifTrue:		[^self emitCodeForClosureValue: stack encoder: encoder].	encoder genPushThisContext.	stack push: 1.	nArgsNode emitCodeForValue: stack encoder: encoder.	remoteCopyNode		emitCode: stack		args: 1		encoder: encoder.	"Force a two byte jump."	encoder genJumpLong: size.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitCodeForStorePop: stack encoder: encoder].	self emitCodeForEvaluatedValue: stack encoder: encoder.	self returns ifFalse:		[encoder genReturnTopToCaller.		pc := encoder methodStreamPosition].	stack pop: 1! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/29/2008 15:21'!sizeCodeExceptLast: encoder	| codeSize |	codeSize := 0.	1 to: statements size - 1 do: 		[:i | | statement |		 statement := statements at: i.		 codeSize := codeSize + (statement sizeCodeForEffect: encoder)].	^codeSize! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13'!sizeCodeForEvaluatedEffect: encoder	^self returns		ifTrue: [self sizeCodeForEvaluatedValue: encoder]		ifFalse: [(self sizeCodeExceptLast: encoder)				+ (statements last sizeCodeForEffect: encoder)]! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEvaluatedValue: encoder	^(self sizeCodeExceptLast: encoder)		+ (statements last sizeCodeForBlockValue: encoder)! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55'!sizeCodeForValue: encoder	self generateAsClosure ifTrue:		[^self sizeCodeForClosureValue: encoder].	nArgsNode := encoder encodeLiteral: arguments size.	remoteCopyNode := encoder encodeSelector: #blockCopy:.	size := self sizeCodeForEvaluatedValue: encoder.	self returns ifFalse:		[size := size + encoder sizeReturnTopToCaller]. "endBlock"	arguments := arguments collect:  "Chance to prepare debugger remote temps"						[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size := size + (arg sizeCodeForStorePop: encoder)].	^encoder sizePushThisContext	 + (nArgsNode sizeCodeForValue: encoder) 	 + (remoteCopyNode sizeCode: encoder args: 1 super: false)	 + (encoder sizeJumpLong: size)	 + size! !!BlockNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitBlockNode: self! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 19:23'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	| effectiveScope blockStart |	effectiveScope := optimized						ifTrue: [actualScopeIfOptimized := scopeBlock]						ifFalse: [self].	arguments ifNotNil:		[arguments do: [:temp| temp definingScope: self]].	temporaries ifNotNil:		[temporaries do: [:temp| temp definingScope: self]].	optimized ifFalse: "if optimized this isn't an actual scope"		[rootNode noteBlockEntry:			[:entryNumber|			 blockExtent := (blockStart := entryNumber) to: 0]].	"Need to enumerate a copy because closure analysis can add a statement	 via ifHasRemoteTempNodeEnsureInitializationStatementExists:."	statements copy do:		[:statement|		 statement analyseTempsWithin: effectiveScope rootNode: rootNode assignmentPools: assignmentPools].	optimized		ifTrue: "if optimized loop need to add nils for any temps read before written"			[optimizedMessageNode isOptimizedLoop ifTrue:				[self nilReadBeforeWrittenTemps]]		ifFalse: "if optimized this isn't an actual scope"			[rootNode noteBlockExit:				[:exitNumber|				 blockExtent := blockStart to: exitNumber]].	"Now that the analysis is done move any temps that need to be moved."	self postNumberingProcessTempsWithin: effectiveScope rootNode: rootNode.	"This is simply a nicety for compiler developers..."	temporaries do:		[:temp|		(temp isIndirectTempVector and: [temp name includes: $?]) ifTrue:			[temp name: temp definingScope remoteTempNodeName]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'nice 8/19/2010 16:31'!computeCopiedValues: rootNode	| referencedValues |	referencedValues := rootNode referencedValuesWithinBlockExtent: blockExtent.	^(referencedValues reject: [:temp| temp isDefinedWithinBlockExtent: blockExtent])		asArray sort: ParseNode tempSortBlock! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 2/3/2011 09:19'!deoptimize	optimized := false.	optimizedMessageNode := nil! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:36'!nilReadBeforeWrittenTemps	| visitor readBeforeWritten |	self accept: (visitor := OptimizedBlockLocalTempReadBeforeWrittenVisitor new).	readBeforeWritten := visitor readBeforeWritten.	temporaries reverseDo:		[:temp|		((readBeforeWritten includes: temp)		 and: [temp isRemote not]) ifTrue:			[statements addFirst: (AssignmentNode new variable: temp value: NodeNil)]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:30'!noteOptimizedIn: anOptimizedMessageNode	optimized := true.	optimizedMessageNode := anOptimizedMessageNode! !!BlockNode methodsFor: 'converting' stamp: 'eem 9/27/2011 15:23'!ensureNotQuick: encoder	"If the receiver is quick (can be generated as a Quick method, ^self,^inst var or ^ special constant)	 make it not so.  This is used to create break-pointable versions of quick methods.   Answer if the	 receiver was quick."	self isQuick ifFalse:		[^false].	"Making statements size > 1 is sufficient to cause isQuick to answer false (see BlockNode>>isQuick).	 N.B. This is a no-op since statements generate via emitCodeForEffect: and VariableNodes have no effect."	statements addFirst: (encoder encodeVariable: 'self').	^true! !!BlockNode commentStamp: '<historical>' prior: 0!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!BookMorph methodsFor: 'menu' stamp: 'cmm 12/4/2010 15:10'!setPageColor	"Get a color from the user, then set all the pages to that color"	self currentPage ifNil: [ ^ self ].	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: self currentPage color				setColorSelector: #setAllPagesColor:) openNear: self fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #setAllPagesColor: ;				 originalColor: self currentPage color ;								putUpFor: self				near: self fullBoundsInWorld ]! !!BookMorph methodsFor: 'other' stamp: 'cmm 12/6/2010 16:28'!exitFullScreen	| floater |	self isInFullScreenMode ifFalse: [ ^ self ].	self		setProperty: #fullScreenMode		toValue: false.	(self hasProperty: #showWorldMainDockingBarWhenNotFullScreen) ifTrue:		[ MorphicProject current showWorldMainDockingBar: (self valueOfProperty: #showWorldMainDockingBarWhenNotFullScreen).		self removeProperty: #showWorldMainDockingBarWhenNotFullScreen ].	floater := self		valueOfProperty: #floatingPageControls		ifAbsent: [  ].	floater ifNotNil:		[ floater delete.		self removeProperty: #floatingPageControls ].	self position: 0 @ 0.	self adjustCurrentPageForFullScreen! !!BookMorph methodsFor: 'other' stamp: 'cmm 12/6/2010 16:29'!goFullScreen	| floater |	self isInFullScreenMode ifTrue: [ ^ self ].	self		setProperty: #fullScreenMode		toValue: true.	self		setProperty: #showWorldMainDockingBarWhenNotFullScreen		toValue: Project current showWorldMainDockingBar.	Project current showWorldMainDockingBar: false.	self position: (currentPage topLeft - self topLeft) negated.	self adjustCurrentPageForFullScreen.	floater := self buildFloatingPageControls.	self		setProperty: #floatingPageControls		toValue: floater.	floater openInWorld! !!BookMorph methodsFor: 'sorting' stamp: 'ul 6/17/2011 12:32'!morphsForPageSorter	| thumbnails |	'Assembling thumbnail images...'		displayProgressFrom: 0 to: pages size		during:			[:bar | | i |			i := 0.			thumbnails := pages collect:				[:p | bar value: (i:= i+1).				pages size > 40 					ifTrue: [p smallThumbnailForPageSorter inBook: self]					ifFalse: [p thumbnailForPageSorter inBook: self]]].	^ thumbnails! !!Boolean methodsFor: 'logical operations' stamp: 'nice 2/1/2011 21:50'!==> aBlock	"this is material implication, a ==> b, also known as:			b if a 			a implies b			if a then b			b is a consequence of a			a therefore b (but note: 'it is raining therefore it is cloudy' is implication; 'it is autumn therefore the leaves are falling' is equivalence).			Here is the truth table for material implication (view in a monospaced font):		   p   |   q   |   p ==> q	-------|-------|-------------	   T   |   T   |      T	   T   |   F   |      F	   F   |   T   |      T	   F   |   F   |      T	"	self subclassResponsibility! !!BooleanScriptEditor methodsFor: 'dropping/grabbing' stamp: 'nice 5/8/2011 10:10'!wantsDroppedMorph: aMorph event: evt 	"Answer whether the receiver would be interested in accepting the morph"	(submorphs anySatisfy: [:m | m isAlignmentMorph]) 		ifTrue: [^ false].	((aMorph isKindOf: ParameterTile) and: [aMorph scriptEditor == self topEditor])		ifTrue: [^ true].	^ (aMorph isKindOf: PhraseTileMorph orOf: WatcherWrapper) 		and: [(#(#Command #Unknown) includes: aMorph resultType capitalized) not]! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/20/2010 13:33'!drawOn: aCanvas	"aCanvas fillRectangle: self bounds color: Color red" "for debugging"! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:22'!setDefaultColors! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:21'!setInverseColors! !!BorderedMorph methodsFor: 'geometry' stamp: 'ul 11/15/2010 11:17'!acquireBorderWidth: aBorderWidth	"Gracefully acquire the new border width, keeping the interior area intact and not seeming to shift"	| delta |	(delta := aBorderWidth- self borderWidth) = 0 ifTrue: [^ self].	self bounds: ((self bounds origin - (delta @ delta)) corner: (self bounds corner + (delta @ delta))).	self borderWidth: aBorderWidth.	self layoutChanged! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'ar 6/23/2010 17:09'!addEdgeGrips	"Add resizers along the four edges of the receiver"	self		addMorphBack: (TopGripMorph new target: self;position: self position).	self		addMorphBack: (BottomGripMorph new target: self;position: self position).	self		addMorphBack: (RightGripMorph new target: self;position: self position).	self		addMorphBack: (LeftGripMorph new target: self;position: self position).! !!BottomGripMorph methodsFor: 'target resize' stamp: 'ael 6/3/2011 00:39'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin corner: oldBounds corner + (0 @ delta y))! !!BottomGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!BottomGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 1 corner: 1 @ 1)		offsets: (0 @ self defaultHeight negated corner: 0@ 0)! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!ptName	^#bottom! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!resizeCursor	^ Cursor resizeForEdge: #top! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:40'!emitCodeForValue: stack encoder: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[elements do: [:node| node emitCodeForValue: stack encoder: encoder].		 encoder genPushConsArray: elements size.		 stack			pop: elements size;			push: 1.		 ^self].	^emitNode emitCodeForValue: stack encoder: encoder! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:22'!sizeCodeForValue: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])		  + (encoder sizePushConsArray: elements size)].	emitNode := elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^emitNode sizeCodeForValue: encoder! !!BraceNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitBraceNode: self! !!BracketMorph methodsFor: 'drawing' stamp: 'gvc 9/21/2006 16:16'!drawOn: aCanvas	"Draw triangles at the edges."		|r|	r := self horizontal		ifTrue: [self bounds insetBy: (2@1 corner: 2@1)]		ifFalse: [self bounds insetBy: (1@2 corner: 1@2)].	aCanvas		drawPolygon: (self leftOrTopVertices: self bounds)		fillStyle: self borderColor;		drawPolygon: (self leftOrTopVertices: r)		fillStyle: self fillStyle;		drawPolygon: (self rightOrBottomVertices: self bounds)		fillStyle: self borderColor;		drawPolygon: (self rightOrBottomVertices: r)		fillStyle: self fillStyle! !!BracketMorph methodsFor: 'accessing' stamp: 'gvc 9/21/2006 15:48'!horizontal	"Answer whether horizontal or vertical."		^self orientation == #horizontal! !!BracketMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 15:54'!horizontal: aBoolean	"Set whether horizontal or vertical."		^self orientation: (aBoolean ifTrue: [#horizontal] ifFalse: [#vertical])! !!BracketMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 15:51'!orientation	"Answer the value of orientation"	^ orientation! !!BracketMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 15:52'!orientation: anObject	"Set the value of orientation"	orientation := anObject.	self changed! !!BracketMorph methodsFor: 'initialization' stamp: 'gvc 9/19/2006 15:52'!initialize	"Initialize the receiver."	super initialize.	self		orientation: #horizontal! !!BracketMorph methodsFor: 'geometry' stamp: 'gvc 9/21/2006 15:45'!leftOrTopVertices: r	"Answer the vertices for a left or top bracket in the given rectangle."		^self orientation == #vertical		ifTrue: [{r topLeft - (0@1). r left + (r height // 2 + (r height \\ 2))@(r center y - (r height + 1 \\ 2)).				r left + (r height // 2 + (r height \\ 2))@(r center y). r bottomLeft}]		ifFalse: [{r topLeft. (r center x - (r width + 1 \\ 2))@(r top + (r width // 2 + (r width \\ 2))).				r center x@(r top + (r width // 2 + (r width \\ 2))). r topRight}]! !!BracketMorph methodsFor: 'geometry' stamp: 'gvc 9/21/2006 16:18'!rightOrBottomVertices: r	"Answer the vertices for a right or bottom bracket in the given rectangle."		^self orientation == #vertical		ifTrue: [{r topRight - (0@1). r right - (r height // 2 + (r height \\ 2))@(r center y - (r height + 1 \\ 2)).				r right - (r height // 2 + (r height \\ 2))@(r center y). r bottomRight}]		ifFalse: [{(r center x)@(r bottom - 1 - (r width // 2 + (r width \\ 2))).				r center x @(r bottom - 1 - (r width // 2 + (r width \\ 2))). r bottomRight. r bottomLeft - (1@0)}]! !!BracketMorph commentStamp: 'gvc 5/18/2007 13:48' prior: 0!Morph displaying opposing arrows.!!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:40'!defaultFillStyle	"Answer the defauolt fill style."	^Color gray! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:40'!extent: aPoint	"Update the gradient directions."	super extent: aPoint.	self updateFillStyle! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/7/2007 16:05'!fillStyleToUse	"Answer the fillStyle that should be used for the receiver."		^self fillStyle! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 14:06'!gradient	"Answer the gradient."	self subclassResponsibility! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/2/2010 21:26'!initialize	"Initialize the receiver."	super initialize.	self		fillStyle: self defaultFillStyle;		borderStyle: (BorderStyle inset baseColor: self color; width: 1);		sliderColor: Color black;		clipSubmorphs: true! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 15:53'!initializeSlider	"Make the slider raised."		slider :=( BracketMorph newBounds: self totalSliderArea)		horizontal: self bounds isWide;		color: self thumbColor;		borderStyle: (BorderStyle raised baseColor: Color white; width: 1).	sliderShadow := (BracketMorph newBounds: self totalSliderArea)		horizontal: self bounds isWide;		color: self pagingArea color;		borderStyle: (BorderStyle inset baseColor: (Color white alpha: 0.6); width: 1).	slider on: #mouseMove send: #scrollAbsolute: to: self.	slider on: #mouseDown send: #mouseDownInSlider: to: self.	slider on: #mouseUp send: #mouseUpInSlider: to: self.	"(the shadow must have the pagingArea as its owner to highlight properly)"	self pagingArea addMorph: sliderShadow.	sliderShadow hide.	self addMorph: slider.	self computeSlider.! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:41'!layoutBounds: aRectangle	"Set the bounds for laying out children of the receiver.	Note: written so that #layoutBounds can be changed without touching this method"		super layoutBounds: aRectangle.	self updateFillStyle.	slider horizontal: self bounds isWide.	sliderShadow horizontal: self bounds isWide! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 11:34'!roomToMove	"Allow to run off the edges a bit."		^self bounds isWide		ifTrue: [self totalSliderArea insetBy: ((self sliderThickness // 2@0) negated corner: (self sliderThickness // 2 + 1)@0)]		ifFalse: [self totalSliderArea insetBy: (0@(self sliderThickness // 2) negated corner: 0@(self sliderThickness // 2 - (self sliderThickness \\ 2) + 1))]! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/8/2009 13:29'!sliderColor: newColor	"Set the slider colour."		super sliderColor: (self enabled ifTrue: [Color black] ifFalse: [self sliderShadowColor]).	slider ifNotNil: [slider borderStyle baseColor: Color white]! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 15:43'!sliderShadowColor	"Answer the color for the slider shadow."		^Color black alpha: 0.6! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/26/2006 12:02'!sliderThickness	"Answer the thickness of the slider."		^((self bounds isWide		ifTrue: [self height]		ifFalse: [self width]) // 2 max: 8) // 2 * 2 + 1! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:41'!updateFillStyle	"Update the fill style directions."	|b fs|	fs := self fillStyle.	fs isOrientedFill ifTrue: [		b := self innerBounds.		fs origin: b topLeft.		fs direction: (b isWide			ifTrue: [b width@0]			ifFalse: [0@b height])]! !!BracketSliderMorph commentStamp: 'gvc 5/18/2007 13:39' prior: 0!Abstract superclass for morphs that are used to select a component (R, G, B or A) of a colour.!!BreakpointManager class methodsFor: 'intialization-release' stamp: 'emm 5/30/2002 09:08'!clear	"BreakpointManager clear"	self installed copy keysDo:[ :breakMethod |		self unInstall: breakMethod].				! !!BreakpointManager class methodsFor: 'private' stamp: 'nice 2/23/2011 21:38'!breakpointMethodSourceFor: aSymbol in: aClass 	"Compose new source containing a break statement (currently it will be the first,	later we want to insert it in any place)"	| oldSource methodNode breakOnlyMethodNode sendBreakMessageNode |	oldSource := aClass sourceCodeAt: aSymbol.	methodNode := aClass newCompiler		compile: oldSource		in: aClass 		notifying: nil 		ifFail: [self error: '[breakpoint] unable to install breakpoint'].	breakOnlyMethodNode := aClass newCompiler		compile: 'temporaryMethodSelectorForBreakpointself break.^self'		in: aClass 		notifying: nil 		ifFail: [self error: '[breakpoint] unable to install breakpoint'].	sendBreakMessageNode := breakOnlyMethodNode block statements first.	methodNode block statements addFirst: sendBreakMessageNode.	^methodNode printString	! !!BreakpointManager class methodsFor: 'private' stamp: 'nice 2/23/2011 21:38'!compilePrototype: aSymbol in: aClass 	"Compile and return a new method containing a break statement"	| source node method |	source := self breakpointMethodSourceFor: aSymbol in: aClass.	node := aClass newCompiler		compile: source		in: aClass 		notifying: nil 		ifFail: [self error: '[breakpoint] unable to install breakpoint'].	node isNil ifTrue: [^nil].	"dunno what the arguments mean..."	method := node generate.	^method! !!BreakpointManager class methodsFor: 'private' stamp: 'nice 8/27/2010 22:14'!installed	^Installed ifNil: [Installed := IdentityDictionary new]! !!BrowseTest methodsFor: 'testing' stamp: 'eem 5/23/2011 17:02'!testFindReferencesToFloatNaN	self assert: (SystemNavigation new allCallsOn: (Float bindingOf: #NaN)) notEmpty! !!BrowseTest methodsFor: 'testing' stamp: 'eem 7/25/2011 10:21'!testSystemNavigationAllBehaviorsDo	| oc |	oc := OrderedCollection new.	SystemNavigation new allBehaviorsDo:		[:c| oc add: c].	self assert: oc size = oc asSet size! !!Browser methodsFor: 'accessing' stamp: 'fbs 3/3/2011 18:42'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod := currentCompiledMethod.	currentCompiledMethod := nil.	editSelection == #newTrait		ifTrue: [^ClassDescription newTraitTemplateIn: self selectedSystemCategory].	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass := self selectedClass)			ifNil:				[Class template: self selectedSystemCategory]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategory]].	editSelection == #editClass 		ifTrue: [^self classDefinitionText].	editSelection == #editComment 		ifTrue:			[(theClass := self selectedClass) ifNil: [^ ''].			comment := theClass comment.			currentCompiledMethod := theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [^self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue:			[^ (theClass := self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[^ self editContentsWithDefault:				[currentCompiledMethod := latestCompiledMethod.				self selectedMessage]].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'accessing' stamp: 'fbs 3/17/2011 07:56'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	self hasMessageCategorySelected & (self hasMessageSelected not)		ifTrue: [^ 1 to: 500]	"entire empty method template"		ifFalse: [^ 1 to: 0]  "null selection"! !!Browser methodsFor: 'accessing' stamp: 'nice 5/8/2011 10:11'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	^self dependents		anySatisfy: [:d | (d respondsTo: #getListSelector)				and: [d getListSelector == #systemCategoryList]]! !!Browser methodsFor: 'accessing' stamp: 'nice 3/31/2011 21:51'!doItReceiver	"This class's classPool has been jimmied to be the classPool of the class 	being browsed. A doIt in the code pane will let the user see the value of 	the class variables."	^ self selectedClass! !!Browser methodsFor: 'accessing' stamp: 'fbs 3/4/2011 20:57'!noteSelectionIndex: anInteger for: aSymbol	aSymbol == #systemCategoryList		ifTrue:			[self systemCategoryListIndex: anInteger].	aSymbol == #classList		ifTrue:			[self classListIndex: anInteger].	aSymbol == #messageCategoryList		ifTrue:			[self messageCategoryListIndex: anInteger].	aSymbol == #messageList		ifTrue:			[self messageListIndex: anInteger].! !!Browser methodsFor: 'accessing' stamp: 'fbs 3/3/2011 22:58'!spawn: aString 	"Create and schedule a fresh browser and place aString in its code pane.  This method is called when the user issues the #spawn command (cmd-o) in any code pane.  Whatever text was in the original code pane comes in to this method as the aString argument; the changes in the original code pane have already been cancelled by the time this method is called, so aString is the only copy of what the user had in his code pane."	self selectedClassOrMetaClass ifNotNil: [^ super spawn: aString].	self hasSystemCategorySelected ifTrue:		["This choice is slightly useless but is the historical implementation"		^ self buildSystemCategoryBrowserEditString: aString].			^ super spawn: aString  	"This bail-out at least saves the text being spawned, which would otherwise be lost"! !!Browser methodsFor: 'annotation' stamp: 'bf 4/12/2011 15:27'!annotation: aText 	"The user accepted aText in our annotation pane"	| theClass |	(theClass := self selectedClass) ifNil: [^false].	self editSelection == #editClass		ifTrue: [			self stripNaggingAttributeFromComment: aText.			theClass comment: aText stamp: Utilities changeStamp.			self changed: #classCommentText.			^ true].	^ false! !!Browser methodsFor: 'breakpoints' stamp: 'jmv 3/2/2010 15:43'!toggleBreakOnEntry	"Install or uninstall a halt-on-entry breakpoint"	| selectedMethod |	self selectedClassOrMetaClass ifNil: [ ^self].	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.	selectedMethod hasBreakpoint		ifTrue:			[BreakpointManager unInstall: selectedMethod]		ifFalse:			[BreakpointManager 				installInClass: self selectedClassOrMetaClass				selector: self selectedMessageName].	self changed: #messageList! !!Browser methodsFor: 'class comment pane' stamp: 'bf 4/12/2011 14:58'!stripNaggingAttributeFromComment: aText	^aText removeAttribute: TextColor red from: 1 to: aText size! !!Browser methodsFor: 'class functions' stamp: 'cmm 5/2/2011 09:56'!classListMenu: aMenu shifted: shifted	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	self 		menuHook: aMenu 		named: #classListMenu 		shifted: shifted.	Preferences useOnlyServicesInMenu ifTrue:[^aMenu].	shifted ifTrue:[^ self shiftedClassListMenu: aMenu].	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('references... (r)'			browseVariableReferences)		('assignments... (a)'			browseVariableAssignments)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		-		('more...'					offerShiftedClassListMenu)).	^ aMenu! !!Browser methodsFor: 'class functions' stamp: 'fbs 3/4/2011 20:56'!copyClass	| originalClass originalName copysName |	self hasClassSelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	originalClass := self selectedClass.	originalName := originalClass name.	copysName := self request: 'Please type new class name' initialAnswer: originalName.	copysName = '' ifTrue: [^ self].  " Cancel returns '' "	copysName := copysName asSymbol.	copysName = originalName ifTrue: [^ self].	(Smalltalk hasClassNamed: copysName)		ifTrue: [^ self error: copysName , ' already exists'].	Cursor wait showWhile: [		| newDefinition newMetaDefinition newClass |		newDefinition := originalClass definition			copyReplaceAll: originalName printString			with: copysName printString.		newClass := Compiler evaluate: newDefinition logged: true.		newMetaDefinition := originalClass class definition			copyReplaceAll: originalClass class name			with: newClass class name.		Compiler evaluate: newMetaDefinition logged: true.		newClass copyAllCategoriesFrom: originalClass.		newClass class copyAllCategoriesFrom: originalClass class.		originalClass hasComment ifTrue: [			newClass comment: originalClass comment ] ].	self classListIndex: 0.	self changed: #classList! !!Browser methodsFor: 'class functions' stamp: 'eem 8/12/2009 11:52'!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection,	 except do NOT clobber or override any selectors already understood by the instances of the selected class"	self selectedClassOrMetaClass ifNotNil:		[:aClass| | cr |		cr := String with: Character cr.		aClass instVarNames do: 			[:aName | | newMessage setter |			(aClass canUnderstand: aName asSymbol) ifFalse:				[newMessage :=					aName, cr,					'	"Answer the value of ', aName, '"', cr, cr,					'	^ ', aName.				aClass compile: newMessage classified: #accessing notifying: nil].			(aClass canUnderstand: (setter := aName, ':') asSymbol) ifFalse:				[newMessage :=					setter, ' anObject', cr,					'	"Set the value of ', aName, '"', cr, cr,						(aClass settersReturnValue ifTrue: ['	^'] ifFalse: ['	']),						aName, ' := anObject'.				aClass compile: newMessage classified: #accessing notifying: nil]]]! !!Browser methodsFor: 'class functions' stamp: 'ul 12/9/2011 02:33'!defineClass: defString notifying: aController  	"The receiver's textual content is a request to define a new class. The	source code is defString. If any errors occur in compilation, notify	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass := self selectedClassOrMetaClass.	defTokens := defString findTokens: Character separators.		((defTokens first = 'Trait' and: [defTokens second = 'named:'])		or: [defTokens second = 'classTrait'])		ifTrue: [^self defineTrait: defString notifying: aController].			keywdIx := defTokens findFirst: [:x | x beginsWith: 'category'].	envt := Smalltalk.	keywdIx := defTokens findFirst: [:x | '*subclass*' match: x].	newClassName := (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldClass isNil or: [oldClass theNonMetaClass name asString ~= newClassName])		and: [envt includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass := oldClass superclass].	class := oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: false.	(class isKindOf: Behavior)		ifTrue: [self changed: #systemCategoryList.				self changed: #classList.				self clearUserEditFlag.				self setClass: class selector: nil.				"self clearUserEditFlag; editClass."				^ true]		ifFalse: [^ false]! !!Browser methodsFor: 'class functions' stamp: 'fbs 3/4/2011 20:53'!editClass	"Retrieve the description of the class definition."	self hasClassSelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #editClass.	self changed: #contents.	self changed: #classCommentText.! !!Browser methodsFor: 'class functions' stamp: 'fbs 3/4/2011 20:53'!editComment	"Retrieve the description of the class comment."	self hasClassSelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	metaClassIndicated := false.	self editSelection: #editComment.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self decorateButtons.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'nice 5/8/2011 10:13'!explainSpecial: string 	"Answer a string explaining the code pane selection if it is displaying 	one of the special edit functions."	| classes whole lits reply |	(editSelection == #editClass or: [editSelection == #newClass])		ifTrue: 			["Selector parts in class definition"			string last == $: ifFalse: [^nil].			lits := Array with:				#subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:.			(whole := lits					detect: [:each | each keywords anySatisfy: [:frag | frag = string] ]					ifNone: []) ~~ nil				ifTrue: [reply := '"' , string , ' is one part of the message selector ' , whole , '.']				ifFalse: [^nil].			classes := self systemNavigation allClassesImplementing: whole.			classes := 'these classes ' , classes printString.			^reply , '  It is defined in ' , classes , '."Smalltalk browseAllImplementorsOf: #' , whole].	editSelection == #hierarchy		ifTrue: 			["Instance variables in subclasses"			classes := self selectedClassOrMetaClass allSubclasses.			classes := classes					detect: [:each | each instVarNames anySatisfy: [:name | name = string] ]					ifNone: [^nil].			classes := classes printString.			^'"is an instance variable in class ' , classes , '."' , classes , ' browseAllAccessesTo: ''' , string , '''.'].	editSelection == #editSystemCategories ifTrue: [^nil].	editSelection == #editMessageCategories ifTrue: [^nil].	^nil! !!Browser methodsFor: 'class functions' stamp: 'fbs 3/4/2011 20:56'!fileOutClass	"Print a description of the selected class onto a file whose name is the 	category name followed by .st."Cursor write showWhile:		[self hasClassSelected ifTrue: [self selectedClass fileOut]]! !!Browser methodsFor: 'class functions' stamp: 'fbs 3/4/2011 20:52'!hierarchy	"Display the inheritance hierarchy of the receiver's selected class."	self hasClassSelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #hierarchy.	self changed: #editComment.	self contentsChanged.	^ self! !!Browser methodsFor: 'class functions' stamp: 'fbs 3/4/2011 20:54'!plusButtonHit	"Cycle among definition, comment, and hierachy"	editSelection == #editComment		ifTrue: [self hierarchy. ^ self].	editSelection == #hierarchy		ifTrue: [self editSelection: #editClass.			self hasClassSelected ifFalse: [^ self].			self okToChange ifFalse: [^ self].			self changed: #editComment.			self contentsChanged.			^ self].	self editComment! !!Browser methodsFor: 'class functions' stamp: 'fbs 3/4/2011 20:52'!printOutClass	"Print a description of the selected class onto a file whose name is the 	category name followed by .html."Cursor write showWhile:		[self hasClassSelected ifTrue: [self selectedClass fileOutAsHtml: true]]! !!Browser methodsFor: 'class functions' stamp: 'fbs 9/10/2011 14:54'!renameClass	| oldName newName obs |	self hasClassSelected ifFalse: [^ self].	self okToChange		ifFalse: [^ self].	oldName := self selectedClass name.	newName := self request: 'Please type new class name' initialAnswer: oldName.	newName = ''		ifTrue: [^ self].	"Cancel returns ''"	newName := newName asSymbol.	newName = oldName		ifTrue: [^ self].	(self selectedClass environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	self selectedClass rename: newName.	selectedClassName := newName.	self changed: #classList.	obs := self systemNavigation				allCallsOn: (self selectedClass environment associationAt: newName).	obs isEmpty		ifFalse: [self systemNavigation				browseMessageList: obs				name: 'Obsolete References to ' , oldName				autoSelect: oldName].	self selectClassNamed: newName.! !!Browser methodsFor: 'class list' stamp: 'fbs 3/16/2011 10:43'!classListIndex	"Answer the index of the current class selection."	^ self classListIndexOf: self selectedClassName.! !!Browser methodsFor: 'class list' stamp: 'fbs 3/16/2011 10:54'!classListIndex: anInteger 	| newClassName |	newClassName := self classList at: anInteger ifAbsent: [ nil ].	newClassName := newClassName ifNotNil: [newClassName withoutLeadingBlanks asSymbol].	self selectClassNamed: newClassName.! !!Browser methodsFor: 'class list' stamp: 'fbs 3/14/2011 17:27'!classListIndexOf: className 	| classList |	classList := self classList.	classList := classList collect: [:ea | ea withoutLeadingBlanks asSymbol].	^ classList indexOf: className.! !!Browser methodsFor: 'class list' stamp: 'fbs 3/3/2011 17:46'!defaultClassList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."			^ self hasSystemCategorySelected		ifTrue: [systemOrganizer listAtCategoryNamed: self selectedSystemCategory]		ifFalse: [Array new].! !!Browser methodsFor: 'class list' stamp: 'fbs 3/13/2011 21:11'!flattenHierarchyTree: classHierarchy on: col indent: indent	^ self		flattenHierarchyTree: classHierarchy		on: col		indent: indent		by: Character space.! !!Browser methodsFor: 'class list' stamp: 'fbs 3/13/2011 21:20'!flattenHierarchyTree: classHierarchy on: col indent: indent by: indentChars	"Recursively add to col the names in classHierarchy indenting to show the hierarchical relationship. Use indentChars to do the indenting: spaces, tabs, etc."	| plusIndent |	plusIndent := indentChars.	classHierarchy do: [:assoc |		| class childs |		class := assoc key.		col add: indent , class name.		childs := assoc value.		self			flattenHierarchyTree: childs			on: col			indent: indent , plusIndent			by: indentChars].	^ col! !!Browser methodsFor: 'class list' stamp: 'fbs 3/14/2011 17:57'!hasClassSelected	^ selectedClassName notNil.! !!Browser methodsFor: 'class list' stamp: 'ul 11/15/2010 11:30'!recent	"Let the user select from a list of recently visited classes.  11/96 stp.	 12/96 di:  use class name, not classes themselves.	 : dont fall into debugger in empty case"	| className class recentList |	recentList := RecentClasses select: [:n | Smalltalk hasClassNamed: n].	recentList size = 0 ifTrue: [^ Beeper beep].	className := UIManager default chooseFrom: recentList values: recentList.	className == nil ifTrue: [^ self].	class := Smalltalk at: className.	self selectCategoryForClass: class.	self classListIndex: (self classListIndexOf: class name)! !!Browser methodsFor: 'class list' stamp: 'fbs 3/16/2011 07:57'!selectClass: classNotMeta	^ self selectClassNamed:		(classNotMeta			ifNil: [ nil ]			ifNotNil: [ classNotMeta name ]).! !!Browser methodsFor: 'class list' stamp: 'fbs 6/27/2011 12:44'!selectClassNamed: aSymbolOrString	| className currentMessageCategoryName currentMessageName |	currentMessageCategoryName := [self selectedMessageCategoryName]										on: Error										do: [:ex| ex return: nil].	currentMessageName := [self selectedMessageName]								on: Error								do: [:ex| ex return: nil].									selectedClassName := aSymbolOrString ifNotNil: [ aSymbolOrString asSymbol ].	self setClassOrganizer.	"Try to reselect the category and/or selector if the new class has them."	selectedMessageCategoryName :=(self messageCategoryList includes: currentMessageCategoryName)		ifTrue: [currentMessageCategoryName]		ifFalse: [nil].	selectedMessageName := (self messageList includes: currentMessageName)		ifTrue: [currentMessageName]		ifFalse: [nil].	self hasMessageSelected ifTrue:		[self editSelection: #editMessage] ifFalse:	[self hasMessageCategorySelected ifTrue:		[self editSelection: #newMessage] ifFalse:	[self classCommentIndicated		ifTrue: [self editSelection: #editComment]		ifFalse: [self editSelection: (self hasClassSelected not					ifTrue: [(metaClassIndicated or: [ self hasSystemCategorySelected not ])						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])]]].	contents := nil.	self selectedClass isNil		ifFalse: [className := self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'class list' stamp: 'fbs 4/25/2011 19:27'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	| name envt |	(name := self selectedClassName) ifNil: [^ nil].	(envt := self selectedEnvironment) ifNil: [^ nil].	^ envt at: name ifAbsent: [nil]! !!Browser methodsFor: 'class list' stamp: 'fbs 3/16/2011 10:43'!selectedClassName	^ selectedClassName.! !!Browser methodsFor: 'code pane' stamp: 'cmm 3/13/2011 17:31'!codePaneMenu: aMenu shifted: shifted 	self 		menuHook: aMenu 		named: #codePaneMenu 		shifted: shifted.	Preferences useOnlyServicesInMenu ifTrue:[^aMenu].	^super codePaneMenu: aMenu shifted: shifted.! !!Browser methodsFor: 'code pane' stamp: 'fbs 3/30/2011 22:01'!compileMessage: aText notifying: aController	"Compile the code that was accepted by the user, placing the compiled method into an appropriate message category.  Return true if the compilation succeeded, else false."	| fallBackCategoryName originalSelectorName result fallBackMethodName |	self selectedMessageCategoryName ifNil:			[ self selectOriginalCategoryForCurrentMethod 											ifFalse:["Select the '--all--' category"											self messageCategoryListIndex: 1]]. 	self selectedMessageCategoryName asSymbol = ClassOrganizer allCategory		ifTrue:			[ "User tried to save a method while the ALL category was selected"			fallBackCategoryName := selectedMessageCategoryName.			fallBackMethodName := selectedMessageName.			editSelection == #newMessage				ifTrue:					[ "Select the 'as yet unclassified' category"					selectedMessageCategoryName := nil.					(result := self defineMessageFrom: aText notifying: aController)						ifNil:							["Compilation failure:  reselect the original category & method"							selectedMessageCategoryName := fallBackCategoryName.							selectedMessageName := fallBackMethodName]						ifNotNil:							[self setSelector: result]]				ifFalse:					[originalSelectorName := self selectedMessageName.					self setOriginalCategoryIndexForCurrentMethod.					selectedMessageName := fallBackMethodName := originalSelectorName.								(result := self defineMessageFrom: aText notifying: aController)						ifNotNil:							[self setSelector: result]						ifNil:							[ "Compilation failure:  reselect the original category & method"							selectedMessageCategoryName := fallBackCategoryName.							selectedMessageName := fallBackMethodName.							^ result notNil]].			self changed: #messageCategoryList.			^ result notNil]		ifFalse:			[ "User tried to save a method while the ALL category was NOT selected"			^ (self defineMessageFrom: aText notifying: aController) notNil]! !!Browser methodsFor: 'copying' stamp: 'fbs 3/30/2011 21:51'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  See DeepCopier class comment."super veryDeepInner: deepCopier."systemOrganizer := systemOrganizer. 	clone has the old value. we share it""classOrganizer := classOrganizer		clone has the old value. we share it""metaClassOrganizer 	:= metaClassOrganizer	clone has the old value. we share it"selectedSystemCategory := selectedSystemCategory veryDeepCopyWith: deepCopier.selectedClassName := selectedClassName veryDeepCopyWith: deepCopier.selectedMessageCategoryName := selectedMessageCategoryName veryDeepCopyWith: deepCopier.selectedMessageName := selectedMessageName veryDeepCopyWith: deepCopier.editSelection := editSelection veryDeepCopyWith: deepCopier.metaClassIndicated := metaClassIndicated veryDeepCopyWith: deepCopier.! !!Browser methodsFor: 'drag and drop' stamp: 'laza 12/10/2010 10:37'!dropOnMessageCategories: method at: index	| dstClass category copy |	copy := Sensor shiftPressed.	(method isKindOf: CompiledMethod) 		ifFalse:[^self inform: 'Can only drop methods'].	dstClass := self selectedClassOrMetaClass.	(dstClass == method methodClass) ifTrue:[		category := self messageCategoryList at: index.		category = ClassOrganizer allCategory ifTrue: [^false].		dstClass organization classify: method selector  under: category suppressIfDefault: false.		^true].	copy ifFalse: [		(self confirm: (			'Classes {1} and {2} are unrelated.{3}Are you sure you want to move this method?'				format: { method methodClass. dstClass. Character cr })) 					ifFalse: [ ^false ] ].	dstClass		compile: method getSource		classified: (self messageCategoryList at: index)		withStamp: method timeStamp		notifying: nil.	copy ifFalse: [		method methodClass removeSelector: method selector ].	^true! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:53'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!Browser methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 19:06'!labelString	| label |	label := self selectedClass				ifNil: [ self defaultBrowserTitle ]				ifNotNil: [ self defaultBrowserTitle, ': ', self selectedClass printString ].	(multiWindowState notNil	 and: [multiWindowState models size > 1]) ifTrue:		[label := (multiWindowState models indexOf: self) printString, '. ', label].	^label! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 15:50'!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	"Example:		Browser newOnClass: Browser.	"	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0.0@0.0 corner: 0.5@0.08) -> [self buildClassListSingletonWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0 width: 0.5 bottomFraction: max) -> [self buildMessageCategoryListWith: builder].		(self topConstantHeightFrame: self buttonHeight fromLeft: 0.5 width: 0.5) -> [self buildSwitchesWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0.5 width: 0.5 bottomFraction: max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 3/30/2011 21:48'!systemOrganizer: aSystemOrganizer	"Initialize the receiver as a perspective on the system organizer, 	aSystemOrganizer. Typically there is only one--the system variable 	SystemOrganization."		contents := nil.	systemOrganizer := aSystemOrganizer.	selectedSystemCategory := nil.	selectedMessageCategoryName := nil.	selectedClassName := nil.	selectedMessageName := nil.	metaClassIndicated := false.	self setClassOrganizer.	self editSelection: #none.! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:52'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !!Browser methodsFor: 'message category functions' stamp: 'fbs 3/30/2011 21:57'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines menuIndex newName oldCategory |	self okToChange ifFalse: [^ self].	self hasClassSelected ifFalse: [^ self].	labels := OrderedCollection with: 'new...'.	reject := Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines := OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls | | cats |		cls = Object ifFalse: [			cats := cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asSortedCollection.				reject addAll: cats]]].	newName := (labels size = 1 or: [		menuIndex := (UIManager default chooseFrom: labels lines: lines title: 'Add Category').		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldCategory := self selectedMessageCategoryName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName := newName asSymbol].	self classOrMetaClassOrganizer		addCategory: newName		before: (self hasMessageCategorySelected				ifFalse: [nil]				ifTrue: [self selectedMessageCategoryName]).	self changed: #messageCategoryList.	self selectMessageCategoryNamed:		(oldCategory isNil			ifTrue: [self classOrMetaClassOrganizer categories last]			ifFalse: [oldCategory]).	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'fbs 5/1/2011 08:47'!alphabetizeMessageCategories	| oldMessageCategory oldMethod |	oldMessageCategory := selectedMessageCategoryName.	oldMethod := selectedMessageName.	self hasClassSelected ifFalse: [^ false].	self okToChange ifFalse: [^ false].	self classOrMetaClassOrganizer sortCategories.	self clearUserEditFlag.	self editClass.	self selectClassNamed: selectedClassName.	self selectMessageCategoryNamed: oldMessageCategory.	self selectMessageNamed: oldMethod.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'fbs 3/30/2011 17:40'!buildMessageCategoryBrowserEditString: aString 	"Create and schedule a message category browser for the currently 	selected	 message category. The initial text view contains the characters 	in aString."	"wod 6/24/1998: set newBrowser classListIndex so that it works whether the	receiver is a standard or a Hierarchy Browser."	| newBrowser |	^ self hasMessageCategorySelected		ifFalse: [ nil ]		ifTrue: 			[newBrowser := Browser new.			newBrowser selectSystemCategory: self selectedSystemCategory.			newBrowser selectClass: self selectedClass.			newBrowser metaClassIndicated: self metaClassIndicated.			newBrowser selectMessageCategoryNamed: self selectedMessageCategoryName.			newBrowser selectMessageNamed: self selectedMessageName.			self class openBrowserView: (newBrowser openMessageCatEditString: aString)				label: 'Message Category Browser (' , 						newBrowser selectedClassOrMetaClassName , ')'.			newBrowser.].! !!Browser methodsFor: 'message category functions' stamp: 'fbs 3/14/2011 17:43'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self clearUserEditFlag.	self editClass.	self selectClassNamed: selectedClassName.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'fbs 3/4/2011 20:53'!editMessageCategories	"Indicate to the receiver and its dependents that the message categories of 	the selected class have been changed."	self okToChange ifFalse: [^ self].	self hasClassSelected		ifTrue: 			[self messageCategoryListIndex: 0.			self editSelection: #editMessageCategories.			self changed: #editMessageCategories.			self contentsChanged]! !!Browser methodsFor: 'message category functions' stamp: 'fbs 3/30/2011 07:50'!fileOutMessageCategories	"Print a description of the selected message category of the selected class 	onto an external file."Cursor write showWhile:	[self hasMessageCategorySelected		ifTrue: 			[self selectedClassOrMetaClass fileOutCategory: self selectedMessageCategoryName]]! !!Browser methodsFor: 'message category functions' stamp: 'cmm 3/13/2011 17:32'!messageCategoryMenu: aMenu	self 		menuHook: aMenu 		named: #messageCategoryMenu 		shifted: false.	Preferences useOnlyServicesInMenu ifTrue:[^aMenu].	^ aMenu labels:'browseprintOutfileOutreorganizealphabetizeremove empty categoriescategorize all uncategorizednew category...rename...remove'		lines: #(3 8)		selections:		#(buildMessageCategoryBrowser printOutMessageCategories fileOutMessageCategories		editMessageCategories alphabetizeMessageCategories removeEmptyCategories		categorizeAllUncategorizedMethods addCategory renameCategory removeMessageCategory)! !!Browser methodsFor: 'message category functions' stamp: 'fbs 3/30/2011 07:55'!printOutMessageCategories	"Print a description of the selected message category of the selected class 	onto an external file in Html format."Cursor write showWhile:	[self hasMessageCategorySelected		ifTrue: 			[self selectedClassOrMetaClass fileOutCategory: self selectedMessageCategoryName										asHtml: true]]! !!Browser methodsFor: 'message category functions' stamp: 'fbs 3/30/2011 08:01'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	self hasMessageCategorySelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	messageCategoryName := self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?'])		ifTrue: 			[self selectedClassOrMetaClass removeCategory: messageCategoryName.			self selectMessageCategoryNamed: nil.			self changed: #classSelectionChanged].	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'fbs 3/30/2011 07:59'!renameCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldName newName |	self hasClassSelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	self hasMessageCategorySelected ifFalse: [^ self].			oldName := self selectedMessageCategoryName.	newName := self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName := newName asSymbol].	newName = oldName ifTrue: [^ self].	self classOrMetaClassOrganizer		renameCategory: oldName		toBe: newName.	self selectClassNamed: selectedClassName.	self selectMessageCategoryNamed: oldName.	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/4/2011 17:40'!hasMessageCategorySelected	^ self selectedMessageCategoryName notNil.! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/4/2011 17:33'!messageCategoryList	"Answer the selected category of messages."	self hasClassSelected		ifTrue: [^ (Array with: ClassOrganizer allCategory), self classOrMetaClassOrganizer categories]		ifFalse: [^ Array new]! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/30/2011 21:37'!messageCategoryListIndex	"Answer the index of the selected message category."	^self messageCategoryList indexOf: selectedMessageCategoryName ifAbsent: [0].! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/30/2011 21:43'!messageCategoryListIndex: anInteger	"Set the selected message category to be the one indexed by anInteger."	selectedMessageCategoryName := nil.	self selectMessageCategoryNamed: (self messageCategoryList at: anInteger ifAbsent: [nil]).! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/30/2011 21:58'!rawMessageCategoryList	^ self hasClassSelected		ifTrue: [self classOrMetaClassOrganizer categories]		ifFalse: [Array new]! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/30/2011 21:55'!selectMessageCategoryNamed: aSymbol 	"Given aSymbol, select the category with that name.  Do nothing if 	aSymbol doesn't exist."	selectedMessageCategoryName := aSymbol.		selectedMessageName := nil.	self changed: #messageCategorySelectionChanged.	self changed: #messageCategoryListIndex. "update my selection"	self changed: #messageList.	self editSelection: (aSymbol notNil		ifTrue: [#newMessage]		ifFalse: [self hasClassSelected			ifTrue: [#editClass]			ifFalse: [#newClass]]).	contents := nil.	self contentsChanged.! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/30/2011 21:50'!selectOriginalCategoryForCurrentMethod	"private - Select the message category for the current method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected. 	 	 Returns: true on success, false on failure."	| aSymbol selectorName |	aSymbol := self categoryOfCurrentMethod.	selectorName := self selectedMessageName.	(aSymbol notNil and: [aSymbol ~= ClassOrganizer allCategory])		ifTrue: 			[selectedMessageCategoryName := aSymbol.			selectedMessageName := selectorName.			self changed: #messageCategorySelectionChanged.			self changed: #messageCategoryListIndex.	"update my selection"			self changed: #messageList.			self changed: #messageListIndex.			^ true].	^ false! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/30/2011 21:50'!selectedMessageCategoryName	"Answer the name of the selected message category, if any. Answer nil 	otherwise."	^ selectedMessageCategoryName! !!Browser methodsFor: 'message category list' stamp: 'fbs 3/30/2011 21:50'!setOriginalCategoryIndexForCurrentMethod	"private - Set the message category index for the currently selected method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected."	selectedMessageCategoryName := self categoryOfCurrentMethod.! !!Browser methodsFor: 'message functions' stamp: 'nice 2/23/2011 21:45'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName := self selectedMessageName.	oldMessageList := self messageList.	contents := nil.	selector := (self selectedClassOrMetaClass newParser parseSelector: aString).	(self metaClassIndicated		and: [(self selectedClassOrMetaClass includesSelector: selector) not		and: [Metaclass isScarySelector: selector]])		ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"				(self confirm: ((selector , ' is used in the existing class system.Overriding it could cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: selector size))				ifFalse: [^nil]].	selector := self selectedClassOrMetaClass				compile: aString				classified: (category := self selectedMessageCategoryName)				notifying: aController.	selector == nil ifTrue: [^ nil].	contents := aString copy.	selector ~~ selectedMessageName		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)].	^ selector! !!Browser methodsFor: 'message functions' stamp: 'cmm 5/2/2011 09:56'!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	self 		menuHook: aMenu 		named: #messageListMenu 		shifted: shifted.	Preferences useOnlyServicesInMenu ifTrue:[^aMenu].	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('what to show...'			offerWhatToShowMenu)			('toggle break on entry'		toggleBreakOnEntry)			-			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)			('copy selector (c)'						copySelector)			('copy reference'						copyReference)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('versions (v)'				browseVersions)			-			('references... (r)'			browseVariableReferences)			('assignments... (a)'			browseVariableAssignments)			('class refs (N)'			browseClassRefs)			-			('remove method (x)'			removeMessage)			('explore method'			exploreMethod)			('inspect method'			inspectMethod)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'message functions' stamp: 'fbs 3/17/2011 17:26'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	self hasMessageSelected not		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName := self selectedMessageName.	confirmation := self systemNavigation   confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation = 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self selectMessageNamed: nil.	self changed: #messageList.	self setClassOrganizer.	"In case organization not cached"	confirmation = 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !!Browser methodsFor: 'message list' stamp: 'fbs 3/17/2011 07:39'!hasMessageSelected	^ self selectedMessageName notNil.! !!Browser methodsFor: 'message list' stamp: 'fbs 3/22/2011 21:28'!lastMessageName	^ self messageList last.! !!Browser methodsFor: 'message list' stamp: 'fbs 3/30/2011 21:44'!messageList	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!), it is reset to zero."	| sel |	(sel := self messageCategoryListSelection) ifNil: 		[			^ self classOrMetaClassOrganizer				ifNil:		[Array new]				ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]			"^ Array new"		].	^ sel = ClassOrganizer allCategory		ifTrue: 			[self classOrMetaClassOrganizer				ifNil:		[Array new]				ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]]		ifFalse:			[(self classOrMetaClassOrganizer listAtCategoryNamed: self selectedMessageCategoryName )				ifNil: [selectedMessageCategoryName := nil. Array new]]! !!Browser methodsFor: 'message list' stamp: 'fbs 3/29/2011 17:03'!messageListIndex	"Answer the index of the selected message selector into the currently 	selected message category."	^ self messageListIndexOf: self selectedMessageName! !!Browser methodsFor: 'message list' stamp: 'fbs 3/28/2011 07:47'!messageListIndex: anInteger	"Set the selected message selector to be the one indexed by anInteger."	self selectMessageNamed: (self messageList at: anInteger ifAbsent: [nil])! !!Browser methodsFor: 'message list' stamp: 'fbs 3/22/2011 22:17'!messageListIndexOf: aString	^ self messageList indexOf: aString.! !!Browser methodsFor: 'message list' stamp: 'fbs 4/26/2011 08:41'!reformulateList	"If the receiver has a way of reformulating its message list, here is a chance for it to do so"	super reformulateList.	(self messageList includes: self selectedMessageName)		ifFalse: [ self messageList					ifEmpty: [ self selectMessageNamed: nil ]					ifNotEmpty: [ self selectMessageNamed: self lastMessageName ]].! !!Browser methodsFor: 'message list' stamp: 'fbs 3/29/2011 17:04'!selectMessageNamed: aSymbolOrString	| name |	name := aSymbolOrString ifNotNil: [ aSymbolOrString asSymbol ].	selectedMessageName := name.	self editSelection: (name notNil		ifTrue: [#editMessage]		ifFalse: [self messageCategoryListIndex > 0			ifTrue: [#newMessage]			ifFalse: [self hasClassSelected				ifTrue: [#editClass]				ifFalse: [#newClass]]]).	contents := nil.	self changed: #messageListIndex. "update my selection"	self contentsChanged.	self decorateButtons.! !!Browser methodsFor: 'message list' stamp: 'fbs 3/29/2011 17:03'!selectedMessageName	"Answer the message selector of the currently selected message, if any. 	Answer nil otherwise."	^ selectedMessageName.! !!Browser methodsFor: 'metaclass' stamp: 'fbs 3/30/2011 21:48'!metaClassIndicated: trueOrFalse 	"Indicate whether browsing instance or class messages."	metaClassIndicated := trueOrFalse.	self setClassOrganizer.	self hasSystemCategorySelected ifTrue:		[self editSelection: (self hasClassSelected			ifFalse: [metaClassIndicated				ifTrue: [#none]				ifFalse: [#newClass]]			ifTrue: [#editClass])].	selectedMessageCategoryName := nil.	selectedMessageName := nil.	contents := nil.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #contents.	self changed: #annotation.	self decorateButtons! !!Browser methodsFor: 'metaclass' stamp: 'fbs 3/4/2011 20:56'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer := nil.	metaClassOrganizer := nil.	self hasClassSelected ifFalse: [^ self].	theClass := self selectedClass ifNil: [ ^self ].	classOrganizer := theClass organization.	metaClassOrganizer := theClass classSide organization.! !!Browser methodsFor: 'system category functions' stamp: 'fbs 3/5/2011 20:54'!addSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldSelection newName |	self okToChange ifFalse: [^ self].	oldSelection := self selectedSystemCategory.	newName := self		request: 'Please type new category name'		initialAnswer: 'Category-Name'.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName := newName asSymbol].	systemOrganizer		addCategory: newName		before: self selectedSystemCategory.	self selectSystemCategory:		(oldSelection isNil			ifTrue: [ self systemCategoryList last ]			ifFalse: [ oldSelection ]).	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'fbs 3/5/2011 20:55'!alphabetizeSystemCategories	self okToChange ifFalse: [^ false].	systemOrganizer sortCategories.	self selectSystemCategory: nil.	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'fbs 3/5/2011 20:55'!buildSystemCategoryBrowserEditString: aString 	"Create and schedule a new system category browser with initial textual 	contents set to aString."	| newBrowser |	self hasSystemCategorySelected		ifTrue: 			[newBrowser := self class new.			newBrowser selectSystemCategory: self selectedSystemCategory.			newBrowser setClass: self selectedClassOrMetaClass selector: self selectedMessageName.			self class openBrowserView: (newBrowser openSystemCatEditString: aString)				label: 'Classes in category ', newBrowser selectedSystemCategory]! !!Browser methodsFor: 'system category functions' stamp: 'fbs 3/5/2011 20:55'!editSystemCategories	"Retrieve the description of the class categories of the system organizer."	self okToChange ifFalse: [^ self].	self selectSystemCategory: nil.	self editSelection: #editSystemCategories.	self changed: #editSystemCategories.	self contentsChanged! !!Browser methodsFor: 'system category functions' stamp: 'fbs 3/3/2011 17:53'!fileOutSystemCategory	"Print a description of each class in the selected category onto a file 	whose name is the category name followed by .st."	self hasSystemCategorySelected		ifTrue: [systemOrganizer fileOutCategory: self selectedSystemCategory]! !!Browser methodsFor: 'system category functions' stamp: 'ul 12/12/2010 23:30'!findClass	"Search for a class by name."	| foundClass |	(multiWindowState notNil	 or: [self okToChange]) ifFalse:		[^self classNotFound].	foundClass := UIManager default chooseClassOrTrait.	foundClass ifNil: [^self classNotFound].	(self selectedClass notNil	 and: [multiWindowState notNil	 "Can only support multi-window if original window has all the right panes."	 and: [multiWindowState prototype isHierarchy not]]) ifTrue:		[(self classList includes: foundClass name)			ifTrue: [multiWindowState copyWindow]			ifFalse: [multiWindowState addNewWindow]]. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!Browser methodsFor: 'system category functions' stamp: 'fbs 3/3/2011 17:40'!printOutSystemCategory	"Print a description of each class in the selected category as Html."Cursor write showWhile:	[self hasSystemCategorySelected		ifTrue: [systemOrganizer fileOutCategory: self selectedSystemCategory								asHtml: true ]]! !!Browser methodsFor: 'system category functions' stamp: 'fbs 3/5/2011 20:55'!removeSystemCategory	"If a class category is selected, create a Confirmer so the user can 	verify that the currently selected class category and all of its classes 	should be removed from the system. If so, remove it."	self hasSystemCategorySelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	(self classList size = 0		or: [self confirm: 'Are you sure you want toremove this system category and all its classes?'])		ifTrue: 		[systemOrganizer removeSystemCategory: self selectedSystemCategory.		self selectSystemCategory: nil.		self changed: #systemCategoryList]! !!Browser methodsFor: 'system category functions' stamp: 'fbs 8/3/2011 07:30'!renameSystemCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldSelection newName |	oldSelection := self selectedSystemCategory.	oldSelection isNil		ifTrue: [^ self].  "no selection"	self okToChange ifFalse: [^ self].		newName := self		request: 'Please type new category name'		initialAnswer: oldSelection.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName := newName asSymbol].	oldSelection = newName ifTrue: [^ self].	systemOrganizer		renameCategory: oldSelection		toBe: newName.	self selectSystemCategory: newName.	self changed: #systemCategoryList.! !!Browser methodsFor: 'system category functions' stamp: 'cmm 4/26/2011 16:38'!systemCategoryMenu: aMenu	self 		menuHook: aMenu 		named: #systemCategoryMenu 		shifted: false.	Preferences useOnlyServicesInMenu ifTrue:[^aMenu].	^ aMenu labels:'find class... (f)back... (b)browse allbrowseprintOutfileOutreorganizealphabetizeupdateadd item...rename...remove' 	lines: #(2 4 6 8)	selections:		#(findClass recent browseAllClasses buildSystemCategoryBrowser		printOutSystemCategory fileOutSystemCategory		editSystemCategories alphabetizeSystemCategories updateSystemCategories		addSystemCategory renameSystemCategory removeSystemCategory )! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/3/2011 17:27'!hasSystemCategorySelected	^ self selectedSystemCategory notNil.! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/5/2011 20:55'!selectCategoryForClass: theClass	self selectSystemCategory: theClass category.! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/30/2011 21:50'!selectSystemCategory: aSymbol	"Set the selected system category. Update all other selections to be deselected."	selectedSystemCategory := aSymbol.	selectedClassName := nil.	selectedMessageCategoryName := nil.	selectedMessageName := nil.	self editSelection: ( aSymbol isNil ifTrue: [#none] ifFalse: [#newClass]).	metaClassIndicated := false.	self setClassOrganizer.	contents := nil.	self changed: #systemCategorySelectionChanged.	self changed: #systemCategoryListIndex.	"update my selection"	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/3/2011 17:53'!selectedEnvironment	"Answer the name of the selected system category or nil."	self hasSystemCategorySelected ifFalse: [^nil].	^ Smalltalk! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/3/2011 07:55'!selectedSystemCategory	^ selectedSystemCategory! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/3/2011 13:10'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	^ self selectedSystemCategory.! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/3/2011 17:45'!systemCategoryListIndex	"Answer the index of the selected class category."	^ self systemCategoryList indexOf: self selectedSystemCategory.! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/5/2011 20:55'!systemCategoryListIndex: anInteger 	"Set the selected system category index to be anInteger. Update all other 	selections to be deselected."		self selectSystemCategory: (self systemCategoryList at: anInteger ifAbsent: [ nil ])! !!Browser methodsFor: 'system category list' stamp: 'fbs 3/3/2011 17:53'!systemCategorySingleton	| cat |	cat := self selectedSystemCategory.	^ cat ifNil: [Array new]		ifNotNil: [Array with: cat]! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:29'!buildClassListSingletonWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classListSingleton; 		getIndex: #indexIsOne; 		setIndex: #indexIsOne:; 		menu: #classListMenu:shifted; 		keyPress: #classListKey:from:.	^listSpec! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:30'!buildClassListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classList; 		getIndex: #classListIndex; 		setIndex: #classListIndex:; 		menu: #classListMenu:shifted:; 		keyPress: #classListKey:from:.	Preferences browseWithDragNDrop 		ifTrue:[listSpec dragItem: #dragFromClassList:].	^listSpec! !!Browser methodsFor: '*services-base' stamp: 'cmm 3/13/2011 22:25'!menuHook: aMenu named: aSymbol shifted: aBool	"Enhance aMenu with registered services."	aSymbol 		caseOf: 			{ [ #classListMenu ] 		-> [ ServiceGui browser: self classMenu: aMenu ].			[ #codePaneMenu ]			-> [ ServiceGui browser: self codePaneMenu: aMenu ].			[ #messageCategoryMenu]	-> [ ServiceGui browser: self messageCategoryMenu: aMenu ].			[ #messageListMenu ] 		-> [ ServiceGui browser: self messageListMenu: aMenu ].			[ #systemCategoryMenu ] 	-> [ ServiceGui browser: self classCategoryMenu: aMenu ] } 		otherwise: [ "do nothing" ]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 21:44'!arrowKey: aChar from: view	"Intercept Apple-Digit to select panes"	| index |	(aChar isDigit	 and: [multiWindowState notNil]) ifTrue:	 	[index := aChar asciiValue - $0 asciiValue.		index = 0 ifTrue: [index := 10].		^index <= multiWindowState models size			ifTrue: [multiWindowState selectWindowIndex: index]			ifFalse: [self changed: #flash]].	^super arrowKey: aChar from: view! !!Browser methodsFor: 'multi-window support' stamp: 'fbs 3/30/2011 08:00'!classHierarchy	| behavior newBrowser |	(behavior := self selectedClassOrMetaClass) isNil ifTrue:		[^self].	(self isPackage "PackageBrowser pains can't support a hierarchy browser; not sure why."	 or: [multiWindowState isNil]) ifTrue:		[^super classHierarchy].	(newBrowser := HierarchyBrowser new initHierarchyForClass: behavior)		selectMessageCategoryNamed: self selectedMessageCategoryName;		selectMessageNamed: self selectedMessageName;		editSelection: editSelection.	multiWindowState addWindow: newBrowser! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^false! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^false! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self selectedClass			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[s print: self selectedClass.				 self metaClassIndicated ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy']].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:23'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'className:')			ifNil: [(getarg value: 'restoreToCategory:')					ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]					ifNotNil: [:categoryName| s nextPutAll: categoryName]]			ifNotNil:				[:className|				s nextPutAll: className.				(getarg value: 'meta:') ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy'].				(getarg value: 'selector:')					ifNil: [(getarg value: 'protocol:') ifNotNil:							[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]					ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 17:34'!okToClose	^super okToClose	  and: [multiWindowState isNil or: [multiWindowState okToClose]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 20:20'!restoreMultiWindowState: aMessage	"Restore the state after a multi-window switch.."	aMessage sentTo: self! !!Browser methodsFor: 'multi-window support' stamp: 'fbs 3/5/2011 20:55'!restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self selectSystemCategory: category.	self classListIndex: (self classListIndexOf: className).	self metaClassIndicated: metaBool.	self messageCategoryListIndex: (self messageCategoryList indexOf: protocol).	self messageListIndex: (self messageList indexOf: selector).	editSelection := editMode.	self		contentsChanged;		decorateButtons! !!Browser methodsFor: 'multi-window support' stamp: 'fbs 3/3/2011 17:53'!saveMultiWindowState	^Message		selector: #restoreToCategory:className:protocol:selector:mode:meta:		arguments: {	self selectedSystemCategory.						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !!Browser commentStamp: '<historical>' prior: 0!I represent a query path into the class descriptions, the software of the system.!!Browser class methodsFor: 'instance creation' stamp: 'fbs 3/5/2011 20:55'!newOnCategory: aCategory	"Browse the system category of the given name.  7/13/96 sw"	"Browser newOnCategory: 'Interface-Browser'"	| newBrowser newCat |	newBrowser := self new..	newCat := aCategory asSymbol.	(newBrowser systemCategoryList includes: newCat)		ifTrue: [ newBrowser selectSystemCategory: newCat ]		ifFalse: [ ^ self inform: 'No such category' ].		^ self 		openBrowserView: (newBrowser openSystemCatEditString: nil)		label: 'Classes in category ', aCategory! !!Browser class methodsFor: 'instance creation' stamp: 'eem 7/1/2010 11:44'!openBrowserView: aBrowserView label: aString 	"Schedule aBrowserView, labelling the view aString."(aBrowserView isKindOf: ToolBuilderSpec) ifTrue:[	(self canUseMultiWindowBrowsers	 and: [self useMultiWindowBrowsers]) ifTrue:		[aBrowserView multiWindowStyle: #labelButton].	ToolBuilder open: aBrowserView label: aString.] ifFalse:[	aBrowserView isMorph		ifTrue:  [(aBrowserView setLabel: aString) openInWorld]		ifFalse: [aBrowserView label: aString.				aBrowserView minimumSize: 300 @ 200.				aBrowserView subViews do: [:each | each controller].				aBrowserView controller open].].	^ aBrowserView model! !!Browser class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	^true! !!BrowserHierarchicalListTest methodsFor: 'helper' stamp: 'fbs 3/5/2011 20:55'!hierarchicalClassListForCategory: category	^ Browser new		selectSystemCategory: category;		hierarchicalClassList.! !!BrowserRequestor methodsFor: 'requests' stamp: 'nice 2/15/2011 23:28'!getPackageForCategory	"answers a packageinfo for the current class category"	^ PackageInfo named: self getClass category! !!BrowserRequestor methodsFor: 'requests' stamp: 'fbs 3/3/2011 17:54'!getSystemCategory	^ self getBrowser selectedSystemCategory! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/3/2011 12:41'!setUp	browser := Browser new.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 21:09'!testAlphabetizeMessageCategories	browser selectSystemCategory: browser class category.	self deny: browser alphabetizeMessageCategories.		browser selectClass: browser class.	browser metaClassIndicated: false.	self assert: browser alphabetizeMessageCategories.	self assert: browser classOrMetaClassOrganizer categories isSorted.		browser metaClassIndicated: true.	self assert: browser alphabetizeMessageCategories.	self assert: browser classOrMetaClassOrganizer categories isSorted.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/14/2011 17:44'!testAlphabetizeMessageCategoriesLeavesClassSelected	browser selectSystemCategory: browser class category.	browser selectClassNamed: browser class name.		"This is a no-op."	browser alphabetizeMessageCategories.	self assert: browser selectedClassName = browser class name.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:57'!testBuildMessageCategoryBrowserEditString	| spawn |	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser messageCategoryListIndex: 1.	browser messageListIndex: 1.		spawn := browser buildMessageCategoryBrowserEditString: 'We don''t yet test that we do the right thing with this string!!'.	[self assert: spawn selectedSystemCategory = browser selectedSystemCategory.	self assert: spawn selectedClass = browser selectedClass.	self assert: spawn messageCategoryListIndex = browser messageCategoryListIndex.	self assert: spawn messageListIndex = browser messageListIndex]		ensure: [ ToolBuilder default close: spawn topView ].! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:52'!testBuildMessageCategoryBrowserEditStringNoCategorySelected	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser messageCategoryListIndex: 0.		self assert: (browser buildMessageCategoryBrowserEditString: 'foo') isNil.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/14/2011 17:42'!testChangeMessageCategoriesLeavesClassSelected	browser selectSystemCategory: browser class category.	browser selectClassNamed: browser class name.		"This is a no-op."	browser changeMessageCategories: browser classOrMetaClassOrganizer printString.	self assert: browser selectedClassName = browser class name.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/31/2011 09:41'!testClassCommentViewingPersists	browser selectSystemCategory: browser class category.	self assert: browser classList size > 1 description: 'We use the first TWO classes in the category!!'.	browser classListIndex: 1.	browser metaClassIndicated: false.	browser editComment.		browser classListIndex: 2.	self assert: browser editSelection = #editComment.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/17/2011 07:55'!testContentsSelection	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	"No category or message selected."	self assert: browser contentsSelection isEmpty.	"Category selected, but no message selected."	browser messageCategoryListIndex: 1.	browser selectMessageNamed: browser messageList first.	self assert: browser contentsSelection isEmpty.		"Category and message selected."	browser selectMessageNamed: nil.	self deny: browser contentsSelection isEmpty.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/12/2011 22:11'!testCreateHierarchyTreeOf	"Empty."	self assert: (browser createHierarchyTreeOf: #()) isEmpty.	"Single class."	self assert: { Browser -> #() } = (browser createHierarchyTreeOf: { Browser }).	"Single class + 1 subclass"	self assert: { Browser->{HierarchyBrowser->#()} } = (browser createHierarchyTreeOf: { Browser. HierarchyBrowser. }).	"Single class + 2 subclasses"	self assert: { Browser->{HierarchyBrowser->#() . FileContentsBrowser->#()} } = (browser createHierarchyTreeOf: { Browser. HierarchyBrowser. FileContentsBrowser. }).	"Superclass, class, subclass"	self assert: { CodeHolder->{Browser->{HierarchyBrowser->#()}} } = (browser createHierarchyTreeOf: { CodeHolder. Browser. HierarchyBrowser. }).	"Two 'unrelated' classes"	self assert: {Browser->#() . SmallInteger->#()} = (browser createHierarchyTreeOf: { Browser. SmallInteger }).	"Two 'unrelated' classes and a common ancestor"	self assert: {Browser->#() . SmallInteger->#() . ProtoObject->#()} = (browser createHierarchyTreeOf: { Browser. SmallInteger. ProtoObject }).! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:25'!testDefaultClassList	browser selectSystemCategory: nil.	self assert: browser defaultClassList isEmpty.		browser selectSystemCategory: Browser category.	self assert: browser defaultClassList = (SystemOrganization listAtCategoryNamed: Browser category)! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/30/2011 08:45'!testFileOutMessageCategories	| fileName |		browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser messageCategoryListIndex: 1.		"Handcrafted from ClassDescription>>fileOutCategory:asHtml:"	fileName := browser selectedClass name, '-', browser selectedMessageCategoryName, FileDirectory dot, 'st'.	self deny: (FileDirectory default fileExists: fileName).		[browser fileOutMessageCategories.	self assert: (FileDirectory default fileExists: fileName).	] ensure: [FileDirectory default deleteFileNamed: fileName].! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/13/2011 20:48'!testFlattenHierarchyTreeOnIndent	| flatten |	flatten := [:coll | browser		flattenHierarchyTree: (browser createHierarchyTreeOf: coll)		on: OrderedCollection new		indent: ''].	"Empty collection."	self assert: (flatten value: #()) isEmpty.	"Single class."	self assert: (OrderedCollection with: 'Browser') = (flatten value: {Browser}).	"Single class + subclass."	self assert: (OrderedCollection with: 'Browser' with: ' HierarchyBrowser') = (flatten value: {Browser. HierarchyBrowser}).	"Single class + 2 subclasses"	self assert: (OrderedCollection with: 'Browser' with: ' HierarchyBrowser' with: ' FileContentsBrowser') = (flatten value: { Browser. HierarchyBrowser. FileContentsBrowser. }).	"Superclass, class, subclass"	self assert: (OrderedCollection with: 'CodeHolder' with: ' Browser' with: '  HierarchyBrowser') = (flatten value: { CodeHolder. Browser. HierarchyBrowser. }).	"Two 'unrelated' classes"	self assert: (OrderedCollection with: 'Browser' with: 'SmallInteger') = (flatten value: { Browser. SmallInteger }).	"Two 'unrelated' classes and a common ancestor"	self assert: (OrderedCollection with: 'Browser' with: 'SmallInteger' with: 'ProtoObject') = (flatten value: { Browser. SmallInteger. ProtoObject }).! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/13/2011 21:03'!testFlattenHierarchyTreeOnIndentBy	| flatten |	flatten := [:coll | browser		flattenHierarchyTree: (browser createHierarchyTreeOf: coll)		on: OrderedCollection new		indent: '' by: 'x'].	"Empty collection."	self assert: (flatten value: #()) isEmpty.	"Single class."	self assert: (OrderedCollection with: 'Browser') = (flatten value: {Browser}).	"Single class + subclass."	self assert: (OrderedCollection with: 'Browser' with: 'xHierarchyBrowser') = (flatten value: {Browser. HierarchyBrowser}).	"Single class + 2 subclasses"	self assert: (OrderedCollection with: 'Browser' with: 'xHierarchyBrowser' with: 'xFileContentsBrowser') = (flatten value: { Browser. HierarchyBrowser. FileContentsBrowser. }).	"Superclass, class, subclass"	self assert: (OrderedCollection with: 'CodeHolder' with: 'xBrowser' with: 'xxHierarchyBrowser') = (flatten value: { CodeHolder. Browser. HierarchyBrowser. }).	"Two 'unrelated' classes"	self assert: (OrderedCollection with: 'Browser' with: 'SmallInteger') = (flatten value: { Browser. SmallInteger }).	"Two 'unrelated' classes and a common ancestor"	self assert: (OrderedCollection with: 'Browser' with: 'SmallInteger' with: 'ProtoObject') = (flatten value: { Browser. SmallInteger. ProtoObject }).! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:56'!testGetSystemCategoryListIndex	| cat |	cat := SystemOrganization categories first.	browser selectSystemCategory: cat.	self assert: browser systemCategoryListIndex = (SystemOrganization categories indexOf: browser selectedSystemCategory).! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:25'!testHasClassSelected	browser selectSystemCategory: browser class category.	self deny: browser hasClassSelected.	browser selectClass: browser class.	self assert: browser hasClassSelected.	browser selectClass: nil.	self deny: browser hasClassSelected.	browser selectClassNamed: browser class name asString.	self assert: browser hasClassSelected.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:58'!testHasMessageCategorySelected	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser messageCategoryListIndex: 0.	self deny: browser hasMessageCategorySelected.		browser messageCategoryListIndex: 1.	self assert: browser hasMessageCategorySelected.		browser messageCategoryListIndex: 0.	self deny: browser hasMessageCategorySelected.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:45'!testHasMessageSelected	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser messageCategoryListIndex: 1.		self deny: browser hasMessageSelected.		browser messageListIndex: 0.	self deny: browser hasMessageSelected.		browser messageListIndex: 1.	self assert: browser hasMessageSelected.		browser messageListIndex: 0.	self deny: browser hasMessageSelected.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/23/2011 17:32'!testHomeCategory	"This also 'just happens' to test #selectOriginalCategoryForCurrentMethod. It's not appropriate to directly test a private method. (It's a private method because its comment says so, not its category.)"	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser messageCategoryListIndex: 0. "Select -- all --"	browser selectMessageNamed: browser messageList first.	browser showHomeCategory.		self assert: browser selectedMessageCategoryName = (browser class organization categoryOfElement: browser selectedMessageName).! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:56'!testMessageCatListSingleton	| catName |	browser selectSystemCategory: browser class category.	browser selectClass: browser class.		self assert: browser messageCatListSingleton = #().		catName := browser messageCategoryList second.	browser selectMessageCategoryNamed: catName.		self assert: browser messageCatListSingleton = {catName}.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:56'!testMessageCategoryList	browser selectSystemCategory: browser class category.	browser selectClass: browser class.		self assert: browser messageCategoryList = ({ClassOrganizer allCategory}, browser class organization categories).		browser selectClass: nil.	self assert: browser messageCategoryList = #().		browser selectClass: browser class.	browser metaClassIndicated: true.	self assert: browser messageCategoryList = ({ClassOrganizer allCategory}, browser class classSide organization categories).! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:42'!testMessageCategoryListIndex	browser selectSystemCategory: browser class category.	browser selectClass: browser class.		self assert: browser messageCategoryList size > 1 description: 'Sanity check: test refers to first two categories.'.		browser messageCategoryListIndex: 0.	self assert: browser selectedMessageCategoryName isNil.		browser messageCategoryListIndex: 1.	self assert: browser selectedMessageCategoryName = browser messageCategoryList first.		browser messageListIndex: 1.	browser messageCategoryListIndex: 2.	self assert: browser selectedMessageName isNil description: 'Changing category deselects method'.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/30/2011 17:34'!testMessageList	browser selectSystemCategory: browser class category.	browser selectClass: nil.	self assert: browser messageList isEmpty.		browser selectClass: browser class.	browser messageCategoryListIndex: 0.	self assert: browser messageList = browser classOrMetaClassOrganizer allMethodSelectors.	browser messageCategoryListIndex: 1. "-- all --"	self assert: browser messageList = browser classOrMetaClassOrganizer allMethodSelectors.		browser messageCategoryListIndex: 2.	self assert: browser messageList = (browser classOrMetaClassOrganizer listAtCategoryNumber: 1).		browser metaClassIndicated: true.	browser messageCategoryListIndex: 0.	self assert: browser messageList = browser classOrMetaClassOrganizer allMethodSelectors.		browser messageCategoryListIndex: 1. "-- all --"	self assert: browser messageList = browser classOrMetaClassOrganizer allMethodSelectors.		browser messageCategoryListIndex: 2.	self assert: browser messageList = (browser classOrMetaClassOrganizer listAtCategoryNumber: 1).! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/8/2011 17:08'!testMetaClassIndicatedFalseOnExistingClass	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser metaClassIndicated: false.		self assert: browser messageListIndex = 0.	self assert: browser messageCategoryListIndex = 0.	self deny: browser contents isEmpty. "It shows the class definition."		self deny: browser messageCategoryList isEmpty.		self assert: browser messageList = (browser class organization allMethodSelectors).	self assert: browser editSelection = #editClass.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:56'!testMetaClassIndicatedNotOnNoClass	browser selectSystemCategory: browser class category.	browser selectClass: nil.	browser metaClassIndicated: false.		self assert: browser messageListIndex = 0.	self assert: browser messageCategoryListIndex = 0.	self deny: browser contents isEmpty. "It shows the class definition."		self assert: browser messageCategoryList isEmpty.		self assert: browser messageList isEmpty.	self assert: browser editSelection = #newClass.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:56'!testMetaClassIndicatedNotWithNoSystemCategorySelected	browser selectSystemCategory: nil.	browser metaClassIndicated: false.		self assert: browser messageListIndex = 0.	self assert: browser messageCategoryListIndex = 0.	self assert: browser contents isEmpty. "It shows the Class definition."	self assert: browser messageCategoryList isEmpty.	self assert: browser editSelection = #none.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:56'!testMetaClassIndicatedOnNoClass	browser selectSystemCategory: browser class category.	browser selectClass: nil.	browser metaClassIndicated: true.		self assert: browser messageListIndex = 0.	self assert: browser messageCategoryListIndex = 0.	self assert: browser contents isEmpty.		self assert: browser messageCategoryList isEmpty.		self assert: browser messageList isEmpty.	self assert: browser editSelection = #none.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/8/2011 17:08'!testMetaClassIndicatedTrueOnExistingClass	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser metaClassIndicated: true.		self assert: browser messageListIndex = 0.	self assert: browser messageCategoryListIndex = 0.	self deny: browser contents isEmpty. "It shows the Class definition."	self deny: browser messageCategoryList isEmpty.		self assert: browser messageList = (browser class classSide organization allMethodSelectors).! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:56'!testMetaClassIndicatedWithNoSystemCategorySelected	browser selectSystemCategory: nil.	browser metaClassIndicated: true.		self assert: browser messageListIndex = 0.	self assert: browser messageCategoryListIndex = 0.	self assert: browser contents isEmpty. "It shows the Class definition."	self assert: browser messageCategoryList isEmpty.	self assert: browser editSelection = #none.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:56'!testRawMessageCategoryList	browser selectSystemCategory: browser class category.	browser selectClass: browser class.		self assert: browser rawMessageCategoryList = browser class organization categories.		browser selectClass: nil.	self assert: browser rawMessageCategoryList = #().		browser selectClass: browser class.	browser metaClassIndicated: true.	self assert: browser rawMessageCategoryList = browser class classSide organization categories.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/3/2011 22:30'!testSelectCategoryForClass	browser selectCategoryForClass: Browser.	self assert: browser selectedSystemCategory = Browser category.		browser selectCategoryForClass: TestCase.	self assert: browser selectedSystemCategory = TestCase category.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:25'!testSelectClass	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	self assert: browser hasClassSelected.		browser selectClass: nil.	self deny: browser hasClassSelected.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:25'!testSelectClassEditSelectionNoClass	browser selectSystemCategory: browser class category.		browser selectClass: nil.	self assert: browser editSelection = #newClass.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:25'!testSelectClassEditSelectionWhenCommentSelected	| editSelection |	browser selectSystemCategory: Heap category.	browser selectClass: Heap.	browser editComment.	browser messageListIndex: 0.	browser messageListIndex: 0.	editSelection := browser editSelection.	browser selectClass: Interval.	self assert: browser editSelection = editSelection.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:25'!testSelectClassEditSelectionWhenEditingClass	browser selectSystemCategory: Heap category.	browser selectClass: Heap.	browser metaClassIndicated: false.	browser messageListIndex: 0.	browser messageListIndex: 0.		browser selectClass: Interval.	self assert: browser editSelection = #editClass.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:25'!testSelectClassEditSelectionWhenEditingMetaclass	browser selectSystemCategory: Heap category.	browser selectClass: Heap.	browser metaClassIndicated: true.	browser messageListIndex: 0.	browser messageListIndex: 0.		browser selectClass: Interval.	self assert: browser editSelection = #editClass.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:25'!testSelectClassEditSelectionWhenMsgSelected	browser selectSystemCategory: Heap category.	browser selectClass: Heap.	browser selectMessageCategoryNamed: 'adding'.	browser messageListIndex: (browser messageList indexOf: #add:).		browser selectClass: Interval.	self assert: browser editSelection = #editMessage.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:26'!testSelectClassEditSelectionWhenNoMsgButCatSelected	browser selectSystemCategory: Heap category.	browser selectClass: Heap.	browser selectMessageCategoryNamed: 'adding'.	browser messageListIndex: 0.		browser selectClass: Interval.	self assert: browser editSelection = #newMessage.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 21:16'!testSelectClassNamed	browser selectSystemCategory: browser class category.	browser selectClassNamed: browser class name.	self assert: browser selectedClassName = browser class name.		browser selectClassNamed: nil.	self assert: browser selectedClassName isNil.		browser selectClassNamed: browser class name asString.	self assert: browser selectedClassName = browser class name.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 6/27/2011 12:49'!testSelectClassNamedPreservesPlace	| commonCategory commonSelector otherClass |	browser selectSystemCategory: browser class category.	otherClass := HierarchyBrowser. "Unlikely to move out of Browser's package!!"	browser selectClassNamed: browser class name.		commonCategory := (browser class organization categories intersection: otherClass organization categories) first.	commonSelector := #classList.	browser selectMessageCategoryNamed: commonCategory.	browser selectMessageNamed: commonSelector.	browser selectClass: otherClass.		self assert: browser selectedClassName = otherClass name.	self assert: browser selectedMessageCategoryName = commonCategory.	self assert: browser selectedMessageName = commonSelector.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:26'!testSelectClassReselectsMessage	"Colections-Sequences contains a number of classes with similar protocols. In particular, several classes have a method called #add: in a category 'adding'."	| selectedMsgCat selectedMethod |	selectedMsgCat := 'adding'.	selectedMethod := #add:.	browser selectSystemCategory: Heap category.	browser selectClass: Heap.	browser selectMessageCategoryNamed: selectedMsgCat.	browser messageListIndex: (browser messageList indexOf: selectedMethod).		browser selectClass: Interval.		self assert: browser selectedMessageCategoryName = selectedMsgCat.	self assert: browser selectedMessageName = selectedMethod.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/14/2011 17:52'!testSelectClassSelectsClass	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	self assert: browser classListIndex ~= 0.	self assert: browser selectedClass = browser class.	self assert: browser selectedClassName = browser class name.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/15/2011 17:40'!testSelectClassWhenNothingSelected	self assert: browser editSelection = #none.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 20:57'!testSelectMessageCategoryEditSelection	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser selectMessageCategoryNamed: browser messageCategoryList first.		self assert: browser editSelection = #newMessage.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 21:00'!testSelectMessageCategoryEditSelectionNoMsgCat	browser selectSystemCategory: browser class category.	browser selectClass: browser class..	browser messageCategoryListIndex: 0.		self assert: browser editSelection = #editClass.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 21:07'!testSelectMessageCategoryEditSelectionNoMsgCatNoClass	browser selectSystemCategory: browser class category.	browser selectClass: nil..	browser messageCategoryListIndex: 0.		self assert: browser editSelection = #newClass.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:57'!testSelectMessageCategoryNamed	| catName |	browser selectSystemCategory: browser class category.	browser selectClass: browser class.		catName := browser messageCategoryList anyOne.	browser selectMessageCategoryNamed: catName.	self assert: browser selectedMessageCategoryName = catName.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/17/2011 07:36'!testSelectMessageNamed	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser messageCategoryListIndex: 1.	browser selectMessageNamed: browser messageList first.	self assert: browser selectedMessageName = browser messageList first.	self assert: browser messageListIndex = 1.			browser selectMessageNamed: nil.	self assert: browser selectedMessageName isNil.	self assert: browser messageListIndex = 0.		browser selectMessageNamed: browser messageList second.	self assert: browser selectedMessageName = browser messageList second.	self assert: browser messageListIndex = 2.		browser selectMessageNamed: browser messageList first asString.	self assert: browser selectedMessageName = browser messageList first.	self assert: browser messageListIndex = 1.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/14/2011 21:22'!testSelectedClass	browser selectSystemCategory: browser class category.	browser classListIndex: 0.	self assert: browser classListIndex = 0.	self assert: browser selectedClass isNil.		browser classListIndex: 1.	self assert: browser classListIndex = 1.	self assert: browser selectedClass notNil.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:26'!testSelectedEnvironment	browser selectSystemCategory: browser class category.	self assert: browser selectedEnvironment = Smalltalk.		browser selectSystemCategory: nil.	self assert: browser selectedEnvironment isNil.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:57'!testSelectedSystemCategory	| cat newCat |	cat := SystemOrganization categories first.	newCat := SystemOrganization categories second.	browser selectSystemCategory: cat.	self assert:	browser selectedSystemCategory = cat.			browser systemCategoryListIndex: 2.	self assert:	browser selectedSystemCategory = newCat.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/17/2011 17:58'!testShowHomeCategory	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	"Select '--all--'."	browser selectMessageCategoryNamed: browser messageCategoryList first.	browser selectMessageNamed: browser messageList first.		browser showHomeCategory.	self assert: browser messageCategoryListIndex > 1.! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:26'!testSpawnHierarchy	| spawn |	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser selectMessageCategoryNamed: browser messageCategoryList last.	browser messageListIndex: (browser messageList size).	spawn := browser spawnHierarchy.	[self assert: spawn selectedSystemCategory = browser selectedSystemCategory.	self assert: spawn selectedClassName = browser selectedClassName.	self assert: spawn selectedMessageCategoryName = browser selectedMessageCategoryName.	self assert: spawn messageListIndex = browser messageListIndex.]		ensure: [ ToolBuilder default close: spawn topView ].! !!BrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/3/2011 17:52'!testSystemCategoryListIndex	| oldCat |		browser systemCategoryListIndex: 1.	oldCat := browser selectedSystemCategory.	self assert:	browser selectedSystemCategory = SystemOrganization categories first.			browser systemCategoryListIndex: 2.	self deny: browser selectedSystemCategory = oldCat.	self assert:	browser selectedSystemCategory = SystemOrganization categories second.! !!BrowserTest methodsFor: 'testing - message list' stamp: 'fbs 5/1/2011 08:54'!testAlphabetizingMethodsPreservesPlace	| oldCategory oldMethod |	oldCategory := 'breakpoints'.	oldMethod := #toggleBreakOnEntry.	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser selectMessageCategoryNamed: oldCategory.	browser selectMessageNamed: oldMethod.	browser alphabetizeMessageCategories.	self assert: browser selectedMessageCategoryName = oldCategory.	self assert: browser selectedMessageName = oldMethod.! !!BrowserTest methodsFor: 'testing - message list' stamp: 'fbs 5/1/2011 09:06'!testAlphabetizingMethodsPreservesPlaceWhenNoMessageCategorySelected	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser selectMessageCategoryNamed: nil.	browser selectMessageNamed: nil.	browser alphabetizeMessageCategories.	self assert: browser selectedMessageCategoryName = nil.	self assert: browser selectedMessageName = nil.! !!BrowserTest methodsFor: 'testing - message list' stamp: 'fbs 5/1/2011 09:03'!testAlphabetizingMethodsPreservesPlaceWhenNoMethodSelected	| oldCategory |	oldCategory := 'breakpoints'.	browser selectSystemCategory: browser class category.	browser selectClass: browser class.	browser selectMessageCategoryNamed: oldCategory.	browser selectMessageNamed: nil.	browser alphabetizeMessageCategories.	self assert: browser selectedMessageCategoryName = oldCategory.	self assert: browser selectedMessageName = nil.! !!BrowserTest methodsFor: 'testing - message list' stamp: 'fbs 5/13/2011 18:42'!testKeepMethodSelectedWhenChangingClass	browser selectSystemCategory: SequenceableCollection category.	browser selectClass: SequenceableCollection.	browser selectMessageNamed: #add:.	self assert: browser selectedMessageName = #add:.		"Even though we have no message category selected, stay looking at the #add: method."	browser selectClass: Collection.	self assert: browser selectedMessageName = #add:.! !!BrowserTest commentStamp: 'fbs 3/4/2011 07:22' prior: 0!I provide the test suite for Browser.!!BrowserUrl methodsFor: 'downloading' stamp: 'ls 7/26/1998 21:21'!retrieveContentsForBrowser: aBrowser	^aBrowser browserUrlContents: locator! !!ButtonStub methodsFor: 'simulating' stamp: 'cwp 7/14/2006 11:09'!isEnabled	enabled ifNil: [enabled := spec model perform: spec enabled].	^ enabled! !!ByteArray methodsFor: 'accessing' stamp: 'ul 9/12/2010 03:47'!indexOf: anInteger startingAt: start	(anInteger isInteger and: [		anInteger >= 0 and: [		anInteger <= 255 ] ]) ifFalse: [ ^0 ].	^ByteString indexOfAscii: anInteger inString: self startingAt: start! !!ByteArray methodsFor: 'testing' stamp: 'eem 6/4/2010 17:55'!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^self class == ByteArray! !!ByteArray class methodsFor: 'byte based hash' stamp: 'dtl 10/24/2010 12:40'!hashBytes: aByteArray startingWith: speciesHash	"Answer the hash of a byte-indexed collection,	using speciesHash as the initial value.	See SmallInteger>>hashMultiply.	The primitive should be renamed at a	suitable point in the future"	| byteArraySize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	<var: #aHash declareC: 'int speciesHash'>	<var: #aByteArray declareC: 'unsigned char *aByteArray'>	byteArraySize := aByteArray size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: byteArraySize do: [:pos |		hash := hash + (aByteArray basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!ByteArrayTest methodsFor: 'hex tests' stamp: 'nice 6/5/2010 10:06'!testIsLiteral	self assert: #[122 43 213 7] isLiteral description: 'ByteArray instances are literal'.	self deny: thisContext method isLiteral description: 'ByteArray sub instances are not literal'! !!ByteString methodsFor: 'comparing' stamp: 'dtl 10/24/2010 12:41'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	<var: #key declareC: 'unsigned char *key'>	<var: #body declareC: 'unsigned char *body'>	<var: #matchTable declareC: 'unsigned char *matchTable'>	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!ByteString methodsFor: 'testing' stamp: 'ul 4/1/2011 04:16'!beginsWith: sequence	"Answer whether the receiver begins with the given sequence. The comparison is case-sensitive. Overridden for better performance."	| sequenceSize |	sequence class isBytes ifFalse: [ ^super beginsWith: sequence ].	((sequenceSize := sequence size) = 0 or: [ self size < sequenceSize ]) ifTrue: [ ^false ].	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."	(self basicAt: 1) = (sequence basicAt: 1) ifFalse: [ ^false ].	^(self findSubstring: sequence in: self startingAt: 1 matchTable: CaseSensitiveOrder) = 1! !!ByteString methodsFor: '*Nebraska' stamp: 'ul 2/28/2011 05:20'!getInteger32: location	"Read a SmallInteger stored in the receiver using big-endian one's complement representation. Avoid creation of LargeIntegers."	| firstByte |	(firstByte := self byteAt: location) < 64 ifTrue: [ 		^(((((			firstByte bitShift: 8) bitOr:			(self byteAt: location + 1)) bitShift: 8) bitOr: 			(self byteAt: location + 2)) bitShift: 8) bitOr: 			(self byteAt: location + 3) ].	^(64 - firstByte bitShift: 24) - (((((		(self byteAt: location + 1)) bitShift: 8) bitOr: 		(self byteAt: location + 2)) bitShift: 8) bitOr: 		(self byteAt: location + 3))! !!ByteString methodsFor: '*Nebraska' stamp: 'ul 2/28/2011 06:05'!putInteger32: anInteger at: location	"Store a SmallInteger in the receiver using big-endian one's complement representation. Avoid creation of LargeIntegers."		| integer firstByte |	(integer := anInteger) >= 0 		ifTrue: [ firstByte := (anInteger bitShift: -24) bitAnd: 255 ]		ifFalse: [			integer := 0 - integer.			firstByte := (integer bitShift: -24) + 64 bitAnd: 255 ].	self 		byteAt: location put: firstByte;		byteAt: location + 1 put: ((integer bitShift: -16) bitAnd: 255);		byteAt: location + 2 put: ((integer bitShift: -8) bitAnd: 255);		byteAt: location + 3 put: (integer bitAnd: 255)! !!ByteString methodsFor: '*monticello' stamp: 'cmm 3/3/2011 14:35'!asMCVersionName 	^ MCVersionName on: self! !!ByteString class methodsFor: 'primitives' stamp: 'dtl 10/24/2010 12:44'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	<var: #string1 declareC: 'unsigned char *string1'>	<var: #string2 declareC: 'unsigned char *string2'>	<var: #order declareC: 'unsigned char *order'>	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 := order at: (string1 basicAt: i) + 1.		c2 := order at: (string2 basicAt: i) + 1.		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!ByteString class methodsFor: 'primitives' stamp: 'dtl 10/24/2010 12:42'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	<var: #aString declareC: 'unsigned char *aString'>	<var: #inclusionMap  declareC: 'char *inclusionMap'>	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i := start.	stringSize := aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i := i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!ByteString class methodsFor: 'primitives' stamp: 'dtl 10/24/2010 12:42'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>	<var: #aCharacter declareC: 'int anInteger'>	<var: #aString declareC: 'unsigned char *aString'>	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!ByteString class methodsFor: 'primitives' stamp: 'ul 11/2/2010 03:07'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	<var: #aHash declareC: 'int speciesHash'>	<var: #aString declareC: 'unsigned char *aString'>	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString at: pos) asciiValue.		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!ByteString class methodsFor: 'primitives' stamp: 'dtl 10/24/2010 12:43'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>	<var: #table  declareC: 'unsigned char *table'>	<var: #aString  declareC: 'unsigned char *aString'>	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!ByteSymbol methodsFor: 'testing' stamp: 'ul 4/1/2011 04:16'!beginsWith: sequence	"Answer whether the receiver begins with the given sequence. The comparison is case-sensitive. Overridden for better performance."	| sequenceSize |	sequence class isBytes ifFalse: [ ^super beginsWith: sequence ].	((sequenceSize := sequence size) = 0 or: [ self size < sequenceSize ]) ifTrue: [ ^false ].	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."	(self basicAt: 1) = (sequence basicAt: 1) ifFalse: [ ^false ].	^(self findSubstring: sequence in: self startingAt: 1 matchTable: CaseSensitiveOrder) = 1! !!ByteSymbol methodsFor: '*monticello' stamp: 'cmm 3/7/2011 14:23'!asMCVersionName	^ self asString asMCVersionName! !!ByteTextConverter methodsFor: 'private' stamp: 'ul 4/26/2011 02:02'!decode: aByte	"Answer a decoded squeak character corresponding to aByte code.	Note that aByte does necessary span in the range 0...255, since this receiver is a ByteTextEncoder."	| code |	((code := self class decodeTable at: 1 + aByte) = -1 or: [code = 16rFFFD]) ifTrue: [^nil].	^Character value: code! !!ByteTextConverter methodsFor: 'conversion' stamp: 'nice 8/27/2010 20:14'!nextFromStream: aStream	| character1 |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 := aStream basicNext ifNil: [^ nil].	^ self toSqueak: character1! !!ByteTextConverter methodsFor: 'conversion' stamp: 'ul 5/17/2011 17:26'!nextPut: aCharacter toStream: aStream		| charCode |	aStream isBinary ifTrue: [ ^aCharacter storeBinaryOn: aStream ].	(charCode := aCharacter charCode) < 256 		ifFalse: [ aStream basicNextPut: (Character value: (self encode: charCode)) ]		ifTrue: [			(latin1Encodings at: charCode + 1)				ifNil: [ aStream basicNextPut: aCharacter ]				ifNotNil: [ :encodedString | aStream basicNextPutAll: encodedString ] ].	^aCharacter! !!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 8/18/2011 17:44'!bindBlockTemp: name	"This shouldn't be used with BytecodeEncoder.  Use bindBlockTemp:within: instead."	self shouldNotImplement! !!BytecodeEncoder methodsFor: 'temps' stamp: 'nice 12/29/2010 14:41'!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	| blockExtentsToTempsMap |	blockExtentsToLocals ifNil:		[^nil].	blockExtentsToTempsMap := Dictionary new.	blockExtentsToLocals keysAndValuesDo:		[:blockExtent :locals|		blockExtentsToTempsMap			at: blockExtent			put: (Array streamContents:					[:aStream|					locals withIndexDo:						[:local :index|						local isIndirectTempVector							ifTrue: [local remoteTemps withIndexDo:										[:remoteLocal :innerIndex| aStream nextPut: { remoteLocal key. { index. innerIndex } }]]							ifFalse: [aStream nextPut: { local key. index }]]])].	^blockExtentsToTempsMap! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:24'!becomeCached	"The receiver is already cached."	^self! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:21'!becomeUncached	self become: (BlockClosure 					outerContext: outerContext					startpc: startpc					numArgs: numArgs					copiedValues: self)! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:24'!once	^cachedValue! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:17'!value	^cachedValue! !!CachedBlockClosure methodsFor: 'initialize-release' stamp: 'eem 7/22/2010 12:16'!outerContext: aContext startpc: aStartpc numArgs: argCount cachedValue: aValue copiedValues: anArrayOrNil	cachedValue := aValue.	super outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil! !!CachedBlockClosure commentStamp: 'eem 7/22/2010 12:34' prior: 0!I'm a BlockClosure with an added instance variable for storing the once upon a time result of evaluating myself when I was simple BlockClosure. This is triggered by sending #once to a normal BlockClosure. Future sends of once will simply return this value rather than evaluate myself. When sent value, I revert back to a BlockClosure.  Originally by Travis Griggs, from whom we copy this idea with thanks.Instance Variables	cachedValue	<Object>cachedValue	- result of having sent value to myself when i was just a BlockClosure!!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 1/22/2005 19:37'!fillRectangle: aRectangle fillStyle: aFillStyle borderStyle: aBorderStyle	"Fill the given rectangle."	aFillStyle isTransparent ifFalse:[		self fillRectangle: (aRectangle insetBy: aBorderStyle width) fillStyle: aFillStyle].	aBorderStyle ifNil:[^self].	aBorderStyle width <= 0 ifTrue:[^self].	aBorderStyle frameRectangle: aRectangle on: self! !!Canvas methodsFor: 'initialization' stamp: 'ar 6/17/2010 16:43'!finish: allDamage	"If there are any pending operations on the receiver complete them. 	Do not return before all modifications have taken effect."	^self finish! !!Canvas methodsFor: 'Nebraska/embeddedWorlds' stamp: 'ul 8/2/2011 19:57'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| patchRect subCanvas pureRect biggerPatch biggerClip interForm |	self flag: #bob.		"added to Canvas in hopes it will work for Nebraska"	(aDisplayTransform isPureTranslation) ifTrue: [		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to aClipRect"	pureRect := (aDisplayTransform globalBoundsToLocal: aClipRect).	patchRect := pureRect rounded.	patchRect area = 0 ifTrue: [^self]. 	"oh, well!!"	biggerPatch := patchRect expandBy: 1.	biggerClip := (aDisplayTransform localBoundsToGlobal: biggerPatch) rounded.	"Render the submorphs visible in the clipping rectangle, as patchForm"	subCanvas := FormCanvas extent: biggerPatch extent depth: self depth.	self isShadowDrawing ifTrue: [		subCanvas shadowColor: self shadowColor	].	"this biggerPatch/biggerClip is an attempt to improve positioning of the final image in high magnification conditions. Since we cannot grab fractional pixels from the source, take one extra and then take just the part we need from the expanded form"	subCanvas 		translateBy: biggerPatch topLeft negated rounded		during: aBlock.	interForm := Form extent: biggerClip extent depth: self depth.	subCanvas form 		displayInterpolatedIn: interForm boundingBox		on: interForm.	self 		drawImage: interForm 		at: aClipRect origin 		sourceRect: (aClipRect origin - biggerClip origin extent: aClipRect extent)! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:41'!emitCodeForValue: stack encoder: encoder	receiver emitCodeForValue: stack encoder: encoder.	1 to: messages size - 1 do: 		[:i | 		encoder genDup.		stack push: 1.		(messages at: i) emitCodeForValue: stack encoder: encoder.		encoder genPop.		stack pop: 1].	messages last emitCodeForValue: stack encoder: encoder! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:39'!sizeCodeForValue: encoder	| size |	size := (receiver sizeCodeForValue: encoder)			 + (messages size - 1 * (encoder sizeDup + encoder sizePop)).	messages do: [:aMessage | size := size + (aMessage sizeCodeForValue: encoder)].	^size! !!CascadeNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitCascadeNode: self! !!Categorizer methodsFor: 'accessing' stamp: 'nice 8/19/2010 21:26'!sortCategories	| privateCategories publicCategories newCategories |	privateCategories := self categories select:		[:one | (one findString: 'private' startingAt: 1 caseSensitive: false) = 1].	publicCategories := self categories copyWithoutAll: privateCategories.	newCategories := publicCategories asArray sort , privateCategories asArray sort.	self categories: newCategories! !!Categorizer commentStamp: 'nice 5/6/2010 21:10' prior: 0!A Categorizer goal is to classify the elements of a collection into categories.It is typically used to classify methods of class into categories (also named protocols in this case).Instance Variables	categoryArray:		<SequenceableCollection of: Object>	categoryStops:		<SequenceableCollection of: Integer>	elementArray:		<SequenceableCollection of: Object>categoryArray	- holds the list of categories.	A category could be any Object but is generally a String or Symbol.	Categories should be unique (categoryArray asSet size = categoryArray size)categoryStops	- holds the index of last element belonging to each category.	There should be a category stop for each category (categoryStops size = categoryArray size).	The categoryStops should be sorted (categoryStops sorted = categoryStops).	A category stop equal to its predecessor (= 0 for the first category stop) denotes an empty category.elementArray	- holds the elements to be classified. The elements are sorted by category.Class variables	Default is the default category used to classify yet unclassified methods of a class	NullCategory is the category to be displayed in a Browser for a class having no method.!!CategorizerTest methodsFor: 'running' stamp: 'mtf 9/10/2007 10:10'!setUp	categorizer := Categorizer defaultList: #(a b c d e).	categorizer classifyAll: #(a b c) under: 'abc'.	categorizer addCategory: 'unreal'.! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:17'!testClassifyNewElementNewCategory	categorizer classify: #f under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')(''nice'' f)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:18'!testClassifyNewElementOldCategory	categorizer classify: #f under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'' f)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:17'!testClassifyOldElementNewCategory	categorizer classify: #e under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'')(''nice'' e)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:54'!testClassifyOldElementOldCategory	categorizer classify: #e under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'' e)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:22'!testDefaultCategoryIsTransient	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	categorizer classifyAll: #(d e) under: #abc.	self assert: categorizer printString ='(''abc'' a b c d e)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/11/2007 15:15'!testNullCategory	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	| aCategorizer |	aCategorizer := Categorizer defaultList: #().	self assert: aCategorizer printString ='(''as yet unclassified'')'.	self assert: aCategorizer categories = #('no messages').	aCategorizer classify: #a under: #b.	self assert: aCategorizer printString ='(''b'' a)'.	self assert: aCategorizer categories = #(b).! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:57'!testRemoveEmptyCategory	categorizer removeCategory: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:55'!testRemoveExistingElement	categorizer removeElement: #a.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:59'!testRemoveNonEmptyCategory	self should: [categorizer removeCategory: #abc] raise: Error.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:59'!testRemoveNonExistingCategory	categorizer removeCategory: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:57'!testRemoveNonExistingElement	categorizer removeElement: #f.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/11/2007 14:49'!testRemoveThenRename	categorizer removeCategory: #unreal.	categorizer renameCategory: #abc toBe: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''unreal'' a b c)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:14'!testUnchanged	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategoryViewer methodsFor: 'categories' stamp: 'ul 11/15/2010 11:30'!chooseCategory	"The mouse went down on my category-list control; pop up a list of category choices"	| aList reply aLinePosition lineList |	aList := scriptedPlayer categoriesForViewer: self.	aLinePosition := aList indexOf: #miscellaneous ifAbsent: [nil].	aList := aList collect:			[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	lineList := aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aList size = 0 ifTrue: [aList add: ScriptingSystem nameForInstanceVariablesCategory translated].	reply := UIManager default 		chooseFrom: aList 		values: aList 		lines: lineList		title: 'category' translated.	reply ifNil: [^ self].	self chooseCategoryWhoseTranslatedWordingIs: reply asSymbol! !!CategoryViewer methodsFor: 'entries' stamp: 'ul 11/15/2010 11:31'!phraseForCommandFrom: aMethodInterface	"Answer a phrase for the non-slot-like command represented by aMethodInterface - classic tiles"	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal tileBearingHelp |	aDocString := aMethodInterface documentation.	aDocString = 'no help available' ifTrue: [aDocString := nil].	names := scriptedPlayer class namedTileScriptSelectors.	resultType := aMethodInterface resultType.	cmd := aMethodInterface selector.	(universal := scriptedPlayer isUniversalTiles)		ifTrue:			[aPhrase := scriptedPlayer universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs = 0			ifTrue:				[aPhrase := PhraseTileMorph new vocabulary: self currentVocabulary.				aPhrase setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType := aMethodInterface typeForArgumentNumber: 1.				aPhrase := PhraseTileMorph new vocabulary: self currentVocabulary.				(self isSpecialPatchReceiver: scriptedPlayer and: cmd) ifTrue: [					aPhrase setOperator: cmd						type: resultType						rcvrType: #Patch						argType: argType.				] ifFalse: [					aPhrase setOperator: cmd						type: resultType						rcvrType: #Player						argType: argType.				].				(self isSpecialPatchCase: scriptedPlayer and: cmd) ifTrue: [					argTile := (Vocabulary vocabularyForType: argType) defaultArgumentTileFor: scriptedPlayer.				] ifFalse: [					argTile := ScriptingSystem tileForArgType: argType.				].				(#(bounce: wrap:) includes: cmd) ifTrue:					["help for the embattled bj"					argTile setLiteral: 'silence'; updateLiteralLabel].				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(scriptedPlayer slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector := #userSlot].	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])		ifTrue:			[aDocString ifNil:				[aDocString := (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentation].			aDocString ifNil:				[balloonTextSelector := #userScript]].	tileBearingHelp := universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]. 	aDocString		ifNotNil:			[tileBearingHelp setBalloonText: aDocString]		ifNil:			[balloonTextSelector ifNil:				[tileBearingHelp setProperty: #inherentSelector toValue: cmd.				balloonTextSelector := #methodComment].			tileBearingHelp balloonTextSelector: balloonTextSelector].	aPhrase markAsPartsDonor.	cmd == #emptyScript ifTrue:		[aPhrase setProperty: #newPermanentScript toValue: true.		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.		aPhrase submorphs second setBalloonText: 'drag and drop to add a new script' translated].	universal ifFalse:		[selfTile := self tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow := ViewerLine newRow borderWidth: 0; color: self color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 2@2; beTransparent).	aRow addMorphBack: (self infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	aPhrase on: #mouseEnter send: #addCommandFeedback to: aRow.	aPhrase on: #mouseLeave send: #removeHighlightFeedback to: aRow.	aPhrase on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		cmd numArgs = 0 ifTrue:			[aPhrase beTransparent.			aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.			aRow addMorphBack: (stat := (inst := scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).			inst updateStatusMorph: stat]].	aRow beSticky; disableDragNDrop.	^ aRow! !!ChangeList methodsFor: 'menu actions' stamp: 'ul 11/15/2010 11:31'!browseAllVersionsOfSelections	"Opens a Versions browser on all the currently selected methods, showing each alongside all of their historical versions."	|  oldSelection aList |	oldSelection := self listIndex.	aList := OrderedCollection new.	Cursor read showWhile: [		1 to: changeList size do: [:i |			(listSelections at: i) ifTrue: [				listIndex := i.				self browseVersions.				aList add: i.				]]].	listIndex := oldSelection.	aList size = 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].! !!ChangeList methodsFor: 'menu actions' stamp: 'ul 11/15/2010 11:31'!browseCurrentVersionsOfSelections	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"	| aList |	aList := OrderedCollection new.	Cursor read showWhile: [		1 to: changeList size do: [:i |			(listSelections at: i) ifTrue: [				| aClass aChange |				aChange := changeList at: i.				(aChange type = #method					and: [(aClass := aChange methodClass) notNil					and: [aClass includesSelector: aChange methodSelector]])						ifTrue: [							aList add: (								MethodReference new									setStandardClass: aClass  									methodSymbol: aChange methodSelector							)						]]]].	aList size = 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].	ToolSet		browseMessageSet: aList		name: 'Current versions of selected methods in ', file localName		autoSelect: nil! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 6/29/2010 17:58'!changeListMenu: aMenu	"Fill aMenu up so that it comprises the primary changelist-browser menu"	aMenu addTitle: 'change list'.	aMenu addStayUpItemSpecial.	aMenu addList: #(	('fileIn selections'							fileInSelections						'import the selected items into the image')	('fileOut selections...	'						fileOutSelections						'create a new file containing the selected items')	-	('compare to current'						compareToCurrentVersion			'open a separate window which shows the text differences between the on-file version and the in-image version.' )	('toggle diffing (D)'							toggleDiffing						'start or stop showing diffs in the code pane.')	-	('select conflicts with any changeset'		selectAllConflicts					'select methods in the file which also occur in any change-set in the system')	('select conflicts with current changeset'	selectConflicts						'select methods in the file which also occur in the current change-set')	('select conflicts with...'						selectConflictsWith					'allows you to designate a file or change-set against which to check for code conflicts.')	-	('select unchanged definitions'				selectUnchangedDefinitions			'select class definitions, class comments and methods in the file whose in-image versions are the same as their in-file counterparts' )	('select unchanged methods'					selectUnchangedMethods				'select methods in the file whose in-image versions are the same as their in-file counterparts' )	('select new methods'						selectNewMethods					'select methods in the file that do not current occur in the image')	('select methods for this class'				selectMethodsForThisClass			'select all methods in the file that belong to the currently-selected class')	('select methods for extant classes'			selectMethodsForExtantClasses		'select all methods in the file that belong to a class that exists in the image')	('select changes with contents matching'		selectContentsMatching				'select all changes in the file whose text includes a pattern')	-	('select all (a)'								selectAll								'select all the items in the list')	('deselect all'								deselectAll							'deselect all the items in the list')	('invert selections'							invertSelections						'select every item that is not currently selected, and deselect every item that *is* currently selected')	-	('browse all versions of single selection'			browseVersions		'open a version browser showing the versions of the currently selected method')	('browse all versions of selections'			browseAllVersionsOfSelections		'open a version browser showing all the versions of all the selected methods')	('browse current versions of selections'		browseCurrentVersionsOfSelections	'open a message-list browser showing the current (in-image) counterparts of the selected methods')	('destroy current methods of selections'		destroyCurrentCodeOfSelections		'remove (*destroy*) the in-image counterparts of all selected methods')	-	('remove doIts'								removeDoIts							'remove all items that are doIts rather than methods')	('remove older versions'						removeOlderMethodVersions			'remove all but the most recent versions of methods in the list')	('remove up-to-date versions'				removeExistingMethodVersions		'remove all items whose code is the same as the counterpart in-image code')	('remove selected items'						removeSelections					'remove the selected items from the change-list')	('remove unselected items'					removeNonSelections					'remove all the items not currently selected from the change-list')).	^ aMenu! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 2/23/2011 21:46'!removeExistingMethodVersions	"Remove all up to date version of entries from the receiver"	| newChangeList newList |	newChangeList := OrderedCollection new.	newList := OrderedCollection new.	changeList with: list do:[:chRec :strNstamp | 			| str keep cls sel |			keep := true.			(cls := chRec methodClass) ifNotNil:[				str := chRec string.				sel := cls newParser parseSelector: str.				keep := (cls sourceCodeAt: sel ifAbsent:['']) asString ~= str.			].			keep ifTrue:[					newChangeList add: chRec.					newList add: strNstamp]].	newChangeList size < changeList size		ifTrue:			[changeList := newChangeList.			list := newList.			listIndex := 0.			listSelections := Array new: list size withAll: false].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'ul 11/15/2010 11:34'!removeNonSelections	"Remove the unselected items from the receiver."	| newChangeList newList |	newChangeList := OrderedCollection new.	newList := OrderedCollection new.	1 to: changeList size do:		[:i | (listSelections at: i) ifTrue:			[newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size = 0 ifTrue:		[^ self inform: 'That would remove everything.Why would you want to do that?'].	newChangeList size < changeList size		ifTrue:			[changeList := newChangeList.			list := newList.			listIndex := 0.			listSelections := Array new: list size withAll: false].	self changed: #list	! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 1/18/2009 15:21'!selectContentsMatching	| pattern |	pattern := UIManager default request: 'pattern to match'.	pattern isEmpty ifTrue: [^self].	^Cursor execute showWhile:		[self selectSuchThat: ((pattern includesAnyOf: '?*')								ifTrue: [[ :change | pattern match: change string]]								ifFalse: [[ :change | change string includesSubString: pattern]])]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 8/18/2009 13:41'!selectMethodsForExtantClasses	^self selectSuchThat:		[ :change |		Smalltalk hasClassNamed: change methodClassName]! !!ChangeList methodsFor: 'menu actions' stamp: 'ul 8/2/2011 19:57'!selectSuchThat: aBlock	"select all changes for which block returns true"	listSelections := changeList collect: aBlock.	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 7/22/2010 13:40'!selectUnchangedDefinitions	"Selects all recognizable definitions for which there is already a definition in the current image, whose source is exactly the same."	| change class tokens |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put: false.		(change type = #method		 and: [(class := change methodClass) notNil		 and: [class includesSelector: change methodSelector]]) ifTrue:			[listSelections				at: i				put: change string withBlanksCondensed					= (class sourceCodeAt: change methodSelector) asString withBlanksCondensed].		(change type == #classComment		and: [(class := change commentClass) notNil]) ifTrue:			[listSelections at: i put: change string = class comment asString].		change type == #doIt ifTrue:			[tokens := Scanner new scanTokens: change string.			 ((tokens select:				[:substr| #(subclass: variableSubclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3			 and: [(class := Smalltalk at: tokens third ifAbsent: []) notNil			 and: [class isBehavior]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class definition withBlanksCondensed].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #instanceVariableNames:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) notNil			 and: [class isBehavior]]]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class class definition withBlanksCondensed].			(tokens size = 3			 and: [tokens second == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class includesSelector: tokens third) not]]]]) ifTrue:				[listSelections at: i put: true].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class class includesSelector: tokens fourth) not]]]]]) ifTrue:				[listSelections at: i put: true]]]].	self changed: #allSelections! !!ChangeList methodsFor: 'scanning' stamp: 'eem 7/17/2008 15:50'!scanCategory  	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp anIndex |	itemPosition := file position.	item := file nextChunk.	((item includesSubString: 'commentStamp:')	or: [(item includesSubString: 'methodsFor:')	or: [item endsWith: 'reorganize']]) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 50)].	tokens := Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp := ''.		anIndex := tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp := tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanCategory: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanCategory: tokens fourth class: tokens first							meta: true stamp: stamp]].	tokens second == #commentStamp:		ifTrue:			[stamp := tokens third.			self addItem:					(ChangeRecord new file: file position: file position type: #classComment									class: tokens first category: nil meta: false stamp: stamp)					text: 'class comment for ' , tokens first, 						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).			file nextChunk.			^ file skipStyleChunk].	self assert: tokens last == #reorganize.	self addItem:		(ChangeRecord new			file: file position: file position type: #reorganize			class: tokens first category: nil meta: false stamp: stamp)		text: 'organization for ' , tokens first, (tokens second == #class ifTrue: [' class'] ifFalse: ['']).	file nextChunk! !!ChangeList methodsFor: 'scanning' stamp: 'nice 2/23/2011 21:46'!scanCategory: category class: class meta: meta stamp: stamp	| itemPosition method selector |	[itemPosition := file position.	method := file nextChunk.	file skipStyleChunk.	method size > 0]						"done when double terminators"		whileTrue:		[self addItem: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: category meta: meta stamp: stamp)			text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, ((selector := (Smalltalk at: class ifAbsent: [Object]) newParser parseSelector: method) isNil					ifTrue: ['unparsableSelector']					ifFalse: [selector])				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !!ChangeList methodsFor: 'scanning' stamp: 'ul 6/17/2011 12:32'!scanFile: aFile from: startPosition to: stopPosition		file := aFile.	changeList := OrderedCollection new.	list := OrderedCollection new.	listIndex := 0.	file position: startPosition.'Scanning ', aFile localName, '...'	displayProgressFrom: startPosition to: stopPosition	during: [:bar | | prevChar itemPosition item |	[file position < stopPosition]		whileTrue:		[bar value: file position.		[file atEnd not and: [file peek isSeparator]]				whileTrue: [prevChar := file next].		(file peekFor: $!!)		ifTrue:			[(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [self scanCategory]]		ifFalse:			[itemPosition := file position.			item := file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)					text: 'do it: ' , (item contractTo: 50)]]]].	listSelections := Array new: list size withAll: false! !!ChangeList methodsFor: 'viewing access' stamp: 'ul 11/5/2010 19:38'!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange := changeList at: listIndex.	 (aChange type == #method	 and: [(aClass := aChange methodClass) notNil	 and: [aClass includesSelector: aChange methodSelector]]) ifTrue:		[^Utilities			methodDiffFor: aChange text			class: aClass			selector: aChange methodSelector			prettyDiffs: self showingPrettyDiffs].	aChange type == #doIt ifTrue:		[| tokens |		 tokens := Scanner new scanTokens: aChange string.		 ((tokens select:				[:substr| #(subclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3		  and: [(aClass := Smalltalk at: tokens third ifAbsent: []) notNil		  and: [aClass isBehavior]]) ifTrue:			[^ClassDiffBuilder buildDisplayPatchFrom: aClass definition to: aChange string].		(tokens size = 4		 and: [tokens second == #class		 and: [tokens third == #instanceVariableNames:		 and: [(aClass := Smalltalk at: tokens first ifAbsent: []) notNil		 and: [aClass isBehavior]]]]) ifTrue:			[^ClassDiffBuilder buildDisplayPatchFrom: aClass class definition to: aChange string]].	(aChange type == #classComment	and: [(aClass := aChange commentClass) notNil]) ifTrue:		[^ClassDiffBuilder buildDisplayPatchFrom: aClass comment asString to: aChange string].	^(changeList at: listIndex) text! !!ChangeList class methodsFor: 'public access' stamp: 'ul 11/15/2010 11:34'!browseRecentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile := origChangesFile readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	changesFile setConverterForCode.	pos := initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk := changesFile nextChunk.			i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos := Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos := 0]].	changesFile close.	banners size = 0 ifTrue: [^ self inform: 'this image has never been savedsince changes were compressed' translated].	pos := UIManager default chooseFrom:  banners values: positions title: 'Browse as far back as...' translated.	pos ifNil: [^ self].	self browseRecent: end - pos on: origChangesFile! !!ChangeList class methodsFor: '*monticello' stamp: 'ul 11/15/2010 11:34'!recentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile := origChangesFile readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	pos := initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk := changesFile nextChunk.			i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos := Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos := 0]].	changesFile close.	banners size = 0 ifTrue: [^self recent: end on: origChangesFile].	pos := UIManager default chooseFrom: banners values: positions				title: 'Browse as far back as...'.	pos == nil		ifTrue: [^ self].	^self recent: end - pos on: origChangesFile! !!ChangeRecord methodsFor: 'access' stamp: 'eem 4/23/2007 10:37'!commentClass 	| commentClass |	type == #classComment ifFalse: [^ nil].	(Smalltalk includesKey: class asSymbol) ifFalse: [^ nil].	commentClass := Smalltalk at: class asSymbol.	^meta ifTrue: [commentClass class]		ifFalse: [commentClass]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 5/18/2010 20:25'!fileIndex	SourceFiles withIndexDo: [:sf :i| sf name = file name ifTrue: [^i]].	^nil! !!ChangeRecord methodsFor: 'access' stamp: 'eem 8/14/2010 20:35'!methodClass	| methodClassName methodClass |	(#(method #classComment) includes: type) ifFalse: [ ^ nil ].	methodClassName := class subStrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	(Smalltalk globals includesKey: methodClassName) ifFalse: [ ^ nil ].	methodClass := Smalltalk at: methodClassName.	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 9/19/2010 20:00'!methodClassName	| tokens |	(class isNil	and: [type = #doIt	and: [(tokens := Scanner new scanTokens: self text) size >= 3	and: [(tokens includes: #'.') not "exclude multi-statement doits"	and: [tokens first isSymbol	and: [tokens first isKeyword not	and: [tokens first first canBeGlobalVarInitial	and: [(tokens includes: #instanceVariableNames:)		or: [tokens second == #comment:		or: [tokens third == #comment:]]]]]]]]]) ifTrue:		["Could be a class definition.			Class definitions start with Superclass blahSubclass: #ClassName			Metaclass definitions start with ClassName class instanceVariableNames:"		 (tokens second isSymbol		  and: [tokens second isKeyword		  and: [tokens third isSymbol		  and: [tokens third isKeyword not		  and: [(2 to: tokens size by: 2) allSatisfy: [:i| (tokens at: i) isKeyword]]]]]) ifTrue:			[^tokens third].		 (tokens size = 4		  and: [tokens second = #class		  and: [(tokens third = #instanceVariableNames: or: [tokens third = #comment:])		  and: [tokens last isString]]]) ifTrue:			[^tokens first].		 (tokens size = 3		  and: [tokens second = #comment:		  and: [tokens last isString]]) ifTrue:			[^tokens first]].	^class! !!ChangeRecord methodsFor: 'access' stamp: 'nice 2/23/2011 21:46'!methodSelector	^type == #method ifTrue:		[(Smalltalk at: class ifAbsent: [Object]) newParser parseSelector: self string]! !!ChangeRecord methodsFor: 'initialization' stamp: 'cmm 7/2/2010 18:26'!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it; if I represent a reorganization then get organized!!"	Cursor read showWhile:		[| s cls aSelector |		type == #doIt			ifTrue:				[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]]			ifFalse:				[cls := self methodClass.				 type == #method ifTrue:					[cls compile: self text classified: category withStamp: stamp notifying: nil.					(aSelector := self methodSelector) ifNotNil:						[Utilities noteMethodSubmission: aSelector forClass: cls]].				 type == #classComment ifTrue:					[cls comment: self text stamp: stamp.					Utilities noteMethodSubmission: #Comment forClass: cls ].				 type == #reorganize ifTrue:					[cls organization changeFromString: self text]]]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 8/9/2010 10:47'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	Cursor write showWhile: [ | internalStream |			internalStream := WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(UIManager default chooseFrom: #('Ignore' 'Browse slips')				 	title: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ul 11/15/2010 11:34'!lookForSlips	"Scan the receiver for changes that the user may regard as slips to be remedied"	| slips nameLine msg |	nameLine := '"', self name, '"'.	(slips := self checkForSlips) size = 0 ifTrue:		[^ self inform: 'No slips detected in change set', nameLine].	msg := slips size = 1		ifTrue:			[ 'One method in change set', nameLine, 'has a halt, reference to the Transcript,and/or some other ''slip'' in it.Would you like to browse it? ?']		ifFalse:			[ slips size printString,' methods in change set', nameLine, 'have halts or references to theTranscript or other ''slips'' in them.Would you like to browse them?'].	(UIManager default  chooseFrom: #('Ignore' 'Browse slips') title: msg) = 2		ifTrue: [self systemNavigation  browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:21'!summaryStringDelta: delta	"Answer the string summarizing this changeSet"		^ String streamContents:		[:s | | line author s2 ps intName date |		intName := self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps := self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 := ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date := s2 nextLine.			s2 match: 'Author:'; skipSeparators.  author := s2 nextLine.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line := s2 nextLine.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!ChangeSet class methodsFor: 'scanning' stamp: 'ul 6/17/2011 12:25'!scanFile: file from: startPosition to: stopPosition	| changeList |	changeList := OrderedCollection new.	file position: startPosition.'Scanning ', file localName, '...'	displayProgressFrom: startPosition to: stopPosition	during: [:bar | | itemPosition item prevChar |	[file position < stopPosition] whileTrue:[		bar value: file position.		[file atEnd not and: [file peek isSeparator]]			whileTrue: [prevChar := file next].		(file peekFor: $!!) ifTrue:[			(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [changeList addAll: (self scanCategory: file)].		] ifFalse:[			itemPosition := file position.			item := file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:[				changeList add: (ChangeRecord new file: file position: itemPosition type: #doIt).			].		].	]].	^changeList! !!ChangeSet class methodsFor: 'scanning' stamp: 'ul 11/15/2010 11:34'!scanVersionsOf: method class: class meta: meta category: cat selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp changeList file |	changeList := OrderedCollection new.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:[:x | x ifNotNil:[x readOnlyCopy]].	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil] whileTrue:[		preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := [Scanner new scanTokens: preamble] on: Error do:[#()]]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-3) = #stamp: ifTrue:[					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size-2.					prevPos := tokens last.					prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.					prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos.				] ifFalse: ["Old format gives no stamp; prior pointer in two parts"					prevPos := tokens at: tokens size-2.					prevFileIndex := tokens last.				].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]			].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-1) = #stamp: ifTrue: [					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size.			]		]. 		changeList add: (ChangeRecord new file: file position: position type: #method						class: class name category: cat meta: meta stamp: stamp).		position := prevPos.		prevPos notNil ifTrue:[file := sourceFilesCopy at: prevFileIndex].	].	sourceFilesCopy do: [:x | x ifNotNil:[x close]].	^changeList! !!ChangeSorter methodsFor: 'annotation' stamp: 'nice 2/15/2011 23:34'!annotationForPackageforSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing 	information about the given selector and class"	"requestList"	| aCategory |	aClass ifNil: [ ^nil].	aSelector ifNotNil:		[ aCategory := aClass organization categoryOfElement: aSelector.		(aCategory notNil and: [ aCategory first = $* ]) 			ifTrue: [^ aCategory asString]] .		"Ok. So the selector category does not indicate our package. We defer to the class category"	^ aClass category asString.	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'ul 11/15/2010 11:34'!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName := UIManager default request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size = 0]) ifTrue:			[^ Beeper beep].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	self update.	self changed: #mainButtonName.	self changed: #relabel.! !!ChangeSorter methodsFor: 'class list' stamp: 'cmm 5/2/2011 09:56'!classListMenu: aMenu shifted: shifted	"Fill aMenu with items appropriate for the class list"	aMenu title: 'class list'.	aMenu addStayUpItemSpecial.	(parent notNil and: [shifted not])		ifTrue: [aMenu addList: #( "These two only apply to dual change sorters"			('copy class chgs to other side'			copyClassToOther)				('move class chgs to other side'			moveClassToOther))].	aMenu addList: (shifted		ifFalse: [#(			-			('delete class from change set (d)'		forgetClass)			('remove class from system (x)'			removeClass)			-			('browse full (b)'						browseMethodFull)			('browse hierarchy (h)'					spawnHierarchy)			('browse protocol (p)'					browseFullProtocol)			-			('printOut'								printOutClass)			('fileOut'								fileOutClass)			-			('references... (r)'						browseVariableReferences)			('assignments... (a)'						browseVariableAssignments)			('class refs (N)'							browseClassRefs)			-			('more...'								offerShiftedClassListMenu))]		ifTrue: [#(			-			('unsent methods'						browseUnusedMethods)			('unreferenced inst vars'				showUnreferencedInstVars)			('unreferenced class vars'				showUnreferencedClassVars)			-			('sample instance'						makeSampleInstance)			('inspect instances'						inspectInstances)			('inspect subinstances'					inspectSubInstances)			-			('more...'								offerUnshiftedClassListMenu ))]).	^ aMenu! !!ChangeSorter methodsFor: 'code pane' stamp: 'ul 11/15/2010 11:34'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	(class := self selectedClassOrMetaClass) ifNil:		[(myChangeSet preambleString == nil or: [aString size = 0]) ifTrue: [ ^ false].		(aString count: [:char | char == $"]) odd 			ifTrue: [self inform: 'unmatched double quotes in preamble']			ifFalse: [(Scanner new scanTokens: aString) size > 0 ifTrue: [				self inform: 'Part of the preamble is not within double-quotes.To put a double-quote inside a comment, type two double-quotes in a row.(Ignore this warning if you are including a doIt in the preamble.)']].		myChangeSet preambleString: aString.		self currentSelector: nil.  "forces update with no 'unsubmitted chgs' feedback"		^ true].	oldSelector := self selectedMessageName.	category := class organization categoryOfElement: oldSelector.	selector := class compile: aString				classified: category				notifying: aController.	selector ifNil: [^ false].	(self messageList includes: selector)		ifTrue: [self currentSelector: selector]		ifFalse: [self currentSelector: oldSelector].	self update.	^ true! !!ChangeSorter methodsFor: 'message list' stamp: 'ul 11/15/2010 11:34'!removeMessage	"Remove the selected msg from the system. Real work done by the 	parent, a ChangeSorter"	| confirmation sel |	self okToChange		ifFalse: [^ self].	currentSelector		ifNotNil: [confirmation := self systemNavigation   confirmRemovalOf: (sel := self selectedMessageName) on: self selectedClassOrMetaClass.			confirmation = 3				ifTrue: [^ self].			self selectedClassOrMetaClass removeSelector: sel.			self update.			confirmation = 2				ifTrue: [self systemNavigation browseAllCallsOn: sel]]! !!ChangeSorter class methodsFor: 'browse' stamp: 'ul 11/15/2010 11:35'!browseChangeSetsWithClass: class selector: selector	"Put up a menu comprising a list of change sets that hold changes for the given class and selector.  If the user selects one, open a single change-sorter onto it"	| hits index |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ self inform: class name, '.', selector , 'is not in any change set'].	index := hits size = 1		ifTrue:	[1]		ifFalse:	[(UIManager default chooseFrom: (hits collect: [:cs | cs name])					lines: #())].	index = 0 ifTrue: [^ self].	(ChangeSorter new myChangeSet: (hits at: index)) open.! !!ChangeSorter class methodsFor: 'browse' stamp: 'ul 11/15/2010 11:35'!browseChangeSetsWithSelector: aSelector	"Put up a list of all change sets that contain an addition, deletion, or change of any method with the given selector"	| hits index |	hits := self allChangeSets select: 		[:cs | cs hasAnyChangeForSelector: aSelector].	hits isEmpty ifTrue: [^ self inform: aSelector , 'is not in any change set'].	index := hits size = 1		ifTrue:	[1]		ifFalse:	[(UIManager default chooseFrom: (hits collect: [:cs | cs name])					lines: #())].	index = 0 ifTrue: [^ self].	(ChangeSetBrowser new myChangeSet: (hits at: index)) open"ChangeSorter browseChangeSetsWithSelector: #clearPenTrails"! !!ChangedMessageSet methodsFor: 'acceptance' stamp: 'nice 2/23/2011 21:46'!contents: aString notifying: aController	"Accept the string as new source for the current method, and make certain the annotation pane gets invalidated"	| existingSelector existingClass superResult newSelector |	existingSelector := self selectedMessageName.	existingClass := self selectedClassOrMetaClass.	superResult := super contents: aString notifying: aController.	superResult ifTrue:  "succeeded"		[newSelector := existingClass newParser parseSelector: aString.		newSelector ~= existingSelector			ifTrue:   "Selector changed -- maybe an addition"				[self reformulateList.				self changed: #messageList.				self messageList doWithIndex:					[:aMethodReference :anIndex |						(aMethodReference actualClass == existingClass and:									[aMethodReference methodSymbol == newSelector])							ifTrue:								[self messageListIndex: anIndex]]]].	^ superResult! !!ChangesOrganizer commentStamp: 'cbr 7/27/2010 19:17' prior: 0!I manage ChangeSets in the system. See the protocols on my class side.For an example of what I can do, select the following line in a Workspace and print it.ChangesOrganizer allChangeSetNames!!Character methodsFor: 'accessing' stamp: 'nice 5/1/2011 22:13'!leadingChar	"Answer the value of the 8 highest bits which is used to identify the language.	This is mostly used for east asian languages CJKV as a workaround against unicode han-unification."	^ value bitShift: -22! !!Character methodsFor: 'converting' stamp: 'nice 7/20/2011 17:16'!macToSqueak	"Convert the receiver from MacRoman to Squeak encoding"	| asciiValue |	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	asciiValue := #[		196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232	"80-8F"		234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252	"90-9F"		134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216	"A0-AF"		129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248	"B0-BF"		191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156	"C0-CF"		150 151 147 148 145 146 247 179 255 159 185 164 139 155 188 189	"D0-DF"		135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212	"E0-EF"		190 210 218 219 217 208 136 152 175 215 221 222 184 240 253 254 ]	"F0-FF"			at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'converting' stamp: 'nice 7/14/2011 22:34'!squeakToMac	"Convert the receiver from Squeak to MacRoman encoding."	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	^ Character value: (#[		173 176 226 196 227 201 160 224 246 228 178 220 206 179 182 183	"80-8F"		184 212 213 210 211 165 208 209 247 170 185 221 207 186 189 217	"90-9F"		202 193 162 163 219 180 195 164 172 169 187 199 194 197 168 248	"A0-AF"		161 177 198 215 171 181 166 225 252 218 188 200 222 223 240 192 	"B0-BF"		203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 	"C0-CF"		245 132 241 238 239 205 133 249 175 244 242 243 134 250 251 167	"D0-DF"		136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149	"E0-EF"		253 150 152 151 153 155 154 214 191 157 156 158 159 254 255 216	"F0-FF"	] at: value - 127)! !!Character methodsFor: 'copying' stamp: 'ul 4/26/2011 02:33'!clone	"Characters from 0 to 255 are unique, copy only the rest."			value < 256 ifTrue: [ ^self ].	^super clone! !!Character methodsFor: 'copying' stamp: 'ul 4/26/2011 02:33'!copy	"Characters from 0 to 255 are unique, copy only the rest."		value < 256 ifTrue: [ ^self ].	^super copy! !!Character methodsFor: 'copying' stamp: 'ul 4/26/2011 02:33'!deepCopy	"Characters from 0 to 255 are unique, copy only the rest."		value < 256 ifTrue: [ ^self ].	^super deepCopy! !!Character methodsFor: 'copying' stamp: 'ul 4/26/2011 02:35'!shallowCopy	"Characters from 0 to 255 are unique, copy only the rest."			value < 256 ifTrue: [ ^self ].	^super shallowCopy! !!Character methodsFor: 'copying' stamp: 'ul 4/26/2011 02:34'!veryDeepCopyWith: deepCopier	"Characters from 0 to 255 are unique, copy only the rest."		value < 256 ifTrue: [ ^self ].	^super veryDeepCopyWith: deepCopier! !!Character methodsFor: 'printing' stamp: 'eem 5/21/2010 11:11'!hex	^value printStringBase: 16! !!Character methodsFor: 'printing' stamp: 'nice 7/14/2011 22:22'!printOn: aStream	| name |	(value > 32 and: [value ~= 127])		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [ aStream nextPutAll: self class name; nextPutAll: ' value: '; print: value ] ].! !!Character methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28'!storeOn: aStream	"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value."	| name |	self shouldBePrintedAsLiteral		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [					aStream 						nextPut: $(; nextPutAll: self class name; 						nextPutAll: ' value: '; print: value; nextPut: $) ] ].! !!Character methodsFor: 'testing'!isLiteral	^true! !!Character methodsFor: 'testing' stamp: 'nice 7/14/2011 22:21'!shouldBePrintedAsLiteral	^(value between: 33 and: 255) and: [value ~= 127]! !!Character methodsFor: 'testing' stamp: 'eem 11/2/2011 11:03'!shouldBePrintedAsLiteralVisiting: aSet	^self shouldBePrintedAsLiteral! !!Character class methodsFor: 'instance creation' stamp: 'ar 10/25/2010 19:00'!allByteCharacters	"Answer all the characters that can be encoded in a byte"	^ (0 to: 255) collect: [:v | Character value: v] as: String! !!Character class methodsFor: 'instance creation' stamp: 'ul 4/26/2011 02:29'!leadingChar: leadChar code: code	code >= 16r400000 ifTrue: [		self error: 'code is out of range'.	].	leadChar >= 256 ifTrue: [		self error: 'lead is out of range'.	].	code < 256 ifTrue: [ ^self value: code ].	^self value: (leadChar bitShift: 22) + code.! !!Character class methodsFor: 'instance creation' stamp: 'ar 10/25/2010 18:54'!separators	"Answer a collection of the standard ASCII separator characters."	^ #(32 "space"		13 "cr"		9 "tab"		10 "line feed"		12 "form feed")		collect: [:v | Character value: v] as: String! !!CharacterBlock commentStamp: 'mtf 5/15/2010 12:44' prior: 0!I describe the location of one character displayed on the screen. My instances are used to return the results of methods:	Paragraph characterBlockAtPoint: aPoint and	Paragraph characterBlockForIndex: stringIndex.Any recomposition or movement of a Paragraph can make the information I store stale.text (Text): The text where my character is fromstringIndex (Integer): The index of my character in the text, starting from 1textLine (TextLine): The displayed line my character is onorigin (Point): The top-left corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0corner (Point): The bottom-right corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0!!CharacterBlockScanner methodsFor: 'scanning' stamp: 'nice 4/15/2011 21:50'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop stopCondition |	line := textLine.	rightMargin := line rightMargin.	lastIndex := line first.	self setStopConditions.		"also sets font"	characterIndex := index.  " == nil means scanning for point"	characterPoint := aPoint.	(characterPoint isNil or: [characterPoint y > line bottom])		ifTrue: [characterPoint := line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX := leftMargin := line leftMarginForAlignment: alignment.	destY := line top.	runLength := text runLengthFor: line first.	lineStop := characterIndex	"scanning for index"		ifNil: [ line last ].			"scanning for point"	runStopIndex := lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0.	[		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block operations."		self lastCharacterExtentSetX: (specialWidth			ifNil: [font widthOf: (text at: lastIndex)]			ifNotNil: [specialWidth]).		self perform: stopCondition	] whileFalse.	characterIndex		ifNil: [			"Result for characterBlockAtPoint: "			(stopCondition ~~ #cr and: [ lastIndex == line last				and: [ aPoint x > ((characterPoint x) + (lastCharacterExtent x / 2)) ]])					ifTrue: [ "Correct for right half of last character in line"						^ (CharacterBlock new stringIndex: lastIndex + 1								text: text								topLeft: characterPoint + (lastCharacterExtent x @ 0) + (font descentKern @ 0)								extent:  0 @ lastCharacterExtent y)							textLine: line ].				^ (CharacterBlock new					stringIndex: lastIndex					text: text topLeft: characterPoint + (font descentKern @ 0)					extent: lastCharacterExtent - (font baseKern @ 0))							textLine: line]		ifNotNil: ["Result for characterBlockForIndex: "				^ (CharacterBlock new					stringIndex: characterIndex					text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)					extent: lastCharacterExtent)							textLine: line]! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'nice 4/15/2011 21:45'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex := characterIndex.			characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter := (text at: lastIndex).				characterPoint := destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter := (text at: line last).				characterPoint := destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex := lastIndex + 1.	lastCharacter := text at: lastIndex.	currentX := destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint := currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1) font: font))].	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'cmm 6/12/2010 11:52'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: (stopIndex min: sourceString size) in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := EncodedCharSet scanSelectorAt: startEncoding.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stops with: kernDelta).	].		^ stops endOfRun! !!CharacterSet methodsFor: 'collection ops' stamp: 'ul 9/28/2011 14:04'!add: aCharacter	"I automatically become a WideCharacterSet if you add a wide character to myself"		aCharacter asciiValue >= 256		ifTrue: [| wide |			wide := WideCharacterSet new.			wide addAll: self.			wide add: aCharacter.			self becomeForward: wide.			^aCharacter].	map at: aCharacter asciiValue + 1 put: 1.	^aCharacter! !!CharacterSet methodsFor: 'conversion' stamp: 'ar 10/25/2010 18:54'!asString	"Convert the receiver into a String"	^String new: self size streamContents:[:s|		self do:[:ch| s nextPut: ch].	].! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'ul 9/28/2011 14:04'!removeAll	self becomeForward: CharacterSet new! !!CharacterTest methodsFor: 'testing-printing' stamp: 'nice 2/23/2011 22:01'!testPrintStringAll	Character allCharacters do: [ :each |		self assert: (self class newCompiler 			evaluate: each printString) = each ].! !!CharacterTest methodsFor: 'testing-printing' stamp: 'nice 2/23/2011 22:01'!testStoreStringAll	Character allCharacters do: [ :each |		self assert: (self class newCompiler 			evaluate: each storeString) = each ].! !!CharacterTest methodsFor: 'tests - various' stamp: 'ar 10/25/2010 18:59'!testCharacterSeparators	"Regression test"	| result |	self shouldnt:[result := '/', Character separators] raise: Error.	self assert: result size = (Character separators size + 1).	self shouldnt:[result := '/', CharacterSet separators] raise: Error.	self assert: result size = (CharacterSet separators asArray size + 1).! !!ChronologyConstants commentStamp: 'brp 3/12/2004 14:34' prior: 0!ChronologyConstants is a SharedPool for the constants used by the Kernel-Chronology classes.!!CircleMorph methodsFor: 'parts bin' stamp: 'nice 5/6/2011 00:12'!initialize	super initialize.	self extent: 40@40;		color: Color green lighter! !!Class methodsFor: 'initialize-release' stamp: 'spd 12/4/2010 13:21'!declare: varString 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	| newVars conflicts |		newVars := 		(Scanner new scanFieldNames: varString)			collect: [:x | x asSymbol].	newVars do:		[:var | var first canBeGlobalVarInitial			ifFalse: [self error: var, ' class variable name should be capitalized; proceed to include anyway.']].	conflicts := false.	classPool == nil 		ifFalse: [(classPool keys reject: [:x | newVars includes: x]) do: 					[:var | self removeClassVarName: var]].	(newVars reject: [:var | self classPool includesKey: var])		do: [:var | "adding"			"check if new vars defined elsewhere"			(self canFindWithoutEnvironment: var) ifTrue: [					(DuplicateVariableError new)						superclass: superclass; "fake!!!!!!"						variable: var;						signal: var, ' is already defined'.					conflicts := true]].	newVars size > 0		ifTrue: 			[classPool := self classPool.			"in case it was nil"			newVars do: [:var | classPool declare: var from: Undeclared]].	^conflicts! !!Class methodsFor: 'testing' stamp: 'nice 5/6/2011 22:54'!whichMethodsStoreInto: varName 	"Answer a collection of CompiledMethod whose methods access the argument, varName, as a named class variable. Or let super try with a named instance variable."	| ref |	ref := self classPool		associationAt: varName		ifAbsent: [ ^ super whichMethodsStoreInto: varName ].	^self methodDict values select: [:eachMethod | eachMethod writesRef: ref ]! !!Class methodsFor: 'testing' stamp: 'nice 5/7/2011 14:04'!whichSelectorsStoreInto: varName 	"Answer a collection of selectors whose methods access the argument, varName, as a named class variable. Or let super try with a named instance variable."	| ref |	ref := self classPool		associationAt: varName		ifAbsent: [ ^ super whichSelectorsStoreInto: varName ].	^self methodDict keys select: [:aSelector | (self methodDict at: aSelector) writesRef: ref ]! !!Class methodsFor: 'class variables' stamp: 'spd 12/4/2010 13:20'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol oldState |	oldState := self copy.	aString first canBeGlobalVarInitial		ifFalse: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol := aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		(self canFindWithoutEnvironment: symbol) ifTrue: [			(DuplicateVariableError new)				superclass: superclass; "fake!!!!!!"				variable: aString;				signal: aString, ' is already defined']].	classPool == nil ifTrue: [classPool := Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		classPool declare: symbol from: Undeclared.		SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: oldState to: self]! !!Class methodsFor: 'class variables' stamp: 'cmm 5/1/2011 22:05'!allClassVarNames	"Answer a Set of the names of the receiver's class variables, including those defined in the superclasses of the receiver."	| aSet |	^ self superclass == nil		ifTrue: 			[self classVarNames asSet]  "This is the keys so it is a new Set."		ifFalse: 			[aSet := self superclass allClassVarNames.			aSet addAll: self classVarNames.			aSet]! !!Class methodsFor: 'compiling' stamp: 'spd 12/3/2010 13:32'!canFindWithoutEnvironment: varName	"This method is used for analysis of system structure -- see senders."	"Look up varName, in the context of the receiver. Return true if it can be found without using the declared environment."	"First look in classVar dictionary."	(self classPool bindingOf: varName) ifNotNil:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool bindingOf: varName) ifNotNil:[^true].	].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil		ifTrue: [^ false]		ifFalse: [^ superclass canFindWithoutEnvironment: varName].! !!Class methodsFor: 'copying' stamp: 'nice 12/29/2010 10:47'!copy 	"Answer a copy of the receiver without a list of subclasses."	| newClass |	newClass := self class copy new		superclass: superclass		methodDict: self methodDict copy		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools copy.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'organization' stamp: 'laza 12/14/2011 16:13'!category: aString 	"Categorize the receiver under the system category, aString, removing it from 	any previous categorization."	| oldCategory |	oldCategory := category.	aString isString		ifTrue: [			category := aString asSymbol.			SystemOrganization classify: self name under: category ]		ifFalse: [self errorCategoryName]! !!Class methodsFor: '*monticello' stamp: 'cmm 3/8/2011 20:55'!workingCopy	^ self packageInfo workingCopy! !!Class methodsFor: '*HelpSystem-Core' stamp: 'tbn 3/11/2010 23:42'!asHelpTopic	^SystemReference forClass: self! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:26'!addMethods	^ addMethods! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:26'!addMethods: anObject	addMethods := anObject! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:02'!addSubclasses	^ addSubclasses! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:02'!addSubclasses: anObject	addSubclasses := anObject! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:45'!subclassesAsSeparateTopic	^ subclassesAsSeparateTopic! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:45'!subclassesAsSeparateTopic: anObject	subclassesAsSeparateTopic := anObject! !!ClassAPIHelpBuilder methodsFor: 'building' stamp: 'ul 4/30/2011 03:26'!build	CurrentReadOnlySourceFiles cacheDuring: [		topicToBuild := (HelpTopic named: rootToBuildFrom name).		topicToBuild icon: (HelpIcons iconNamed: #pageIcon).		topicToBuild contents: rootToBuildFrom comment.			addMethods ifTrue: [ self buildSubnodesForMethods ].		addSubclasses	 ifTrue: [ self buildSubnodesForSubclasses ] ].	 ! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'ul 4/30/2011 03:44'!buildMethodTopicsOn: topic for: aClass		topic contents: (String streamContents: [ :stream |		aClass selectors sort do: [ :selector |			stream 				nextPutAll: aClass name;				nextPutAll: '>>';				nextPutAll: selector asString;				cr;				nextPutAll: (					(aClass commentsAt: selector)						at: 1						ifAbsent: [ 'Method has no comment.' ]);				cr; cr ] ])! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/8/2010 16:56'!buildSubclassTopicFor: aSubclass	 	^(self class new) 			rootToBuildFrom: aSubclass;			addSubclasses: addSubclasses;			addMethods: addMethods;			subclassesAsSeparateTopic: subclassesAsSeparateTopic;			build;			topicToBuild 	 ! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/23/2010 21:40'!buildSubnodesForMethods	| instanceSide classSide |	instanceSide := HelpTopic named: 'Instance side'.	classSide := HelpTopic named: 'Class side'.	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	topicToBuild 		addSubtopic: instanceSide;		addSubtopic: classSide.	self buildMethodTopicsOn: instanceSide for: rootToBuildFrom.		self buildMethodTopicsOn: classSide for: rootToBuildFrom class.	! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/23/2010 21:40'!buildSubnodesForSubclasses	| topic |	rootToBuildFrom subclasses isEmpty ifTrue: [^self].	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	topic := subclassesAsSeparateTopic 				ifTrue: [topicToBuild addSubtopic: (HelpTopic named: 'Subclasses')]				ifFalse: [topicToBuild ].	rootToBuildFrom subclasses 		do: [:subclass | topic addSubtopic: (self buildSubclassTopicFor: subclass)].	topic sortSubtopicsByTitle.	! !!ClassAPIHelpBuilder methodsFor: 'initialize-release' stamp: 'tbn 3/8/2010 16:37'!initialize	"Initializes the receiver"		super initialize.	addSubclasses := false.	addMethods := true.	subclassesAsSeparateTopic := true.! !!ClassAPIHelpBuilder commentStamp: 'tbn 4/30/2010 15:37' prior: 0!A builder to build the API Help for a classInstance Variables	addMethods:		<Boolean>	addSubclasses:		<Boolean>	subclassesAsSeparateTopic:		<Boolean>addMethods	- When true the builder will include method helpaddSubclasses	- When true the builder will recursively go through and add subclassessubclassesAsSeparateTopic	- xxxxx!!ClassAPIHelpBuilder class methodsFor: 'building' stamp: 'tbn 3/11/2010 23:39'!buildHierarchicalHelpTopicFrom: aClass withSubclasses: aBoolean withMethods: anotherBoolean	"Start building from the given class"		^(self new)		addSubclasses: aBoolean;		addMethods: anotherBoolean;		rootToBuildFrom: aClass;		build;		topicToBuild ! !!ClassAPIHelpBuilderTest methodsFor: 'testing' stamp: 'ul 3/17/2011 02:46'!testDefaultBuilding	|topic|	topic := CurrentReadOnlySourceFiles cacheDuring: [		ClassAPIHelpBuilder buildHelpTopicFrom: Integer ].	self assert: topic subtopics size = 2.	self assert: topic subtopics first title = 'Instance side'.	self assert: topic subtopics last title = 'Class side'  ! !!ClassAPIHelpBuilderTest methodsFor: 'testing' stamp: 'ul 3/17/2011 02:47'!testMethodsButNoSubclasses	|topic|	topic := CurrentReadOnlySourceFiles cacheDuring: [		ClassAPIHelpBuilder 			buildHierarchicalHelpTopicFrom: Integer 			withSubclasses: false 			withMethods: true ].	self assert: topic subtopics size = 2.	self assert: topic subtopics first title = 'Instance side'.	self assert: topic subtopics last title = 'Class side'  ! !!ClassBuilder methodsFor: 'class definition' stamp: 'laza 12/14/2011 10:23'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass instVars classVars copyOfOldClass newClass | 	environ := env.	instVars := Scanner new scanFieldNames: instVarString.	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass := env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse: [oldClass := nil]  "Already checked in #validateClassName:"		ifTrue: [			copyOfOldClass := oldClass copy.			copyOfOldClass superclass addSubclass: copyOfOldClass].			[ | newCategory needNew force organization oldCategory |	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined. \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass := self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.	] ifFalse:[		"Reuse the old class"		newClass := oldClass.	].	"Install the class variables and pool dictionaries... "	force := (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	newCategory := category asSymbol.	organization := environ ifNotNil:[environ organization].	oldClass isNil ifFalse: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].	organization classify: newClass name under: newCategory suppressIfDefault: true.	newClass environment: environ.	"... recompile ..."	newClass := self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[environ at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		environ flushClassNameCache.	].	newClass doneCompiling.	"... notify interested clients ..."	oldClass isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.		^ newClass].	newCategory ~= oldCategory 		ifTrue: [SystemChangeNotifier uniqueInstance class: newClass recategorizedFrom: oldCategory to: category]		ifFalse: [SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.].] ensure: 		[copyOfOldClass ifNotNil: [copyOfOldClass superclass removeSubclass: copyOfOldClass].		Behavior flushObsoleteSubclasses.		].	^newClass! !!ClassBuilder methodsFor: 'validation' stamp: 'ul 6/17/2011 12:21'!validateClass: srcClass forMoving: iv downTo: dstClass	"Make sure that we don't have any accesses to the instVar left"	srcClass withAllSubclassesDo:[:cls|		(cls == dstClass or:[cls inheritsFrom: dstClass]) ifFalse:[			(cls whichSelectorsAccess: iv) isEmpty ifFalse:[				self notify: (iv printString asText allBold), ' is still used in ', cls name asText allBold,'.Proceed to move it to Undeclared'.			].		].	].	^true! !!ClassBuilder methodsFor: 'private' stamp: 'ar 6/14/2010 22:06'!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		ProtoObject Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext BlockClosure		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:57'!categoryNameForTemporaryClasses	"Answer the category where to classify temporarily created classes"		^'Dummy-Tests-ClassBuilder'! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55'!cleanup	subClass ifNotNil:[subClass removeFromSystem].	baseClass ifNotNil:[baseClass removeFromSystem].	(Smalltalk organization listAtCategoryNamed: self categoryNameForTemporaryClasses) isEmpty		ifTrue: [Smalltalk organization removeCategory: self categoryNameForTemporaryClasses]! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55'!makeByteVariableSubclassOf: aClass	subClass := aClass variableByteSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55'!makeIVarsSubclassOf: aClass	subClass := aClass subclass: self subClassName		instanceVariableNames: 'var3 var4'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55'!makeNormalSubclassOf: aClass	subClass := aClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55'!makeVariableSubclassOf: aClass	subClass := aClass variableSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55'!makeWeakSubclassOf: aClass	subClass := aClass weakSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55'!makeWordVariableSubclassOf: aClass	subClass := aClass variableWordSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:55'!testByteVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableByteSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self should:[self makeIVarsSubclassOf: baseClass] raise: Error.	self should:[self makeVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWeakSubclassOf: baseClass] raise: Error.	"bit classes"	self shouldnt:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56'!testChangeToVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[		self shouldnt:[baseClass := Object variableSubclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56'!testSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert:(subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert:(subClass isVariable).	self assert:(subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self shouldnt:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWordVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56'!testSubclassWithInstanceVariables	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var1 var2'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56'!testVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	"pointer classes"	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56'!testWeakSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object weakSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	"pointer classes"	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56'!testWordVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableWordSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self should:[self makeIVarsSubclassOf: baseClass] raise: Error.	self should:[self makeVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWeakSubclassOf: baseClass] raise: Error.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self shouldnt:[self makeWordVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'nice 9/21/2010 11:56'!testDuplicateClassVariableError	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: 'TestVar'		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	self should:[		subClass := baseClass subclass: self subClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] raise: DuplicateVariableError.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'TestVar'.		ex resume.	].	self shouldnt:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] raise: Error.	self should:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] raise: DuplicateVariableError.	[baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'TestVar'.		ex resume.	].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'nice 9/21/2010 11:56'!testDuplicateInstanceVariableError	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	self should:[		subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] raise: DuplicateVariableError.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'var'.		ex resume.	].	self shouldnt:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] raise: Error.	self should:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] raise: DuplicateVariableError.	[baseClass := Object subclass: self baseClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'var'.		ex resume.	].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'nice 9/21/2010 11:56'!testMoveVarFromSubToSuperclass	| baseInst subInst |	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	subClass := baseClass subclass: self subClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	subClass compile: 'subGet ^var'.	subClass compile: 'subSet: v var := v'.	self assert:[baseClass instSize = 0].	self assert:[subClass instSize = 1].	baseInst := baseClass new.	subInst := subClass new.	subInst instVarAt: 1 put: 123.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst subGet) = 123.	[baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	] on: DuplicateVariableError do:[:ex| ex resume].	baseClass compile: 'superGet ^var'.	baseClass compile: 'superSet: v var := v'.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 2].	"the assumption here is that an existing value is propagated up"	self assert: (baseInst instVarAt: 1) = nil.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst instVarAt: 2) = 123.	"the assumption below is that the subclass binds to the local scope not	the outer one, which is in line with common name space approaches."	subInst superSet: 666.	subInst subSet: 321.	self assert: (subInst instVarAt: 1) = 666.	self assert: (subInst instVarAt: 2) = 321.	self assert: (subInst superGet) = 666.	self assert: (subInst subGet) = 321.	subClass := baseClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 1].	"the assumption here is that the current (subclass) value is propagated up"	self assert: (subInst instVarAt: 1) = 321.	self assert: (subInst subGet) = 321.! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'nice 9/21/2010 11:56'!testMoveVarFromSuperToSubclass	| baseInst subInst |	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	baseClass compile: 'superGet ^var'.	baseClass compile: 'superSet: v var := v'.	subClass := baseClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	subClass compile: 'subGet ^var'.	subClass compile: 'subSet: v var := v'.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 1].	baseInst := baseClass new.	subInst := subClass new.	baseInst instVarAt: 1 put: 42.	subInst instVarAt: 1 put: 123.	self assert: (baseInst instVarAt: 1) = 42.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst subGet) = 123.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] on: DuplicateVariableError do:[:ex| ex resume].	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 2].	self assert: (baseInst instVarAt: 1) = 42.	"the assumption below is that for duplicate variables the values get duplicated too.	this isn't strictly necessary; what we really need is that the old var doesn't get 	nuked but it has some advantages when moving vars up the hierarchy"	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst instVarAt: 2) = 123.	self assert: (subInst superGet) = 123.	self assert: (subInst subGet) = 123.	"the assumption below is that the subclass binds to the local scope not	the outer one, which is in line with common name space approaches."	subInst superSet: 666.	subInst subSet: 321.	self assert: (subInst instVarAt: 1) = 666.	self assert: (subInst instVarAt: 2) = 321.	self assert: (subInst superGet) = 666.	self assert: (subInst subGet) = 321.	baseClass removeSelector: #superGet.	baseClass removeSelector: #superSet:.	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	self assert:[baseClass instSize = 0].	self assert:[subClass instSize = 1].	self assert: (subInst instVarAt: 1) = 321.	self assert: (subInst subGet) = 321.! !!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'nice 2/23/2011 21:46'!scanFromNoCompile: aStream 	"Just move the source code for the methods from aStream."	| methodText selector |	[methodText := aStream nextChunkText.	 methodText size > 0]		whileTrue:		[(SourceFiles at: 2) ifNotNil: [			selector := class newParser parseSelector: methodText.			(class compiledMethodAt: selector) putSource: methodText 				fromParseNode: nil class: class category: category				withStamp: changeStamp inFile: 2 priorMethod: nil]]! !!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'fbs 5/6/2011 21:08'!scanVersionsOf: class 	"Scan for all past versions of the class comment of the given class"	| oldCommentRemoteStr sourceFilesCopy position prevPos stamp preamble tokens prevFileIndex |	classOfMethod := class.	oldCommentRemoteStr := class  organization commentRemoteStr.	currentCompiledMethod := oldCommentRemoteStr.	selectorOfMethod := #Comment.	changeList := OrderedCollection new.	list := OrderedCollection new.	listIndex := 0.	oldCommentRemoteStr ifNil:[^ nil] ifNotNil: [oldCommentRemoteStr sourcePointer].	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	position := oldCommentRemoteStr position.	file := sourceFilesCopy at: oldCommentRemoteStr sourceFileNumber.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  " Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble := file nextChunk].		prevPos := nil.		stamp := ''.		(preamble findString: 'commentStamp:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble.				(tokens at: tokens size-3) = #commentStamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]]			ifFalse: ["The stamp get lost, maybe after a condenseChanges"					stamp := '<historical>']. 		self addItem:				(ChangeRecord new file: file position: position type: #classComment						class: class name category: nil meta: class isMeta stamp: stamp)			text: stamp , ' ' , class name , ' class comment'. 		prevPos = 0 ifTrue:[prevPos := nil].		position := prevPos.		prevPos notNil 					ifTrue:[file := sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections := Array new: list size withAll: false! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'nice 8/19/2010 16:32'!allMethodCategoriesIntegratedThrough: mostGenericClass	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"	| aColl |	aColl := OrderedCollection new.	self withAllSuperclasses do:		[:aClass |			(aClass includesBehavior: mostGenericClass)				ifTrue:	[aColl addAll: aClass organization categories]].	aColl remove: 'no messages' asSymbol ifAbsent: [].	^aColl asSet asArray sort: [:a :b | a asLowercase < b asLowercase]"ColorTileMorph allMethodCategoriesIntegratedThrough: TileMorph"! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'MarcusDenker 3/5/2010 14:33'!methodsInCategory: aName 	"Answer a list of the methods of the receiver that are in category named aName"		| aColl |	aColl := Set withAll: (aName = ClassOrganizer allCategory			ifTrue: [self organization allMethodSelectors]			ifFalse: [self organization listAtCategoryNamed: aName]).	^ aColl asArray sort! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'nice 12/29/2010 12:29'!isClassSide	^self isMeta! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ul 11/15/2010 10:11'!moveClassCommentTo: aFileStream fileIndex: newFileIndex	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file fileIndex.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."	| header aStamp aCommentRemoteStr |	self isMeta ifTrue: [^ self].  "bulletproofing only"	((aCommentRemoteStr := self organization commentRemoteStr) isNil or:		[aCommentRemoteStr sourceFileNumber = 1]) ifTrue: [^ self].	aFileStream cr; nextPut: $!!.	header := String streamContents: [:strm | strm nextPutAll: self name;		nextPutAll: ' commentStamp: '.		(aStamp := self organization commentStamp ifNil: ['<historical>']) storeOn: strm.		strm nextPutAll: ' prior: 0'].	aFileStream nextChunkPut: header.	aFileStream cr.	self organization classComment: (RemoteString newString: self organization classComment onFileNumber: newFileIndex toFile: aFileStream) stamp: aStamp! !!ClassDescription methodsFor: 'instance variables' stamp: 'bf 11/17/2011 14:15'!chooseVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter."	| lines labelStream allVars index |	(self allInstVarNames size + self theNonMetaClass allClassVarNames size) = 0 ifTrue: [ ^ self inform: 'There are no variables.' ].	allVars := OrderedCollection new.	lines := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[ : class | | vars |		vars := class instVarNames , class theNonMetaClass classVarNames.		vars do:			[ : var | labelStream				 nextPutAll: var ;				 cr.			allVars add: var ].		vars isEmpty ifFalse: [ lines add: allVars size ] ].	labelStream skip: -1.	"cut last CR"	(lines size > 0 and: [ lines last = allVars size ]) ifTrue: [ lines removeLast ].	"dispense with inelegant line beneath last item"	index := UIManager default		chooseFrom: (labelStream contents subStrings: {Character cr})		lines: lines		title: 'Variables in ' , self name.	index = 0 ifTrue: [ ^ self ].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: 'instance variables' stamp: 'ul 11/15/2010 10:10'!instVarIndexFor: instVarName ifAbsent: aBlock	"Answer the index of the named instance variable."	| index |	index := instanceVariables == nil 				ifTrue: [0]				ifFalse: [instanceVariables indexOf: instVarName ifAbsent: [0]].	index = 0 ifTrue: 		[^superclass == nil 			ifTrue: [aBlock value]			ifFalse: [superclass instVarIndexFor: instVarName ifAbsent: aBlock]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!ClassDescription methodsFor: 'instance variables' stamp: 'nice 2/23/2011 21:47'!replaceSilently: old to: new	"text-replace any part of a method.  Used for class and pool variables.  Don't touch the header.  Not guaranteed to work if name appears in odd circumstances"	| oldName newName |	oldName := old asString.	newName := new asString.	self withAllSubclasses do:		[:cls |		| sels |		sels := cls selectors copyWithoutAll: #(DoIt DoItIn:).		sels do:			[:sel |			| oldCode newCode parser header body |			oldCode := cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser := cls newParser) parseSelector: oldCode.			header := oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body := header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode := header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].		cls isMeta ifFalse:			[| oldCode newCode |			oldCode := cls comment.			newCode := oldCode copyReplaceTokens: oldName with: newName.			newCode ~= oldCode ifTrue:				[cls comment: newCode]]]! !!ClassDescription methodsFor: 'printing' stamp: 'nice 10/22/2009 09:39'!classVariablesString	"Answer a string of my class variable names separated by spaces."	^String streamContents: [ :stream | 		self classVarNames 			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 2/23/2011 21:46'!replaceSelector: originalSelector withAlias: aliasSelector in: source	"replaces originalSelector with aliasSelector in in given source code"	| oldKeywords newKeywords args selectorWithArgs s |	oldKeywords := originalSelector keywords.	newKeywords := aliasSelector keywords.	oldKeywords size = newKeywords size ifFalse:[self error: 'Keyword mismatch'].	args := (self newParser parseArgsAndTemps: source asString notifying: nil) 				copyFrom: 1 to: originalSelector numArgs.	selectorWithArgs := String streamContents: [:stream |		newKeywords keysAndValuesDo: [:index :keyword |			stream nextPutAll: keyword.			stream space.			args size >= index ifTrue: [				stream nextPutAll: (args at: index); space]]].	s := source asString readStream.	oldKeywords do: [ :each | s match: each ].	args isEmpty ifFalse: [ s match: args last ].	^selectorWithArgs withBlanksTrimmed asText , s upToEnd! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 2/23/2011 21:39'!traitAddSelector: selector withMethod: traitMethod	"Add a method inherited from a trait. 	Recompiles to avoid sharing and implement aliasing."	| oldMethod source methodNode newMethod originalSelector |	oldMethod := self compiledMethodAt: selector ifAbsent:[nil].	oldMethod ifNotNil:[		"The following is an important optimization as it prevents exponential		growth in recompilation. If T1 is used by T2 and T2 by T3 then (without		this optimization) any change in T1 would cause all methods in T2 to be		recompiled and each recompilation of a method in T2 would cause T3		to be fully recompiled. The test eliminates all such situations."		(oldMethod sameTraitCodeAs: traitMethod) ifTrue:[^oldMethod].	].	originalSelector := traitMethod selector.	source := traitMethod methodClass sourceCodeAt: originalSelector.	originalSelector == selector ifFalse:[		"Replace source selectors for aliases"		source := self replaceSelector: originalSelector withAlias: selector in: source.	].	methodNode := self newCompiler		compile: source in: self classified: nil notifying: nil ifFail:[^nil].	newMethod := methodNode generate: self defaultMethodTrailer.	newMethod putSource: source fromParseNode: methodNode inFile: 2		withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Trait method'; cr].	newMethod originalTraitMethod: traitMethod.	^super addSelectorSilently: selector withMethod: newMethod.! !!ClassDescription methodsFor: 'filein/out' stamp: 'MarcusDenker 2/21/2010 12:51'!moveChangesWithVersionsTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	changes := self selectors select: [:sel | (self methodDict at: sel) fileIndex > 1].	self fileOutChangedMessagesHistorically: changes		on: newFile		moveSource: true		toFile: 2! !!ClassDiffBuilder methodsFor: 'private' stamp: 'ul 11/4/2010 22:33'!print: aString withAttributes: attributes on: stream	stream		currentAttributes: attributes;		nextPutAll: aString! !!ClassDiffBuilder methodsFor: 'private' stamp: 'ul 11/16/2010 06:08'!split: aString	"I return an array with aString splitted by whitespace ' and ""."	^Array streamContents: [ :stream |		| input separators |		input := aString readStream.		separators := CharacterSet separators			add: $'; "for variables"			add: $"; "for comments in mc"			yourself.		[ input atEnd ] whileFalse: [			| word separator |			word := input				upToAnyOf: separators				do: [ :matchingSeparator |					separator := matchingSeparator ].			stream nextPut: word.			separator ifNotNil: [				stream nextPut: separator asString ] ] ]! !!ClassForBehaviorTest methodsFor: 'accessing' stamp: 'nice 5/7/2011 13:59'!initialize	iv1 := CV1 ifNil: [CV1 := 1]! !!ClassForBehaviorTest methodsFor: 'accessing' stamp: 'nice 5/7/2011 13:56'!iv1	^iv1! !!ClassForBehaviorTest methodsFor: 'accessing' stamp: 'nice 5/7/2011 13:56'!iv1: anyObject	iv1 := anyObject! !!ClassForBehaviorTest methodsFor: 'accessing' stamp: 'nice 5/7/2011 13:56'!iv2	^iv2! !!ClassForBehaviorTest methodsFor: 'accessing' stamp: 'nice 5/7/2011 13:56'!iv2: anyObject	iv2 := anyObject! !!ClassForBehaviorTest methodsFor: 'accessing' stamp: 'nice 5/7/2011 13:57'!reset	iv1 := iv2 := nil! !!ClassForBehaviorTest class methodsFor: 'accessing' stamp: 'nice 5/7/2011 14:13'!civ1	^civ1 ifNil: [civ1 := false]! !!ClassForBehaviorTest class methodsFor: 'class initialization' stamp: 'nice 5/7/2011 13:59'!initialize	CV1 := 1.	CV2 := 2! !!ClassListBrowser methodsFor: 'initialization' stamp: 'fbs 3/9/2011 11:42'!initForClassesNamed: nameList title: aTitle	"Initialize the receiver for the class-name-list and title provided"	self systemOrganizer: SystemOrganization.	metaClassIndicated := false.	defaultTitle := aTitle.	classDisplayList := nameList copy.	self class openBrowserView:  (self openSystemCatEditString: nil)		label: aTitle	"ClassListBrowser new initForClassesNamed: #(Browser CategoryViewer) title: 'Frogs'"! !!ClassOrganizer methodsFor: 'accessing' stamp: 'laza 12/8/2011 14:54'!addCategory: catString before: nextCategory	SystemChangeNotifier uniqueInstance		doSilently: [super addCategory: catString before: nextCategory];		protocolAdded: catString inClass: self subject! !!ClassOrganizer methodsFor: 'accessing' stamp: 'laza 12/8/2011 14:53'!removeCategory: cat 	SystemChangeNotifier uniqueInstance		doSilently: [super removeCategory: cat];		protocolRemoved: cat inClass: self subject! !!ClassOrganizer methodsFor: 'accessing' stamp: 'laza 12/8/2011 14:56'!renameCategory: oldCatString toBe: newCatString	SystemChangeNotifier uniqueInstance		doSilently: [super renameCategory: oldCatString toBe: newCatString];		protocolRenamedFrom: oldCatString asSymbol to: newCatString asSymbol inClass: self subject! !!ClassTest methodsFor: 'setup' stamp: 'nice 9/21/2010 11:58'!categoryNameForTemporaryClasses	"Answer the category where to classify temporarily created classes"		^'Dummy-Tests-Class'! !!ClassTest methodsFor: 'setup' stamp: 'nice 9/21/2010 12:04'!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassTest methodsFor: 'setup' stamp: 'nice 9/21/2010 12:01'!tearDown	self deleteClass.	self deleteRenamedClass.	(Smalltalk organization listAtCategoryNamed: self categoryNameForTemporaryClasses) isEmpty		ifTrue: [Smalltalk organization removeCategory: self categoryNameForTemporaryClasses]! !!ClassTrait methodsFor: 'accessing' stamp: 'nice 2/15/2011 23:16'!category	"Answer the category used for classifying this ClassTrait.	The category is shared between a Trait and its associated ClassTrait."		^baseTrait category! !!ClickExerciser methodsFor: 'event handling' stamp: 'mtf 2/20/2011 20:41'!mouseDown: evt 	"Do nothing upon mouse-down except inform the hand to watch for a  	double-click; wait until an ensuing click:, doubleClick:, or drag:  	message gets dispatched"	Preferences disable: #NewClickTest .	evt hand		waitForClicksOrDrag: self		event: evt		selectors: self selectors		threshold: HandMorph dragThreshold! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'HenrikSperreJohansen 5/27/2010 14:01'!testBlockDoitDecompilation	"Tests that decompile of a doit block with remote vars executes correcly"	"Tests that decompilation of a Block, when 'method' of block is equivalent to that compiled by a DoIt, preserves the temp names "		|blockSourceStream methodNode compiledMethod block decompiledBlock|	blockSourceStream := '|x y| [:a :b | x := a. y := b. x + y]' readStream.	methodNode := nil class evaluatorClass new 						from: blockSourceStream class: nil class context: nil notifying: nil;						translate: blockSourceStream noPattern: true ifFail: [nil].	compiledMethod := methodNode generateWithTempNames.	block := nil withArgs: #() executeMethod: compiledMethod.		self shouldnt: [decompiledBlock := block decompile] raise: Error.	self assert: '{[:a :b | x := a.	y := b.	x + y]}' equals: decompiledBlock printString! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'nice 2/23/2011 21:39'!testDecompiledDoitMethodTempNames	"self new testDecompiledDoitMethodTempNames"	"Test that a decompiled doit that has been copied with temps decompiles to the input"	| removeComments |	removeComments := [:n| n comment: nil].	self closureCases do:		[:source| | mns m mps mnps |		"Need to compare an ungenerated tree with the generated method's methodNode		 because generating code alters the tree when it introduces remote temp vectors."		mns := #(first last) collect:					[:ignored|					source first isLetter						ifTrue:							[self class newCompiler								compile: source								in: self class								notifying: nil								ifFail: [self error: 'compilation error']]						ifFalse:							[self class newCompiler								compileNoPattern: source								in: self class								context: nil								notifying: nil								ifFail: [self error: 'compilation error']]].		m := (mns last generateWithTempNames).		removeComments value: mns first.		mns first nodesDo: removeComments.		self assert: (mnps := mns first printString) = (mps := m methodNode printString)]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'nice 2/23/2011 21:39'!testMethodAndNodeTempNames	"self new testMethodAndNodeTempNames"	"Test that BytecodeAgnosticMethodNode>>blockExtentsToTempRefs answers the same	 structure as CompiledMethod>>blockExtentsToTempRefs when the method has been	 copied with the appropriate temps.  This tests whether doit methods are debuggable	 since they carry their own temps."	self closureCases do:		[:source| | mn om m mbe obe |		mn := source first isLetter					ifTrue:						[self class newCompiler							compile: source							in: self class							notifying: nil							ifFail: [self error: 'compilation error']]					ifFalse:						[self class newCompiler							compileNoPattern: source							in: self class							context: nil							notifying: nil							ifFail: [self error: 'compilation error']].		m := (om := mn generate) copyWithTempsFromMethodNode: mn.		self assert: m holdsTempNames.		self assert: m endPC = om endPC.		mbe := m blockExtentsToTempsMap.		obe := mn blockExtentsToTempsMap.		self assert: mbe keys asSet = obe keys asSet.		(mbe keys intersection: obe keys) do:			[:interval|			self assert: (mbe at: interval) = (obe at: interval)]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 9/5/2009 17:33'!testOptimizedBlockLocalNilling1	"Whether a block is optimized or not a block-local temp	 should be nil at the start of each evaluation of the block."	1 to: 3 do: [:i| | j |		self assert: j isNil.		j := i + 1.		self assert: j isNil not]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 9/5/2009 17:32'!testOptimizedBlockLocalNilling2	"Whether a block is optimized or not a block-local temp	 should be nil at the start of each evaluation of the block."	1 to: 6 do: [:i| | j k |		self assert: j isNil.		self assert: k isNil.		i even			ifTrue: [j := i + 2]			ifFalse: [k := i + 1].		self assert: (j isNil or: [k isNil]).		self assert: (j isNil not or: [k isNil not])]! !!ClosureExtractor methodsFor: 'accessing' stamp: 'mha 9/21/2010 11:18'!action	^ action! !!ClosureExtractor methodsFor: 'accessing' stamp: 'mha 9/21/2010 11:18'!action: aBlock	action := aBlock! !!ClosureExtractor methodsFor: 'accessing' stamp: 'mha 9/21/2010 11:35'!scanner	^ scanner! !!ClosureExtractor methodsFor: 'accessing' stamp: 'mha 9/21/2010 11:35'!scanner: anInstructionStream	scanner := anInstructionStream! !!ClosureExtractor methodsFor: 'instruction decoding' stamp: 'mha 9/21/2010 13:25'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize		"Create a BlockClosure corresponding to the closure bytecode	and execute the action block with it. The created BlockClosure is only a pseudo value,	it is not populated with meaningful context and argument information."		action value:		(BlockClosure			outerContext: (MethodContext				sender: thisContext				receiver: self				method: scanner method				arguments: (Array new: scanner method numArgs))			startpc: scanner pc			numArgs: numArgs			copiedValues: (Array new: numCopied))! !!ClosureExtractor commentStamp: 'mha 9/21/2010 11:16' prior: 0!A ClosureExtractor is a utility class that is used to extract all BlockClosures from a CompiledMethod. It inherits from InstructionClient and understands only one single message, namely that corresponding to the push closure bytecode instruction. Being sent this message, a ClosureExtractor will create a BlockClosure instance and evaluate the block it holds as an instance variable with that closure as parameter.!!ClosureExtractor class methodsFor: 'instance creation' stamp: 'mha 9/21/2010 11:34'!withAction: aBlock andScanner: anInstructionStream	"The passed block must accept one value, which will be a BlockClosure."	^ self new action: aBlock; scanner: anInstructionStream! !!ClosureTests methodsFor: 'testing-while' stamp: 'eem 5/22/2010 09:35'!testWhileWithTempIsNil	| index |	index := 0.	[ index < 5 ] whileTrue: [		| temp |		collection add: temp.		temp := index := index + 1. 		collection add: temp].	self assertValues: #(nil 1 nil 2 nil 3 nil 4 nil 5)! !!CodeHolder methodsFor: 'annotation' stamp: 'ul 11/15/2010 11:35'!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"add an annotation detailing the prior versions count"	| versionsCount |	versionsCount := VersionsBrowser versionCountForSelector: aSelector class: aClass.	aStream nextPutAll: 				((versionsCount > 1					ifTrue:						[versionsCount = 2 ifTrue:							['1 prior version']							ifFalse:								[versionsCount printString, ' prior versions']]					ifFalse:						['no prior versions']), self annotationSeparator)! !!CodeHolder methodsFor: 'annotation' stamp: 'bf 4/12/2011 14:11'!annotation: aString 	"The user accepted aString in our annotation pane.  Return false because by default we cannot edit annotations"	^ false! !!CodeHolder methodsFor: 'annotation' stamp: 'ul 11/15/2010 11:35'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| separator aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream := ReadWriteStream on: ''.	requestList := self annotationRequests.	separator := requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | | aString sendersCount aComment aCategory implementorsCount aList stamp | 			aRequest == #firstComment				ifTrue: [aComment := aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment := aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment := aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp := self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory := aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount := (self systemNavigation allCallsOn: aSelector) size.					sendersCount := sendersCount = 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount := self systemNavigation numberOfImplementorsOf: aSelector.					implementorsCount := implementorsCount = 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp := VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString := ChangesOrganizer mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList := ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator]].	^ aStream contents! !!CodeHolder methodsFor: 'commands' stamp: 'cmm 5/2/2011 09:46'!abbreviatedWordingFor: aButtonSelector	"Answer the abbreviated form of wording, from a static table.  Answer nil if there is no entry -- in which case the long form will be used on the corresponding browser button."	#(	(browseMethodFull				'browse')	(browseSendersOfMessages	   	'senders')	(browseMessages				'impl')	(browseVersions					'vers')	(methodHierarchy				'inher')	(classHierarchy					'hier')	(browseVariableReferences				'refs')	(offerMenu						'menu')) do:		[:pair | pair first == aButtonSelector ifTrue: [^ pair second]].	^ nil! !!CodeHolder methodsFor: 'commands' stamp: 'fbs 3/3/2011 13:26'!spawn: aString 	"Create and schedule a spawned message category browser for the currently selected message category.  The initial text view contains the characters in aString.  In the spawned browser, preselect the current selector (if any) as the going-in assumption, though upon acceptance this will often change"	| newBrowser aCategory aClass |	(aClass := self selectedClassOrMetaClass) isNil ifTrue:		[^ aString isEmptyOrNil ifFalse: [(Workspace new contents: aString) openLabel: 'spawned workspace']].	(aCategory := self categoryOfCurrentMethod)		ifNil:			[self buildClassBrowserEditString: aString]		ifNotNil:			[newBrowser := Browser new setClass: aClass selector: self selectedMessageName.			self suggestCategoryToSpawnedBrowser: newBrowser.			^ Browser openBrowserView: (newBrowser openMessageCatEditString: aString)		label: 'category "', aCategory, '" in ', 				newBrowser selectedClassOrMetaClassName]! !!CodeHolder methodsFor: 'controls' stamp: 'cmm 5/2/2011 09:46'!optionalButtonPairs	"Answer a tuple (formerly pairs) defining buttons, in the format:			button label			selector to send			help message"	| aList |	aList := #(	('browse'			browseMethodFull			'view this method in a browser')	('senders' 			browseSendersOfMessages	'browse senders of...')	('implementors'		browseMessages				'browse implementors of...')	('versions'			browseVersions				'browse versions')), 	(Preferences decorateBrowserButtons		ifTrue:			[{#('inheritance'		methodHierarchy 'browse method inheritancegreen: sends to supertan: has override(s)mauve: both of the abovepink: is an override but doesn''t call superpinkish tan: has override(s), also is an override but doesn''t call super' )}]		ifFalse:			[{#('inheritance'		methodHierarchy			'browse method inheritance')}]),	#(	('hierarchy'		classHierarchy				'browse class hierarchy')	('vars'			browseVariableReferences			'references...')).	^ aList! !!CodeHolder methodsFor: 'diffs' stamp: 'sw 2/3/2001 00:10'!showingTiles	"Answer whether the receiver is currently showing tiles"	^ contentsSymbol == #tiles! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:50'!decompiledSourceIntoContents	"For backwards compatibility."	^self  decompiledSourceIntoContentsWithTempNames: (Sensor leftShiftDown not) ! !!CodeHolder methodsFor: 'message list' stamp: 'nice 2/23/2011 21:40'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			contents := (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class newCompiler									parse: method getSourceFromFile asString									in: class									notifying: nil)										generate: CompiledMethodTrailer defaultMethodTrailer;										schematicTempNamesString.			contents := ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	contents := contents asText makeSelectorBoldIn: class.	^ contents copy! !!CodeHolder methodsFor: 'message list' stamp: 'topa 7/14/2010 16:47'!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	(class isNil or: [selector isNil]) ifTrue: [^'missing'].	sourceString := class ultimateSourceCodeAt: selector ifAbsent: [^'error'].	self validateMessageSource: sourceString forSelector: selector inClass: class.	(#(#prettyPrint #prettyDiffs) 		includes: contentsSymbol) 			ifTrue: 				[sourceString := class prettyPrinterClass 							format: sourceString							in: class							notifying: nil].	self showingAnyKindOfDiffs 		ifTrue: [sourceString := self diffFromPriorSourceFor: sourceString].	^sourceString! !!CodeHolder methodsFor: 'message list' stamp: 'nice 2/23/2011 21:47'!validateMessageSource: sourceString forSelector: aSelector inClass: theClass	"Check whether there is evidence that method source is invalid"	(theClass newParser parseSelector: sourceString asString) = aSelector		ifFalse: [self informPossiblyCorruptSource].! !!CodeHolder methodsFor: 'message list menu' stamp: 'cmm 5/2/2011 09:56'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	aChar == $D ifTrue: [^ self toggleDiffing].	sel := self selectedMessageName.	aChar == $m ifTrue:  "These next two put up a type in if no message selected"		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: self ].	aChar == $n ifTrue: 		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: self ].	"The following require a class selection"	(class := self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self classHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	aChar == $r ifTrue: [^ self browseVariableReferences].	aChar == $a ifTrue: [^ self browseVariableAssignments].	"The following require a method selection"	sel ifNotNil: 		[aChar == $o ifTrue: [^ self fileOutMessage].		aChar == $c ifTrue: [^ self copySelector].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage].		aChar == $d ifTrue: [^ self removeMessageFromBrowser].		(aChar == $C and: [self canShowMultipleMessageCategories])			ifTrue: [^ self showHomeCategory]].	^ self arrowKey: aChar from: view! !!CodeHolder methodsFor: 'misc' stamp: 'topa 7/14/2010 16:35'!informPossiblyCorruptSource	| sourcesName |	sourcesName := FileDirectory localNameFor: SmalltalkImage current sourcesName.	self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.(Occasionally, the source code for a method may legitimatelystart with a non-alphabetic character -- for example, Behaviormethod #formalHeaderPartsFor:.  In such rare cases, you canhappily disregard this warning.)'! !!CodeHolder methodsFor: 'misc' stamp: 'cmm 3/15/2011 17:17'!menuHook: aMenu named: aSymbol shifted: aBool	"Provide a hook for supplemental menu items.  Answer the appropriately-enhanced menu."	^ aMenu! !!CodeHolder methodsFor: 'toolbuilder' stamp: 'bf 4/12/2011 14:10'!buildCodePaneWith: builder	| textSpec top buttonSpec annoSpec |	self wantsOptionalButtons ifTrue: [		top := builder pluggablePanelSpec new.		top children: OrderedCollection new.		buttonSpec := self buildOptionalButtonsWith: builder.		buttonSpec frame: self optionalButtonsFrame.		top children add: buttonSpec].	textSpec := builder pluggableCodePaneSpec new.	textSpec 		model: self;		getText: #contents; 		setText: #contents:notifying:; 		selection: #contentsSelection; 		menu: #codePaneMenu:shifted:.	self wantsAnnotationPane ifTrue: [		top ifNil: [			top := builder pluggablePanelSpec new.			top children: OrderedCollection new].		annoSpec := builder pluggableInputFieldSpec new.		annoSpec model: self; getText: #annotation; setText: #annotation:. 		annoSpec frame: self annotationFrame.		top children add: annoSpec].	top ifNotNil: [		textSpec frame: self textFrame.		top children add: textSpec].	^top ifNil: [textSpec]! !!CodeHolder methodsFor: 'toolbuilder' stamp: 'dtl 9/24/2011 11:15'!buildCodeProvenanceButtonWith: builder	| buttonSpec |	buttonSpec := builder pluggableActionButtonSpec new.	buttonSpec model: self.	buttonSpec label: #codePaneProvenanceString.	buttonSpec changeLabelWhen: #contents.	buttonSpec style: #menuButton.	buttonSpec action: #offerWhatToShowMenu.	buttonSpec help: 'Governs what view is shown in the code pane.  Click here to change the view'.	^buttonSpec! !!CodeHolder methodsFor: 'toolbuilder' stamp: 'cmm 5/1/2011 22:13'!receiverClass	^ self selectedClassOrMetaClass ! !!CodeHolder methodsFor: 'traits' stamp: 'ul 11/15/2010 11:35'!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport |	((cls := self selectedClass) isNil or: [cls isTrait]) ifTrue: [^ self].	aList := self systemNavigation allUnreferencedClassVariablesOf: cls.	aList size = 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport := String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	UIManager default chooseFrom: aList values: aList 		title: 'Unreferencedclass variables in ' , cls name! !!CodeHolder methodsFor: 'traits' stamp: 'ul 11/15/2010 11:35'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	((cls := self selectedClassOrMetaClass) isNil or: [cls isTrait]) ifTrue: [^ self].	aList := cls allUnreferencedInstanceVariables.	aList size = 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport := String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	UIManager default chooseFrom: aList values: aList title: 'Unreferencedinstance variables in ', cls name! !!CodeHolder methodsFor: 'traits' stamp: 'fbs 3/15/2011 23:07'!spawnHierarchy	"Create and schedule a new hierarchy browser on the currently selected class or meta."	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |	(selectedClassOrMetaClass := self selectedClassOrMetaClass)		ifNil: [^ self].	selectedClassOrMetaClass isTrait ifTrue: [^self].	newBrowser := HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.	((aSymbol := self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])		ifTrue:			[aBehavior := selectedClassOrMetaClass.			messageCatIndex := aBehavior organization numberOfCategoryOfElement: aSymbol.			newBrowser messageCategoryListIndex: messageCatIndex + 1.			newBrowser messageListIndex:				((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol)].	Browser		openBrowserView: (newBrowser openSystemCatEditString: nil)		label: newBrowser labelString.	Smalltalk isMorphic		ifTrue: ["this workaround only needed in morphic"			newBrowser assureSelectionsShow].	^ newBrowser.! !!CodeHolder methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 19:02'!multiWindowState: aSavedMultiWindowState	multiWindowState := aSavedMultiWindowState! !!CodeHolder methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!exploreMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod explore]! !!CodeHolder methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!inspectMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod inspect]! !!CodeHolder commentStamp: '<historical>' prior: 0!An ancestor class for all models which can show code.  Eventually, much of the code that currently resides in StringHolder which only applies to code-holding StringHolders might get moved down here.!!CodeHolder class methodsFor: 'controls' stamp: 'nice 5/8/2011 10:16'!addContentsSymbolQuint: quint afterEntry: aSymbol 	"Register a menu selection item in the position after the entry with	selection symbol aSymbol."	"CodeHolder		addContentsSymbolQuint: #(#altSyntax #toggleAltSyntax #showingAltSyntaxString 'altSyntax' 'alternative syntax')		afterEntry: #colorPrint"	(ContentsSymbolQuints		anySatisfy: [:e | (e isKindOf: Collection) and: [e first = quint first]])		ifFalse: [			| entry |			entry := ContentsSymbolQuints						detect: [:e | (e isKindOf: Collection) and: [e first = aSymbol]].			ContentsSymbolQuints add: quint after: entry.			^ self].	self notify: 'entry already exists for ', quint first! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	"This is a hook to allow browsers to control whether to respond to the muli-window preference.	 Currenty CodeHolder cannot usefully use multi-windows, but may be able to do so in the future."	^false! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 11:43'!useMultiWindowBrowsers	<preference: 'Multi-window browsers'		category: 'browsing'		description: 'When enabled, the browser uses a multi-window to conserve real-estate.  e.g. enable then click in the window label of a browser.'		type: #Boolean>	^MultiWindowBrowsers ifNil: [false]! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 6/30/2010 21:37'!useMultiWindowBrowsers: aBoolean	MultiWindowBrowsers := aBoolean! !!CodeLoader commentStamp: 'hjh 4/22/2010 12:58' prior: 0!CodeLoader provides a simple facility for loading code from the network.CodeLoader has a very specific purpose, primarily for loading Etoys projects. It is not meant to be used for anything else. Use Installer for general purposes.Examples:	| loader |	loader := CodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	loader localCache: #('.cache' 'source').	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader localCache: #('.cache' 'segments').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!!CodeLoader class methodsFor: 'utilities' stamp: 'ul 6/17/2011 12:25'!compressFileNamed: aFileName in: aDirectory	"Compress the currently selected file"	| zipped buffer unzipped zipFileName |	unzipped := aDirectory readOnlyFileNamed: (aDirectory fullNameFor: aFileName).	unzipped binary.	zipFileName := aFileName copyUpToLast: $. .	zipped := aDirectory newFileNamed: (zipFileName, FileDirectory dot, ImageSegment compressedFileExtension).	zipped binary.	zipped := GZipWriteStream on: zipped.	buffer := ByteArray new: 50000.	'Compressing ', zipFileName		displayProgressFrom: 0 to: unzipped size		during:[:bar|			[unzipped atEnd] whileFalse:[				bar value: unzipped position.				zipped nextPutAll: (unzipped nextInto: buffer)].			zipped close.			unzipped close].! !!CodeLoader class methodsFor: 'utilities' stamp: 'nice 2/23/2011 21:40'!exportCodeSegment: exportName classes: aClassList keepSource: keepSources	"Code for writing out a specific category of classes as an external image segment.  Perhaps this should be a method."	| is oldMethods newMethods classList symbolHolder fileName |	keepSources		ifTrue: [			self confirm: 'We are going to abandon sources.Quit without saving after this has run.' orCancel: [^self]].	classList := aClassList asArray.	"Strong pointers to symbols"	symbolHolder := Symbol allSymbols.	oldMethods := OrderedCollection new: classList size * 150.	newMethods := OrderedCollection new: classList size * 150.	keepSources		ifTrue: [			classList do: [:cl |				cl selectorsAndMethodsDo:					[:selector :m |					| oldCodeString methodNode |					m fileIndex > 0 ifTrue:						[oldCodeString := cl sourceCodeAt: selector.						methodNode := cl newCompiler											parse: oldCodeString in: cl notifying: nil.						oldMethods addLast: m.						newMethods addLast: (m copyWithTempsFromMethodNode: methodNode)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	oldMethods := newMethods := nil.	Smalltalk garbageCollect.	is := ImageSegment new copyFromRootsForExport: classList.	"Classes and MetaClasses"	fileName := FileDirectory fileName: exportName extension: ImageSegment fileExtension.	is writeForExport: fileName.	self compressFileNamed: fileName! !!CodeLoader class methodsFor: 'utilities' stamp: 'ul 6/17/2011 12:25'!signFilesFrom: sourceNames to: destNames key: privateKey	"Sign all the given files using the private key.	This will add an 's' to the extension of the file."	"| fd oldNames newNames |	fd := FileDirectory default directoryNamed:'unsigned'.	oldNames := fd fileNames.	newNames := oldNames collect:[:name| 'signed', FileDirectory slash, name].	oldNames := oldNames collect:[:name| 'unsigned', FileDirectory slash, name].	CodeLoader		signFilesFrom: oldNames		to: newNames		key: DOLPrivateKey."	| dsa |	dsa := DigitalSignatureAlgorithm new.	dsa initRandomNonInteractively.	'Signing files...' 		displayProgressFrom: 1 to: sourceNames size during:[:bar|			1 to: sourceNames size do:[:i|				bar value: i.				self signFile: (sourceNames at: i) renameAs: (destNames at: i) key: privateKey dsa: dsa]].! !!Collection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:33'!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."	anInteger timesRepeat: [self add: newObject].	^ newObject! !!Collection methodsFor: 'enumerating' stamp: 'cmm 2/26/2011 22:52'!detect: aBlock ifFound: foundBlock ifNone: exceptionBlock 	"foundBlock takes one argument, the found object."	self 		do: [ :element | (aBlock value: element) ifTrue: [ ^foundBlock value: element ] ].	^exceptionBlock value! !!Collection methodsFor: 'enumerating' stamp: 'ul 6/17/2011 12:26'!do: aBlock displayingProgress: aStringOrBlock every: msecs	"Enumerate aBlock displaying progress information. 	If the argument is a string, use a static label for the process. 	If the argument is a block, evaluate it with the element to retrieve the label.	The msecs argument ensures that updates happen at most every msecs.	Example:		Smalltalk allClasses 			do:[:aClass| (Delay forMilliseconds: 1) wait]			displayingProgress:[:aClass| 'Processing ', aClass name]			every: 0.		Smalltalk allClasses 			do:[:aClass| (Delay forMilliseconds: 1) wait]			displayingProgress:[:aClass| 'Processing ', aClass name]			every: 100.	"	| size labelBlock count oldLabel lastUpdate |	labelBlock := aStringOrBlock isString 		ifTrue:[[:item| aStringOrBlock]] 		ifFalse:[aStringOrBlock].	oldLabel := nil.	count := lastUpdate := 0.	size := self size.	'' displayProgressFrom: 0 to: size during:[:bar |		self do:[:each| | newLabel |			"Special handling for first and last element"			(count = 0 or:[count+1 = size 				or:[(Time millisecondsSince: lastUpdate) >= msecs]]) ifTrue:[					bar value: count.					oldLabel = (newLabel := (labelBlock value: each) ifNil:[oldLabel]) ifFalse:[					ProgressNotification signal: '' extra: (oldLabel := newLabel).				].				lastUpdate := Time millisecondClockValue.			].			aBlock value: each.			count := count + 1.	]]! !!Collection methodsFor: 'enumerating' stamp: 'ul 11/7/2010 01:48'!fold: binaryBlock	"Evaluate the block with the first two elements of the receiver,	 then with the result of the first evaluation and the next element,	 and so on.  Answer the result of the final evaluation. If the receiver	 is empty, raise an error. If the receiver has a single element, answer	 that element."	"#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]"	^self reduce: binaryBlock! !!Collection methodsFor: 'enumerating' stamp: 'ul 11/7/2010 01:47'!reduce: binaryBlock	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.	For sequenceable collections the elements will be used in order, for unordered	collections the order is unspecified."	| first nextValue |	first := true.	self do: [ :each |		first			ifTrue: [ nextValue := each. first := false ]			ifFalse: [ nextValue := binaryBlock value: nextValue value: each ] ].	first ifTrue: [ self errorEmptyCollection ].	^nextValue! !!Collection methodsFor: 'math functions' stamp: 'ar 5/4/2010 08:38'!sum	"Compute the sum of all the elements in the receiver"	^self reduce:[:a :b| a + b]! !!Collection class methodsFor: 'class initialization' stamp: 'dtl 4/6/2011 20:01'!initialize	"Set up a Random number generator to be used by atRandom when the 	user does not feel like creating his own Random generator."	RandomForPicking := Random new.	MutexForPicking := Semaphore forMutualExclusion.	Smalltalk addToStartUpList: self! !!Collection class methodsFor: 'system startup' stamp: 'dtl 4/6/2011 20:10'!startUp	"Reseed the random generator at startup time such that a reloaded	project will not repeat a previous pseudo-random sequence when	selecting at random from a collection."	MutexForPicking		critical: [RandomForPicking initialize]! !!CollectionTest methodsFor: 'tests' stamp: 'ar 5/4/2010 08:52'!testReduce	"self run: #testReduce"	| array set bag |	array := Array with: 1 with: 2 with: 3.	self assert: (array reduce:[:a :b| a + b]) = 6.	set := array asSet.	self assert: (set reduce:[:a :b| a + b]) = 6.	array := Array with: Color red with: Color green with: Color blue.	self assert: (array reduce:[:a :b| a + b]) = Color white.	set := array asSet.	self assert: (set reduce:[:a :b| a + b]) = Color white.	array := Array with: 1 with: 1 with: 1.	self assert: (array reduce:[:a :b| a + b]) = 3.	bag := array asBag.	self assert: (bag reduce:[:a :b| a + b]) = 3.! !!Color methodsFor: 'conversions' stamp: 'nice 12/14/2010 14:55'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack := 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val := (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		"eight bits per component; top 8 bits set to all ones (opaque alpha)"		val := LargePositiveInteger new: 4.		val at: 3 put: ((rgb bitShift: -22) bitAnd: 16rFF).		val at: 2 put: ((rgb bitShift: -12) bitAnd: 16rFF).		val at: 1 put: ((rgb bitShift: -2) bitAnd: 16rFF).		val normalize = 0 ifTrue: [val at: 1 put: 1].  "closest non-transparent black"		val at: 4 put: 16rFF.  "opaque alpha"		^ val normalize].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val := (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val := (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'other' stamp: 'ul 12/9/2010 02:56'!name	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."	^ColorNames detect: [ :name | (Color perform: name) = self ] ifNone: [ nil ]! !!Color methodsFor: 'transformations' stamp: 'jcg 7/12/2010 18:29'!duller	"Answer a darker, desaturated color.  If the original color isn't very saturated, desaturate it by less (otherwise will just end up with grey)."	| sat adjust |	(sat := self saturation) > 0.3		ifTrue: [adjust := -0.1]		ifFalse: [adjust := 0.1 - sat max: 0.0].	^ self adjustSaturation: adjust brightness: -0.1! !!Color methodsFor: 'transformations' stamp: 'bgf 7/22/2006 00:37'!twiceDarker	"Answer a significantly darker shade of this color."	^ self adjustSaturation: 0.075 brightness: -0.15! !!Color methodsFor: '*Morphic' stamp: 'jrd 10/18/2010 13:45'!asMorph	^(RectangleMorph new)		fillStyle: self;		borderWidth: 0;		yourself! !!Color commentStamp: '<historical>' prior: 0!This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:	r	amount of red, a Float between 0.0 and 1.0.	g	amount of green, a Float between 0.0 and 1.0.	b	amount of blue, a Float between 0.0 and 1.0.(But, in fact, the three are encoded as values from 0 to 1023 and combined in a single integer, rgb.  The user does not need to know this.)	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.	Here are some fun things to run in when your screen has color:		Pen new mandala: 30 diameter: Display height-100.		Pen new web  "Draw with the mouse, opt-click to end"		Display fillWhite.  Pen new hilberts: 5.		Form toothpaste: 30  "Draw with mouse, opt-click to end"You might also want to try the comment in	Form>class>examples>tinyText...Messages:	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.	+ 	add two colors	- 	subtract two colors	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.	/	divide a color by a factor or an array of three factors.	errorForDepth: d     How close the nearest color at this depth is to this abstract color.  Sum of the squares of the RGB differences, square rooted and normalized to 1.0.  Multiply by 100 to get percent.	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.	saturation	Returns the saturation of the color.  0.0 to 1.0	brightness	Returns the brightness of the color.  0.0 to 1.0	name    Look to see if this Color has a name.	display	Show a swatch of this color tracking the cursor.	lightShades: thisMany		An array of thisMany colors from white to the receiver. 	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. Messages to Class Color.	red: r green: g blue: b		Return a color with the given r, g, and b components.	r: g: b:		Same as above, for fast typing. 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.	pink 	blue	red ...	Many colors have messages that return an instance of Color.	canUnderstand: #brown	  Returns true if #brown is a defined color.	names		An OrderedCollection of the names of the colors.	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array.    colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.(See also comments in these classes: Form, Bitmap, BitBlt, Pattern, MaskedForm.)!!Color class methodsFor: 'class initialization' stamp: 'mtf 12/28/2010 23:45'!initializeNames	"Name some colors."	"Color initializeNames"	ColorNames := Set new.	self named: #black put: (Color r: 0 g: 0 b: 0).	self named: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).	self named: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).	self named: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).	self named: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).	self named: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).	self named: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).	self named: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).	self named: #white put: (Color r: 1.0 g: 1.0 b: 1.0).	self named: #red put: (Color r: 1.0 g: 0 b: 0).	self named: #yellow put: (Color r: 1.0 g: 1.0 b: 0).	self named: #green put: (Color r: 0 g: 1.0 b: 0).	self named: #cyan put: (Color r: 0 g: 1.0 b: 1.0).	self named: #blue put: (Color r: 0 g: 0 b: 1.0).	self named: #magenta put: (Color r: 1.0 g: 0 b: 1.0).	self named: #brown put: (Color r: 0.6 g: 0.2 b: 0).	self named: #orange put: (Color r: 1.0 g: 0.6 b: 0).	self named: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).	self named: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).	self named: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).	self named: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).	self named: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).	self named: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).	self named: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).	self named: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).	self named: #transparent put: (TranslucentColor new alpha: 0.0).	self named: #paleBuff put: (Color r: 254 g: 250 b: 235 range: 255).	self named: #paleBlue put: (Color r: 222 g: 249 b: 254 range: 255).	self named: #paleYellow put: (Color r: 255 g: 255 b: 217 range: 255).	self named: #paleGreen put: (Color r: 223 g: 255 b: 213 range: 255).	self named: #paleRed put: (Color r: 255 g: 230 b: 230 range: 255).	self named: #veryPaleRed put: (Color r: 255 g: 242 b: 242 range: 255).	self named: #paleTan put: (Color r: 235 g: 224 b: 199 range: 255).	self named: #paleMagenta put: (Color r: 255 g: 230 b: 255 range: 255).	self named: #paleOrange put: (Color r: 253 g: 237 b: 215 range: 255).	self named: #palePeach put: (Color r: 255 g: 237 b: 213 range: 255).	self named: #pantonePurpleU put: (Color r: 193 g: 81 b: 184 range: 255).! !!Color class methodsFor: 'class initialization' stamp: 'ul 12/9/2010 02:57'!named: newName put: aColor	"Add a new color to the list and create an access message and a class variable for it.  The name should start with a lowercase letter.  (The class variable will start with an uppercase letter.)  (Color colorNames) returns a list of all color names.  "	| str cap sym accessor csym |	(aColor isKindOf: self) ifFalse: [^ self error: 'not a Color'].	str := newName asString.	sym := str asSymbol.	cap := str capitalized.	csym := cap asSymbol.	(self class canUnderstand: sym) ifFalse: [		"define access message"		accessor := str, (String with: Character cr with: Character tab), 			'^', cap.		self class compile: accessor			classified: 'named colors'].	(self classPool includesKey: csym) ifFalse: [		self addClassVarName: cap].	ColorNames add: sym.	^ self classPool at: csym put: aColor! !!Color class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 11:35'!fromArray: colorDef	colorDef size = 3			ifTrue: [^self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3)].	colorDef size = 0			ifTrue: [^Color transparent].	colorDef size = 4			ifTrue: [^(TranslucentColor r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3)) alpha: (colorDef at: 4)].	self error: 'Undefined color definition'! !!Color class methodsFor: 'instance creation' stamp: 'ul 12/9/2010 02:58'!fromString: aString	"for HTML color spec: #FFCCAA or white/black"	"Color fromString: '#FFCCAA'.	 Color fromString: 'white'.	 Color fromString: 'orange'"		| aColorHex |	aString isEmptyOrNil ifTrue: [ ^self white ].	aString first = $#		ifTrue: [ aColorHex := aString allButFirst ]		ifFalse: [ aColorHex := aString ].	(aColorHex size = 6 and: [ 		aColorHex allSatisfy: [ :each | '0123456789ABCDEFabcdef' includes: each ] ])			ifTrue: [				| green red blue |				red := (Integer readFrom: (aColorHex first: 2) base: 16) / 255.				green := (Integer readFrom: (aColorHex copyFrom: 3 to: 4) base: 16) / 255.				blue := (Integer readFrom: (aColorHex last: 2) base: 16) / 255.				^self r: red g: green b: blue ].		"try to match aColorHex with known named colors"	^self perform: (ColorNames like: aColorHex asLowercase ifAbsent: [ #white ])! !!Color class methodsFor: 'named colors' stamp: 'jrd 10/16/2010 19:59'!pantonePurpleU	^PantonePurpleU! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ul 8/2/2011 19:58'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		subCanvas := self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect.		aBlock value: subCanvas.		foundMorph := subCanvas foundMorph.		^self	].	"Prepare an appropriate warp from patch to innerRect"	innerRect := aClipRect.	patchRect := aDisplayTransform globalBoundsToLocal:					(self clipRect intersect: innerRect).	sourceQuad := (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	warp cellSize: cellSize.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := ColorPatchCanvas extent: patchRect extent depth: self depth.		subCanvas stopMorph: stopMorph.		subCanvas foundMorph: foundMorph.		subCanvas doStop: doStop.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas			translateBy: patchRect topLeft negated			during: aBlock.		i = 2 ifTrue:[foundMorph := subCanvas foundMorph].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 10:46'!contentMorph	"The outer, containing Morph."	^ contentMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 10:47'!contentMorph: aMorph	"The outer, containing Morph."	contentMorph := aMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 10:32'!getColorSelector	"The selector symbol used to retrieve the color from my model."	^ getColorSelector! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 10:33'!getColorSelector: aSymbol	"The selector symbol used to retrieve the color from my model."	getColorSelector := aSymbol! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 11:26'!labelMorph	"The morph that renders the actual color being presented."	^ labelMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 11:27'!labelMorph: aMorph	"The morph that renders the actual color being presented."	labelMorph := aMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'gvc 9/18/2006 16:17'!solidLabelMorph	"Answer the value of solidLabelMorph"	^ solidLabelMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'gvc 9/18/2006 16:17'!solidLabelMorph: anObject	"Set the value of solidLabelMorph"	solidLabelMorph := anObject! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/22/2006 09:34'!initialize	"Initialize the receiver."	super initialize.	self		borderWidth: 0;		changeTableLayout;		labelMorph: self newLabelMorph;		solidLabelMorph: self newLabelMorph;		contentMorph: self newContentMorph;		addMorphBack: self contentMorph! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/22/2006 09:23'!newContentMorph	"Answer a new content morph"	^Morph new		color: Color transparent;		changeTableLayout;		borderStyle: (BorderStyle inset width: 1);		vResizing: #spaceFill;		hResizing: #spaceFill;		addMorph: self newHatchMorph;		yourself! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'cmm 12/3/2010 14:39'!newHatchMorph	"Answer a new morph showing the three backgrounds; white, hatch pattern, and black, against which my labelMorph is displayed."	^ Morph new		 color: Color transparent ;		 changeProportionalLayout ;		 vResizing: #spaceFill ;		 hResizing: #spaceFill ;		 minWidth: 48 ;		 minHeight: 12 ;				addMorph: (Morph new color: Color white)		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 0.3 @ 1)) ;				addMorph: (Morph new fillStyle: (InfiniteForm with: self class hatchForm))		fullFrame: (LayoutFrame fractions: (0.3 @ 0 corner: 0.7 @ 1)) ;				addMorph: self solidLabelMorph		fullFrame: (LayoutFrame fractions: (0.7 @ 0 corner: 1 @ 1)) ;				addMorph: self labelMorph		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 1 @ 1))! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/18/2006 16:20'!newLabelMorph	"Answer a new label morph"	^Morph new! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/22/2006 09:45'!on: anObject color: getColSel	"Set the receiver to the given model parameterized by the given message selectors."	self		model: anObject;		getColorSelector: getColSel;		updateColor! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 6/3/2009 18:14'!setColor: aColor	"Update the colour of the labels."	self labelMorph color: aColor.	self solidLabelMorph color: aColor asNontranslucentColor! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/22/2006 09:34'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == self getColorSelector ifTrue: 		[self updateColor.		^ self]! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 7/30/2009 18:36'!updateColor	"Update the color state."	|col|	self getColorSelector ifNotNil: [		col := (self model perform: self getColorSelector) ifNil: [Color transparent].		self setColor: col]! !!ColorPresenterMorph commentStamp: 'gvc 5/18/2007 13:38' prior: 0!Displays a colour with alpha against a white, hatched and black background.!!ColorPresenterMorph class methodsFor: 'graphics constants' stamp: 'gvc 9/18/2006 16:05'!hatchForm	"Answer a form showing a grid hatch pattern."	^HatchForm ifNil: [HatchForm := self newHatchForm]! !!ColorPresenterMorph class methodsFor: 'graphics constants' stamp: 'gvc 9/18/2006 16:24'!newHatchForm	"Answer a new hatch form."		^(Form	extent: 8@8	depth: 1	fromArray: #( 4026531840 4026531840 4026531840 4026531840 251658240 251658240 251658240 251658240)	offset: 0@0)! !!ColorPresenterMorph class methodsFor: 'instance creation' stamp: 'StephaneDucasse 3/3/2010 16:12'!on: anObject color: getSel	"Answer a new instance of the receiver on the given model using	the given selectors as the interface."		"(ColorPresenterMorph on: (BorderedMorph new) color: #color) openInWorld"		^self new		on: anObject 		color: getSel! !!CombinedChar class methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:21'!parseCompositionMappingFrom: stream"	self halt.	self parseCompositionMapping"	| line fieldEnd point fieldStart compositions toNumber diacritical result |	toNumber := [:quad | ('16r', quad) asNumber].	Compositions := IdentityDictionary new: 2048.	Decompositions := IdentityDictionary new: 2048.	Diacriticals := IdentitySet new: 2048.	[(line := stream nextLine) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := ('16r', (line copyFrom: 1 to: fieldEnd - 1)) asNumber.		2 to: 6 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		compositions := line copyFrom: fieldStart to: fieldEnd - 1.		(compositions size > 0 and: [compositions first ~= $<]) ifTrue: [			compositions := compositions substrings collect: toNumber.			compositions size > 1 ifTrue: [				diacritical := compositions first.				Diacriticals add: diacritical.				result := compositions second.				(Decompositions includesKey: point) ifTrue: [					self error: 'should not happen'.				] ifFalse: [					Decompositions at: point put: (Array with: diacritical with: result).				].				(Compositions includesKey: diacritical) ifTrue: [					(Compositions at: diacritical) at: result put: point.				] ifFalse: [					Compositions at: diacritical						put: (IdentityDictionary new at: result put: point; yourself).				].			].		].	].! !!Command methodsFor: 'parameters' stamp: 'ul 8/2/2011 19:58'!parameterAt: aSymbol ifAbsent: aBlock	"Answer the parameter stored at the aSymbol, but if none, return the result of evaluating aBlock"	^ self assuredParameterDictionary at: aSymbol ifAbsent: aBlock! !!Command class methodsFor: 'as yet unclassified' stamp: 'ul 2/12/2011 00:32'!cleanUp	MorphExtension allInstancesDo: [ :each | each removeUndoCommands ]! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ul 11/15/2010 11:35'!undoTo	"Not yet functional, and not yet sent.  Allow the user to choose a point somewhere in the undo/redo tape, and undo his way to there.   Applicable only if infiniteUndo is set. "	| anIndex commandList reply |	(anIndex := self historyIndexOfLastCommand) = 0 ifTrue: [^ Beeper beep].	commandList := history		copyFrom:	((anIndex - 10) max: 1)		to:			((anIndex + 10) min: history size).	reply := UIManager default chooseFrom: (commandList collect: [:cmd | cmd cmdWording truncateWithElipsisTo: 20]) values: commandList title: 'undo or redo to...'.	reply ifNotNil: [self inform: #deferred]	"ActiveWorld commandHistory undoTo"! !!CommentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitCommentNode: self! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 9/15/2011 17:04'!properties	"Answer the method properties of the receiver."	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector]		ifFalse: [self class methodPropertiesClass forMethod: self selector: propertiesOrSelector]! !!CompiledMethod methodsFor: 'closures' stamp: 'mha 9/23/2010 10:21'!containsBlockClosures	^ self scanner scanFor: [ :bc | bc = 143 "push closure bytecode" ]! !!CompiledMethod methodsFor: 'closures' stamp: 'ul 3/28/2011 03:55'!embeddedBlockClosures	| bms extractor scanner |	bms := OrderedCollection new.	scanner := self scanner.	extractor := ClosureExtractor withAction: [ :c | bms add: c ] andScanner: scanner.	[ scanner pc <= self endPC ] whileTrue: [ scanner interpretNextInstructionFor: extractor ].	^ bms! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 9/26/2011 17:25'!decompile	"Return the decompiled parse tree that represents self"	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	^class decompilerClass new decompile: selector in: class method: self methodForDecompile! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 9/26/2011 17:26'!decompileWithTemps	"Return the decompiled parse tree that represents self, but get the temp names	 by compiling the sourcecode..."	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	(self fileIndex > 0 and: [(SourceFiles at: self fileIndex) isNil]) ifTrue: [			"Emergency or no source file -- decompile without temp names "			^self decompile.	].	^((self decompilerClass new withTempNames: self methodNode schematicTempNamesString)						decompile: selector						in: class						method: self methodForDecompile)! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 9/26/2011 17:24'!methodForDecompile	"This is a hook to allow recursive methods like MwMethodWrapper to avoid infinite recursion."	^self! !!CompiledMethod methodsFor: 'decompiling' stamp: 'nice 2/23/2011 21:47'!methodNode	"Return the parse tree that represents self. If parsing fails, decompile the method."	| aClass source |	aClass := self methodClass.	source := self				getSourceFor: (self selector ifNil: [self defaultSelector])				in: aClass.	^[(aClass newParser		encoderClass: (self isBlueBookCompiled						ifTrue: [EncoderForV3]						ifFalse: [EncoderForV3PlusClosures]);		parse: source class: aClass)			sourceText: source;			yourself]		on: SyntaxErrorNotification		do: [:ex | ex return: self decompile].! !!CompiledMethod methodsFor: 'decompiling' stamp: 'nice 2/23/2011 21:47'!methodNodeFormattedAndDecorated: decorate	"Answer a method node made from pretty-printed (and colorized, if decorate is true) 	 source text."	| class source node  |		source := self getSourceFromFile.	class := self methodClass ifNil: [self sourceClass].	source ifNil: [^self decompile].	source := class prettyPrinterClass 				format: source				in: class				notifying: nil				decorated: decorate.	node := class newParser parse: source class: class.	node sourceText: source.	^node! !!CompiledMethod methodsFor: 'evaluating' stamp: 'ul 6/13/2011 11:41'!valueWithReceiver: aReceiver arguments: anArray 	"This should be changed after the release of Squeak 4.3 to		^self class receiver: aReceiver withArguments: anArray executeMethod: self"	^ aReceiver withArgs: anArray executeMethod: self! !!CompiledMethod methodsFor: 'initialize-release' stamp: 'eem 9/14/2011 17:33'!copyWithTrailerBytes: trailer"Testing:	(CompiledMethod compiledMethodAt: #copyWithTrailerBytes:)		tempNamesPut: 'copy end '"	| copy end start penultimateLiteral |	start := self initialPC.	end := self endPC.	copy := trailer createMethod: end - start + 1 class: self class header: self header.	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].	(penultimateLiteral := self penultimateLiteral) isMethodProperties ifTrue:		[copy penultimateLiteral: (penultimateLiteral copy									setMethod: copy;									yourself)].	start to: end do: [:i | copy at: i put: (self at: i)].	^copy! !!CompiledMethod methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/19/2010 00:46'!needsFrameSize: newFrameSize	"Set the largeFrameBit to accomodate the newFrameSize"	| largeFrameBit header |	largeFrameBit := 16r20000.	(self numTemps + newFrameSize) > LargeFrame ifTrue:		[^ self error: 'Cannot compile -- stack including temps is too deep'].	header := self objectAt: 1.	(header bitAnd: largeFrameBit) ~= 0		ifTrue: [header := header - largeFrameBit].	self objectAt: 1 put: header			+ ( ((self numTemps + newFrameSize) > SmallFrame or: [ self primitive = 84 "perform:withArguments:"])					ifTrue: [largeFrameBit]					ifFalse: [0])! !!CompiledMethod methodsFor: 'literals' stamp: 'nice 7/20/2011 09:05'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	2 to: self numLiterals - 1 do: "exclude superclass + selector/properties"		[:index |		((self objectAt: index) literalEqual: literal) ifTrue: [^true]].	^false! !!CompiledMethod methodsFor: 'literals' stamp: 'nice 7/20/2011 09:10'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	(self penultimateLiteral isMethodProperties	 and: [self penultimateLiteral hasLiteralThorough: literal]) ifTrue:[^true].	2 to: self numLiterals - 1 "exclude superclass + selector/properties"	   do:[:index | | lit |		(((lit := self objectAt: index) literalEqual: literal)		 or: [(lit isVariableBinding and: [lit key == literal])		 or: [lit isArray and: [lit hasLiteral: literal]]]) ifTrue:			[^ true]].	^ false ! !!CompiledMethod methodsFor: 'printing' stamp: 'ul 3/16/2011 23:45'!preamble	"Return the preamble of this method stored in the source files."	^SourceFiles		fileIndexAndPositionFromSourcePointer: self sourcePointer		do: [ :fileIndex :filePosition |			fileIndex = 0				ifTrue: [ String new "no source pointer for this method" ]				ifFalse: [					(CurrentReadOnlySourceFiles at: fileIndex)						ifNil: [ String new "sources file not available" ]						ifNotNil: [ :file |							self								getPreambleFrom: file								at: (0 max: filePosition - 3) ] ] ]! !!CompiledMethod methodsFor: 'printing' stamp: 'cmm 9/20/2010 13:58'!printOn: aStream 	"Overrides method inherited from the byte arrayed collection."	aStream nextPut: $(.	self printReferenceOn: aStream.	aStream space; nextPut: $".	self printNameOn: aStream.	aStream nextPut: $(;		 print: self identityHash;		 nextPut: $);		 nextPut: $";		 nextPut: $)! !!CompiledMethod methodsFor: 'printing' stamp: 'cmm 9/20/2010 13:58'!printReferenceOn: aStream 	"Print a string that can be used to access the currently installed method."	aStream print: self methodClass;		 nextPutAll: '>>';		 nextPutAll: self selector storeString! !!CompiledMethod methodsFor: 'printing' stamp: 'cmm 9/19/2010 16:32'!printSignatureOn: aStream 	"Print a string that can be used to access the currently installed method."	aStream print: self methodClass;		 nextPutAll: '>>';		 nextPutAll: self selector storeString! !!CompiledMethod methodsFor: 'printing' stamp: 'cmm 9/20/2010 13:59'!reference	^ String streamContents: [ : stream | self printReferenceOn: stream ]! !!CompiledMethod methodsFor: 'printing' stamp: 'ul 3/15/2011 04:57'!timeStamp	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"	| preamble stamp tokens tokenCount |	stamp := nil.	preamble := self preamble.	tokens := (preamble findString: 'methodsFor:' startingAt: 1) > 0		ifTrue: [Scanner new scanTokens: preamble]		ifFalse: [#()  "ie cant be back ref"].	(((tokenCount := tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) == #methodsFor:])		ifTrue:			[(tokens at: tokenCount - 3) == #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokenCount - 2]].	((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) == #methodsFor:])		ifTrue:			[(tokens at: tokenCount  - 1) == #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"					stamp := tokens at: tokenCount]].	^stamp ifNil: [ String new ]! !!CompiledMethod methodsFor: 'source code management' stamp: 'ul 3/16/2011 23:38'!getPreambleFrom: aFileStream at: endPosition	"This method is an ugly hack. This method assumes that source files have ASCII-compatible encoding and that preambles contain no non-ASCII characters."	| chunkSize chunk |	chunkSize := 160 min: endPosition.	[		| index |		chunk := aFileStream			position: (endPosition - chunkSize + 1 max: 0);			basicNext: chunkSize.		(index := chunk lastIndexOf: $!! startingAt: chunk size ifAbsent: 0) ~= 0 ifTrue: [			^chunk copyFrom: index + 1 to: chunk size ].		chunkSize := chunkSize * 2.		chunkSize <= endPosition ] whileTrue.	^chunk! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 9/26/2011 17:25'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| trailer source |	(self properties includesKey: #source) ifTrue:		[^self properties at: #source].	trailer := self trailer.	trailer tempNames ifNotNil: [:namesString | 		"Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: namesString)				decompile: selector in: class method: self methodForDecompile)			decompileString].		trailer sourceCode ifNotNil: [:code | ^ code ].		trailer hasSourcePointer ifFalse: [		"No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self methodForDecompile)			decompileString].	"Situation normal;  read the sourceCode from the file"	source := [self getSourceFromFileAt: trailer sourcePointer]				on: Error		"An error can happen here if, for example, the changes file has been truncated by an aborted download.  The present solution is to ignore the error and fall back on the decompiler.  A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling into this error case, random source code will get returned."				do: [ :ex | ex return: nil].			^source ifNil: [			"Something really wrong -- decompile blind (no temps)"			 (class decompilerClass new decompile: selector in: class method: self methodForDecompile)				decompileString]! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 9/29/2011 14:06'!setSourcePointer: srcPointer	"We can't change the trailer of existing method, since it could have a	 completely different format. Therefore we need to generate a copy	 with new trailer, containing a srcPointer, and then #become it."	| trailer copy start |	trailer := srcPointer = 0				ifTrue: "catch the common case of setting the source pointer to 0 when already 0"					[self sourcePointer = 0 ifTrue:						[^self].					 CompiledMethodTrailer empty]				ifFalse:					[CompiledMethodTrailer new sourcePointer: srcPointer].	copy := self copyWithTrailerBytes: trailer.	"ar 3/31/2010: Be a bit more clever since #become: is slow.	If the old and the new trailer have the same size, just replace it."	(self trailer class == trailer class and:[self size = copy size])		ifTrue:			[start := self endPC + 1.			self replaceFrom: start to: self size with: copy startingAt: start]		ifFalse:			[self becomeForward: copy].	^self "will be copy if #become was needed"! !!CompiledMethod methodsFor: 'source code management' stamp: 'nice 2/23/2011 21:47'!sourceSelector	"Answer my selector extracted from my source.  If no source answer nil"	| sourceString |	sourceString := self getSourceFromFile ifNil: [^ nil].	^self methodClass newParser parseSelector: sourceString! !!CompiledMethod methodsFor: 'private' stamp: 'nice 2/23/2011 21:47'!replace: oldSelector with: newSelector in: aText	| oldKeywords newKeywords args newSelectorWithArgs startOfSource lastSelectorToken |	oldKeywords := oldSelector keywords.	newKeywords := (newSelector ifNil: [self defaultSelector]) keywords.	self assert: oldKeywords size = newKeywords size.	args := (self methodClass newParser		parseArgsAndTemps: aText string notifying: nil) copyFrom: 1 to: self numArgs.	newSelectorWithArgs := String streamContents: [:stream |		newKeywords withIndexDo: [:keyword :index |			stream nextPutAll: keyword.			stream space.			args size >= index ifTrue: [				stream nextPutAll: (args at: index); space]]].	lastSelectorToken := args isEmpty		ifFalse: [args last]		ifTrue: [oldKeywords last].	startOfSource := (aText string		indexOfSubCollection: lastSelectorToken startingAt: 1) + lastSelectorToken size.	^newSelectorWithArgs withBlanksTrimmed asText , (aText copyFrom: startOfSource to: aText size)! !!CompiledMethod methodsFor: 'debugger support' stamp: 'nice 3/31/2011 01:08'!abstractPCForConcretePC: concretePC	"Answer the abstractPC matching concretePC."	| abstractPC scanner client |	self flag: 'belongs in DebuggerMethodMap?'.	abstractPC := 1.	scanner := InstructionStream on: self.	client := InstructionClient new.	[(scanner atEnd	  or: [scanner pc >= concretePC]) ifTrue:		[^abstractPC].	 abstractPC := abstractPC + 1.	 scanner interpretNextInstructionFor: client] repeat! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 9/15/2011 17:04'!propertyValueAt: propName put: propValue	"Set or add the property with key propName and value propValue.	 If the receiver does not yet have a method properties create one and replace	 the selector with it.  Otherwise, either relace propValue in the method properties	 or replace method properties with one containing the new property."	| propertiesOrSelector |	(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifFalse:		[self penultimateLiteral: ((self class methodPropertiesClass									selector: propertiesOrSelector									with: (Association											key: propName asSymbol											value: propValue))									setMethod: self;									yourself).		^propValue].	(propertiesOrSelector includesProperty: propName) ifTrue:		[^propertiesOrSelector at: propName put: propValue].	self penultimateLiteral: (propertiesOrSelector								copyWith: (Association												key: propName asSymbol												value: propValue)).	^propValue! !!CompiledMethod methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:36'!outboundPointersDo: aBlock	| numLiterals |	aBlock value: self class.	numLiterals := self numLiterals.	1 to: numLiterals do: [:i | aBlock value: (self literalAt: i)]! !!CompiledMethod methodsFor: 'converting' stamp: 'ul 12/8/2010 03:24'!asString	^self printString! !!CompiledMethod commentStamp: 'ul 1/29/2011 13:18' prior: 0!My instances are methods suitable for interpretation by the virtual machine.  This is the only class in the system whose instances intermix both indexable pointer fields and indexable integer fields.I'm a subclass of ByteArray to avoid duplicating some of ByteArray's methods, not because a CompiledMethod is-a ByteArray.	The current format of a CompiledMethod is as follows:	header (4 bytes)	literals (4 bytes each)	bytecodes  (variable)	trailer (variable)The header is a 30-bit integer with the following format:(index 0)	9 bits:	main part of primitive number   (#primitive)(index 9)	8 bits:	number of literals (#numLiterals)(index 17)	1 bit:	whether a large frame size is needed (#frameSize)(index 18)	6 bits:	number of temporary variables (#numTemps)(index 24)	4 bits:	number of arguments to the method (#numArgs)(index 28)	1 bit:	high-bit of primitive number (#primitive)(index 29)	1 bit:	flag bit, ignored by the VM  (#flag)The trailer has two variant formats.  In the first variant, the last byte is at least 252 and the last four bytes represent a source pointer into one of the sources files (see #sourcePointer).  In the second variant, the last byte is less than 252, and the last several bytes are a compressed version of the names of the method's temporary variables.  The number of bytes used for this purpose is the value of the last byte in the method.!!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 9/14/2011 10:53'!new	"This will not make a meaningful method, but it could be used	to invoke some otherwise useful method in this class."	^self newMethod: 2 header: 1024! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 9/13/2011 15:16'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits |	nTemps > 63 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		nLits > 255 ifTrue:		[^ self error: 'Cannot compile -- too many literals variables'].		largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits := primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high bit of primitive no. is in the 29th bit of header"				primitiveIndex > 16r3FF ifTrue: [self error: 'prim num too large'].				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19)].	^trailer		createMethod: numberOfBytes		class: self		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 9/13/2011 15:18'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex flag: flag	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits flagBit |	nTemps > 63 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		nLits > 255 ifTrue:		[^ self error: 'Cannot compile -- too many literals variables'].		largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	"For now the high bit of the primitive no. is in a high bit of the header"	primBits := (primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19).	flagBit := flag ifTrue: [ 1 ] ifFalse: [ 0 ].	"Copy the source code trailer to the end"	^trailer		createMethod: numberOfBytes		class: self		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits +				(flagBit bitShift: 29)! !!CompiledMethod class methodsFor: 'evaluating' stamp: 'ul 6/7/2011 21:58'!receiver: receiver withArguments: argArray executeMethod: compiledMethod	"Execute compiledMethod against the receiver and the arguments in argArray"	<primitive: 188>	^receiver withArgs: argArray executeMethod: compiledMethod! !!CompiledMethod class methodsFor: 'accessing class hierarchy' stamp: 'eem 9/16/2011 11:12'!methodPropertiesClass	"Answer the class to use to create a method's properties, which can be a poor man's way	 to add instance variables to subclassses of CompiledMethod.  Subclasses of CompiledMethod	 should define a corresponding subclass of AdditionalMethodState that adds any instance variables	 required, and override this method to answer that class."	^AdditionalMethodState! !!CompiledMethodInspector methodsFor: 'selecting' stamp: 'ajh 3/20/2003 00:17'!contentsIsString	"Hacked so contents empty when deselected"	^ #(0 2 3) includes: selectionIndex! !!CompiledMethodInspector methodsFor: 'selecting' stamp: 'ajh 3/20/2001 11:56'!selectionUnmodifiable	"Answer if the current selected variable is unmodifiable via acceptance in the code pane.  For most inspectors, no selection and a selection of self (selectionIndex = 1) are unmodifiable"	^ true! !!CompiledMethodTest methodsFor: 'examples' stamp: 'mha 9/21/2010 10:35'!withClosure	[ ^ 23 ] value! !!CompiledMethodTest methodsFor: 'examples' stamp: 'mha 9/21/2010 13:26'!withClosureNoNLR	^ [ 23 ] value! !!CompiledMethodTest methodsFor: 'examples' stamp: 'mha 9/23/2010 10:20'!withoutClosure	^ 23 + 42! !!CompiledMethodTest methodsFor: 'tests - closures' stamp: 'mha 9/21/2010 13:26'!testClosureCompiled	self		assert: (self class >> #withClosure) isClosureCompiled;		assert: (self class >> #withClosureNoNLR) isClosureCompiled! !!CompiledMethodTest methodsFor: 'tests - closures' stamp: 'ul 3/28/2011 03:55'!testClosureNLRs	self		assert:			((self class >> #withClosure) embeddedBlockClosures at: 1)				hasMethodReturn;		assert:			((self class >> #withClosureNoNLR) embeddedBlockClosures at: 1) 				hasMethodReturn not! !!CompiledMethodTest methodsFor: 'tests - closures' stamp: 'ul 3/28/2011 04:25'!testClosureSize	self		assert: ((self class >> #withClosure) embeddedBlockClosures at: 1) size			equals: 2;		assert: ((self class >> #withClosureNoNLR) embeddedBlockClosures at: 1) size			equals: 2! !!CompiledMethodTest methodsFor: 'tests - closures' stamp: 'mha 9/23/2010 10:21'!testHasClosure	self		assert: (self class >> #withClosure) containsBlockClosures;		assert: (self class >> #withClosureNoNLR) containsBlockClosures;		assert: (self class >> #withoutClosure) containsBlockClosures not! !!CompiledMethodTest methodsFor: 'tests - performing' stamp: 'StephaneDucasse 12/20/2010 16:07'!a1: a1 a2: a2 a3: a3 a4: a4 a5: a5 a6: a6 a7: a7 a8: a8 a9: a9 a10: a10 a11: a11 a12: a12 a13: a13 a14: a14 a15: a15	"I'm a method with the maximum size of arguments that can be executed via normal send but crash on perform :)"		^ a1 + a2 - a2! !!CompiledMethodTest methodsFor: 'tests - performing' stamp: 'StephaneDucasse 12/20/2010 16:10'!testPerformCanExecutelongMethodWithTemps	"self debug: #testPerformCanExecutelongMethodWithTemps"	"the perform: primitive reuses the context of the method calling it. The primitive adds performed selector arguments to the context variables list. So this means that you can execute some methods but not performed them if the calling methods defined too many temps "		| temp1 temp2 temp3 |	temp1 := 33.	temp2 := 666.	temp3 := 42. 	self assert: (self perform: #a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15: withArguments: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)) = 1.	self assert: (self class>>#testPerformCanExecutelongMethodWithTemps) frameSize = CompiledMethod smallFrameSize.	self assert: (self class>>#a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15:) frameSize = CompiledMethod fullFrameSize.! !!CompiledMethodTest methodsFor: 'tests - performing' stamp: 'StephaneDucasse 12/20/2010 16:01'!testPerformInSuperclassCanExecutelongMethodWithTemps	"self debug: #testPerformInSuperclassCanExecutelongMethodWithTemps"	"the perform: primitive reuses the context of the method calling it. The primitive adds performed selector arguments to the context variables list. So this means that you can execute some methods but not performed them if the calling methods defined too many temps "		| temp1 temp2 temp3 |	temp1 := 33.	temp2 := 666.	temp3 := 42. 	self assert: (self perform: #a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15: withArguments: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15) inSuperclass: self class) = 1! !!CompiledMethodTrailer methodsFor: 'creating a method' stamp: 'eem 9/13/2011 15:14'!createMethod: numberOfBytesForAllButTrailer class: aCompiledMethodClass header: headerWord 	| meth |	encodedData ifNil: [self encode].		meth := aCompiledMethodClass newMethod: numberOfBytesForAllButTrailer + size header: headerWord.	"copy the encoded trailer data"	1 to: size do:		[:i | meth at: meth size - size + i put: (encodedData at: i)].	^meth! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'IgorStasenko 5/10/2011 13:21'!encodeVarLengthSourcePointer	"source pointer must be >=0"	[data >= 0] assert.		encodedData := 		data = 0 ifTrue: [ #[0] ] 		ifFalse: [ ByteArray streamContents: [:str |		| value |		value := data.		[value > 0] whileTrue: [			value > 127 ifTrue: [ str nextPut: 128 + (value bitAnd: 16r7F) ]				ifFalse: [ str nextPut: value. ].			value := value >> 7.			].		]].	encodedData := encodedData reversed copyWith: (self kindAsByte)! !!CompiledMethodTrailer methodsFor: 'private' stamp: 'ul 11/15/2010 10:11'!kindAsByte	| index |	index := self class trailerKinds indexOf: kind.	self assert: (index ~= 0).	^ (index - 1) << 2! !!CompiledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:13'!testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #EmbeddedSourceQCompress ).	self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).	code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer sourceCode: code.	self assert: (trailer kind == #EmbeddedSourceZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompiledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:13'!testEmbeddingTempNames	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer tempNames: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #TempsNamesQCompress ).	self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).		code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer tempNames: code.	self assert: (trailer kind == #TempsNamesZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompiledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:17'!testEncodingNoTrailer	| trailer |		trailer := CompiledMethodTrailer new.		"by default it should be a no-trailer"		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompiledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:14'!testEncodingSourcePointer	| trailer |		trailer := CompiledMethodTrailer new.		CompiledMethod allInstancesDo: [:method | | ptr |		trailer method: method.		self assert: ( (ptr := method sourcePointer) == trailer sourcePointer).		"the last bytecode index must be at 0"		ptr ~= 0 ifTrue: [			self assert: (method endPC = trailer endPC) ].	 ].! !!CompiledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:15'!testEncodingVarLengthSourcePointer	| trailer newTrailer |		trailer := CompiledMethodTrailer new.		trailer sourcePointer: 1.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourcePointer = 1).		trailer sourcePointer: 16r100000000000000.	newTrailer := trailer testEncoding.	self assert: (newTrailer sourcePointer = 16r100000000000000).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompiledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:15'!testSourceByIdentifierEncoding	| trailer id |		trailer := CompiledMethodTrailer new.		id := UUID new asString.	trailer sourceIdentifier: id.		self assert: (trailer kind == #SourceByStringIdentifier ).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceByStringIdentifier ).	self assert: (trailer sourceIdentifier = id).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompiledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:49'!testSourceBySelectorEncoding	| trailer |		trailer := CompiledMethodTrailer new.		trailer setSourceBySelector.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompiledMethodTrailerTest methodsFor: 'tests' stamp: 'IgorStasenko 5/10/2011 13:33'!testEncodingZeroSourcePointer	| trailer |		trailer := CompiledMethodTrailer new.	self assert: 		(trailer sourcePointer: 0) testEncoding sourcePointer = 0	! !!Compiler methodsFor: 'public access' stamp: 'ar 9/27/2005 19:20'!compile: textOrStream in: aClass classified: aCategory notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."	self from: textOrStream		class: aClass		classified: aCategory 		context: nil		notifying: aRequestor.	^self		translate: sourceStream		noPattern: false		ifFail: failBlock! !!Compiler methodsFor: 'public access' stamp: 'nice 2/23/2011 22:27'!evaluate: textOrString 	"See evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor. 	Compilation is carried out with respect to nil, i.e., no object, and the 	invocation is not logged."	^self evaluate: textOrString for: nil logged: false! !!Compiler methodsFor: 'public access' stamp: 'nice 2/23/2011 22:27'!evaluate: textOrString for: anObject logged: logFlag 	"See evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor."	^self evaluate: textOrString for: anObject notifying: nil logged: logFlag! !!Compiler methodsFor: 'public access' stamp: 'nice 2/23/2011 22:14'!evaluate: textOrString for: anObject notifying: aController logged: logFlag	"Compile and execute the argument, textOrString with respect to the class 	of anObject. If a compilation error occurs, notify aController. If both 	compilation and execution are successful then, if logFlag is true, log 	(write) the text onto a system changes file so that it can be replayed if 	necessary."	^ self		evaluate: textOrString		in: nil		to: anObject		notifying: aController		ifFail: [^nil]		logged: logFlag.! !!Compiler methodsFor: 'public access' stamp: 'nice 2/23/2011 22:14'!evaluate: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"	^self		evaluate: aString		in: aContext		to: aReceiver		notifying: nil		ifFail: [^ #failedDoit]! !!Compiler methodsFor: 'public access' stamp: 'eem 7/2/2010 09:54'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into	 a method. If aContext is not nil, the text can refer to temporaries in that	 context (the Debugger uses this). If aRequestor is not nil, then it will receive	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 	 compiled method is invoked from here via withArgs:executeMethod:, hence	 the system no longer creates Doit method litter on errors."	| methodNode method value toLog itsSelection itsSelectionString |	class := (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: true ifFail: [^failBlock value].	method := self interactive				ifTrue: [methodNode generateWithTempNames]				ifFalse: [methodNode generate].	value := receiver				withArgs: (context ifNil: [#()] ifNotNil: [{context}])				executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  			and:[(itsSelection := requestor selection) notNil			and:[(itsSelectionString := itsSelection asString) isEmptyOrNil not]])				ifTrue:[itsSelectionString]				ifFalse:[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext].	^ value! !!Compiler methodsFor: 'public access' stamp: 'nice 2/23/2011 22:27'!evaluate: textOrString logged: logFlag 	"See evaluate:for:notifying:logged:. If a compilation error occurs, 	a Syntax Error view is created rather than notifying any requestor. 	Compilation is carried out with respect to nil, i.e., no object."	^self evaluate: textOrString for: nil logged: logFlag! !!Compiler methodsFor: 'public access' stamp: 'nice 2/23/2011 22:27'!evaluate: textOrString notifying: aController logged: logFlag 	"See evaluate:for:notifying:logged:. Compilation is carried out 	with respect to nil, i.e., no object."	^self evaluate: textOrString for: nil notifying: aController logged: logFlag! !!Compiler methodsFor: 'public access' stamp: 'eem 8/14/2010 20:23'!from: textOrStream class: aClass classified: aCategory context: aContext notifying: req	sourceStream := (textOrStream isKindOf: PositionableStream)						ifTrue: [textOrStream]						ifFalse: [ReadStream on: textOrStream asString].	class := aClass.	context := aContext.	requestor := req.	category := aCategory! !!Compiler methodsFor: 'public access' stamp: 'nice 2/23/2011 21:52'!parser	parser ifNil: [parser := (class ifNil: [self class]) newParser].	^parser! !!Compiler methodsFor: 'private' stamp: 'eem 8/30/2010 17:57'!format: aStream noPattern: noPattern ifFail: failBlock	^(self parser		parse: aStream		class: class		noPattern: noPattern		context: context		notifying: requestor		ifFail: [^failBlock value]) preen! !!Compiler class methodsFor: 'accessing' stamp: 'nice 2/23/2011 21:52'!new	^ super new parser: self newParser! !!Compiler class methodsFor: 'utilities' stamp: 'ul 6/17/2011 12:21'!recompileAll	"Compiler recompileAll"	"Recompile all classes and traits in the system"	Smalltalk allClassesAndTraits 		do: [:classOrTrait | classOrTrait compileAll] 		displayingProgress:[:classOrTrait| 'Recompiling ', classOrTrait]! !!Compiler class methodsFor: 'utilities' stamp: 'ul 6/17/2011 12:20'!recompileAllFrom: firstName 	"Recompile all classes, starting with given name."	Smalltalk allClassesDo: 		[:class | class name >= firstName			ifTrue: 				[Transcript show: class name; cr.				class compileAll]]	"Compiler recompileAllFrom: 'AAABodyShop'."! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'ul 1/12/2011 13:43'!text		^text! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:57'!testAmbiguousSelector 	self 		compiling: 'griffle ^1--1'		shouldRaise: AmbiguousSelector;		compiling: 'griffle ^1@-1'		shouldRaise: AmbiguousSelector;		compiling: 'griffle ^1+-1'		shouldRaise: AmbiguousSelector ! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:58'!testUndeclaredVariable	self 		compiling: 'griffle ^ goo'		shouldRaise: UndeclaredVariable;		compiling: 'griffle ^ [ goo ] value'		shouldRaise: UndeclaredVariable! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:57'!testUndefinedVariable	self 		compiling: 'griffle | goo | ^ goo'		shouldRaise: UndefinedVariable;		compiling: 'griffle [ | goo | ^ goo ] value'		shouldRaise: UndefinedVariable! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:59'!testUnknownSelector		self 		compiling: 'griffle self reallyHopeThisIsntImplementedAnywhere'		shouldRaise: UnknownSelector;		compiling: 'griffle [ self reallyHopeThisIsntImplementedAnywhere ] value'		shouldRaise: UnknownSelector! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:56'!testUnusedVariable	self 		compiling: 'griffle | goo | ^nil'		shouldRaise: UnusedVariable;		compiling: 'griffle ^[ | goo | ]'		shouldRaise: UnusedVariable! !!CompilerExceptionsTest methodsFor: 'private' stamp: 'ul 1/12/2011 13:43'!compile: sourceString	text := sourceString.	self class		compileSilently: text		classified: 'generated'		notifying: self! !!CompilerExceptionsTest methodsFor: 'private' stamp: 'ul 1/12/2011 13:50'!compiling: sourceCode shouldRaise: exceptionClass	self should: [ self compile: sourceCode ] raise: exceptionClass! !!CompilerExceptionsTest methodsFor: 'private' stamp: 'ul 1/12/2011 13:48'!removeGeneratedMethods	self class removeCategory: 'generated'! !!CompilerExceptionsTest methodsFor: 'running' stamp: 'ul 1/12/2011 13:49'!setUp	self removeGeneratedMethods! !!CompilerExceptionsTest methodsFor: 'running' stamp: 'ul 1/12/2011 13:49'!tearDown	self removeGeneratedMethods! !!CompilerTest methodsFor: 'syntax' stamp: 'nice 10/24/2011 19:06'!testBinarySelectorWithBar	"Acknowledge the fact that $| is now allowed at any place in a binary selector"		#(#'||' #'|||' #'|||++' #'<|>') do: [:selector | | source tree |		source := ('1 ' , selector , ' 2') readStream.		tree := (Compiler new)			from: source class: Object context: nil notifying: nil;			translate: source noPattern: true ifFail: [nil].		self assert: tree notNil.			"Hem, this test is really ugly..."		self assert: tree block statements first expr selector key = selector].! !!CompilerTest methodsFor: 'syntax' stamp: 'nice 10/24/2011 18:59'!testEmptyTemporaries	self assert: (Compiler evaluate: '||') isNil! !!CompilerTest methodsFor: 'syntax' stamp: 'nice 10/24/2011 19:14'!testInvalidVerticalBarSelector	self should: [Compiler evaluate: '1 | | 2'] raise: SyntaxErrorNotification.	self should: [Compiler evaluate: '1 | - 2'] raise: SyntaxErrorNotification.! !!CompilerTest methodsFor: 'syntax' stamp: 'nice 10/24/2011 18:59'!testLocalTemporariesInABlock	self assert: ((Compiler evaluate: '[:x|| tmp | tmp := x]') value: 2) = 2! !!CompilerTest methodsFor: 'testing' stamp: 'nice 9/8/2010 00:27'!testToDoModifiesTheLimit	"This is a non regression test for http://bugs.squeak.org/view.php?id=7093.	When blocks writes into to:do: loop limit, optimization shall be carried with care."		self		shouldnt:			[ | n |			n := 2.			1 to: n do: [:i | (n := n+1)>10 ifTrue: [self error: 'Should not get here']].			n]		raise: Error.	self		assert: 			[ | n |			n := 2.			1 to: n do: [:i | (n := n+1)>10 ifTrue: [self error: 'Should not get here']].			n] value = 4.	self		assert: 			[ | n |			n := 2.			1 to: n by: 1 do: [:i | (n := n+1)>10 ifTrue: [self error: 'Should not get here']].			n] value = 4.	self		assert: 			[ | n inc |			n := 2.			inc := 1.			1 to: n by: inc do: [:i | (n := n+1)>10 ifTrue: [self error: 'Should not get here']].			n] value = 4! !!Complex methodsFor: 'arithmetic' stamp: 'nice 4/21/2011 21:47'!absSecure	"Answer the distance of the receiver from zero (0 + 0 i).	Try avoiding overflow and/or underflow"	| scale |	scale := real abs max: imaginary abs.	^scale isZero 		ifTrue: [scale]		ifFalse: [(self class real: real / scale imaginary: imaginary / scale) squaredNorm sqrt * scale]! !!Complex methodsFor: 'arithmetic' stamp: 'nice 4/20/2011 22:18'!arg	"Answer the argument of the receiver."	self isZero ifTrue: [self error: 'zero has no argument.'].	^imaginary arcTan: real! !!Complex methodsFor: 'arithmetic' stamp: 'nice 2/5/2006 03:24'!conjugated	"Return the complex conjugate of this complex number."	^self class real: real imaginary: imaginary negated! !!Complex methodsFor: 'arithmetic' stamp: 'nice 2/5/2006 03:25'!i	"Answer the result of multiplying the receiver with pure imaginary.		^self * 1 i	This is an obvious extension of method i implemented in Number."	^self class real: imaginary negated imaginary: real! !!Complex methodsFor: 'arithmetic' stamp: 'nice 4/20/2011 22:06'!negated	"Answer a Number that is the negation of the receiver."	^self class real: real negated imaginary: imaginary negated! !!Complex methodsFor: 'arithmetic' stamp: 'nice 2/5/2006 03:27'!squaredNorm	"Answer the square of receiver norm."	^real * real + (imaginary * imaginary)! !!Complex methodsFor: 'converting' stamp: 'nice 10/16/2011 16:34'!asComplex	^self! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/24/2011 22:44'!arCosh	"Answer receiver's area hyperbolic cosine.	That is the inverse function of cosh.	Some possible implementations:	^imaginary > 0 		ifTrue: [(self + (self * self - 1) sqrt) ln]		ifFalse: [(self + (self * self - 1) sqrt) ln negated]	^self arcCos i	This implementation provides an answer with a positive real part.	It also avoids creating intermediate Complex."		| x y tmp sh2x shx delta ch2x chx |	imaginary = 0 ifTrue: [real abs > 1			ifTrue: 				[y := real < 0					ifTrue: [Float pi]					ifFalse: [0].				x := real abs arCosh.				^self class real: x imaginary: y]			ifFalse: [^self class real: 0 imaginary: real arcCos]].	tmp := self squaredNorm - 1 / 2.	delta := tmp squared + imaginary squared.	sh2x := tmp + delta sqrt.	shx := sh2x sqrt.	ch2x := 1 + sh2x.	chx := ch2x sqrt.	x := shx arSinh.	y := imaginary copySignTo: (real / chx) arcCos.	^self class real: x imaginary: y! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 01:31'!arSinh	"Answer receiver's area hyperbolic sine.	That is the inverse function of sinh."	"Some possible implementation:	^imaginary * real < 0 		ifTrue: [(self + (self * self + 1) sqrt) ln]		ifFalse: [(self - (self * self + 1) sqrt) ln]"	^self i arcSin i negated! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 01:31'!arTanh	"Answer receiver's area hyperbolic tangent.	That is the inverse function of tanh."	"Some other possible implementation:	^((1 + self) / (1 - self)) ln / 2"	^self i arcTan i negated! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/24/2011 21:31'!arcCos	"Answer the arc cosine of the receiver.	This is the inverse function of cos."	| x y tmp sh2y shy delta ch2y chy |	imaginary = 0 ifTrue: [real abs > 1			ifTrue: 				[x := real < 0					ifTrue: [Float pi]					ifFalse: [0].				y := real copySignTo: real abs arCosh.				^self class real: x imaginary: y]			ifFalse: [^self class real: real arcCos imaginary: 0]].	tmp := self squaredNorm - 1 / 2.	delta := tmp squared + imaginary squared.	sh2y := tmp + delta sqrt.	shy := sh2y sqrt.	ch2y := 1 + sh2y.	chy := ch2y sqrt.	y := imaginary copySignTo: shy arSinh.	x := (real / chy) arcCos.	^self class real: x imaginary: y negated! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/24/2011 22:46'!arcSin	"Answer the arc sine of the receiver.	This is the inverse function of sin."	| x y tmp delta sh2y shy ch2y chy |	imaginary = 0 		ifTrue: 			[real abs > 1 				ifTrue: 					[x := Float pi / 2 * real sign.					y := (real copySignTo: real abs arCosh) negated.					^self class real: x imaginary: y]				ifFalse: [^self class real: real arcSin imaginary: 0]].	tmp := (self squaredNorm - 1) / 2.	delta := tmp squared + imaginary squared.	sh2y := tmp + delta sqrt.	shy := sh2y sqrt.	ch2y := 1 + sh2y.	chy := ch2y sqrt.	y := imaginary copySignTo: shy arSinh.	x := (real / chy) arcSin.	^self class real: x imaginary: y! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/21/2011 21:45'!arcTan	"Answer the arc tangent of the receiver.	This is the inverse function of tan."	| r2 |	r2 := self squaredNorm.	^self class		real: (real * 2 arcTan: 1 - r2) / 2		imaginary: ((r2 + (imaginary * 2) + 1) / (r2 - (imaginary * 2) + 1)) ln / 4! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 01:34'!arcTan: denominator 	"Answer the  four quadrants arc tangent of receiver over denominator."	^denominator isZero 		ifTrue: 			[self isZero 				ifTrue: 					["shouldn't it be an error ? ^DomainError signal: '0 arcTan: 0'"					^self class real: 0 imaginary: 0]				ifFalse: 					[self class						real: Float pi / (real copySignTo: 2)						imaginary: 0]]		ifFalse: 			[| res |			res := (self / denominator) arcTan.			denominator real < 0 ifTrue: [res := res + Float pi].			res real > Float pi 				ifTrue: [res := res - (Float pi * 2)].			res]! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:54'!cos	"Answer receiver's cosine."	^self i cosh! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 21:30'!cosh	"Answer receiver's hyperbolic cosine.	Hyperbolic cosine is defined by same power serie expansion as for real numbers, that is in term of exponential:	^ (self exp + self negated exp) / 2.	This implementation avoids creating intermediate objects."		^self class		real: real cosh * imaginary cos		imaginary: real sinh * imaginary sin! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 00:38'!exp	"Answer the exponential of the receiver."	^ real exp * (imaginary cos + imaginary sin i)! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 00:39'!ln	"Answer the natural log of the receiver."	^ self abs ln + self arg i! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 9/18/2008 22:51'!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue:		["Do the special case of integer power"		^ self raisedToInteger: aNumber].		0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"	0 = self ifTrue: [				"Special case of self = 0"		aNumber < 0			ifTrue: [^ (ZeroDivide dividend: self) signal]			ifFalse: [^ self]].	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 6/17/2011 04:14'!raisedToInteger: operand 	"Answer the receiver raised to the power operand, an Integer."	"implementation note: this code is copied from Number.	This suggest that both Number and Complex should have an	ArithmeticValue common superclass like in Visualworks.	Or maybe should it be a Traits (a property of fields ?)"	| count result |	operand isInteger ifFalse: [^ ArithmeticError signal: 'parameter is not an Integer'].	operand = 0 ifTrue: [^ self class one].	operand = 1 ifTrue: [^ self].	operand < 0 ifTrue: [^ (self raisedToInteger: operand negated) reciprocal].	count := 1 bitShift: (operand-1) highBit.	result := self class one.	[count > 0]		whileTrue: 			[result := result squared.			(operand bitAnd: count)				= 0 ifFalse: [result := result * self].			count := count bitShift: -1].	^ result! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:54'!sin	"Answer receiver's sine."	^self i sinh i negated! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 21:30'!sinh	"Answer receiver's hyperbolic sine.	Hyperbolic sine is defined by same power serie expansion as for real numbers, that is in term of exponential:	^ (self exp - self negated exp) / 2.	This implementation avoids creating intermediate objects."		^self class		real: real sinh * imaginary cos		imaginary: real cosh * imaginary sin! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/20/2011 21:58'!sqrt	"Return the square root of the receiver with a positive imaginary part."	| u v |	(imaginary = 0 and: [real >= 0])		ifTrue:	[^self class real: real sqrt imaginary: 0].	v := (self abs - real / 2) sqrt.	u := imaginary / 2 / v.	^self class real: u imaginary: v! !!Complex methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:55'!tanh	"Answer receiver's hyperbolic tangent."	"Some possible implementation are:	^self sinh / self cosh	| tr ti |	tr := real tanh.	ti := imaginary tan i.	^(tr + ti) / (tr * ti + 1)"	^self i tan i negated! !!Complex methodsFor: 'testing' stamp: 'nice 4/20/2011 22:06'!isZero	^ real isZero and: [imaginary isZero]! !!Complex methodsFor: 'private' stamp: 'nice 8/29/2011 00:11'!real: aNumber1 imaginary: aNumber2	"Private - initialize the real and imaginary parts of a Complex"	real := aNumber1.	imaginary := aNumber2.! !!Complex class methodsFor: 'instance creation' stamp: 'nice 4/22/2011 00:46'!abs: aNumber1 arg: aNumber2	^self		real: aNumber1 * aNumber2 cos		imaginary: aNumber1 * aNumber2 sin! !!Complex class methodsFor: 'instance creation' stamp: 'nice 9/18/2008 22:50'!one	^ self real: 1 imaginary: 0! !!Complex class methodsFor: 'instance creation' stamp: 'nice 8/29/2011 00:11'!real: aNumber1 imaginary: aNumber2	^self basicNew	real: aNumber1 imaginary: aNumber2! !!Complex class methodsFor: 'instance creation' stamp: 'nice 9/18/2008 22:50'!zero	^ self real: 0 imaginary: 0! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 22:31'!testArCosh	| c |	c := (2.5 + 0 i).	self assert: (c arCosh real closeTo: c real arCosh).	self assert: (c arCosh imaginary closeTo: 0).	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: (c arCosh cosh real closeTo: c real).		self assert: (c arCosh cosh imaginary closeTo: c imaginary).		self deny: c arCosh real negative]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 22:29'!testArSinh	| c |	c := (2.5 + 0 i).	self assert: (c arSinh real closeTo: c real arSinh).	self assert: (c arSinh imaginary closeTo: 0).	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: (c arSinh sinh real closeTo: c real).		self assert: (c arSinh sinh imaginary closeTo: c imaginary)]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 22:29'!testArTanh	| c |	c := (0.5 + 0 i).	self assert: (c arTanh real closeTo: c real arTanh).	self assert: (c arTanh imaginary closeTo: 0).	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: (c arTanh tanh real closeTo: c real).		self assert: (c arTanh tanh imaginary closeTo: c imaginary)]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 22:29'!testArcCos	| c |	c := (0.5 + 0 i).	self assert: (c arcCos real closeTo: c real arcCos).	self assert: (c arcCos imaginary closeTo: 0).	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: (c arcCos cos real closeTo: c real).		self assert: (c arcCos cos imaginary closeTo: c imaginary)]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 21:18'!testArcCosPlusArcSin	| c |	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: ((c arcCos + c arcSin) real closeTo: Float halfPi).		self assert: ((c arcCos + c arcSin) imaginary closeTo: 0.0)]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 22:29'!testArcSin	| c |	c := (0.5 + 0 i).	self assert: (c arcSin real closeTo: c real arcSin).	self assert: (c arcSin imaginary closeTo: 0).	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: (c arcSin sin real closeTo: c real).		self assert: (c arcSin sin imaginary closeTo: c imaginary)]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 22:29'!testArcTan	| c |	c := (0.5 + 0 i).	self assert: (c arcTan real closeTo: c real arcTan).	self assert: (c arcTan imaginary closeTo: 0).	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: (c arcTan tan real closeTo: c real).		self assert: (c arcTan tan imaginary closeTo: c imaginary)]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:06'!testConjugated		| c cc |	c := (5 - 6 i).	cc := c conjugated.	self assert: cc real = c real.	self assert: cc imaginary = c imaginary negated.! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:41'!testCos	| c c2 |	c := (2 + 0 i).	self assert: (c cos real closeTo: c real cos).	self assert: (c cos imaginary closeTo: 0).	c := (2 + 3 i).	c2 := c i exp + c i negated exp / 2.	self assert: (c cos real closeTo: c2 real).	self assert: (c cos imaginary closeTo: c2 imaginary).! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 21:33'!testCos2PlusSin2	| c |	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: ((c cos squared + c sin squared) real closeTo: 1).		self assert: ((c cos squared + c sin squared) imaginary closeTo: 0.0)]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:36'!testCosh	| c c2 |	c := (2 + 0 i).	self assert: (c cosh real closeTo: c real cosh).	self assert: (c cosh imaginary closeTo: 0).	c := (2 + 3 i).	c2 := c exp + c negated exp / 2.	self assert: (c cosh real closeTo: c2 real).	self assert: (c cosh imaginary closeTo: c2 imaginary).	c2 := c i cos.	self assert: (c cosh real closeTo: c2 real).	self assert: (c cosh imaginary closeTo: c2 imaginary).! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 21:34'!testCosh2MinusSinh2	| c |	#(-0.5 -2 -3 0 0.5 2 3) do: [:real |	#(-0.5 -2 -3 0 0.5 2 3) do: [:imag |		c := real + imag i.		self assert: ((c cosh squared - c sinh squared) real closeTo: 1).		self assert: ((c cosh squared - c sinh squared) imaginary closeTo: 0.0)]]! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:05'!testMultiplyByI		| c |	c := (5 - 6 i).	self assert: (c * 1i = c i)! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:40'!testRaisedTo		| c c3 |	c := (5 - 6 i).	c3 := (c raisedTo: 0.2) raisedTo: 5.	self assert: (c3 real closeTo: c real).	self assert: (c3 imaginary closeTo: c imaginary).! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:05'!testRaisedToInteger		| c c3 |	c := (5 - 6 i).	c3 := (c * c * c).	self assert: (c3 = (c raisedToInteger: 3)).	self assert: (c3 reciprocal = (c raisedToInteger: -3)).! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/24/2011 21:33'!testSin	| c c2 |	c := (2 + 0 i).	self assert: (c sin real closeTo: c real sin).	self assert: (c sin imaginary closeTo: 0).	c := 2 + 3 i.	c2 := c i exp - c i negated exp / 2 i.	self assert: (c sin real closeTo: c2 real).	self assert: (c sin imaginary closeTo: c2 imaginary).! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:38'!testSinh	| c c2 |	c := (2 + 0 i).	self assert: (c sinh real closeTo: c real sinh).	self assert: (c sinh imaginary closeTo: 0).	c := 2 + 3 i.	c := c cosh squared - c sinh squared.	self assert: (c real closeTo: 1).	self assert: (c imaginary closeTo: 0).	c2 := c exp - c negated exp / 2.	self assert: (c sinh real closeTo: c2 real).	self assert: (c sinh imaginary closeTo: c2 imaginary).	c2 := c i sin i negated.	self assert: (c sinh real closeTo: c2 real).	self assert: (c sinh imaginary closeTo: c2 imaginary).! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:17'!testTan	| c c2 |	c := (2 + 0 i).	self assert: (c tan real closeTo: c real tan).	self assert: (c tan imaginary closeTo: 0).	c := 2 + 3 i.	c2 := c sin / c cos.	self assert: (c2 real closeTo: c tan real).	self assert: (c2 imaginary closeTo: c tan imaginary).! !!ComplexTest methodsFor: 'tests' stamp: 'nice 4/23/2011 03:16'!testTanh	| c c2 |	c := (2 + 0 i).	self assert: (c tanh real closeTo: c real tanh).	self assert: (c tanh imaginary closeTo: 0).	c := 2 + 3 i.	c2 := c sinh / c cosh.	self assert: (c2 real closeTo: c tanh real).	self assert: (c2 imaginary closeTo: c tanh imaginary).! !!CompositionScanner methodsFor: 'scanning' stamp: 'ul 6/17/2011 12:36'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength stopCondition |	"Set up margins"	leftMargin := lineRectangle left.	leftSide ifTrue: [leftMargin := leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX := spaceX := leftMargin.	rightMargin := lineRectangle right.	rightSide ifTrue: [rightMargin := rightMargin - textStyle rightIndent].	lastIndex := startIndex.	"scanning sets last index"	destY := lineRectangle top.	lineHeight := baseline := 0.  "Will be increased by setFont"	line := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	self setStopConditions.	"also sets font"	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	spaceCount := 0.	self handleIndentation.	leftMargin := destX.	line leftMargin: leftMargin.	[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex		in: text string rightX: rightMargin stopConditions: stopConditions		kern: kern.	"See setStopConditions for stopping conditions for composing."	(self perform: stopCondition)		ifTrue: [^ line lineHeight: lineHeight + textStyle leading						baseline: baseline + textStyle leading]] repeat! !!CompositionScanner methodsFor: 'scanning' stamp: 'ul 6/17/2011 12:36'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength stopCondition |	destX := spaceX := leftMargin := aParagraph leftMarginForCompositionForLine: lineIndex.	destY := 0.	rightMargin := aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex := startIndex.	"scanning sets last index"	lineHeight := textStyle lineGrid.  "may be increased by setFont:..."	baseline := textStyle baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount := 0.		[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex		in: text string rightX: rightMargin stopConditions: stopConditions		kern: kern.	"See setStopConditions for stopping conditions for composing."	(self perform: stopCondition)		ifTrue: [^line lineHeight: lineHeight + textStyle leading					baseline: baseline + textStyle leading]] repeat! !!CompositionScanner methodsFor: 'testing' stamp: 'cmm 6/12/2010 11:07'!canComputDefaultLineHeight	^ rightMargin notNil! !!CompositionScanner methodsFor: 'testing' stamp: 'cmm 6/13/2010 20:50'!canComputeDefaultLineHeight	^ rightMargin notNil! !!CompoundTextConverter methodsFor: 'conversion' stamp: 'ul 5/22/2011 22:11'!nextPut: aCharacter toStream: aStream	| charCode leadingChar class |	aStream isBinary ifTrue: [^aCharacter storeBinaryOn: aStream].	aCharacter isTraditionalDomestic ifFalse: [		class := (EncodedCharSet charsetAt: aCharacter leadingChar) traditionalCharsetClass.		charCode := (class charFromUnicode: aCharacter asUnicode) charCode.		leadingChar := class leadingChar.	] ifTrue: [		charCode := aCharacter charCode.		leadingChar := aCharacter leadingChar.	].	charCode < 256 ifTrue: [		(latin1Encodings at: charCode + 1)			ifNil: [ aStream basicNextPut: aCharacter ]			ifNotNil: [ :encodedString | aStream basicNextPutAll: encodedString ].		^aCharacter ].	self 		nextPutValue: charCode		toStream: aStream		withShiftSequenceIfNeededForLeadingChar: leadingChar.	^aCharacter! !!ConnectionQueue methodsFor: 'private' stamp: 'nice 3/31/2011 01:28'!listenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	| newConnection |	socket := Socket newTCP.	"We'll accept four simultanous connections at the same time"	socket listenOn: portNumber backlogSize: 4.	"If the listener is not valid then the we cannot use the	BSD style accept() mechanism."	socket isValid ifFalse: [^self oldStyleListenLoop].	[		socket isValid ifFalse: [			"socket has stopped listening for some reason"			socket destroy.			(Delay forMilliseconds: 10) wait.			^self listenLoop ].		newConnection := socket 			waitForAcceptFor: 10			ifTimedOut: [ nil ].		(newConnection notNil and: [newConnection isConnected]) ifTrue: [			accessSema critical: [connections addLast: newConnection.].			newConnection := nil.			self changed].		self pruneStaleConnections] repeat! !!ConnectionQueue methodsFor: 'private' stamp: 'nice 3/31/2011 01:28'!oldStyleListenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	[		((socket == nil) and: [connections size < maxQueueLength]) ifTrue: [			"try to create a new socket for listening"			socket := Socket createIfFail: [nil]].		socket == nil			ifTrue: [(Delay forMilliseconds: 100) wait]			ifFalse: [				socket isUnconnected ifTrue: [socket listenOn: portNumber].				socket 					waitForConnectionFor: 10					ifTimedOut: [						socket isConnected							ifTrue: [  "connection established"								accessSema critical: [connections addLast: socket].								socket := nil]							ifFalse: [								socket isWaitingForConnection									ifFalse: [socket destroy. socket := nil]]]].  "broken socket; start over"		self pruneStaleConnections] repeat! !!ContextInspector methodsFor: 'accessing' stamp: 'ar 8/19/2010 12:24'!fieldList	"Answer the base field list plus an abbreviated list of indices."	^ self baseFieldList , (object tempNames collect:[:t| '[',t,']'])! !!ContextInspector methodsFor: 'accessing' stamp: 'ar 8/19/2010 12:21'!selection	"The receiver has a list of variables of its inspected object.	One of these is selected. Answer the value of the selected variable."	| basicIndex |	selectionIndex = 0 ifTrue: [^ ''].	selectionIndex = 1 ifTrue: [^ object].	selectionIndex = 2 ifTrue: [^ object longPrintStringLimitedTo: 20000].	(selectionIndex - 2) <= object class instSize		ifTrue: [^ object instVarAt: selectionIndex - 2].	basicIndex := selectionIndex - 2 - object class instSize.	^object debuggerMap namedTempAt: basicIndex in: object! !!ContextPart methodsFor: 'controlling' stamp: 'eem 12/5/2011 14:14'!runUntilErrorOrReturnFrom: aSender 	"ASSUMES aSender is a sender of self.  Execute self's stack until aSender returns or an unhandled exception is raised.  Return a pair containing the new top context and a possibly nil exception.  The exception is not nil if it was raised before aSender returned and it was not handled.  The exception is returned rather than openning the debugger, giving the caller the choice of how to handle it."	"Self is run by jumping directly to it (the active process abandons thisContext and executes self).  However, before jumping to self we insert an ensure block under aSender that jumps back to thisContext when evaluated.  We also insert an exception handler under aSender that jumps back to thisContext when an unhandled exception is raised.  In either case, the inserted ensure and exception handler are removed once control jumps back to thisContext."	| error ctxt here topContext aSendersSender |	here := thisContext.	aSendersSender := aSender sender.	"Insert ensure and exception handler contexts under aSender"	error := nil.	ctxt := aSender insertSender: (ContextPart		contextOn: UnhandledError do: [:ex |			error ifNil: [				error := ex exception.				topContext := thisContext.				ex resumeUnchecked: here jump]			ifNotNil: [ex pass]		]).	ctxt := ctxt insertSender: (ContextPart		contextEnsure: [error ifNil: [				topContext := thisContext.				here jump]		]).	self jump.  "Control jumps to self"	"Control resumes here once above ensure block or exception handler is executed"	^ error ifNil: [		"No error was raised, remove ensure context by stepping until popped"		[ctxt isDead or: [aSender isDead]] whileFalse: [topContext := topContext stepToCallee].		^{aSender isDead			ifTrue:				[| retValue |				retValue := (ctxt method == (BlockClosure >> #ensure:)							or: [ctxt method == (BlockClosure >> #ifCurtailed:)]) ifTrue:								[ctxt tempAt: 3]. "returnValue in ensure: and result in ifCurtailed:"				aSendersSender push: retValue.				aSendersSender]			ifFalse: [topContext].		     nil}	] ifNotNil: [		"Error was raised, remove inserted above contexts then return signaler context"		aSender terminateTo: ctxt sender.  "remove above ensure and handler contexts"		{topContext. error}	].! !!ContextPart methodsFor: 'debugger access' stamp: 'mtf 6/26/2009 17:56'!errorReportOn: strm	"Write a detailed error report on the stack (above me) on a stream.  For both the error file, and emailing a bug report.  Suppress any errors while getting printStrings.  Limit the length."	| cnt aContext startPos | 	strm print: Date today; space; print: Time now; cr.	strm cr.	strm nextPutAll: 'VM: ';		nextPutAll:  SmalltalkImage current platformName asString;		nextPutAll: ' - ';		nextPutAll: SmalltalkImage current asString;		cr.	strm nextPutAll: 'Image: ';		nextPutAll:  SystemVersion current version asString;		nextPutAll: ' [';		nextPutAll: SmalltalkImage current lastUpdateString asString;		nextPutAll: ']';		cr.	strm cr.	SecurityManager default printStateOn: strm.		"Note: The following is an open-coded version of ContextPart>>stackOfSize: since this method may be called during a low space condition and we might run out of space for allocating the full stack."	cnt := 0.  startPos := strm position.	aContext := self.	[aContext notNil and: [(cnt := cnt + 1) < 20]] whileTrue:		[aContext printDetails: strm.	"variable values"		strm cr.		aContext := aContext sender].	strm cr; nextPutAll: '--- The full stack ---'; cr.	aContext := self.	cnt := 0.	[aContext == nil] whileFalse:		[cnt := cnt + 1.		cnt = 20 ifTrue: [strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; cr].		strm print: aContext; cr.  "just class>>selector"			strm position > (startPos+40000) ifTrue: [strm nextPutAll: '...etc...'.			^ self]. 	"exit early"		cnt > 60 ifTrue: [strm nextPutAll: '-- and more not shown --'.  ^ self].		aContext := aContext sender].! !!ContextPart methodsFor: 'printing' stamp: 'jrd 5/6/2010 00:41'!printDetails: strm	"Put my class>>selector and arguments and temporaries on the stream.  Protect against errors during printing."	| str |	self printOn: strm.  	strm cr; tab; nextPutAll: 'Arguments and temporary variables: '; cr.	str := [self tempsAndValuesLimitedTo: 160 indent: 2] ifError: [:err :rcvr | 						'<<error during printing>>'].	strm nextPutAll: str.	strm peekLast == Character cr ifFalse: [strm cr].! !!ContextPart methodsFor: 'query' stamp: 'ul 4/27/2011 22:57'!copyTo: aContext	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender."	| copy |	self == aContext ifTrue: [ ^nil ].	copy := self copy.	sender ifNotNil: [ copy privSender: (sender copyTo: aContext) ].	^copy! !!ContextPart methodsFor: 'query' stamp: 'ul 4/28/2011 00:01'!copyTo: aContext bottomContextDo: aBlock	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender. Evaluate aBlock with the copy of bottom context when it still points to the original sender."	| copy |	self == aContext ifTrue: [ ^nil ].	copy := self copy.	sender		ifNil: [ aBlock value: copy ]		ifNotNil: [			sender == aContext ifTrue: [ aBlock value: copy ].			copy privSender: (sender copyTo: aContext bottomContextDo: aBlock) ].	^copy! !!ContextPart methodsFor: 'private' stamp: 'ul 6/7/2011 21:44'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	 simulated receiver and arguments are given as arguments to this message.	 Any primitive which provikes execution needs to be intercepted and simulated	 to avoid execution running away."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	(primitiveIndex = 19) ifTrue:		[ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	"ContextPart>>blockCopy:; simulated to get startpc right"	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart]) 		ifTrue: [^self push: ((BlockContext newForMethod: receiver method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext]) "BlockContext>>value[:value:...]"		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [receiver isMemberOf: BlockContext]) "BlockContext>>valueWithArguments:"		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50" "Object>>perform:[with:...]"		ifTrue: [^self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50" "Object>>perform:withArguments:"		ifTrue: [^self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	primitiveIndex = 188 ifTrue: [		arguments size = 2 ifTrue: [ "eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"			^MethodContext				sender: self				receiver: receiver				method: (arguments at: 2)				arguments: (arguments at: 1) ].		arguments size = 3 ifTrue: [ "CompiledMethod class >> #receiver:withArguments:executeMethod:"			^MethodContext				sender: self				receiver: (arguments at: 1)				method: (arguments at: 3)				arguments: (arguments at: 2) ] ].	primitiveIndex = 189 ifTrue: [ "Object >> (#with:)*executeMethod"		^MethodContext			sender: self			receiver: receiver			method: arguments last			arguments: arguments allButLast ].	"Closure primitives"	(primitiveIndex = 200 and: [receiver == self]) ifTrue:		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"		[^self push: (BlockClosure						outerContext: receiver						startpc: pc + 2						numArgs: arguments first						copiedValues: arguments last)].	((primitiveIndex between: 201 and: 205)			 "BlockClosure>>value[:value:...]"	or: [primitiveIndex between: 221 and: 222]) ifTrue: "BlockClosure>>valueNoContextSwitch[:]"		[^receiver simulateValueWithArguments: arguments caller: self].	primitiveIndex = 206 ifTrue:						"BlockClosure>>valueWithArguments:"		[^receiver simulateValueWithArguments: arguments first caller: self].	primitiveIndex = 120 ifTrue:[ "FFI method"		value := meth literals first tryInvokeWithArguments: arguments.	] ifFalse:[		arguments size > 6 ifTrue: [^PrimitiveFailToken].		value := primitiveIndex = 117 "named primitives"				ifTrue:[self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]				ifFalse:[receiver tryPrimitive: primitiveIndex withArgs: arguments].	].	^value == PrimitiveFailToken		ifTrue: [PrimitiveFailToken]		ifFalse: [self push: value]! !!ContextPart methodsFor: 'private' stamp: 'eem 5/23/2010 14:13'!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Hack. Attempt to execute the named primitive from the given compiled method"	| selector theMethod spec |	arguments size > 8 ifTrue:[^PrimitiveFailToken].	selector := #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	theMethod := aReceiver class lookupSelector: selector.	theMethod == nil ifTrue:[^PrimitiveFailToken].	spec := theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	theMethod flushCache.	selector flushCache.	^aReceiver perform: selector withArguments: arguments! !!ContextPart methodsFor: 'private-exceptions' stamp: 'nice 10/11/2010 23:25'!handleSignal: exception	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then execute my handle block (second arg), otherwise forward this message to the next handler context.  If none left, execute exception's defaultAction (see nil>>handleSignal:)."	| val |	(((self tempAt: 1) handles: exception) and: [self tempAt: 3]) ifFalse: [		^ self nextHandlerContext handleSignal: exception].	exception privHandlerContext: self contextTag.	self tempAt: 3 put: false.  "disable self while executing handle block"	val := [(self tempAt: 2) cull: exception ]		ensure: [self tempAt: 3 put: true].	self return: val.  "return from self if not otherwise directed in handle block"! !!ContextPart methodsFor: 'private-exceptions' stamp: 'mtf 6/3/2010 09:36'!rearmHandlerDuring: aBlock	"Sent to handler (on:do:) contexts only. Makes me re-entrant for the duration of aBlock. Only works in a closure-enabled image"	^ [self tempAt: 3 put: true. aBlock value]		ensure: [self tempAt: 3 put: false]! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!object: anObject basicAt: index 	"Answer the value of an indexable element in the argument anObject without sending	 it a message. Fail if the argument index is not an Integer or is out of bounds, or if	 anObject is not indexable. This mimics the action of the VM when it indexes an object.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self object: anObject basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!object: anObject basicAt: index put: value 	"Store the last argument 	 value in the indexable element of the argument anObject indicated by index without sending	 anObject a message. Fail if the argument index is not an Integer or is out of bounds, or if	 anObject is not indexable, or if value is an inappropriate value for anObject's indexable slots.	 This mimics the action of the VM when it indexes an object.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= (self objectSize: anObject)])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self object: anObject basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:23'!object: anObject eqeq: anOtherObject 	"Answer whether the first and second arguments are the same object (have the	 same object pointer) without sending a message to the first argument.  This	 mimics the action of the VM when it compares two object pointers.  Used to	 simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 4/8/2009 19:27'!object: anObject instVarAt: anIndex	"Primitive. Answer a fixed variable in an object. The numbering of the 	 variables corresponds to the named instance variables. Fail if the index 	 is not an Integer or is not the index of a fixed variable. Essential for the	 debugger. See  Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self object: anObject basicAt: anIndex - (self objectClass: anObject) instSize! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 4/8/2009 19:30'!object: anObject instVarAt: anIndex put: aValue 	"Primitive. Store a value into a fixed variable in the argument anObject.	 The numbering of the variables corresponds to the named instance	 variables.  Fail if the index is not an Integer or is not the index of a	 fixed variable.  Answer the value stored as the result. Using this	 message violates the  principle that each object has sovereign control	 over the storing of values into its instance variables. Essential for the	 debugger. See Object documentation whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self object: anObject basicAt: anIndex - (self objectClass: anObject) instSize put: aValue! !!ContextPart methodsFor: 'mirror primitives' stamp: 'dtl 12/11/2011 19:39'!object: anObject perform: selector withArguments: argArray inClass: lookupClass	"Send the selector, aSymbol, to anObject with arguments in argArray.	 Fail if the number of arguments expected by the selector 	 does not match the size of argArray, or if lookupClass	 cannot be found among the anObject's superclasses.	 Primitive. Essential for the debugger."	<primitive: 100 error: error>	(selector isSymbol) ifFalse:		[^self error: 'selector argument must be a Symbol'].	(argArray isMemberOf: Array) ifFalse:		[^self error: 'argArray must be an Array'].	(selector numArgs = argArray size)		ifFalse: [^self error: 'incorrect number of arguments'].	((self objectClass: anObject) == lookupClass	 or: [(self objectClass: anObject) inheritsFrom: lookupClass]) ifFalse:		[^self error: 'lookupClass is not in anObject''s inheritance chain'].	self primitiveFailed! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!objectSize: anObject	"Answer the number of indexable variables in the argument anObject without sending	 it a message. This mimics the action of the VM when it fetches an object's variable size.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!ContextPart class methodsFor: 'instance creation' stamp: 'cmm 8/1/2011 13:41'!basicNew: size 	^ (size = CompiledMethod smallFrameSize or: [ size = CompiledMethod fullFrameSize ])		ifTrue: [ super basicNew: size ]		ifFalse: [ self error: 'Contexts must be ' , CompiledMethod smallFrameSize , ' or ' , CompiledMethod fullFrameSize , ' bytes.' ]! !!ControlManager methodsFor: 'scheduling' stamp: 'ul 11/15/2010 11:35'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically := Sensor shiftPressed.	controllers := OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size = 0 ifTrue: [^ self].	listToUse := sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels := String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'fm 9/11/2010 00:10'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	^ self interruptName: labelString preemptedProcess: activeControllerProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'fm 9/11/2010 01:26'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the interrupted process with the given label. Make the Notifier the active controller."	theInterruptedProcess suspend.	(activeController ~~ nil and: [activeController ~~ screenController]) ifTrue: [		theInterruptedProcess == activeControllerProcess			ifTrue: [				"Carefully de-emphasis the current window."				activeController view topView deEmphasizeForDebugger]			ifFalse: [				activeController controlTerminate]].	"This will just scheduleNoTerminate the newly built controller"	Debugger			openInterrupt: labelString			onProcess: theInterruptedProcess.	self searchForActiveController! !!ControlManager methodsFor: 'scheduling' stamp: 'nice 6/11/2010 21:50'!windowFromUser	"Present a menu of window titles, and returns the StandardSystemController belonging to the one that gets chosen, or nil if none"	| controllers labels index |	controllers := OrderedCollection new.	labels := String streamContents:		[:strm |		scheduledControllers do:			[:controller | controller == screenController ifFalse:				[controllers addLast: controller.				strm nextPutAll: (controller view label contractTo: 40); cr]].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	^ index > 0		ifTrue:			[controllers at: index]		ifFalse:			[nil]! !!CrLfFileStream commentStamp: 'ul 12/26/2010 03:13' prior: 0!This class is now obsolete, use MultiByteFileStream instead.I am the same as a regular file stream, except that when I am in text mode, I will automatically convert line endings between the underlying platform's convention, and Squeak's convention of carriage-return only.  The goal is that Squeak text files can be treated as OS text files, and vice versa.In binary mode, I behave identically to a StandardFileStream.To enable CrLfFileStream as the default file stream class for an entire image, modify FileStream class concreteStream .There are two caveats on programming with CrLfFileStream.First, the choice of text mode versus binary mode affects which characters are visible in Squeak, and no longer just affects whether those characters are returned as Character's or as Integer's.  Thus the choice of mode needs to be made very carefully, and must be based on intent instead of convenience of representation.  The methods asString, asByteArray, asCharacter, and asInteger can be used to convert between character and integer representations.  (Arguably, file streams should accept either strings or characters in nextPut: and nextPutAll:, but that is not the case right now.)Second, arithmetic on positions no longer works, because one character that Squeak sees (carriage return) could map to two characters in the underlying file (carriage return plus line feed, on MS Windows and MS DOS).  Comparison between positions still works.  (This caveat could perhaps be fixed by maintaining a map between Squeak positions and positions in the underlying file, but it is complicated.  Consider, for example, updates to the middle of the file.  Also, consider that text files are rarely updated in the middle of the file, and that general random access to a text file is rarely very useful.  If general random access with specific file counts is desired, then the file is starting to sound like a binary file instead of a text file.)!!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ul 12/26/2010 03:14'!new	self deprecated: 'This class is now obsolete, use MultiByteFileStream instead.'.	^ (MultiByteFileStream new) wantsLineEndConversion: true; yourself.! !!Cubic methodsFor: 'cubic support' stamp: 'ul 7/25/2011 01:03'!honeIn: enough 	"Find if there is a smaller n than enough that give the same  	measure for n."		enough < 2 ifTrue: [ ^enough].	^ self		honeIn: enough		step: enough // 2		measure: (self measureFor: enough)		withIn: self leeway! !!Cubic methodsFor: 'cubic support' stamp: 'ul 7/25/2011 00:56'!measureFor: n 	"Return a distance measure for cubic curve with n segments. 	For convienence and accuracy we use the sum of the	distances. "	"first point is poly of 0."	| p1 measure |	p1 := self at: 1.	measure := 0.	1 to: n do: [ :i |		| x p2 |		x := i asFloat / n.		p2 := self polynomialEval: x @ x.		measure := measure + (p2 dist: p1).		p1 := p2 ].	^measure! !!CurrentReadOnlySourceFiles methodsFor: 'handling' stamp: 'ul 3/16/2011 22:56'!defaultAction	"Return a read-only copy of SourceFiles."	^SourceFiles collect: [ :each |		each ifNotNil: [			[ each readOnlyCopy ]				on: FileDoesNotExistException				do: [ :ex | nil "file does not exist happens in secure mode" ] ] ]! !!CurrentReadOnlySourceFiles commentStamp: 'ul 3/17/2011 01:17' prior: 0!I'm useful to avoid the creation of several read-only copies of the source files. Use me instead of SourceFiles in your code when you need a read-only copy, like here:CurrentReadOnlySourceFiles at: 1.To reuse the source files, surround your code the following way:CurrentReadOnlySourceFiles cacheDuring: [	<your code here using CurrentReadOnlySourceFiles> ]Note that it's still better performance wise to store the source files in a variable in your code if you need them more than once, than throwing many exceptions.!!CurrentReadOnlySourceFiles class methodsFor: 'act like SourceFiles' stamp: 'ul 3/16/2011 23:02'!at: sourceFileIndex	^self signal at: sourceFileIndex! !!CurrentReadOnlySourceFiles class methodsFor: 'caching' stamp: 'ul 3/17/2011 01:15'!cacheDuring: aBlock	"Cache the read only source files on the first request and use them on subsequent requests during the evaluation of aBlock."		| currentReadOnlySouceFiles |	currentReadOnlySouceFiles := nil.	^aBlock		on: self		do: [ :exception |			exception resume: (currentReadOnlySouceFiles ifNil: [				currentReadOnlySouceFiles := exception defaultAction ]) ]! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57'!initBottomLeft	BottomLeftCursor := 		(Cursor extent: 16 @ 16			fromArray: #(		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1111111111111111		2r1111111111111111)			offset: 0 @ -16).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57'!initBottomRight	BottomRightCursor := 		(Cursor extent: 16 @ 16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -16 @ -16).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57'!initCorner	CornerCursor := 		(Cursor 			extent: 16 @ 16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -16 @ -16).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57'!initCrossHair	CrossHairCursor :=   		(Cursor			extent: 16 @ 16			fromArray: #(		2r0000000000000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0111111111111100		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000000000000		2r0)			offset: -7 @ -7).		! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57'!initDown	DownCursor  :=		     (Cursor	extent: 16 @ 16	fromArray: #(		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r1111110000000000		2r111100000000000		2r11000000000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57'!initMarker	MarkerCursor := 		Cursor			extent: 16 @ 16			fromArray: #(		2r0111000000000000		2r1111100000000000		2r1111100000000000		2r0111000000000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)			offset: 0 @ 0.! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57'!initMenu 	MenuCursor  :=		        (Cursor	extent: 16 @ 16	fromArray: #(		2r1111111111100000		2r1000000000100000		2r1010011000100000		2r1000000000100000		2r1101001101100000		2r1111111111100000		2r1000000000100000		2r1011001010100000		2r1000000000100000		2r1010110010100000		2r1000000000100000		2r1010010100100000		2r1000000000100000		2r1111111111100000		0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:58'!initMove	MoveCursor := 		Cursor 			extent: 16 @ 16			fromArray: #(		2r1111111111111100		2r1111111111111100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1111111111111100		2r1111111111111100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1111111111111100		2r1111111111111100          0)			offset: 0 @ 0.! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:58'!initNormal	NormalCursor :=   		(Cursor			extent: 16 @ 16			fromArray: #(		2r1000000000000000		2r1100000000000000		2r1110000000000000		2r1111000000000000		2r1111100000000000		2r1111110000000000		2r1111111000000000		2r1111100000000000		2r1111100000000000		2r1001100000000000		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0 @ 0).		! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:58'!initNormalWithMask    "Cursor initNormalWithMask.  Cursor normal show"	"Next two lines work simply for any cursor..."	self initNormal.	NormalCursor := CursorWithMask derivedFrom: NormalCursor.	"But for a good looking cursor, you have to tweak things..."	NormalCursor := (CursorWithMask extent: 16 @ 16 depth: 1			fromArray: #( 0 1073741824 1610612736 1879048192				2013265920 2080374784 2113929216 2130706432				2080374784 2080374784 1275068416 100663296				100663296 50331648 50331648 0)			offset: -1 @ -1)		setMaskForm: (Form extent: 16 @ 16 depth: 1			fromArray: #( 3221225472 3758096384 4026531840 4160749568				4227858432 4261412864 4278190080 4286578688				4278190080 4261412864 4261412864 3472883712				251658240 125829120 125829120 50331648)			offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:58'!initOrigin	OriginCursor :=   		(Cursor			extent: 16 @ 16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59'!initRead	ReadCursor :=  		(Cursor			extent: 16 @ 16			fromArray: #(		2r0000000000000000		2r0000000000000000		2r0001000000001000		2r0010100000010100		2r0100000000100000		2r1111101111100000		2r1000010000100000		2r1000010000100000		2r1011010110100000		2r0111101111000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59'!initResizeLeft       ResizeLeftCursor :=               (Cursor extent: 16 @ 16 fromArray: #(               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000100000010000               2r0001100000011000               2r0011100000011100               2r0111111111111110               2r0011100000011100               2r0001100000011000               2r0000100000010000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000 )       offset: -7 @ -7 ) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59'!initResizeTop    "Cursor initResizeTop"       ResizeTopCursor :=               (Cursor extent: 16 @ 16 fromArray: #(               2r000000100000000               2r000001110000000               2r000011111000000               2r000111111100000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000111111100000               2r000011111000000               2r000001110000000               2r000000100000000               2r000000000000000)       offset: -7 @ -7) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59'!initResizeTopLeft       ResizeTopLeftCursor :=               (Cursor extent: 16 @ 16 fromArray: #(               2r0000000000000000               2r0111110000000000               2r0111100000000000               2r0111000000000000               2r0110100000000000               2r0100010000000000               2r0000001000000000               2r0000000100000000               2r0000000010000000               2r0000000001000100               2r0000000000101100               2r0000000000011100               2r0000000000111100               2r0000000001111100               2r0000000000000000               2r0000000000000000)       offset: -7 @ -7) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59'!initResizeTopRight       ResizeTopRightCursor :=               (Cursor extent: 16 @ 16 fromArray: #(               2r0000000000000000               2r0000000001111100               2r0000000000111100               2r0000000000011100               2r0000000000101100               2r0000000001000100               2r0000000010000000               2r0000000100000000               2r0000001000000000               2r0100010000000000               2r0110100000000000               2r0111000000000000               2r0111100000000000               2r0111110000000000               2r0000000000000000               2r0000000000000000)       offset: -7 @ -7) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59'!initRightArrow 	RightArrowCursor  :=		      (Cursor	extent: 16 @ 16	fromArray: #(		2r100000000000		2r111000000000		2r1111111110000000		2r111000000000		2r100000000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0 @ 0).		"Cursor initRightArrow"! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59'!initSquare	SquareCursor := 		(Cursor			extent: 16 @ 16			fromArray: #(		2r0		2r0		2r0		2r0		2r0		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: -8 @ -8).	! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59'!initTopLeft	TopLeftCursor := 		(Cursor extent: 16 @ 16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00'!initTopRight	TopRightCursor := 		(Cursor extent: 16 @ 16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011)			offset: -16 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00'!initUp	UpCursor := 		    (Cursor	extent: 16 @ 16	fromArray: #(		2r11000000000000		2r111100000000000		2r1111110000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00'!initWait	WaitCursor := 		  (Cursor			extent: 16 @ 16			fromArray: #(		2r1111111111111100		2r1000000000000100		2r0100000000001000		2r0010000000010000		2r0001110011100000		2r0000111111000000		2r0000011110000000		2r0000011110000000		2r0000100101000000		2r0001000100100000		2r0010000110010000		2r0100001111001000		2r1000111111110100		2r1111111111111100		0)			offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00'!initWrite	WriteCursor := (Cursor	extent: 16 @ 16	fromArray: #(		2r0000000000011000		2r0000000000111100		2r0000000001001000		2r0000000010010000		2r0000000100100000		2r0000001001000100		2r0000010010000100		2r0000100100001100		2r0001001000010000		2r0010010000010000		2r0111100000001000		2r0101000011111000		2r1110000110000000		2r0111111100000000		2r0		2r0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00'!initXeq	XeqCursor := 		(Cursor			extent: 16 @ 16			fromArray: #(		2r1000000000010000		2r1100000000010000		2r1110000000111000		2r1111000111111111		2r1111100011000110		2r1111110001000100		2r1111111001111100		2r1111000001101100		2r1101100011000110		2r1001100010000010		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0 @ 0).! !!CustomHelp commentStamp: 'tbn 3/29/2010 13:23' prior: 0!This is a common superclass for custom help. Subclasses of this class are automatically included into the system help.By default the informations provided on the receiver class are converted into help topics by a specific builder - here the CustomHelpHelpBuilder. Note that you can provide an own custom builder by overriding the #builder method!!CustomHelp class methodsFor: 'editing' stamp: 'ar 4/20/2010 23:26'!accept: aSelector title: title contents: text	"Accept edited text. Compile it into a HelpTopic"	| code |	code := String streamContents:[:s|		s nextPutAll: aSelector.		s crtab; nextPutAll: '"This method was automatically generated. Edit it using:"'.		s crtab; nextPutAll: '"', self name,' edit: ', aSelector storeString,'"'.		s crtab; nextPutAll: '^HelpTopic'.		s crtab: 2; nextPutAll: 'title: ', title storeString.		s crtab: 2; nextPutAll: 'contents: '.		s cr; nextPutAll: (String streamContents:[:c| c nextChunkPutWithStyle: text]) storeString.		s nextPutAll:' readStream nextChunkText'.	].	self class 		compile: code		classified: ((self class organization categoryOfElement: aSelector) ifNil:['pages']).! !!CustomHelp class methodsFor: 'editing' stamp: 'ar 4/20/2010 23:24'!edit: aSelector	"Open a Workspace on the text in the given selector.	When accepted, compile the result as a help topic."	| topic window |	topic := (self respondsTo: aSelector) 			ifTrue:[self perform: aSelector]			ifFalse:[HelpTopic title: 'Untitled' contents: 'Please edit this topic. To change the topic title, edit the window label.'].	window := UIManager default		edit: topic contents		label: topic title		accept: [:text| self accept: aSelector title: window label contents: text].! !!CustomHelp class methodsFor: 'converting' stamp: 'tbn 3/29/2010 13:17'!asHelpTopic	"Convert the receiver to a help topic"		^self builder buildHelpTopicFrom: self! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!bookName	"Returns the name of the custom help book"		^'Help'! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!icon	"Returns an icon used for displaying the custom help book"		^HelpIcons iconNamed: #bookIcon! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:18'!key	"Returns a unique key identifying the receiver in the help system"		^''! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!pages 	"Returns a collection of method selectors to return the pages of the custom help book"			^#()! !!CustomHelp class methodsFor: 'defaults' stamp: 'tbn 3/29/2010 13:24'!builder	"Returns the builder that is used to build the given help book from the receiver. You can override this method	 in a subclass to provide an own builder".		^CustomHelpHelpBuilder! !!CustomHelpHelpBuilder methodsFor: 'building' stamp: 'tbn 3/6/2010 00:28'!build	"Start building a help topic from a code description"		topicToBuild := self createTopicFrom: rootToBuildFrom ! !!CustomHelpHelpBuilder methodsFor: 'private' stamp: 'tbn 9/30/2010 23:31'!createTopicFrom: aDescription	"Create a topic from a description stored on a class.	aDescription can specify (via #pages) the name of a class and not	only a selector. This allows for hierarchies with 'subtrees in the middle'"		|topic page   pageClasses |	topic := HelpTopic named: aDescription bookName.	topic key: aDescription key.	topic icon: aDescription icon.	pageClasses := Set new.	aDescription pages do: [:pageSelectorOrClass|		page:= (Smalltalk hasClassNamed: pageSelectorOrClass asString)					ifFalse: [aDescription perform: pageSelectorOrClass]					ifTrue: [pageClasses add: (Smalltalk classNamed: pageSelectorOrClass asString).							 (Smalltalk classNamed: pageSelectorOrClass asString) asHelpTopic].		topic addSubtopic: page.	].		((aDescription subclasses asSet)		removeAllFoundIn: pageClasses;		yourself) do: [:subclass | topic subtopics add: subclass asHelpTopic ].	^topic! !!CustomHelpHelpBuilder commentStamp: 'tbn 3/29/2010 13:30' prior: 0!This builder builds help topics from a help topic description (which is typically storedin a class). The help topic description object has to understand the following messages:  #bookName - should return the name of the help book  #icon - should return the icon of the help book  #key - should return a unique key to identify the book  #pages - should return an array of method selectors to call to get the books pages!!CustomMenu methodsFor: 'construction' stamp: 'nice 6/11/2010 21:44'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList := aString lines asArray.	anArrayOrNil		ifNil: [linesArray := #()]		ifNotNil: [linesArray := anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font := aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'nice 6/11/2010 21:50'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelList isString		ifTrue: [labelArray := labelList lines]		ifFalse: [labelArray := labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!CustomMenu methodsFor: 'invocation' stamp: 'ul 11/15/2010 11:35'!invokeOn: targetObject orSendTo: anObject	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return  nil if no item is selected.  If the chosen selector has arguments, obtain appropriately.  If the recipient does not respond to the resulting message, send it to the alternate object provided"	| aSelector anIndex recipient |	^ (aSelector := self startUp) ifNotNil:		[anIndex := self selection.		recipient := ((targets := self targets) isEmptyOrNil or: [anIndex > targets size])			ifTrue:				[targetObject]			ifFalse:				[targets at: anIndex].		aSelector numArgs = 0			ifTrue:				[recipient perform: aSelector orSendTo: anObject]			ifFalse:				[recipient perform: aSelector withArguments: (self arguments at: anIndex)]]! !!DataStream methodsFor: 'write and read' stamp: 'ul 11/15/2010 11:38'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos internalObject |	type := byteStream next.	type ifNil: [pos := byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos := byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType := self noteCurrentReference: type.	selector := #(readNil readTrue readFalse readInteger	"<-4"			readStringOld readSymbol readByteArray		"<-7"			readArray readInstance readReference readBitmap	"<-11"			readClass readUser readFloat readRectangle readShortInst 	"<-16"			readString readWordArray readWordArrayForSegment 	"<-19"			readWordLike readMethod "<-21") at: type ifAbsent: [				pos := byteStream position.	"absolute!!!!"				byteStream close. 				self error: 'file is more recent than this system'. ^ nil].	anObject := self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].		"After reading the externalObject, internalize it.		 #readReference is a special case. Either:		   (1) We actually have to read the object, recursively calling			   next, which internalizes the object.		   (2) We just read a reference to an object already read and			   thus already interalized.		 Either way, we must not re-internalize the object here."	selector == #readReference ifTrue: [^ anObject].	internalObject := anObject comeFullyUpOnReload: self.	internalObject == String ifTrue:[		"This is a hack to figure out if we're loading a String class 		that really should be a ByteString. Note that these days this		will no longer be necessary since we use #withClassVersion:		for constructing the global thus using a different classVersion		will perfectly do the trick."		((anObject isKindOf: DiskProxy) 			and:[anObject globalObjectName == #String			and:[anObject constructorSelector == #yourself]]) ifTrue:[				internalObject := ByteString]].	^ self maybeBeginReference: internalObject! !!DataType methodsFor: '*Etoys-tiles' stamp: 'ul 11/15/2010 11:38'!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	"Answer, for classic tiles, an updating readout tile for a part with the receiver's type, with the given getter and setter"	| aTile displayer actualSetter |	actualSetter := setter ifNotNil:		[(#(none #nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile := self newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: getter;		target: aTarget;		growable: true;		minimumWidth: 24;		putSelector: actualSetter.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs = 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	^ aTile! !!Date class methodsFor: 'squeak protocol' stamp: 'cmm 7/17/2011 15:00'!starting: aDateAndTime 	^ super		starting: aDateAndTime midnight		duration: Duration oneDay! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'klc 9/12/2010 15:29'!= aDateAndTimeOrTimeStamp 	self == aDateAndTimeOrTimeStamp ifTrue: [ ^ true ].	((aDateAndTimeOrTimeStamp isKindOf: self class)		or: [aDateAndTimeOrTimeStamp isKindOf: DateAndTime orOf: TimeStamp])			ifFalse: [ ^ false ].	^ self offset = aDateAndTimeOrTimeStamp offset		ifTrue: [ self hasEqualTicks: aDateAndTimeOrTimeStamp ]		ifFalse: [ self asUTC ticks = aDateAndTimeOrTimeStamp asUTC ticks ]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'klc 9/12/2010 15:56'!asDate	^ Date starting: self asDateAndTime! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'cmm 7/17/2011 15:18'!makeUTC	"Change the receiver's timezone to UTC. Like #asUTC, but modifies the receiver and is much faster."	self primOffset: Duration zero! !!DateAndTime methodsFor: 'private' stamp: 'cmm 7/16/2011 15:32'!primOffset: aDuration	offset := aDuration! !!DateAndTime commentStamp: 'brp 5/13/2003 08:07' prior: 0!I represent a point in UTC time as defined by ISO 8601. I have zero duration.My implementation uses three SmallIntegers and a Duration:jdn		- julian day number.seconds	- number of seconds since midnight.nanos	- the number of nanoseconds since the second.offset	- duration from UTC.The nanosecond attribute is almost always zero but it defined for full ISO compliance and is suitable for timestamping.!!DateAndTime class methodsFor: 'ansi protocol' stamp: 'ul 11/6/2010 23:57'!now 	| nanoTicks msm |	nanoTicks := (msm := self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [		LastTick := nanoTicks.		^ self todayAtMilliSeconds: msm].	LastTickSemaphore critical: [		LastTick :=  LastTick + 1.		^ self todayAtNanoSeconds: LastTick]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'ul 11/6/2010 23:38'!milliSecondsSinceMidnight	| msm msClock |	"This is usually only during system startup..."	self waitForOffsets.	msClock := self millisecondClockValue.	msClock < LastMilliSeconds ifTrue: [ "rolled over"		MilliSecondOffset := MilliSecondOffset + (SmallInteger maxVal // 2) + 1 ].	LastMilliSeconds := msClock.	[	msm := msClock + MilliSecondOffset.	msm >= 86400000 ] whileTrue: [		"next day"		LastTick := -1.		DaysSinceEpoch := DaysSinceEpoch + 1.		MilliSecondOffset := MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	(LastTick = -1 and: [		(Duration			days: SqueakEpoch			hours: 0			minutes: 0			seconds: self clock totalSeconds) days ~= DaysSinceEpoch ]) ifTrue: [		self initializeOffsets.		^ self milliSecondsSinceMidnight ].	^ msm.! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'spd 8/5/2010 09:17'!readFrom: aStream	| offset date time ch |	date := Date readFrom: aStream.	[aStream peek isDigit]		whileFalse: [aStream next].	time := Time readFrom: aStream.	aStream atEnd		ifTrue: [ offset := self localOffset ]		ifFalse: [			ch := aStream next.			ch = $+ ifTrue: [ch := Character space].			offset := Duration fromString: ch asString, '0:', aStream upToEnd, ':0'].			^ self		year: date year		month: date monthIndex		day: date dayOfMonth		hour: time hour		minute: time minute		second: time second		nanoSecond: time nanoSecond		offset: offset	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 10/19/2010 14:14'!todayAtMilliSeconds: milliSecondsSinceMidnight	"This is usually only during system startup..."	self waitForOffsets.	 ^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (milliSecondsSinceMidnight // 1000) 			nano: (milliSecondsSinceMidnight  \\ 1000 * 1000000  ) 			offset: self localOffset	 " [ 100000 timesRepeat: [ self fromMilliSeconds: self milliSecondsSinceMidnight. ] ] timeToRun."! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 10/19/2010 14:14'!todayAtNanoSeconds: nanoSecondsSinceMidnight	"This is usually only during system startup..."	self waitForOffsets.	^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (nanoSecondsSinceMidnight // 1000000000) 			nano: (nanoSecondsSinceMidnight  \\ 1000000000  ) 			offset: self localOffset ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'ul 11/6/2010 23:37'!initializeOffsets	| durationSinceEpoch secondsSinceMidnight nowSecs |	LastTick := 0.	nowSecs := self clock secondsWhenClockTicks.	LastMilliSeconds := self millisecondClockValue.	durationSinceEpoch := Duration		days: SqueakEpoch		hours: 0		minutes: 0		seconds: nowSecs.	DaysSinceEpoch := durationSinceEpoch days.	secondsSinceMidnight := (durationSinceEpoch -		(Duration			days: DaysSinceEpoch			hours: 0			minutes: 0			seconds: 0)) asSeconds.	MilliSecondOffset := secondsSinceMidnight * 1000 - LastMilliSeconds! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'dtl 4/13/2011 08:10'!startUp: resuming	resuming ifFalse: [ ^ self ].	Time initializeMillisecondClockMask.	OffsetsAreValid := false.	[		self initializeOffsets.		OffsetsAreValid := true	] forkAt: Processor userInterruptPriority.! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'jmv 10/19/2010 14:10'!waitForOffsets	OffsetsAreValid ifFalse: [		[			(Delay forSeconds: 1) wait.			OffsetsAreValid		] whileFalse	]! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:19'!testEpoch	self assert: aDateAndTime =  '1901-01-01T00:00:00+00:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:19'!testNoon	self assert: aDateAndTime noon = '1901-01-01T12:00:00+00:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:20'!testOffset	self assert: aDateAndTime offset =  '0:00:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '1901-01-01T00:00:00+12:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:20'!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:12:00:00') =  '1901-01-01T12:00:00+12:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21'!testMidnight	self assert: aDateAndTime midnight =  '2004-02-29T00:00:00+00:00' asDateAndTime.	self deny: aDateAndTime midnight =  '2004-02-29T00:00:00+02:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 4/28/2011 22:28'!testMonthParsing	self assert:		(Month readFrom: 'Feb 2011' readStream) =			(Month				month: 2				year: 2011)! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21'!testNoon	self assert: aDateAndTime noon =  '2004-02-29T12:00:00+00:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21'!testOffset	self assert: aDateAndTime offset =  '0:02:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '2004-02-29T13:33:00+12:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:22'!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:02:00:00') =  '2004-02-29T13:33:00+02:00' asDateAndTime! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'spd 8/5/2010 09:17'!testFromString	| fromString fromStringNoOffset |	fromString := DateAndTime fromString: '-1199-01-05T20:33:14.321-05:00'.	self assert: (fromString printString = '-1199-01-05T20:33:14.321-05:00').		"if no offset is provided, the local offset should be used"	fromStringNoOffset := DateAndTime fromString: '-1199-01-05T20:33:14.321'.	self assert: (fromStringNoOffset offset = DateAndTime localOffset).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'klc 9/9/2010 15:55'!testPrintString	"(self new setTestSelector: #testPrintString) debug"	| dt dtNoOffset |	dt :=DateAndTime		year: 2004		month: 11		day: 2		hour: 14		minute: 3		second: 5		nanoSecond: 12345		offset: (Duration seconds: (5 * 3600)).	self assert: dt printString = '2004-11-02T14:03:05.000012345+05:00'.		self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').	self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  	self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').	self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).	self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').	self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime printString = '2002-05-16T17:20:45-02:34').	self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime printString = '2002-05-16T17:20:45+00:00').	self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime printString = '1997-04-26T01:02:03+01:02:3').	"When no offset is provided, the local one is used"	dtNoOffset := '2002-05-16T17:20' asDateAndTime.	self assert: (('2002-05-16T17:20:00*' match: dtNoOffset printString) and: [dtNoOffset offset = DateAndTime localOffset]).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'spd 8/5/2010 09:19'!testReadFromself assert: ((DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream) printString = '-1199-01-05T20:33:14.321-05:00'). ! !!DateTest methodsFor: 'testing' stamp: 'cmm 7/16/2011 15:27'!testMakeUTC	"Equal dates should compare equal regardless of which TimeZone	they are created in."	| priorTz march31stLocal march31stOcean |	"This test won't work in GMT-9, but nobody lives there."	self deny: DateAndTime localTimeZone offset hours = -9.	priorTz := DateAndTime localTimeZone.	march31stLocal := Date today.	DateAndTime		localTimeZone: (TimeZone				offset: -9 hours				name: 'No Countries'				abbreviation: 'Ocean').	march31stOcean := Date today.	DateAndTime localTimeZone: priorTz.	self assert: march31stLocal makeUTC = march31stOcean makeUTC ;		 deny: march31stOcean makeUTC > march31stLocal makeUTC ;		 deny: march31stOcean makeUTC < march31stLocal makeUTC! !!Debugger methodsFor: 'accessing' stamp: 'fbs 12/2/2010 17:38'!contents 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	^contents ifNil:		[self selectedContext			ifNotNil: [self selectedMessage]			ifNil: [String new]] ! !!Debugger methodsFor: 'accessing' stamp: 'eem 3/31/2011 18:28'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		"N.B. Only reset the contents if the compilation succeeds.  If contents are reset		 when compilation fails both compiler error message and modifications are lost."		(result := self contents: aText notifying: aController) ifTrue:			[self contentsChanged].		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass newParser parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	contents := aText.	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	Smalltalk isMorphic ifTrue:		[World			addAlarm: #changed:			withArguments: #(contentsSelection)			for: self			at: (Time millisecondClockValue + 200)].	^true! !!Debugger methodsFor: 'accessing' stamp: 'fbs 12/10/2010 22:30'!contextStackTop	^ contextStack first.! !!Debugger methodsFor: 'accessing' stamp: 'abc 2/12/2010 15:02'!debuggerMap	^self selectedContext debuggerMap! !!Debugger methodsFor: 'accessing' stamp: 'fbs 12/10/2010 22:36'!interruptedContext	"Answer the suspended context of the interrupted process."	^self contextStackTop.! !!Debugger methodsFor: 'breakpoints' stamp: 'jmv 3/2/2010 15:56'!toggleBreakOnEntry	"Install or uninstall a halt-on-entry breakpoint"	| selectedMethod |	self selectedClassOrMetaClass ifNil: [ ^self].	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.	selectedMethod hasBreakpoint		ifTrue:			[BreakpointManager unInstall: selectedMethod]		ifFalse:			[BreakpointManager 				installInClass: self selectedClassOrMetaClass				selector: self selectedMessageName].! !!Debugger methodsFor: 'context stack menu' stamp: 'eem 9/7/2010 16:15'!browseMessages	"Present a menu of all messages sent by the currently selected message.	Open a message set browser of all implementors of the message chosen.	Do nothing if no message is chosen."	contextStackIndex = 0 ifTrue: [^ self].	self withSelectorAndMessagesIn: self selectedContext method		evaluate: [:selector| self systemNavigation browseAllImplementorsOf: selector]! !!Debugger methodsFor: 'context stack menu' stamp: 'eem 9/7/2010 16:14'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all	messages sent by it.  Open a message set browser of all senders	of the message chosen."	contextStackIndex = 0 ifTrue: [^ self].	self withSelectorAndMessagesIn: self selectedContext method		evaluate: [:selector| self systemNavigation browseAllCallsOn: selector]! !!Debugger methodsFor: 'context stack menu' stamp: 'eem 9/7/2010 12:16'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	VersionsBrowser		browseVersionsOf: (class compiledMethodAt: selector									ifAbsent: [^self changed: #flash])		class: self selectedClass theNonMetaClass		meta: class isMeta		category: self selectedMessageCategoryName		selector: selector! !!Debugger methodsFor: 'context stack menu' stamp: 'cmm 5/2/2011 09:56'!contextStackMenu: aMenu shifted: shifted	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"	^ shifted ifFalse:[		aMenu addList: {			{'fullStack (f)'.		#fullStack}.			{'restart (r)'.		#restart}.			{'proceed (p)'.		#proceed}.			{'step (t)'.			#doStep}.			{'step through (T)'.	#stepIntoBlock}.			{'send (e)'.			#send}.			{'where (w)'.		#where}.			{'peel to first like this'.		#peelToFirst}.			#-.			{'return entered value'.		#returnValue}.			#-.			{'toggle break on entry'.	#toggleBreakOnEntry}.			{'senders of... (n)'.			#browseSendersOfMessages}.			{'implementors of... (m)'.	#browseMessages}.			{'inheritance (i)'.	#methodHierarchy}.			#-.			{'versions (v)'.		#browseVersions}.			#-.			{'references... (r)'.		#browseVariableReferences}.			{'assignments... (a)'.	#browseVariableAssignments}.			#-.			{'class refs (N)'.		#browseClassRefs}.			{'browse full (b)'.	#browseMethodFull}.			{'file out '.			#fileOutMessage}.			#-.			{'mail out bug report'.	#mailOutBugReport}.			{'more...'.		#shiftedYellowButtonActivity}.		}.	] ifTrue: [		aMenu addList: {			{'browse class hierarchy'.	#classHierarchy}.			{'browse class'.				#browseClass}.			{'browse method (O)'.		#openSingleMessageBrowser}.			{'implementors of sent messages'.		#browseAllMessages}.			{'change sets with this method'.		#findMethodInChangeSets}.			#-.			{'inspect instances'.		#inspectInstances}.			{'inspect subinstances'.		#inspectSubInstances}.			#-.			{'revert to previous version'.			#revertToPreviousVersion}.			{'remove from current change set'.		#removeFromCurrentChanges}.			{'revert & remove from changes'.		#revertAndForget}.			#-.			{'more...'.					#unshiftedYellowButtonActivity}. 		}	].! !!Debugger methodsFor: 'context stack (message list)' stamp: 'fbs 12/10/2010 22:22'!expandStack	"A Notifier is being turned into a full debugger.  Show a substantial amount of stack in the context pane."	self newStack: (self contextStackTop stackOfSize: 20).	contextStackIndex := 0.	receiverInspector := Inspector inspect: nil.	contextVariablesInspector := ContextVariablesInspector inspect: nil.	proceedValue := nil! !!Debugger methodsFor: 'context stack (message list)' stamp: 'fbs 12/10/2010 22:21'!fullyExpandStack	"Expand the stack to include all of it, rather than the first four or five contexts.	Well, almost all of it, we better maintain sane limits too."	self okToChange ifFalse: [^ self].	self newStack: (self contextStackTop stackOfSize: contextStack size + 100000).	self changed: #contextStackList! !!Debugger methodsFor: 'context stack (message list)' stamp: 'nice 1/10/2011 21:09'!selectedMessage	"Answer the source code of the currently selected context."	| aContext |	^contents := (aContext := self selectedContext) debuggerMap sourceText asText makeSelectorBoldIn: aContext home receiver class! !!Debugger methodsFor: 'initialize' stamp: 'dtl 9/11/2010 21:52'!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	| oldContextStackIndex |	oldContextStackIndex := contextStackIndex.	self expandStack. "Sets contextStackIndex to zero."	ToolBuilder default openDebugger: self label: aString.	self toggleContextStackIndex: oldContextStackIndex.! !!Debugger methodsFor: 'initialize' stamp: 'dtl 9/11/2010 21:38'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg builder spec |	Sensor flushKeyboard.	savedCursor := Sensor currentCursor.	Sensor currentCursor: Cursor normal.	(label beginsWith: 'Space is low')		ifTrue: [msg := self lowSpaceChoices, (msgString ifNil: [''])]		ifFalse: [msg := msgString].	builder := ToolBuilder default.	spec := self buildNotifierWith: builder label: label message: msg.	self expandStack.	builder openDebugger: spec.	errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: interruptedProcess.! !!Debugger methodsFor: 'initialize' stamp: 'fbs 12/10/2010 22:21'!windowIsClosing	"My window is being closed; clean up. Restart the low space watcher."	interruptedProcess == nil ifTrue: [^ self].	interruptedProcess terminate.	interruptedProcess := nil.	interruptedController := nil.	contextStack := nil.	receiverInspector := nil.	contextVariablesInspector := nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"! !!Debugger methodsFor: 'notifier menu' stamp: 'nice 2/13/2011 22:24'!storeLog	Smalltalk logSqueakError: labelString printString inContext: self contextStackTop! !!Debugger methodsFor: 'toolbuilder' stamp: 'cmm 5/2/2011 18:21'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	(self selectedMessageName = #doesNotUnderstand: and: [ self selectedClassOrMetaClass = Object ])		ifTrue:			[ self systemNavigation				spawnHierarchyForClass: self receiverClass				selector: self selectedMessageName ]		ifFalse: [ super classHierarchy ]! !!Debugger methodsFor: 'toolbuilder' stamp: 'cmm 5/1/2011 22:13'!receiverClass	^ self selectedContext receiver class! !!Debugger methodsFor: 'private' stamp: 'fbs 12/10/2010 22:23'!createMethod	"Should only be called when this Debugger was created in response to a	MessageNotUnderstood exception. Create a stub for the method that was	missing and proceed into it."		| msg chosenClass |	msg := self contextStackTop tempAt: 1.	chosenClass := self		askForSuperclassOf: self contextStackTop receiver class		toImplement: msg selector		ifCancel: [^self].	self implement: msg inClass: chosenClass.! !!Debugger methodsFor: 'private' stamp: 'fbs 12/10/2010 22:22'!process: aProcess controller: aController context: aContext	super initialize.	Smalltalk at: #MessageTally ifPresentAndInMemory: [ :tally |		tally terminateTimerProcess].	contents := nil. 	interruptedProcess := aProcess.	interruptedController := aController.	self newStack: (aContext stackOfSize: 1).	contextStackIndex := 1.	externalInterrupt := false.	selectingPC := true.	Smalltalk isMorphic ifTrue:		[errorWasInUIProcess := false]! !!Debugger methodsFor: 'private' stamp: 'fbs 12/10/2010 22:23'!resetContext: aContext 	"Used when a new context becomes top-of-stack, for instance when the	method of the selected context is re-compiled, or the simulator steps or	returns to a new method. There is room for much optimization here, first	to save recomputing the whole stack list (and text), and secondly to avoid	recomposing all that text (by editing the paragraph instead of recreating it)."	| oldContext |	oldContext := self selectedContext.	self newStack: aContext contextStack.	self changed: #contextStackList.	self contextStackIndex: 1 oldContextWas: oldContext.	self contentsChanged.! !!Debugger methodsFor: 'private' stamp: 'fbs 12/10/2010 22:24'!selectedContext	contextStackIndex = 0		ifTrue: [^contextStack first]		ifFalse: [^contextStack at: contextStackIndex]! !!Debugger commentStamp: '<historical>' prior: 0!I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.Special note on recursive errors:Some errors affect Squeak's ability to present a debugger.  This is normally an unrecoverable situation.  However, if such an error occurs in an isolation layer, Squeak will attempt to exit from the isolation layer and then present a debugger.  Here is the chain of events in such a recovery.	* A recursive error is detected.	* The current project is queried for an isolationHead	* Changes in the isolationHead are revoked	* The parent project of isolated project is returned to	* The debugger is opened there and execution resumes.If the user closes that debugger, execution continues in the outer project and layer.  If, after repairing some damage, the user proceeds from the debugger, then the isolationHead is re-invoked, the failed project is re-entered, and execution resumes in that world. !!Debugger class methodsFor: 'class initialization' stamp: 'mtf 12/20/2010 16:36'!openContext: aContext label: aString contents: contentsStringOrNil	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logSqueakError: aString inContext: aContext].	ErrorRecursion ifTrue:[		ErrorRecursion := false.		self primitiveError: aString].	ErrorRecursion := true.	self informExistingDebugger: aContext label: aString.	(Debugger context: aContext)		openNotifierContents: contentsStringOrNil		label: aString.	ErrorRecursion := false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'bf 12/16/2011 13:03'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger := self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.	Preferences logDebuggerStackToFile ifTrue:		[(aString includesSubString: 'Space') & (aString includesSubString: 'low')			ifTrue: [Smalltalk logError: aString inContext: debugger interruptedContext to: 'LowSpaceDebug.log']			"logging disabled for 4.3 release, see				http://lists.squeak.org/pipermail/squeak-dev/2011-December/162503.html"			"ifFalse: [Smalltalk logSqueakError: aString inContext: debugger interruptedContext]"].	Preferences eToyFriendly ifTrue: [World stopRunningAll].	^ debugger		openNotifierContents: nil		label: aString! !!Debugger class methodsFor: 'opening' stamp: 'dtl 2/27/2011 16:37'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short	view of the sender stack and provides a menu that lets the user open a full debugger.	Dispatch the request to a method appropriate for the active project."	^ Project current		dispatchTo: self		addPrefixAndSend: #OpenOn:context:label:contents:fullView:		withArguments: { process . context . title . contentsStringOrNil . bool }! !!Debugger class methodsFor: 'private' stamp: 'eem 7/26/2010 18:01'!ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess	| sema |	errorWasInUIProcess ifTrue:		[^self].	self interruptUIProcessIfBlockedOnErrorInBackgroundProcess ifFalse:		[^self].	"Only interrupt the UI if it is unresponsive (and so is doing something that needs	 interrupting).  Test using addDeferredUIMessage: to see if it is running UI activities."	sema := Semaphore new.	Project current addDeferredUIMessage: [sema signal].	(sema waitTimeoutMSecs: 100) ifTrue:		[[Project current interruptName: 'Interrupt from Background Error'] fork]	"| s |	s := Semaphore new.	[self assert: 0 > 1000. s signal] fork.	s wait"! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:52'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess	<preference: 'Interrupt UI process on background error'		category: 'debug'		description: 'When enabled, the debugger will interrupt the UI process if an error occurs in a background process and the UI process is blocked.'		type: #Boolean>	^InterruptUIProcessIfBlockedOnErrorInBackgroundProcess ifNil: [false]! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:53'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess: aBoolean	InterruptUIProcessIfBlockedOnErrorInBackgroundProcess := aBoolean! !!Debugger class methodsFor: '*Morphic-opening' stamp: 'nice 8/3/2011 14:48'!morphicOpenOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| errorWasInUIProcess debugger |	errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: process.	[Preferences logDebuggerStackToFile		ifTrue: [Smalltalk logSqueakError: title inContext: context]] on: Error do: [:ex | ex return: nil].	WorldState addDeferredUIMessage: [ 		"schedule debugger in deferred UI message to address redraw		problems after opening a debugger e.g. from the testrunner."		[			debugger := self new process: process controller: nil context: context.			bool				ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			debugger errorWasInUIProcess: errorWasInUIProcess.		] on: Error do: [:ex |				self primitiveError: 					'Original error: ', 					title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'			]	].	process suspend.! !!Debugger class methodsFor: '*ST80-opening' stamp: 'nice 8/4/2011 00:28'!mvcOpenOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller debugger |	controller := ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController].	[Preferences logDebuggerStackToFile		ifTrue: [Smalltalk logSqueakError: title inContext: context]] on: Error do: [:ex | ex return: nil].	[debugger := self new				process: process				controller: controller				context: context.	bool		ifTrue: [debugger openFullNoSuspendLabel: title]		ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].	] on: Error do: [:ex |			self primitiveError: 'Original error: ' , title asString , '.			Debugger error: ' , ([ex description]							on: Error							do: ['a ' , ex class printString]) , ':'].	process suspend! !!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'eem 9/8/2011 10:30'!rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext	"Answer the indices in the source code for the supplied pc.	 If the context is the actve context (is at the hot end of the stack)	 then its pc is the current pc.  But if the context isn't, because it is	 suspended sending a message, then its current pc is the previous pc."	| pc i end |	pc := self method abstractPCForConcretePC: (contextIsActiveContext													ifTrue: [contextsConcretePC]													ifFalse: [(self method pcPreviousTo: contextsConcretePC)																ifNotNil: [:prevpc| prevpc]																ifNil: [contextsConcretePC]]).	(self abstractSourceMap includesKey: pc) ifTrue:		[^self abstractSourceMap at: pc].	sortedSourceMap ifNil:		[sortedSourceMap := self abstractSourceMap.		 sortedSourceMap := (sortedSourceMap keys collect: 								[:key| key -> (sortedSourceMap at: key)]) asSortedCollection].	(sortedSourceMap isNil or: [sortedSourceMap isEmpty]) ifTrue: [^1 to: 0].	i := sortedSourceMap findNearbyBinaryIndex: [:assoc| pc - assoc key].	i < 1 ifTrue: [^1 to: 0].	i > sortedSourceMap size ifTrue:		[end := sortedSourceMap inject: 0 into:			[:prev :this | prev max: this value last].		^end+1 to: end].	^(sortedSourceMap at: i) value	"| method source scanner map |	 method := DebuggerMethodMap compiledMethodAt: #rangeForPC:contextIsActiveContext:.	 source := method getSourceFromFile asString.	 scanner := InstructionStream on: method.	 map := method debuggerMap.	 Array streamContents:		[:ranges|		[scanner atEnd] whileFalse:			[| range |			 range := map rangeForPC: scanner pc contextIsActiveContext: true.			 ((map abstractSourceMap includesKey: scanner abstractPC)			  and: [range first ~= 0]) ifTrue:				[ranges nextPut: (source copyFrom: range first to: range last)].			scanner interpretNextInstructionFor: InstructionClient new]]"! !!DebuggerMethodMap commentStamp: '<historical>' prior: 0!I am a place-holder for information needed by the Debugger to inspect method activations.  I insulate the debugger from details of code generation such as exact bytecode offsets and temporary variable locations.  I have two concreate subclasses, one for methods compiled using BlueBook blocks and one for methods compiled using Closures.  These classes deal with temporary variable access. My function is to abstract the source map away from actual bytecode pcs to abstract bytecode pcs.To reduce compilation time I try and defer as much computation to access time as possible as instances of me will be created after each compilation.I maintain a WeakIdentityDictionary of method to DebuggerMethodMap to cache maps.  I refer to my method through a WeakArray to keep the map cache functional. If the reference from a DebuggerMethodMap to its method were strong then the method would never be dropped from the cache because the reference from its map would keep it alive.!!DebuggerMethodMap class methodsFor: 'debugger support' stamp: 'ul 11/15/2010 08:44'!cacheDebugMap: aDebuggerMethodMap forMethod: aCompiledMethod		^self protected: [ 		MapCache size >= MapCacheEntries ifTrue: [			MapCache slowSize >= MapCacheEntries 				ifFalse: [ MapCache rehash ]				ifTrue: [					| mapsByAge |					mapsByAge := MapCache keys sort: [ :m1 :m2 |						"We are holding strongly on the keys, so #at: is suitable."						(MapCache at: m1) timestamp < (MapCache at: m2) timestamp].					mapsByAge from: 1 to: mapsByAge size - MapCacheEntries do: [ :each |						MapCache removeKey: each ] ] ].		MapCache			at: aCompiledMethod			put: aDebuggerMethodMap ]! !!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 08:39'!forMethod: aMethod "<CompiledMethod>"	"Answer a DebuggerMethodMap suitable for debugging activations of aMethod.	 Answer an existing instance from the cache if it exists, cacheing a new one if required."		^self protected: [ 		MapCache			at: aMethod			ifAbsent: [self						cacheDebugMap:							(self								forMethod: aMethod								methodNode: aMethod methodNode)						forMethod: aMethod] ]! !!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'mtf 9/19/2010 19:50'!cleanUp	self initialize! !!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'ul 11/15/2010 08:38'!voidMapCache	self protected: [ 		MapCache := WeakIdentityKeyDictionary new.		MapCacheEntries := 16 ]! !!DebuggerMethodMap class methodsFor: 'synchronization' stamp: 'ul 11/15/2010 08:38'!protected: aBlock	^(AccessLock ifNil: [ AccessLock := Mutex new ]) critical: aBlock! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 10/7/2011 10:19'!privateDereference: tempReference in: aContext	"Fetch the temporary with reference tempReference in aContext.	 tempReference can be		integer - direct temp reference		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index		#( outer. temp reference ) - a temp reference in an outer context."	^tempReference isInteger		ifTrue:			[aContext tempAt: tempReference]		ifFalse:			[tempReference first == #outer				ifTrue:					[self privateDereference: tempReference last						in: aContext outerContext]				ifFalse: "If stopped before indirection vectors are created they will be nil. Simply answer nil"					[(aContext tempAt: tempReference first) ifNotNil:						[:indirectionVector|						indirectionVector at: tempReference second]]]! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 10/7/2011 10:18'!privateDereference: tempReference in: aContext put: aValue	"Assign the temporary with reference tempReference in aContext.	 tempReference can be		integer - direct temp reference		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index		#( outer. temp reference ) - a temp reference in an outer context."	^tempReference isInteger		ifTrue:			[aContext tempAt: tempReference put: aValue]		ifFalse:			[tempReference first == #outer				ifTrue:					[self privateDereference: tempReference last						in: aContext outerContext						put: aValue]				ifFalse: "If stopped before indirection vectors are created they will be nil."					[(aContext tempAt: tempReference first)						ifNil: [UIManager default inform: 'Cannot assign remote temp because indirection vector is nil.\Too early in method execution?' withCRs.							nil]						ifNotNil:							[:indirectionVector|							indirectionVector								at: tempReference second								put: aValue]]]! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 9/14/2011 14:50'!privateTempRefsForContext: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents	"Answer the sequence of temps in scope in aContext in the natural order,	 outermost arguments and temporaries first, innermost last.  Each temp is	 a pair of the temp's name followed by a reference.  The reference can be		integer - index of temp in aContext		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index in aContext		#( outer. temp reference ) - a temp reference in an outer context."	blockExtentsToTempRefs ifNil:		[blockExtentsToTempRefs := (aContext method holdsTempNames										ifTrue: [aContext method]										ifFalse: [methodNode]) blockExtentsToTempsMap.		 blockExtentsToTempRefs ifNil:			["an empty method.  shouldn't be able to step into here but it			  can happen in weird circumstances (i.e. with MethodWrapper)."			blockExtentsToTempRefs := Dictionary new.			blockExtentsToTempRefs				at: (theContextsStartpcsToBlockExtents at: aContext startpc)				put: {}].		 startpcsToTempRefs := Dictionary new].	^startpcsToTempRefs		at: aContext startpc		ifAbsentPut:			[| localRefs |			 localRefs := blockExtentsToTempRefs at: (theContextsStartpcsToBlockExtents at: aContext startpc).			 aContext outerContext				ifNil: [localRefs]				ifNotNil:					[:outer| | outerTemps |					"Present temps in the order outermost to innermost left-to-right, but replace					 copied outermost temps with their innermost copies"					 outerTemps := (self										privateTempRefsForContext: outer										startpcsToBlockExtents: theContextsStartpcsToBlockExtents) collect:						[:outerPair|						localRefs							detect: [:localPair| outerPair first = localPair first]							ifNone: [{ outerPair first. { #outer. outerPair last } }]].					outerTemps,					 (localRefs reject: [:localPair| outerTemps anySatisfy: [:outerPair| localPair first = outerPair first]])]]! !!Decompiler methodsFor: 'control' stamp: 'eem 8/12/2010 13:25'!doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize	| startpc savedTemps savedTempVarCount savedNumLocalTemps	  jump blockArgs blockTemps blockTempsOffset block |	savedTemps := tempVars.	savedTempVarCount := tempVarCount.	savedNumLocalTemps := numLocalTemps.	jump := blockSize + (startpc := pc).	numLocalTemps := BlockLocalTempCounter tempCountForBlockAt: pc - 4 in: method.	blockTempsOffset := numArgs + blockCopiedValues size.	(blockStartsToTempVars notNil "implies we were intialized with temp names."	 and: [blockStartsToTempVars includesKey: pc])		ifTrue:			[tempVars := blockStartsToTempVars at: pc]		ifFalse:			[blockArgs := (1 to: numArgs) collect:							[:i| (constructor									codeTemp: i - 1									named: 't', (tempVarCount + i) printString)								  beBlockArg].			blockTemps := (1 to: numLocalTemps) collect:							[:i| constructor									codeTemp: i + blockTempsOffset - 1									named: 't', (tempVarCount + i + numArgs) printString].			tempVars := blockArgs, blockCopiedValues, blockTemps].	numLocalTemps timesRepeat:		[self interpretNextInstructionFor: self.		 stack removeLast].	tempVarCount := tempVarCount + numArgs + numLocalTemps.	block := self blockTo: jump.	stack addLast: ((constructor						codeArguments: (tempVars copyFrom: 1 to: numArgs)						temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)						block: block)							pc: startpc;							yourself).	tempVars := savedTemps.	tempVarCount := savedTempVarCount.	numLocalTemps := savedNumLocalTemps! !!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 2/3/2011 22:56'!jump: dist	| blockBody destPc nextPC |	destPc := pc + dist.	(lastJumpIfPcStack isEmpty or: [dist < 0 and: [destPc > lastJumpIfPcStack last]])		ifTrue:			["Rule: aBackward jump not crossing a Bfp/Btp must be a repeat"			nextPC := pc.			pc := destPc.			blockBody := self statementsTo: lastPc.			blockBody size timesRepeat: [statements removeLast].			pc := nextPC.			statements addLast:				(constructor					codeMessage: (constructor codeBlock: blockBody returns: false)					selector: (constructor								codeSelector: #repeat								code: #macro)					arguments: #()).			]		ifFalse:			[exit := destPc.			lastJumpPc := lastPc]! !!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 2/3/2011 22:57'!jump: dist if: condition	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock	  thenJump elseJump condHasValue isIfNil saveStack blockBody |	lastJumpIfPcStack addLast: lastPc.	stack last == CascadeFlag ifTrue: [^ [self case: dist] ensure: [lastJumpIfPcStack removeLast]].	elsePc := lastPc.	elseStart := pc + dist.	end := limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign := condition.	savePc := pc.	self interpretJump ifNotNil:		[:elseDist|		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:			 [sign := sign not.  elseStart := pc + elseDist]].	pc := savePc.	ifExpr := stack removeLast.	(isIfNil := stack size > 0 and: [stack last == IfNilFlag]) ifTrue:		[stack removeLast].	saveStack := stack.	stack := OrderedCollection new.	thenBlock := self blockTo: elseStart.	condHasValue := hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["Must be a while loop...			  thenJump will jump to the beginning of the while expr.  In the case of while's			  with a block in the condition, the while expr should include more than just			  the last expression: find all the statements needed by re-decompiling."			stack := saveStack.			pc := thenJump.			blockBody := self statementsTo: elsePc.			"discard unwanted statements from block"			blockBody size - 1 timesRepeat: [statements removeLast].			statements addLast:				(constructor					codeMessage: (constructor codeBlock: blockBody returns: false)					selector: (constructor								codeSelector: (sign												ifTrue: [#whileFalse:]												ifFalse: [#whileTrue:])								code: #macro)					arguments: { thenBlock }).			pc := elseStart.			self convertToDoLoop]		ifFalse:			["Must be a conditional..."			elseBlock := self blockTo: thenJump.			elseJump := exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc ifTrue:				[pc := lastPc].			cond := isIfNil						ifTrue:							[constructor								codeMessage: ifExpr ifNilReceiver								selector: (constructor											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])											code: #macro)								arguments: (Array with: thenBlock)]						ifFalse:							[constructor								codeMessage: ifExpr								selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)								arguments:	(sign												ifTrue: [{elseBlock. thenBlock}]												ifFalse: [{thenBlock. elseBlock}])].			stack := saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]].	lastJumpIfPcStack removeLast.! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 8/12/2010 13:51'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	| copiedValues |	self sawClosureBytecode.	copiedValues := ((1 to: numCopied) collect: [:ign| stack removeLast]) reversed.	self doClosureCopyCopiedValues: copiedValues numArgs: numArgs blockSize: blockSize! !!Decompiler methodsFor: 'public access' stamp: 'eem 9/27/2011 08:49'!decompile: aSelector in: aClass 	"See Decompiler|decompile:in:method:. The method is found by looking up 	the message, aSelector, in the method dictionary of the class, aClass."	^self		decompile: aSelector		in: aClass		method: (aClass compiledMethodAt: aSelector) methodForDecompile! !!Decompiler methodsFor: 'public access' stamp: 'nice 2/3/2011 22:53'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block node |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			lastJumpIfPcStack := OrderedCollection new.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			numLocalTemps := 0.			super method: method pc: method initialPC.			"skip primitive error code store if necessary"			(method primitive ~= 0 and: [self willStore]) ifTrue:				[pc := pc + 2.				 tempVars := tempVars asOrderedCollection].			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	node := constructor				codeMethod: aSelector				block: block				tempVars: tempVars				primitive: method primitive				class: aClass.	method primitive > 0 ifTrue:		[node removeAndRenameLastTempIfErrorCode].	^node preen! !!Decompiler methodsFor: 'public access' stamp: 'eem 8/12/2010 13:46'!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode methodNode home |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home methodClass) == #unknown ifTrue: [^ nil].	aBlock isClosure ifTrue:		[(methodNode := method decompileWithTemps)			ifNil: [^nil]			ifNotNil: [methodNode nodesDo: [:node| node pc = aBlock startpc ifTrue: [^node]]].		 ^self error: 'cannot find block node matching aBlock'].	constructor := self constructorForMethod: aBlock method.		self withTempNames: method methodNode tempNames.	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock endPC.	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super method: method pc: startpc - 5.	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!Decompiler methodsFor: 'private' stamp: 'fbs 12/19/2010 22:24'!interpretNextInstructionFor: client	| code varNames |"Change false here will trace all state in Transcript."true ifTrue: [^ super interpretNextInstructionFor: client].	varNames := self class allInstVarNames.	code := (self method at: pc) radix: 16.	Transcript cr; cr; print: pc; space;		nextPutAll: '<' , code, '>'.	8 to: varNames size do:		[:i | i <= 10 ifTrue: [Transcript cr]				ifFalse: [Transcript space; space].		Transcript nextPutAll: (varNames at: i);				nextPutAll: ': '; print: (self instVarAt: i)].	Transcript endEntry.	^ super interpretNextInstructionFor: client! !!Decompiler commentStamp: 'nice 2/3/2011 22:54' prior: 0!I decompile a method in three phases:	Reverser: postfix byte codes -> prefix symbolic codes (nodes and atoms)	Parser: prefix symbolic codes -> node tree (same as the compiler)	Printer: node tree -> text (done by the nodes)	instance vars:	constructor <DecompilerConstructor> an auxiliary knowing how to generate Abstract Syntax Tree (node tree)	method <CompiledMethod> the method being decompiled	instVars <Array of: String> the instance variables of the class implementing method	tempVars <String | (OrderedCollection of: String)> hold the names of temporary variables (if known)		NOTE: POLYMORPHISM WILL BE RESOLVED IN #initSymbols:	constTable <Collection of: ParseNode> parse node associated with byte encoded constants (nil true false 0 1 -1 etc...)	stack <OrderedCollection of: (ParseNode | String | Integer) > multipurpose...	statements <OrderedCollection of: ParseNode> the statements of the method being decompiled 	lastPc <Integer>	exit <Integer>	caseExits <OrderedCollection of: Integer> - stack of exit addresses that have been seen in the branches of caseOf:'s	lastJumpPc <Integer>	lastReturnPc <Integer>	limit <Integer>	hasValue <Boolean>	blockStackBase <Integer>	numLocaltemps <Integer | Symbol> - number of temps local to a block; also a flag indicating decompiling a block	blockStartsToTempVars <Dictionary key: Integer value: (OrderedCollection of: String)>	tempVarCount <Integer> number of temp vars used by the method	lastJumpIfPcStack <OrderedCollection of: Integer> the value of program counter just before the last encountered conditional jumps!!DecompilerConstructor methodsFor: 'constructor' stamp: 'jmv 3/3/2011 09:17'!decodeIfNilWithReceiver: receiver selector: selector arguments: arguments	receiver ifNil: [ ^nil ].		"For instance, when cascading"	selector == #ifTrue:ifFalse:		ifFalse: [^ nil].	(receiver isMessage: #==				receiver: nil				arguments: [:argNode | argNode == NodeNil])		ifFalse: [^ nil].	^ (MessageNode new			receiver: receiver			selector: (SelectorNode new key: #ifTrue:ifFalse: code: #macro)			arguments: arguments			precedence: 3)		noteSpecialSelector: #ifNil:ifNotNil:! !!DecompilerConstructorForClosures methodsFor: 'constructor' stamp: 'eem 8/15/2010 16:56'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries |	selectorNode := self codeSelector: selector code: nil.	tempVars := vars.	visibleTemps := OrderedCollection new.	invisibleTemps := OrderedCollection new.	tempVars do: [:t|				   ((t isIndirectTempVector or: [t scope >= 0])						ifTrue: [visibleTemps]						ifFalse: [invisibleTemps]) addLast: t].	arguments := visibleTemps copyFrom: 1 to: nArgs.	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.	block		arguments: arguments;		temporaries: temporaries.	blockNode := MethodNode new		selector: selectorNode		arguments: arguments		precedence: selector precedence		temporaries: temporaries		block: block		encoder: (EncoderForV3PlusClosures new initScopeAndLiteralTables					temps: visibleTemps, invisibleTemps					literals: literalValues					class: class)		primitive: primitive		properties: method properties copy.	blockNode properties method: blockNode.	^blockNode! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:56'!assert: aBoolean description: aString resumable: resumableBoolean 	aBoolean ifFalse: 		[failures isNil ifTrue:			[failures := OrderedCollection new].		 failures addLast: (thisContext sender home tempAt: 1) methodReference]! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:51'!computeFailures	(DecompilerTests organization listAtCategoryNamed: #tests) do:		[:s|		(s beginsWith: 'testDecompilerInClasses') ifTrue:			[self perform: s]].	^failures! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:49'!isFailure: cls sel: selector	^false! !!DecompilerTestFailuresCollector methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:56'!checkDecompileMethod: oldMethod		[^super checkDecompileMethod: oldMethod]		on: SyntaxErrorNotification		do: [:ex|			self assert: false 				description: 'syntax error'				resumable: true].! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 9/27/2011 08:51'!checkDecompileMethod: oldMethod		| cls selector oldMethodNode methodNode newMethod oldCodeString newCodeString |	cls := oldMethod methodClass.	selector := oldMethod selector.	oldMethodNode := (cls decompilerClass new withTempNames: oldMethod methodNode schematicTempNamesString)							decompile: selector							in: cls							method: oldMethod methodForDecompile.	[oldMethodNode properties includesKey: #warning] whileTrue:		[oldMethodNode properties removeKey: #warning].	oldCodeString := oldMethodNode decompileString.	methodNode := [cls newCompiler						compile: oldCodeString						in: cls						notifying: nil						ifFail: []]						on: SyntaxErrorNotification						do: [:ex|							ex errorMessage = 'Cannot store into' ifTrue:								[ex return: #badStore].							ex pass].	"Ignore cannot store into block arg errors; they're not our issue."	methodNode ~~ #badStore ifTrue:		[newMethod := methodNode generate.		 newCodeString := ((cls decompilerClass new withTempNames: methodNode schematicTempNamesString)								decompile: selector								in: cls								method: newMethod methodForDecompile) decompileString.		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldCodeString to: newCodeString))				openLabel: 'Decompilation Differences for ', cls name,'>>',selector"		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldMethod abstractSymbolic to: newMethod abstractSymbolic))				openLabel: 'Bytecode Differences for ', cls name,'>>',selector"		 self assert: oldCodeString = newCodeString			description: cls name asString, ' ', selector asString			resumable: true]! !!DecompilerTests methodsFor: 'utilities' stamp: 'ul 3/27/2011 17:27'!classNames		^Smalltalk globals classAndTraitNames! !!DecompilerTests methodsFor: 'utilities' stamp: 'ul 3/17/2011 02:41'!decompileClassesSelect: aBlock	CurrentReadOnlySourceFiles cacheDuring: [		(self classNames select: aBlock) do:			[:cn | | cls |			cls := Smalltalk globals at: cn.			cls selectorsAndMethodsDo:				[:selector :meth |				(self isFailure: cls sel: selector) ifFalse:					[self checkDecompileMethod: meth]]]]! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:26'!decompileStringForParseTree: aMethodNode	"Renumber the temps in the tree in parse tree order to eliminate that as a source of extraneous difference."	| visited count counter |	visited := IdentitySet new.	count := 0.	counter := [:temp|				(visited includes: temp) ifFalse:					[temp name: 't', (count := count + 1) printString.					 visited add: temp]].	aMethodNode nodesDo:		[:node|		(node == aMethodNode or: [node isBlockNode and: [node optimized not]]) ifTrue:			[node arguments do: counter].		node isTemp ifTrue:			[counter value: node]].		aMethodNode nodesDo:		[:node|		(node == aMethodNode or: [node isBlockNode and: [node optimized not]]) ifTrue:			[node temporaries do: counter.			 node temporaries: (node temporaries asSortedCollection: ParseNode tempSortBlock) asArray]].	^aMethodNode decompileString! !!DecompilerTests methodsFor: 'utilities' stamp: 'ul 3/27/2011 17:56'!decompilerFailures	"Here is the list of failures: either a syntax error, a hard error or some failure to decompile correctly.	 Collected via		CurrentReadOnlySourceFiles cacheDuring: [			(DecompilerTestFailuresCollector new computeFailures collect:				[:mr| { mr classSymbol. mr selector }]) asArray ]."	^#(	(BrowserCommentTextMorph showPane)		(ClassDescription replaceSilently:to:)		(CodeHolder getSelectorAndSendQuery:to:with:)		(Date printOn:)		(HttpUrl checkAuthorization:retry:)		(MCConfigurationBrowser post)		(MailComposition breakLinesInMessage:)		(MVCToolBuilder setLayout:in:) "same-name block-local temps in optimized blocks"		(ParagraphEditor inOutdent:delta:)		(PNGReadWriter copyPixelsGray:)		(PointTest testNormal) "fraction printing??"		(PointTest testTheta) "fraction printing??"		(ScaledDecimalTest testConvertFromFraction) "local/non-local temps"		(StandardScriptingSystem holderWithAlphabet) "same-name block-local temps in optimized blocks"		(SystemWindow convertAlignment)		(TextEditor inOutdent:delta:)		(TextURL actOnClickFor:)		(TTContourConstruction segmentsDo:) "Worth fixing; these two are mistaken conversion from a whileTrue: to a to:do: but the index is used outside the whileTrue:"		(TTFontReader processHorizontalMetricsTable:length:))! !!DecompilerTests methodsFor: 'tests' stamp: 'nice 9/8/2010 01:10'!testDecompileLoopWithMovingLimit	"This is a non regression test for http://bugs.squeak.org/view.php?id=7093"		| decompiledCode sourceCode |	sourceCode := 'loopWithMovingLimit	"This loop might be decompiled as a to:do: but should not because it does modify its limit"	| n i |	n := 4.	i := 1.	[i <= n] whileTrue: [		n := n - 1.		i := i + 1].	^n'.	self		shouldnt: [self class compile: sourceCode]		raise: Error.	self assert: (self perform: #loopWithMovingLimit) = 2.	self		shouldnt: [decompiledCode := self class decompile: #loopWithMovingLimit]		raise: Error.	self		shouldnt: [self class compile: decompiledCode decompileString]		raise: Error.	self		assert: (self perform: #loopWithMovingLimit) = 2		description: 'result from decompiledCode should not differ from sourceCode'.! !!DecompilerTests methodsFor: 'initialize-release' stamp: 'nice 9/8/2010 00:52'!tearDown	self class removeSelector: #loopWithMovingLimit! !!DefaultExternalDropHandler methodsFor: 'event handling' stamp: 'spfa 9/22/2010 09:44'!handle: dropStream in: pasteUp dropEvent: anEvent 	"the file was just droped, let's do our job"	| fileName services chosen |	fileName := dropStream name.	services := self servicesForFileNamed: fileName.	"no service, default behavior"	services isEmpty 		ifTrue: [^UIManager default edit: dropStream contentsOfEntireFile].	chosen := self chooseServiceFrom: services.	chosen ifNotNil:[chosen performServiceFor: dropStream]! !!DeflateStream methodsFor: 'accessing' stamp: 'nice 9/10/2011 13:57'!next: bytesCount putAll: aCollection startingAt: startIndex	| start count max |	aCollection species = collection species		ifFalse:			[startIndex to: startIndex + bytesCount - 1 do: [:i | self nextPut: (aCollection at: i)].			^aCollection].	start := startIndex.	count := bytesCount.	[count = 0] whileFalse:[		position = writeLimit ifTrue:[self deflateBlock].		max := writeLimit - position.		max > count ifTrue:[max := count].		collection replaceFrom: position+1			to: position+max			with: aCollection			startingAt: start.		start := start + max.		count := count - max.		position := position + max].	^aCollection! !!Delay methodsFor: 'private' stamp: 'GaryChambers 4/11/2011 10:04'!resumptionTime: anInteger	"Private!! Set the value of the system's millisecondClock at which the receiver's suspended Process will resumed.	Must only be called from the class-side #scheduleDelay:."		resumptionTime := anInteger! !!Delay methodsFor: 'private' stamp: 'GaryChambers 4/11/2011 10:07'!schedule	"Schedule this delay."		beingWaitedOn ifTrue: [^self error: 'This Delay has already been scheduled.'].	AccessProtect critical: [		ScheduledDelay := self.		TimingSemaphore signal]! !!Delay class methodsFor: 'instance creation' stamp: 'brp 9/25/2003 13:43'!forDuration: aDuration	^ self forMilliseconds: aDuration asMilliSeconds! !!Delay class methodsFor: 'timer process' stamp: 'GaryChambers 4/11/2011 10:05'!scheduleDelay: aDelay	"Private. Schedule this Delay."		aDelay resumptionTime: Time millisecondClockValue + aDelay delayDuration. 		"Gary Chambers:  do the above here, via the high priority timer process to avoid rollover bug due to process pre-emption		since the caller cannot use the AccessProtect semaphore."	aDelay beingWaitedOn: true.	ActiveDelay 		ifNil: [ActiveDelay := aDelay]		ifNotNil: [aDelay resumptionTime < ActiveDelay resumptionTime			ifTrue: [SuspendedDelays add: ActiveDelay.					ActiveDelay := aDelay]			ifFalse: [SuspendedDelays add: aDelay]]! !!DependencyBrowser methodsFor: 'contents' stamp: 'laza 2/3/2011 18:33'!aboutToStyle: aStyler	"This is a notification that aStyler is about to re-style its text.	Set the classOrMetaClass in aStyler, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"	| selectedClass |	selectedClass := self classListSelection ifNil:[^false].	self messageListSelection ifNil:[^false].	aStyler classOrMetaClass: ((self messageListSelection == #Definition) ifFalse:[Smalltalk classNamed: selectedClass]).	^true! !!DependencyBrowser methodsFor: 'contents' stamp: 'laza 5/12/2011 14:10'!selectedMessage	"Source code for currently selected message"	| className methodName mref |	className := self classListSelection.	methodName := self messageListSelection.	mref := (classDeps at: self classDepsSelection ifAbsent:[#()])		detect:[:mr| mr actualClass name = className 						and:[mr methodSymbol = methodName]]		ifNone:[nil].	mref ifNil:[^self class comment].	mref methodSymbol == #Definition ifTrue:[^mref actualClass definition].	^mref sourceCode! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:10'!buildClassDepsWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Required Classes' ;		list: #classDeps; 		getIndex: #classDepsIndex; 		setIndex: #classDepsIndex:; 		menu: #classDepsMenu:; 		keyPress: #classDepsKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:13'!buildClassListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Client classes' ;		list: #classList; 		getIndex: #classListIndex; 		setIndex: #classListIndex:; 		menu: #classListMenu:; 		keyPress: #classListKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:14'!buildMessageListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Client methods' ;		list: #messageList; 		getIndex: #messageListIndex; 		setIndex: #messageListIndex:; 		menu: #messageListMenu:; 		keyPress: #messageListKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:10'!buildPackageDepsWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Required Packages' ;		list: #packageDeps; 		getIndex: #packageDepsIndex; 		setIndex: #packageDepsIndex:; 		menu: #packageDepsMenu:; 		keyPress: #packageDepsKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:08'!buildPackageListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Packages' ;		list: #packageList; 		getIndex: #packageListIndex; 		setIndex: #packageListIndex:; 		menu: #packageListMenu:; 		keyPress: #packageListKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'class deps' stamp: 'fbs 5/6/2011 07:38'!classDeps	"Class dependencies for the currently selected package"	packageDeps ifNil: [^ #()].	^ (packageDeps at: self packageDepsSelection ifAbsent:[#()]) sort.! !!DependencyBrowser methodsFor: 'class deps' stamp: 'nice 1/24/2011 23:26'!classDepsMenu: aMenu	^aMenu! !!DependencyBrowser methodsFor: 'class list' stamp: 'fbs 5/6/2011 11:30'!classList	"List of classes that refer to dependencies"	classDeps ifNil: [^ #()].		"classList stores the actual classes displayed in my class list, corresponding to the collection of Strings returned by self classList. This allows us to unambiguously determine the class or metaclass currently being browsed simply by knowing the index of the selected class."	classList := ((classDeps at: self classDepsSelection ifAbsent:[#()]) 		collect:[:mref| mref actualClass] as: Set) asArray sort: [:a :b | a name < b name].			^ classList collect: #name.! !!DependencyBrowser methodsFor: 'class list' stamp: 'nice 1/24/2011 23:26'!classListMenu: aMenu	^aMenu! !!DependencyBrowser methodsFor: 'class list' stamp: 'fbs 5/5/2011 17:44'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."		| name envt |	(name := self selectedClassName) ifNil: [^ nil].	(envt := self selectedEnvironment) ifNil: [^ nil].	^ envt at: name ifAbsent: [nil]! !!DependencyBrowser methodsFor: 'class list' stamp: 'fbs 5/5/2011 17:45'!selectedClassName	| idx |	idx := classListIndex ifNil: [0].	^ self classList ifNotNil: [ :l | l at: idx ifAbsent: [nil]]! !!DependencyBrowser methodsFor: 'class list' stamp: 'fbs 5/6/2011 07:34'!selectedClassOrMetaClass	"Answer the class or metaclass that is currently selected. Answer nil if no selection 	exists."	classList ifNil: [^nil].	^ classList at: classListIndex ifAbsent: [nil].! !!DependencyBrowser methodsFor: 'package deps' stamp: 'nice 1/24/2011 23:26'!packageDepsMenu: aMenu	^aMenu! !!DependencyBrowser methodsFor: 'message list' stamp: 'fbs 5/6/2011 07:33'!messageList	"List of messages creating dependencies"	| selectedClass |	classDeps ifNil: [^ #()].		selectedClass := self classListSelection.	^((classDeps at: self classDepsSelection ifAbsent:[#()]) 		select:[:each| each actualClass name = selectedClass]		thenCollect:[:mref| mref methodSymbol]) asArray sort! !!DependencyBrowser methodsFor: 'message list' stamp: 'nice 1/24/2011 23:26'!messageListMenu: aMenu	^aMenu! !!DependencyBrowser methodsFor: 'message list' stamp: 'fbs 5/5/2011 17:59'!selectedMessageName	^ self messageList at: messageListIndex ifAbsent: [nil]! !!DependencyBrowser methodsFor: 'package list' stamp: 'fbs 5/5/2011 17:47'!hasPackageSelected	^ packageListIndex > 0.! !!DependencyBrowser methodsFor: 'package list' stamp: 'nice 1/24/2011 23:26'!packageListMenu: aMenu	^aMenu! !!DependencyBrowser methodsFor: 'initialize-release' stamp: 'fbs 5/5/2011 17:52'!initialize	super initialize.	packageListIndex := 0.	packageDepsIndex := 0.	classDepsIndex := 0.	classListIndex := 0.	messageListIndex := 0.! !!DependencyBrowser methodsFor: 'accessing' stamp: 'fbs 5/5/2011 17:47'!selectedEnvironment	"Answer the name of the selected package or nil."	self hasPackageSelected ifFalse: [^nil].	^ Smalltalk! !!DependencyBrowser commentStamp: 'fbs 5/6/2011 11:29' prior: 0!A simple dependency browser showing five panes:[1]: Packages: The list of available packages in the system.[2]: Package Dependencies: The dependent packages of the currently selected package.[3]: Class Dependencies: The classes causing the dependencies.[4]: Class List: The classes introducing the dependencies.[5]: Messages: The messages introducing the dependencies.!!DependencyBrowser class methodsFor: 'class initialization' stamp: 'cmm 1/8/2011 15:40'!initialize	"Initializes the receiver class" 	 TheWorldMenu registerOpenCommand: {'Dependency Browser'. {self. #open}}. ! !!DependencyBrowserTest methodsFor: 'running' stamp: 'fbs 5/4/2011 18:43'!setUp	browser := DependencyBrowser new.! !!DependencyBrowserTest methodsFor: 'testing - buttons' stamp: 'fbs 5/5/2011 17:55'!testBrowse	| b |	browser packageListIndex: (browser packageList indexOf: #Collections).	browser packageDepsIndex: (browser packageDeps indexOf: #Compiler).	browser classDepsIndex: (browser classDeps indexOf: #Scanner).	browser classListIndex: (browser classList indexOf: #Symbol).	browser messageListIndex: 1.	b := browser browseMethodFull.	self assert: b notNil.	[self assert: b selectedMessageName = (browser messageList at: browser messageListIndex) ]		ensure: [ToolBuilder default close: b topView]! !!DependencyBrowserTest methodsFor: 'testing - class list' stamp: 'ul 12/8/2011 02:22'!testClassList	"Warning!! When Collections' dependencies change, this test may start to fail!!"	self assert: browser classList isEmpty.		browser packageListIndex: (browser packageList indexOf: #Collections).	self assert: browser classList isEmpty.		browser packageDepsIndex: (browser packageDeps indexOf: #Compiler).	self assert: browser classList isEmpty.		browser classDepsIndex: (browser classDeps indexOf: #Scanner).		self assert: browser classList = #(String Symbol 'Symbol class').		browser classListIndex: (browser classList indexOf: #Symbol).	self assert: browser classList = #(String Symbol 'Symbol class')! !!DependencyBrowserTest methodsFor: 'testing - metaclass' stamp: 'fbs 5/5/2011 17:53'!testHasPackageSelected	self deny: browser hasPackageSelected.		browser packageListIndex: 1.	self assert: browser hasPackageSelected.		browser packageListIndex: 0.	self deny: browser hasPackageSelected.! !!DependencyBrowserTest methodsFor: 'testing - metaclass' stamp: 'fbs 5/6/2011 07:43'!testSelectedClassOrMetaClass	"Warning!! When Collections' dependencies change, this test may start to fail!!"	self assert: browser selectedClassOrMetaClass isNil.	browser packageListIndex: (browser packageList indexOf: #Collections).	self assert: browser selectedClassOrMetaClass isNil.		browser packageDepsIndex: (browser packageDeps indexOf: #Compiler).	self assert: browser selectedClassOrMetaClass isNil.		browser classDepsIndex: (browser classDeps indexOf: #Scanner).	self assert: browser selectedClassOrMetaClass isNil.		browser classListIndex: (browser classList indexOf: #Symbol).	self deny: browser selectedClassOrMetaClass isNil.	self assert: browser selectedClassOrMetaClass == Symbol.! !!DependencyBrowserTest methodsFor: 'testing - message list' stamp: 'fbs 5/14/2011 09:32'!testSelectedMessageClassSideShowsSource	"Warning!! When Collections' dependencies change, this test may start to fail!!"	browser packageListIndex: (browser packageList indexOf: #Kernel).	browser packageDepsIndex: (browser packageDeps indexOf: #Collections).	browser classDepsIndex: (browser classDeps indexOf: #'Array').	browser classListIndex: (browser classList indexOf: #'DateAndTime class').	browser messageListIndex: 1.	self assert: browser selectedMessageName == #fromSeconds:.		self assert: browser contents = (DateAndTime class sourceCodeAt: #fromSeconds:)! !!DependencyBrowserTest methodsFor: 'testing - message list' stamp: 'fbs 5/6/2011 08:26'!testSelectedMessageName	"Warning!! When Collections' dependencies change, this test may start to fail!!"	self assert: browser selectedMessageName isNil.	browser packageListIndex: (browser packageList indexOf: #Collections).	self assert: browser selectedMessageName isNil.		browser packageDepsIndex: (browser packageDeps indexOf: #Compiler).	self assert: browser selectedMessageName isNil.		browser classDepsIndex: (browser classDeps indexOf: #Scanner).	self assert: browser selectedMessageName isNil.		browser classListIndex: (browser classList indexOf: #Symbol).	self assert: browser selectedMessageName isNil.		browser messageListIndex: 1.	self assert: browser selectedMessageName == #storeOn:.		browser messageListIndex: 0.	self assert: browser selectedMessageName isNil.! !!DependencyBrowserTest methodsFor: 'testing - message list' stamp: 'fbs 5/14/2011 09:32'!testSelectedMessageNameClassSide	"Warning!! When Collections' dependencies change, this test may start to fail!!"	self assert: browser selectedMessageName isNil.	browser packageListIndex: (browser packageList indexOf: #Kernel).	self assert: browser selectedMessageName isNil.		browser packageDepsIndex: (browser packageDeps indexOf: #Collections).	self assert: browser selectedMessageName isNil.		browser classDepsIndex: (browser classDeps indexOf: #Array).	self assert: browser selectedMessageName isNil.		browser classListIndex: (browser classList indexOf: #'DateAndTime class').	self assert: browser selectedMessageName isNil.		browser messageListIndex: 1.	self assert: browser selectedMessageName == #fromSeconds:.! !!DependentsArray methodsFor: 'enumerating' stamp: 'ul 6/18/2010 23:31'!select: aBlock 	"Refer to the comment in Collection|select:."	| basicSize newSelf size selection |	basicSize := self basicSize.	newSelf := self species new: basicSize.	size := 0.	1 to: basicSize do: [ :i |		(self basicAt: i) ifNotNil: [ :dep |			(aBlock value: dep) ifTrue: [				newSelf basicAt: (size := size+1) put: dep ] ] ].	selection := self species new: size.	selection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.	^selection! !!DependentsArrayTest methodsFor: 'testing' stamp: 'GabrielOmarCotelli 5/25/2009 16:16'!testSize	self 		assert: (DependentsArray with: nil) size = 0;		assert: (DependentsArray with: nil with: 1 with: nil) size = 1;		assert: (DependentsArray with: 1 with: 3) size = 2;		assert: (DependentsArray with: nil with: nil with: nil) size = 0! !!Dictionary methodsFor: 'adding' stamp: 'ar 8/24/2010 20:19'!addAll: aCollection	"Include all the associations of aCollection as the receiver's elements. Answer 	aCollection. Any collection containing associations can be used as argument."	aCollection == self ifFalse: [		aCollection associationsDo: [:assoc| self add: assoc].	].	^aCollection! !!Dictionary methodsFor: 'removing' stamp: 'ul 7/17/2011 15:11'!unreferencedKeys	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"	^'Scanning for references . . .' 		displayProgressFrom: 0		to: Smalltalk classNames size * 2		during: [ :bar |			| currentClass n associations referencedAssociations |			currentClass := nil.			n := 0.			associations := self associations asIdentitySet.			referencedAssociations := IdentitySet new: associations size.			self systemNavigation allSelectorsAndMethodsDo: [ :behavior :selector :method |				behavior == currentClass ifFalse: [					currentClass := behavior.					 bar value: (n := n + 1) ].				method literalsDo: [ :literal |					(literal isVariableBinding and: [ associations includes: literal ]) ifTrue: [						referencedAssociations add: literal ] ] ].			(associations reject: [ :assoc | referencedAssociations includes: assoc ]) collect: [ :assoc| assoc key ] ]! !!Dictionary methodsFor: '*ShoutCore' stamp: 'tween 9/13/2004 10:11'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a key that begins with aString, false otherwise"		self keysDo:[:each | 		(each beginsWith: aString)			ifTrue:[^true]].	^false! !!Dictionary commentStamp: 'nice 8/26/2010 22:30' prior: 0!A Dictionary is an unordered collection of values which are indexed by arbitrary keys.A Dictionary is accessed via #at: and #at:put: messages like a SequenceableCollection, but instead of being Integer, the keys can be any object that responds to =.		The = message is used to test for the existence of the key in the Dictionary.If the key is absent, #at:put: adds a new entry to the Dictionary.	(Dictionary new)		at: 'foo' put: 1;		at: 'bar' put: 8;		yourself.Each key is unique: storing another value with #at:put: at an already used key overwrites previously associated value.	(Dictionary new)		at: 'bar' put: 4;		at: 'bar' put: 8;		at: 'bar'.		The values are not necessarily unique, thus a Dictionary can also be seen as a sort of Bag with this respect.	(Dictionary new)		at: 'foo' put: 8;		at: 'bar' put: 8;		yourself.If the key is absent, #at: raises an Error. An alternate block of code can be executed and its value returned in this case using #at:ifAbsent:.See also #at:ifAbsentPut:.	(Dictionary new) at: 'foo' ifAbsent: [nil].Dictionary is implemented as a HashedCollection of Association (a value is associated to its key et vice et versa).Being a HashedCollection enables fast random access indexed by keys.Consequently, keys must respond to #hash (see super).BEWARE: as for every HashedCollection, it is better to not modify an object after it is used as a Dictionary key. The reason is that this might change the #hash code, making the Dictionary unable to find corresponding entry, or make two keys equal violating uniqueness. It's progammer responsibility to take care to not modify the keys, or eventually to send #rehash to the Dictionary if they ever happen to change.It is possible to grow or shrink a Dictionary using the messages #add: and #remove: with an Association parameter, however the prefered way to do so is using #at:put: and #removeKey:.BEWARE: as for super, space reserved in internal storage array can grow but never shrink.For conveniency, it is also possible to create a Dictionary out of a Collection of associations, as for example in:    {'foo' -> 1. 'bar' -> 8} as: Dictionary.    Dictionary withAll: {'foo' -> 1. 'bar' -> 8}.    Dictionary new addAll: {'foo' -> 1. 'bar' -> 8}; yourself.BEWARE: though a Sequence collection can be considered as a sequence of values with Integer keys (see #keysAndValuesDo: ), it cannot be converted into a Dictionary using these keys, and following message will fail:	#('foo' 'bar') as: Dictionary.Enumerating a Dictionary with #do: will only enumerate the values, not the keys.Remember, the order of evaluation is arbitrary and can change when you grow or shrink a Dictionary.    ({'foo' -> 1. 'bar' -> 8} as: Dictionary) do: [:each | Transcript cr; show: each printString].For enumerating keys and values, use #keysAndValuesDo:, or use #associationsDo: to enumerate the associations.#select: #reject: #collect: will operate on values while preserving the keys and thus answer a new Dictionary.    ({'foo' -> 1. 'bar' -> 8} as: Dictionary) collect: [:each | each squared].The keys and values of a Dictionary can be extracted by sending #keys and #values message.Though the keys are theoretically a Set and values a Bag, for efficiency reasons, these messages will both return an Array of keysand an Array of values. A neat feature is that these messages are preserving the arbitrary storage order - in other words, (aDictionary values at: 3) is the value associated to key (aDictionary keys at: 3).!!Dictionary class methodsFor: 'instance creation' stamp: 'fbs 9/9/2011 11:50'!newFromPairs: anArray 	"Answer an instance of me associating (anArray at:i) to (anArray at: i+1)	 for each odd i.  anArray must have an even number of entries."	| newDictionary |	newDictionary := self new: (anArray size/2).	1 to: (anArray size-1) by: 2 do: [ :i|		newDictionary at: (anArray at: i) put: (anArray at: i+1).	].	^ newDictionary	"  Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}. "! !!DictionaryTest methodsFor: 'tests' stamp: 'ar 8/24/2010 20:16'!testAddAll		| dict1 dict2 |	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := Dictionary new.	dict2 at: #a put: 3 ; at: #c put: 4.	dict1 addAll: dict2.	self assert: (dict1 at: #a) = 3.	self assert: (dict1 at: #b) = 2.	self assert: (dict1 at: #c) = 4.	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict1 addAll: {#a -> 3. #c -> 4}.	self assert: (dict1 at: #a) = 3.	self assert: (dict1 at: #b) = 2.	self assert: (dict1 at: #c) = 4.! !!DictionaryTest methodsFor: 'tests' stamp: 'ar 8/24/2010 20:17'!testWithAll		| dict1 dict2 |	dict1 := Dictionary withAll: {#a -> 1. #b -> 2}.	self assert: (dict1 at: #a) = 1.	self assert: (dict1 at: #b) = 2.	dict2 := Dictionary withAll: dict1.	self assert: (dict2 at: #a) = 1.	self assert: (dict2 at: #b) = 2.! !!DictionaryTest methodsFor: 'association tests' stamp: 'ul 11/15/2010 11:38'!testAssociationsSelect	| answer d |	d := Dictionary new.	d at: (Array with: #hello with: #world)	  put: #fooBar.	d at: Smalltalk put: #'Smalltalk is the key'.	d at: #Smalltalk put: Smalltalk.	answer := d				associationsSelect: [:assoc | assoc key == #Smalltalk						and: [assoc value == Smalltalk]].	self		should: [answer isKindOf: Dictionary].	self		should: [answer size = 1].	self		should: [(answer at: #Smalltalk)				== Smalltalk].	answer := d				associationsSelect: [:assoc | assoc key == #NoSuchKey						and: [assoc value == #NoSuchValue]].	self		should: [answer isKindOf: Dictionary].	self		should: [answer size = 0]! !!DiffElement methodsFor: 'accessing' stamp: 'ul 11/6/2010 02:23'!string: aString	string := aString.	hash := string hash! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'nice 12/14/2010 15:10'!initRandomFromString: aString	"Ask the user to type a long random string and use the result to seed the secure random number generator."	| s k srcIndex |	s := aString.	k := LargePositiveInteger new: (s size min: 64).	srcIndex := 0.	k digitLength to: 1 by: -1 do: [:i |		k digitAt: i put: (s at: (srcIndex := srcIndex + 1)) asciiValue].	k := k normalize + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"	k highBit > 512 ifTrue: [k := k bitShift: k highBit - 512].	self initRandom: k.! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'nice 12/14/2010 15:10'!initRandomFromUser	"Ask the user to type a long random string and use the result to seed the secure random number generator."	| s k srcIndex |	s := UIManager default request: 'Enter a long random string to seed the random generator.'.	k := LargePositiveInteger new: (s size min: 64).	srcIndex := 0.	k digitLength to: 1 by: -1 do: [:i |		k digitAt: i put: (s at: (srcIndex := srcIndex + 1)) asciiValue].	k := k normalize + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"	k highBit > 512 ifTrue: [k := k bitShift: k highBit - 512].	self initRandom: k.! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'gk 2/26/2004 09:52'!initRandomNonInteractively	[self initRandom: (SoundService default randomBitsFromSoundInput: 512)]		ifError: [self initRandomFromString: 			Time millisecondClockValue printString, 			Date today printString, 			SmalltalkImage current platformName printString].! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'nice 8/28/2010 21:16'!inverseOf: x mod: n	"Answer the inverse of x modulus n. That is, the integer y such that (x * y) \\ n is 1. Both x and n must be positive, and it is assumed that x < n and that x and n are integers."	"Details: Use the extended Euclidean algorithm, Schneier, p. 247."	| v u u1 u2 u3 t1 t2 t3 tmp |	((x <= 0) or: [n <= 0]) ifTrue: [self error: 'x and n must be greater than zero'].	x >= n ifTrue: [self error: 'x must be < n'].	v := x.	u := n.	(x even and: [n even]) ifTrue: [self error: 'no inverse'].	u1 := 1. u2 := 0. u3 := u.	t1 := v. t2 := u - 1. t3 := v.	[	[u3 even ifTrue: [			((u1 odd) or: [u2 odd]) ifTrue: [				u1 := u1 + v.				u2 := u2 + u].			u1 := u1 bitShift: -1.			u2 := u2 bitShift: -1.			u3 := u3 bitShift: -1].		((t3 even) or: [u3 < t3]) ifTrue: [			tmp := u1. u1 := t1. t1 := tmp.			tmp := u2. u2 := t2. t2 := tmp.			tmp := u3. u3 := t3. t3 := tmp].		u3 even and: [u3 > 0]] whileTrue: ["loop while u3 is even"].		[((u1 < t1) or: [u2 < t2]) and: [u1 > 0]] whileTrue: [			u1 := u1 + v.			u2 := u2 + u].			u1 := u1 - t1.		u2 := u2 - t2.		u3 := u3 - t3.		t3 > 0] whileTrue: ["loop while t3 > 0"].	[u1 >= v and: [u2 >= u]] whileTrue: [		u1 := u1 - v.		u2 := u2 - u].	u3 = 1 ifFalse: [self error: 'no inverse'].	^ u - u2! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'nice 8/28/2010 21:21'!isProbablyPrime: p	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."	| iterations factor pMinusOne b m r a j z couldBePrime |	iterations := 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"	"quick elimination: check for p divisible by a small prime"	SmallPrimes ifNil: [  "generate list of small primes > 2"		SmallPrimes := Integer primesUpTo: 2000.		SmallPrimes := SmallPrimes copyFrom: 2 to: SmallPrimes size].	factor := SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].	factor ifNotNil: [^ p = factor].	pMinusOne := p - 1.	b := self logOfLargestPowerOfTwoDividing: pMinusOne.	m := pMinusOne bitShift: b negated.	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"	Transcript show: '      Prime test pass '.	r := Random new.	1 to: iterations do: [:i |		Transcript show: i printString; space.		a := (r next * 16rFFFFFF) truncated.		j := 0.		z := (a raisedTo: m modulo: p) normalize.		couldBePrime := z = 1.		[couldBePrime] whileFalse: [			z = 1 ifTrue: [Transcript show: 'failed!!'; cr. ^ false].  "not prime"			z = pMinusOne				ifTrue: [couldBePrime := true]				ifFalse: [					(j := j + 1) < b						ifTrue: [z := (z * z) \\ p]						ifFalse: [Transcript show: 'failed!!'; cr. ^ false]]]].  "not prime"	Transcript show: 'passed!!'; cr.	^ true  "passed all tests; probably prime"! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'nice 9/2/2010 21:48'!computeSignatureForMessageHash: hash privateKey: privateKey	"Answer the digital signature of the given message hash using the given private key. A signature is a pair of large integers. The private key is an array of four large integers: (p, q, g, x)."	| p q g x r s k tmp |	p := privateKey first.	q := privateKey second.	g := privateKey third.	x := privateKey fourth.	r := s := 0.	[r = 0 or: [s = 0]] whileTrue: [		k := self nextRandom160 \\ q.		r := (g raisedTo: k modulo: p) \\ q.		tmp := (hash + (x * r)) \\ q.		s := ((k reciprocalModulo: q) * tmp) \\ q].	^ Array with: r with: s! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'nice 9/2/2010 21:48'!verifySignature: aSignature ofMessageHash: hash publicKey: publicKey	"Answer true if the given signature is the authentic signature of the given message hash. That is, if the signature must have been computed using the private key set corresponding to the given public key. The public key is an array of four large integers: (p, q, g, y)."	| p q g y r s w u1 u2 v0 v |	p := publicKey first.	q := publicKey second.	g := publicKey third.	y := publicKey fourth.	r := aSignature first.	s := aSignature last.	((r > 0) and: [r < q]) ifFalse: [^ false].  "reject"	((s > 0) and: [s < q]) ifFalse: [^ false].  "reject"	w := s reciprocalModulo: q.	u1 := (hash * w) \\ q.	u2 := (r * w) \\ q.	v0 := (g raisedTo: u1 modulo: p) * (y raisedTo: u2 modulo: p).	v := ( v0 \\ p) \\ q.	^ v = r! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'nice 3/31/2011 01:29'!generateQandP	"Generate the two industrial-grade primes, q (160-bits) and p (512-bit) needed to build a key set. Answer the array (q, p, s), where s is the seed that from which q and p were created. This seed is normally discarded, but can be used to verify the key generation process if desired."	| pBits halfTwoToTheP chunkCount sAndq q twoQ n c w x p s |	pBits := 512.  "desired size of p in bits"	halfTwoToTheP := 2 raisedTo: (pBits - 1).	chunkCount := pBits // 160.	Transcript show: 'Searching for primes q and p...'; cr.	[		sAndq := self generateSandQ.		Transcript show: '  Found a candidate q.'; cr.		s := sAndq first.		q := sAndq last.		twoQ := q bitShift: 1.		n := 2.		c := 0.		[c < 4096] whileTrue: [			w := self generateRandomLength: pBits s: s n: n.			x := w + halfTwoToTheP.			p := (x - ( x \\ twoQ)) + 1.			p highBit = pBits ifTrue: [				Transcript show: '    Testing potential p ', (c + 1) printString, '...'; cr.				(self isProbablyPrime: p) ifTrue: [					Transcript show: '  Found p!!'; cr.					^ Array with: q with: p with: s]].			n := n + chunkCount + 1.			c := c + 1]] repeat! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'nice 4/11/2011 17:01'!generateSandQ	"Generate a 160-bit random seed s and an industrial grade prime q."	| hasher s sPlusOne u q |	hasher := SecureHashAlgorithm new.	[		s := self nextRandom160.		sPlusOne := s + 1.		sPlusOne highBit > 160 ifTrue: [sPlusOne := sPlusOne bitAnd: (1 bitShift: 160) - 1].		u := (hasher hashInteger: s) bitXor: (hasher hashInteger: sPlusOne).		q := u bitOr: ((1 bitShift: 159) bitOr: 1).		(self isProbablyPrime: q) ifTrue: [^ Array with: s with: q]] repeat! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 21:04'!logOfLargestPowerOfTwoDividing: aPositiveInteger	"Answer the base-2 log of the largest power of two that divides the given integer. For example, the largest power of two that divides 24 is 8, whose log base-2 is 3. Do this efficiently even when the given number is a large integer. Assume that the given integer is > 0."	"DigitalSignatureAlgorithm new logOfLargestPowerOfTwoDividing: (32 * 3)"	^aPositiveInteger lowBit - 1! !!DirectoryEntry methodsFor: 'access' stamp: 'bgf 9/9/2010 07:36'!fullName	"The fully-qualified name.	 Since this method falls into the equality test, make it safe when directory is nil."	^ directory 		ifNotNil: [ directory fullNameFor: self name ] 		ifNil: [ self name ]! !!DirectoryEntry methodsFor: 'access' stamp: 'cmm 1/25/2011 13:16'!size	"For API compatibility with byte objects (for streaming api)."	^ self fileSize! !!DirectoryEntry methodsFor: 'access' stamp: 'cmm 2/18/2011 15:54'!splitNameVersionExtension	" answer an array with the root name, version # and extension."	^ self directory splitNameVersionExtensionFor: self name! !!DirectoryEntry methodsFor: 'services' stamp: 'ar 9/5/2010 08:51'!services	"Answer the same collection of SimpleServiceEntry's accessed by the FileList."	^ FileServices itemsForFile: self fullName! !!DirectoryEntry methodsFor: 'testing' stamp: 'cmm 2/24/2011 19:17'!= aDirectoryEntry 	"Answer whether I am equivalent in all of my file-system attributes."	super = aDirectoryEntry ifTrue: [^ true].	self species = aDirectoryEntry species ifFalse: [^ false].	^ self containingDirectory = aDirectoryEntry containingDirectory		and: [self name = aDirectoryEntry name				and: [self modificationTime = aDirectoryEntry modificationTime						and: [self fileSize = aDirectoryEntry fileSize]]]! !!DirectoryEntry methodsFor: 'testing' stamp: 'cmm 2/21/2011 21:50'!exists	^ (self containingDirectory		entryAt: self name		ifAbsent: [ nil ]) notNil! !!DirectoryEntry methodsFor: 'testing' stamp: 'cmm 2/18/2011 16:04'!hash	"Hashing on directory + name should be sufficient."	^ (self containingDirectory hash hashMultiply + self name hash) hashMultiply! !!DirectoryEntryFile methodsFor: 'stream access' stamp: 'ul 7/16/2011 11:22'!contentsFrom: startPosition to: endPosition 	"Answer my contents from startPosition to endPosition."	^ FileStream 		detectFile: self readStream		do: 			[ : stream | 			stream				position: startPosition ;				next: endPosition - startPosition + 1 ]! !!DisplayScanner methodsFor: 'MVC-compatibility' stamp: 'nice 4/15/2011 21:55'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| leftInRun |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset := 0@0.	leftInRun := 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges := false.	foregroundColor := paragraphColor := aParagraph foregroundColor.	backgroundColor := aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt := nil]		ifFalse: [fillBlt := bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin := aParagraph rightMarginForDisplay.	lineY := aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			| string startIndex lastPos runLength stopCondition |			line := aParagraph lines at: lineIndex.			lastIndex := line first.               self setStopConditions. " causes an assignment to inst var.  alignment "			leftMargin := aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX := (runX := leftMargin).			line := aParagraph lines at: lineIndex.			lineHeight := line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex := line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun := text runLengthFor: line first].			destY := lineY + line baseline - font ascent.  "Should have happened in setFont"			runLength := leftInRun.			runStopIndex := lastIndex + (runLength - 1) min: line last.			leftInRun := leftInRun - (runStopIndex - lastIndex + 1).			spaceCount := 0.			string := text string.			self handleIndentation.			[				startIndex := lastIndex.				lastPos := destX@destY.				stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern].				"see setStopConditions for stopping conditions for displaying."				self perform: stopCondition			] whileFalse.			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY := lineY + lineHeight]]! !!DisplayScanner methodsFor: 'scanning' stamp: 'mtf 12/30/2010 23:37'!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	(anchoredMorph isMorph or: [anchoredMorph isPrimitiveCostume]) ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY := lineY.		runX := destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect	].	^ true! !!DisplayScanner commentStamp: '<historical>' prior: 0!My instances are used to scan text and display it on the screen or in a hidden form.!!DisplayScreen methodsFor: 'private' stamp: 'jrd 5/23/2009 00:53'!findAnyDisplayDepth	"Return any display depth that is supported on this system."	^self findAnyDisplayDepthIfNone:[		"Ugh .... now this is a biggie - a system that does not support		any of the Squeak display depths at all."		Smalltalk			logSqueakError:'Fatal error: This system has no support for any display depth at all.'			inContext: thisContext .		Smalltalk quitPrimitive. "There is no way to continue from here"	].! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 12/8/2002 02:20'!transformedBy: aTransform	^self composedWithGlobal: aTransform! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 12/8/2002 02:20'!invertPoint: aPoint	^self globalPointToLocal: aPoint! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 12/8/2002 02:20'!invertRect: aRectangle	^self globalBoundsToLocal: aRectangle! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 12/8/2002 02:20'!transformRect: aRectangle	^self localBoundsToGlobal: aRectangle! !!DoCommandOnceMorph methodsFor: 'stepping and presenter' stamp: 'ul 8/2/2011 19:59'!step	| goForIt |	actionBlock ifNil: [^self stopStepping].	goForIt := actionBlock.	actionBlock := nil.	goForIt		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: innerArea].		"in case a save/load progress display needs a home"! !!DockingBarMorph methodsFor: 'initialize-release' stamp: 'cmm 8/20/2011 14:21'!initialize	"initialize the receiver"	super initialize.	selectedItem := nil.	activeSubMenu := nil.	fillsOwner := true.	avoidVisibleBordersAtEdge := true.	autoGradient := Preferences gradientMenu.	self 		setDefaultParameters ; 		beFloating ; 		beSticky ;		layoutInset: 0 ;		dropEnabled: true.	Project current world activeHand addKeyboardListener: self! !!DockingBarMorph methodsFor: 'initialize-release' stamp: 'cmm 5/3/2011 19:47'!release	activeSubMenu := selectedItem := oldKeyboardFocus := oldMouseFocus := nil! !!DockingBarMorph methodsFor: 'initialize-release' stamp: 'nice 1/1/2010 21:47'!setDefaultParameters	"private - set the default parameter using Preferences as the inspiration source"	| colorFromMenu worldColor menuColor menuBorderColor |	colorFromMenu := Preferences menuColorFromWorld				and: [Display depth > 4				and: [(worldColor := self currentWorld color) isColor]].	""	menuColor := colorFromMenu				ifTrue: [worldColor luminance > 0.7						ifTrue: [worldColor mixed: 0.85 with: Color black]						ifFalse: [worldColor mixed: 0.4 with: Color white]]				ifFalse: [Preferences menuColor].	""	menuBorderColor := Preferences menuAppearance3d				ifTrue: [#raised]				ifFalse: [colorFromMenu						ifTrue: [worldColor muchDarker]						ifFalse: [Preferences menuBorderColor]].	""	self		setColor: menuColor		borderWidth: Preferences menuBorderWidth		borderColor: menuBorderColor! !!DomainError commentStamp: 'nice 4/20/2011 22:13' prior: 0!A DomainError is an error occuring when a mathematical function is used outside its domain of validity.!!DosFileDirectory class methodsFor: '*network-uri' stamp: 'fbs 12/16/2010 22:44'!privateFullPathForURI: aURI	| path |	path := aURI path unescapePercents.	"Check for drive notation (a: etc)"	path size > 1		ifTrue: [			((path at: 3) = $:)				ifTrue: [path := path copyFrom: 2 to: path size]				ifFalse: [					"All other cases should be network path names (\\xxx\sdsd etc)"					path := '/' , path]].	^(path copyReplaceAll: '/' with: self slash) unescapePercents! !!DummySoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 20:48'!randomBitsFromSoundInput: bitCount	"I'm not sure what the right thing to do here is."	self error: 'Can not provide random data.'! !!Duration methodsFor: 'private' stamp: 'dtl 8/29/2010 11:31'!seconds: secondCount nanoSeconds: nanoCount 	"Private - only used by Duration class"	seconds := secondCount.	nanos := nanoCount rounded.	"normalize if signs do not match"	[ nanos < 0 and: [ seconds > 0 ] ]		whileTrue: [ seconds := seconds - 1.			nanos := nanos + NanosInSecond ].	[ seconds < 0 and: [ nanos > 0 ] ]		whileTrue: [ seconds := seconds + 1.			nanos := nanos - NanosInSecond ]! !!Duration class methodsFor: 'ansi protocol' stamp: 'cmm 7/16/2011 15:13'!zero	"Answer the canonicalized instance of Duration zero."	^ Zero! !!Duration class methodsFor: 'squeak protocol' stamp: 'ul 4/28/2010 09:44'!milliSeconds: milliCount 		^self		seconds: (milliCount quo: 1000)		nanoSeconds: (milliCount rem: 1000) * NanosInMillisecond! !!Duration class methodsFor: 'squeak protocol' stamp: 'cmm 7/17/2011 14:59'!oneDay	"Answer the canonicalized Duration representing length of 1 day.  Used by Dates."	^ OneDay! !!Duration class methodsFor: 'initialize-release' stamp: 'cmm 7/17/2011 14:58'!initialize	ChronologyConstants classPool		at: #Zero		put:			(self basicNew				seconds: 0				nanoSeconds: 0) ;		at: #OneDay		put: 1 day! !!DurationTest methodsFor: 'testing' stamp: 'ul 4/28/2010 09:57'!testMilliSeconds	#(		"argument (milliseconds)	seconds	nanoseconds"		(5							0			5000000)		(1005						1			5000000)		(-5							0			-5000000)		(-1005						-1			-5000000)		(1234567					1234		567000000)		(-1234567					-1234		-567000000)			) do: [ :each |		| duration |		duration := Duration milliSeconds: each first.		self assert: duration asSeconds = each second.		self assert: duration nanoSeconds = each third ]! !!DurationTest methodsFor: 'testing' stamp: 'dtl 8/29/2010 11:25'!testNormalizeNanoSeconds	"Subtraction of two DateAndTime values may result in a request to	create a Duration with negative nanoseconds and positive seconds.	The resulting Duration should be normalized, otherwise its printString	will be invalid."	| d t1 t2 |	t1 := '2004-01-07T11:55:01+00:00' asDateAndTime. 	t2 := '2004-01-07T11:55:00.9+00:00' asDateAndTime.	d := t1 - t2. "100 millisecond difference"	self assert: d nanoSeconds > 0.	self assert: d seconds = 0.	self assert: d nanoSeconds = 100000000.	self assert: d asString = '0:00:00:00.1'.	"Verify that other combinations produces reasonable printString values"	self assert: (Duration seconds: 1 nanoSeconds: 100000000) printString = '0:00:00:01.1'.	self assert: (Duration seconds: -1 nanoSeconds: -100000000) printString = '-0:00:00:01.1'.	self assert: (Duration seconds: 1 nanoSeconds: -100000000) printString = '0:00:00:00.9'.	self assert: (Duration seconds: -1 nanoSeconds: 100000000) printString = '-0:00:00:00.9'! !!DynamicVariable commentStamp: 'mvl 3/13/2007 13:55' prior: 0!My subclasses are dynamic variables: each subclass represents a variablewhose value persists inside the block passed to #value:during:. There isno way to change the value inside such a block, but it is possible totemporarirly rebind it in a nested manner.!!DynamicVariable class methodsFor: 'accessing' stamp: 'ul 8/16/2011 11:23'!value: anObject during: aBlock	| p oldValue |	p := Processor activeProcess.	oldValue := p environmentAt: self ifAbsent: [self default].	^[		p environmentAt: self put: anObject.		aBlock value ] 			ensure: [ p environmentAt: self put: oldValue ].! !!EFontBDFFontReaderForRanges methodsFor: 'as yet unclassified' stamp: 'nice 3/31/2011 01:10'!readCharactersInRanges: ranges storeInto: chars	| array form code rangeStream currentRange |	rangeStream := ReadStream on: ranges.	currentRange := rangeStream next.	[		array := self readOneCharacter.		array second ifNil: [^ self].		code := array at: 2.		code > currentRange last ifTrue: [			[rangeStream atEnd not and: [currentRange := rangeStream next. currentRange last < code]] whileTrue.			rangeStream atEnd ifTrue: [^ self].		].		(code between: currentRange first and: currentRange last) ifTrue: [			form := array at: 1.			form ifNotNil: [				chars add: array.			].		].	] repeat! !!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'nice 8/19/2010 14:29'!updateIPAddressField: newAddresses		targetIPAddresses := (		newAddresses copyWithout: NetNameResolver localAddressString	) asSet asArray sort.	(fields at: #ipAddress) contents: targetIPAddresses size printString,' people'.! !!EToyPeerToPeer methodsFor: 'receiving' stamp: 'nice 4/11/2011 16:45'!doAwaitData	[		socket := connectionQueue getConnectionOrNilLenient.		socket ifNil: [			(Delay forMilliseconds: 50) wait		] ifNotNil: [			self class new receiveDataOn: socket for: communicatorMorph		]	] repeat! !!EToySystem class methodsFor: 'development support' stamp: 'ul 6/17/2011 12:20'!cleanupsForRelease	"Miscellaneous space cleanups to do before a release."	"EToySystem cleanupsForRelease"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph initialize.	"forces Prototype to let go of extra things it might hold"	Smalltalk globals removeKey: #AA ifAbsent: [].	Smalltalk globals removeKey: #BB ifAbsent: [].	Smalltalk globals removeKey: #CC ifAbsent: [].	Smalltalk globals removeKey: #DD ifAbsent: [].	Smalltalk globals removeKey: #Temp ifAbsent: [].	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk removeEmptyMessageCategories.	Symbol rehash.! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 11:39'!addNewChildAfter: anotherOrNilOrZero	| where newNode |	anotherOrNilOrZero = 0 ifTrue: [		newNode := EToyTextNode newNode.		children := {newNode} asOrderedCollection,children.		^newNode	].	where := children indexOf: anotherOrNilOrZero ifAbsent: [children size].	children add: (newNode := EToyTextNode newNode) afterIndex: where.	^newNode! !!EToyVocabulary methodsFor: 'category list' stamp: 'nk 8/29/2004 17:17'!categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass	"Answer the category list for the given object, considering only code implemented in aClass and lower"	^ (anObject isPlayerLike)		ifTrue:			[self flag: #deferred.  "The bit commented out on next line is desirable but not yet workable, because it delivers categories that are not relevant to the costume in question"			"#(scripts #'instance variables'), (super categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass)]"			self translatedWordingsFor: ((mostGenericClass == aClass)				ifFalse:					[anObject categoriesForVocabulary: self]				ifTrue:					[{ScriptingSystem nameForScriptsCategory.  ScriptingSystem nameForInstanceVariablesCategory}])]		ifFalse:			[super categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass]! !!EUCTextConverter methodsFor: 'conversion' stamp: 'ul 5/26/2010 04:00'!nextFromStream: aStream	| character1 character2 offset value1 value2 nonUnicodeChar |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 := aStream basicNext ifNil: [^ nil].	character1 asciiValue <= 127 ifTrue: [^ character1].	character2 := aStream basicNext ifNil: [^ nil].	offset := 16rA1.	value1 := character1 asciiValue - offset.	value2 := character2 asciiValue - offset.	(value1 < 0 or: [value1 > 93]) ifTrue: [^ nil].	(value2 < 0 or: [value2 > 93]) ifTrue: [^ nil].	nonUnicodeChar := Character leadingChar: self leadingChar code: value1 * 94 + value2.	^ Character leadingChar: self languageEnvironment leadingChar code: nonUnicodeChar asUnicode.! !!EUCTextConverter methodsFor: 'conversion' stamp: 'ul 5/22/2011 19:39'!nextPut: aCharacter toStream: aStream 	| charCode leadingChar nonUnicodeChar |	aStream isBinary ifTrue: [^aCharacter storeBinaryOn: aStream].	charCode := aCharacter charCode.	leadingChar := aCharacter leadingChar.	(leadingChar = 0 and: [ charCode < 256 ]) ifTrue: [		(latin1Encodings at: charCode + 1)			ifNil: [ aStream basicNextPut: aCharacter ]			ifNotNil: [ :encodedString | aStream basicNextPutAll: encodedString ].		^aCharacter ].	aCharacter isTraditionalDomestic		ifFalse: [ nonUnicodeChar := self nonUnicodeClass charFromUnicode: charCode ]		ifTrue: [ nonUnicodeChar := Character value: charCode ].	nonUnicodeChar ifNotNil: [		charCode := nonUnicodeChar charCode.		aStream			basicNextPut: (Character value: charCode // 94 + 161);			basicNextPut: (Character value: charCode \\ 94 + 161) ].	^aCharacter! !!Editor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 20:08'!backWord: aKeyboardEvent 	^ self class destructiveBackWord 		ifTrue: [ self destructiveBackWord: aKeyboardEvent ]		ifFalse: [ self nonDestructiveBackWord: aKeyboardEvent ]! !!Editor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 20:22'!backspace: aKeyboardEvent 	"Backspace over the last character."	| startIndex |	aKeyboardEvent shiftPressed ifTrue: [^ self backWord: aKeyboardEvent].	startIndex := self markIndex +				(self hasCaret ifTrue: [0] ifFalse: [1]).	startIndex := 1 max: startIndex - 1.	self backTo: startIndex.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 3/16/2011 22:10'!clearSelection	self selectFrom: 1 to: 0! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/7/2010 17:01'!cr: aKeyboardEvent	"Append a carriage return character to the stream of characters."	self addString: Character cr asString.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/7/2010 17:03'!crWithIndent: aKeyboardEvent	"Only for SmalltalkEditor. Regular editors don't indent"	^ self cr: aKeyboardEvent! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:37'!crlf: aKeyboardEvent	"Append a line feed character to the stream of characters."	self addString: String crlf.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:37'!cursorTopHome: aKeyboardEvent	"Put cursor at beginning of text -- invoked from cmd-H shortcut, useful for keyboards that have no home key."	self selectAt: 1.	^ true! !!Editor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 20:09'!destructiveBackWord: aKeyboardEvent 	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else if there is typeahead, delete it.	 Else, delete the word before the caret."	| startIndex |	self hasCaret		ifTrue: "a caret, delete at least one character"			[startIndex := 1 max: self markIndex - 1.			[startIndex > 1 and:				[(self string at: startIndex - 1) tokenish]]				whileTrue:					[startIndex := startIndex - 1]]		ifFalse: "a non-caret, just delete it"			[startIndex := self markIndex].	self backTo: startIndex.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/7/2010 17:37'!enter: aKeyboardEvent	"Enter / return key was pressed"	"Process the various Enter / Return keystrokes"		morph acceptOnCR ifTrue: [		self closeTypeIn.		^ true].	aKeyboardEvent controlKeyPressed ifTrue: [		^ self cr: aKeyboardEvent ].	aKeyboardEvent shiftPressed ifTrue: [		^ self lf: aKeyboardEvent ].	aKeyboardEvent commandAltKeyPressed ifTrue: [		^ self crlf: aKeyboardEvent ].	^ self crWithIndent: aKeyboardEvent! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:38'!lf: aKeyboardEvent 	"Append a line feed character to the stream of characters."	self addString: Character lf asString.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 22:35'!nonDestructiveBackWord: aKeyboardEvent 	"Select the prior word."	| indices newPosition |	self closeTypeIn.	indices := self 		setIndices: true		forward: false.	newPosition := 1 max: (indices at: #moving) - 1.	newPosition :=  self previousWord: newPosition.	self selectMark: (indices at: #fixed) point: newPosition - 1.	^ true! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:38'!normalCharacter: aKeyboardEvent 	"A nonspecial character is to be added to the stream of characters."	self addString: aKeyboardEvent keyCharacter asString.	^false! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:38'!selectAll: aKeyboardEvent 	"select everything, invoked by cmd-a.  1/17/96 sw"	self insertAndCloseTypeIn.	self selectFrom: 1 to: self string size.	^ true! !!Editor methodsFor: 'menu messages' stamp: 'jmv 4/27/2011 07:50'!wordSelectAndEmptyCheck: returnBlock	"Ensure selecting the entire current word; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectWord.  "Select exactly a whole word"	self hasSelection ifFalse: [morph flash.  ^ returnBlock value]! !!Editor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:37'!copySelection: aKeyboardEvent	"Copy the current text selection."	self copySelection.	^true! !!Editor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:38'!cut: aKeyboardEvent 	"Cut out the current text selection."	self cut.	^true! !!Editor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:38'!noop: aKeyboardEvent 	"Unimplemented keyboard command; just ignore it."	^ true! !!Editor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:38'!paste: aKeyboardEvent 	"Replace the current text selection by the text in the shared buffer."	self insertAndCloseTypeIn.	self paste.	^true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:40'!cursorDown: aKeyboardEvent	"Private - Move cursor from position in current line to same position in	next line. If next line too short, put at end. If shift key down,	select."	self insertAndCloseTypeIn.	self 		moveCursor: [:position | self				sameColumn: position				newLine: [:line | line + 1]				forward: true]		forward: true		event: aKeyboardEvent		specialBlock: [:dummy | dummy].	^true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:40'!cursorLeft: aKeyboardEvent	"Private - Move cursor left one character if nothing selected, otherwise 	move cursor to beginning of selection. If the shift key is down, start 	selecting or extending current selection. Don't allow cursor past 	beginning of text"	self insertAndCloseTypeIn.	self		moveCursor:[:position | position - 1 max: 1]		forward: false		event: aKeyboardEvent		specialBlock:[:position | self previousWord: position].	^ true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:40'!cursorPageDown: aKeyboardEvent	self insertAndCloseTypeIn.	self 		moveCursor: [:position |			self				sameColumn: position				newLine: [:lineNo | lineNo + self pageHeight]				forward: true]		forward: true		event: aKeyboardEvent		specialBlock:[:dummy | dummy].	^true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:40'!cursorPageUp: aKeyboardEvent 	self insertAndCloseTypeIn.	self 		moveCursor: [:position |			self				sameColumn: position				newLine: [:lineNo | lineNo - self pageHeight]				forward: false]		forward: false		event: aKeyboardEvent		specialBlock:[:dummy | dummy].	^true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:40'!cursorRight: aKeyboardEvent 	"Private - Move cursor right one character if nothing selected, 	otherwise move cursor to end of selection. If the shift key is down, 	start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	self insertAndCloseTypeIn.	self		moveCursor: [:position | position + 1]		forward: true		event: aKeyboardEvent		specialBlock:[:position | self nextWord: position].	^ true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:40'!cursorUp: aKeyboardEvent 	"Private - Move cursor from position in current line to same position in	prior line. If prior line too short, put at end"	self insertAndCloseTypeIn.	self		moveCursor: [:position | self				sameColumn: position				newLine:[:line | line - 1]				forward: false]		forward: false		event: aKeyboardEvent		specialBlock:[:dummy | dummy].	^true! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/2/2009 12:38'!selectWord: aKeyboardEvent	self insertAndCloseTypeIn.	self selectWord.	^ true! !!Editor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:46'!beginningOfLine: position	"Redefined in subclasses using Paragraph support"	^ self beginningOfParagraph: position! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:33'!beginningOfNextParagraph: position	| s |	s := self string.	^ (s		indexOf: Character cr		startingAt: position		ifAbsent: [ s size ]) + 1! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:37'!beginningOfParagraph: position	^ (self string		lastIndexOf: Character cr		startingAt: position		ifAbsent: [ 0 ]) + 1.! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:39'!beginningOfText	^1! !!Editor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:46'!endOfLine: position	"Redefined in subclasses using Paragraph support"	^self endOfParagraph: position! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:09'!endOfParagraph: position	| s |	s := self string.	^ s		indexOf: Character cr		startingAt: position		ifAbsent: [ s size + 1 ].! !!Editor methodsFor: 'private' stamp: 'jmv 9/17/2010 13:25'!endOfText	^self string size + 1! !!Editor methodsFor: 'private' stamp: 'nice 8/3/2011 20:39'!moveCursor: directionBlock forward: forward event: aKeyboardEvent specialBlock: specialBlock 	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| indices newPosition shouldSelect |	shouldSelect := aKeyboardEvent shiftPressed.	indices := self setIndices: shouldSelect forward: forward.	newPosition := directionBlock value: (indices at: #moving).	(aKeyboardEvent commandKeyPressed or: [aKeyboardEvent controlKeyPressed])		ifTrue: [newPosition := specialBlock value: newPosition].	shouldSelect		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!Editor methodsFor: 'private' stamp: 'nice 8/3/2011 22:28'!moveCursor: directionBlock forward: forward select: shouldSelect	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| indices newPosition |	indices := self setIndices: shouldSelect forward: forward.	newPosition := directionBlock value: (indices at: #moving).	shouldSelect		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!Editor methodsFor: 'new selection' stamp: 'jmv 5/27/2011 15:25'!selectInvisiblyFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	self markIndex: start pointIndex: stop + 1! !!Editor methodsFor: 'new selection' stamp: 'jmv 5/27/2011 15:25'!selectInvisiblyMark: mark point: point	"Select the designated characters, inclusive.  Make no visual changes."	self markIndex: mark pointIndex: point + 1! !!Editor methodsFor: 'new selection' stamp: 'jmv 5/30/2011 10:01'!selectMark: mark point: point	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse: [		self selectInvisiblyMark: mark point: point ]! !!Editor methodsFor: 'new selection' stamp: 'nice 8/4/2011 00:56'!selectWord	"Select delimited text or word--the result of double-clicking."	^self		selectWordLeftDelimiters: '([{<|''"'		rightDelimiters: ')]}>|''"'! !!Editor methodsFor: 'new selection' stamp: 'nice 9/2/2011 20:20'!selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level	string here hereChar start stop |	string := self string.	string size < 2 ifTrue: [^self].	here := self pointIndex.	"Select the whole text when clicking before first or after last character"	(here > string size or: [here < 2]) ifTrue: [^self selectFrom: 1 to: string size].	openDelimiter := string at: here - 1.	match := leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: [			"delimiter is on left -- match to the right"			start := here.			direction := 1.			here := here - 1.			closeDelimiter := rightDelimiters at: match]		ifFalse: [			openDelimiter := string at: here.			match := rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: [					"delimiter is on right -- match to the left"					stop := here - 1.					direction := -1.					closeDelimiter := leftDelimiters at: match]				ifFalse: [					"no delimiters -- select a token"					direction := -1]].	level := 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: [			hereChar := string at: (here := here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: [									start := 1.									"go right if hit string start"									direction := 1]]						ifFalse: [							direction < 0								ifTrue: [									start := here + 1.									"go right if hit non-token"									direction := 1]								ifFalse: [level := 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level := level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level := level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here := here + direction].	^direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!Editor commentStamp: '<historical>' prior: 0!New text editors.TextEditor provides most of the functionality that used to be in TextMorphEditor.SmalltalkEditor is has Smalltalk code specific features.SimpleEditor provides basic functionality for single line text editing. It does not handle fonts and styles, aligning and Smalltalk utilities. It handles one single line.CellStyleEditor allows entering alphabetic characters using only number keys, like many cell phones do.!!Editor class methodsFor: 'class initialization' stamp: 'jmv 9/7/2010 19:37'!initialize	"	Editor initialize	"	self initializeKeystrokeActions.	self allSubclassesDo: [ :c | c initialize ]! !!Editor class methodsFor: 'class initialization' stamp: 'jmv 9/7/2010 23:49'!initializeKeystrokeActions	"Initialize the table for regular (i.e. non-command) keystroke dispatch"	"	self initializeKeystrokeActions	"	| actions |	actions := Array new: 256 withAll: #normalCharacter:.	0 to: 31 do: [ :i | actions at: i+1 put: #noop: ].	actions at: 1 + 1 put: #cursorHome:.				"home key"	actions at: 3 + 1 put: #enter:.						"enter / return key"	actions at: 4 + 1 put: #cursorEnd:.				"end key"	actions at: 5 + 1 put: #noop:.						"insert key"	actions at: 8 + 1 put: #backspace:.				"macDelete winBackspace key"	actions at: 9 + 1 put: #normalCharacter:.		"tab"	actions at: 11 + 1 put: #cursorPageUp:.			"page up key"	actions at: 12 + 1 put: #cursorPageDown:.		"page down key"	actions at: 13 + 1 put: #enter:.					"enter / return key"	actions at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"	actions at: 28 + 1 put: #cursorLeft:.				"left arrow key"	actions at: 29 + 1 put: #cursorRight:.				"right arrow key"	actions at: 30 + 1 put: #cursorUp:.				"up arrow key"	actions at: 31 + 1 put: #cursorDown:.			"down arrow key"	actions at: 127 + 1 put: #forwardDelete:.		"winDelete key"	KeystrokeActions := actions! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/19/2010 20:58'!blinkingCursor	<preference: 'Blinking Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor will blink.'		type: #Boolean>	^ BlinkingCursor ifNil: [ true ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 15:57'!blinkingCursor: aBoolean	BlinkingCursor := aBoolean! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor	<preference: 'Dumbbell-shaped Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor assumes the shape of a dumbbell, otherwise a vertical bar..'		type: #Boolean>	^ DumbbellCursor ifNil: [ false ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor: aBoolean	DumbbellCursor := aBoolean! !!ElementCategory methodsFor: 'copying' stamp: 'nice 10/1/2010 23:40'!postCopy	"Copy own instance variables."	super postCopy.	self copyFrom: self! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'nice 5/6/2011 23:32'!initialize"	self initialize"	self allSubclassesDo: [:each | each initialize].	EncodedCharSets := Array new: 256.	EncodedCharSets at: 0+1 put: Unicode "Latin1Environment".	EncodedCharSets at: 1+1 put: JISX0208.	EncodedCharSets at: 2+1 put: GB2312.	EncodedCharSets at: 3+1 put: KSX1001.	EncodedCharSets at: 4+1 put: JISX0208.	EncodedCharSets at: 5+1 put: JapaneseEnvironment.	EncodedCharSets at: 6+1 put: SimplifiedChineseEnvironment.	EncodedCharSets at: 7+1 put: KoreanEnvironment.	EncodedCharSets at: 8+1 put: GB2312.	"EncodedCharSets at: 9+1 put: UnicodeTraditionalChinese."	"EncodedCharSets at: 10+1 put: UnicodeVietnamese."	EncodedCharSets at: 12+1 put: KSX1001.	"EncodedCharSets at: 13+1 put: GreekEnvironment."	"EncodedCharSets at: 14+1 put: Latin2Environment."	"EncodedCharSets at: 15+1 put: RussianEnvironment."	EncodedCharSets at: 256 put: Unicode.! !!Encoder methodsFor: 'encoding' stamp: 'eem 5/16/2010 17:33'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable					at: name					ifAbsent: 						[(self lookupInPools: name 							ifFound: [:assoc | varNode := self global: assoc name: name])							ifTrue: [varNode]							ifFalse: [^action value]].	range ifNotNil:		[name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]].	(varNode isTemp and: [varNode scope < 0]) ifTrue:		[^OutOfScopeNotification signal			ifTrue: [action value]			ifFalse: [self notify: 'out of scope']].	^varNode! !!Encoder methodsFor: 'encoding' stamp: 'eem 8/15/2010 08:29'!lookupVariable: name ifAbsent: aBlock	"Answer the binding of name in the scope table or aBlock's vaue if none.	 Do not bind and do not lookup in pools.  Used for correction, explanation etc"	^scopeTable at: name ifAbsent: aBlock! !!Encoder methodsFor: 'encoding' stamp: 'nice 3/30/2011 23:26'!noteOptimizedSelector: aSymbol	"Register a selector as being optimized.	These optimized selectors will later be registered into the literals so that tools can easily browse senders."	optimizedSelectors add: aSymbol! !!Encoder methodsFor: 'encoding' stamp: 'ul 10/24/2010 06:34'!sharableLitIndex: literal	"Special access prevents multiple entries for post-allocated super send special selectors"	1 to: literalStream position do:		[:index|		(literal literalEqual: (literalStream originalContents at: index)) ifTrue:			[^index - 1]].	^self litIndex: literal! !!Encoder methodsFor: 'initialize-release' stamp: 'nice 3/30/2011 23:04'!initScopeAndLiteralTables	scopeTable := StdVariables copy.	litSet := StdLiterals copy.	"comments can be left hanging on nodes from previous compilations.	 probably better than this hack fix is to create the nodes afresh on each compilation."	scopeTable do:		[:varNode| varNode comment: nil].	litSet do:		[:varNode| varNode comment: nil].	selectorSet := StdSelectors copy.	litIndSet := Dictionary new: 16.	literalStream := WriteStream on: (Array new: 32).	addedSelectorAndMethodClassLiterals := false.	optimizedSelectors := Set new! !!Encoder methodsFor: 'initialize-release' stamp: 'nice 11/20/2011 21:47'!temps: tempVars literals: lits class: cl 	"Initialize this encoder for decompilation."	supered := false.	class := cl.	nTemps := tempVars size.	tempVars do: [:node | scopeTable at: node name put: node].	literalStream := WriteStream on: (Array new: lits size).	literalStream nextPutAll: lits.	sourceRanges := Dictionary new: 32.	globalSourceRanges := OrderedCollection new: 32.! !!Encoder methodsFor: 'results' stamp: 'nice 3/31/2011 00:35'!allLiterals	addedSelectorAndMethodClassLiterals ifFalse:		[addedSelectorAndMethodClassLiterals := true.		"Put the optimized selectors in literals so as to browse senders more easily"		optimizedSelectors := optimizedSelectors reject: [:e| literalStream originalContents hasLiteral: e].		optimizedSelectors isEmpty ifFalse: [			"Use one entry per literal if enough room, else make anArray"			literalStream position + optimizedSelectors size + 2 > 255				ifTrue: [self litIndex: optimizedSelectors asArray]				ifFalse: [optimizedSelectors do: [:e | self litIndex: e]]].		"Add a slot for selector or MethodProperties"		self litIndex: nil.		self litIndex: self associationForClass].	^literalStream contents! !!Encoder methodsFor: 'results' stamp: 'eem 8/13/2010 16:51'!undeclaredTemps 	^(scopeTable select: [:var | var isVariableNode and: [var isUndeclared]]) values! !!Encoder methodsFor: 'temps' stamp: 'eem 8/14/2010 19:35'!newUndeclaredTemp: name	^UndeclaredVariableNode new name: name! !!Encoder methodsFor: 'private' stamp: 'eem 8/13/2010 16:06'!bindUndeclaredTemp: name	^scopeTable at: name put: (self newUndeclaredTemp: name)! !!Encoder methodsFor: 'private' stamp: 'Lukas Renggli 11/2/2009 00:29'!name: name key: key class: leafNodeClass type: type set: dict 	^dict at: key		ifAbsentPut: 			[leafNodeClass new 				name: name				key: key				index: nil				type: type]! !!Encoder commentStamp: '<historical>' prior: 0!I encode names and literals into tree nodes with byte codes for the compiler. Byte codes for literals are not assigned until the tree-sizing pass of the compiler, because only then is it known which literals are actually needed. I also keep track of sourceCode ranges during parsing and code generation so I can provide an inverse map for the debugger.!!EtoysPresenter methodsFor: 'playerList' stamp: 'ul 11/15/2010 11:39'!browseAllScriptsTextually	"Open a method-list browser on all the scripts in the project"	| aList aMethodList |	(aList := self uniclassesAndCounts) size = 0 ifTrue: [^ self inform: 'there are no scripted players'].	aMethodList := OrderedCollection new.	aList do:		[:aPair | aPair first addMethodReferencesTo: aMethodList].	aMethodList size > 0 ifFalse: [^ self inform: 'there are no scripts in this project!!'].		SystemNavigation new 		browseMessageList: aMethodList 		name: 'All scripts in this project' 		autoSelect: nil"ActiveWorld presenter browseAllScriptsTextually"! !!EtoysPresenter methodsFor: 'playerList' stamp: 'nice 5/8/2011 10:22'!reinvigorateAllScriptsTool: anAllScriptsTool 	"Rebuild the contents of an All Scripts tool"	| showingOnlyActiveScripts candidateList firstTwo oldList allExtantPlayers newList morphList |	showingOnlyActiveScripts := anAllScriptsTool showingOnlyActiveScripts.	self flushPlayerListCache.	"needed? Probably to pick up on programmatical script-status control only"	firstTwo := {anAllScriptsTool submorphs first.  anAllScriptsTool submorphs second}.	oldList := (anAllScriptsTool submorphs copyFrom: 3 to: anAllScriptsTool submorphs size) collect:		[:aRow |			(aRow findA: UpdatingSimpleButtonMorph) target].	allExtantPlayers := self allExtantPlayers.	anAllScriptsTool showingAllInstances "take all instances of all classes"		ifTrue:			[candidateList := allExtantPlayers]  		ifFalse:  "include only one exemplar per uniclass.  Try to get one that has some qualifying scripts"			[candidateList := Set new.			allExtantPlayers do:				[:aPlayer |					(candidateList noneSatisfy: [:plyr | plyr isMemberOf: aPlayer class]) ifTrue:						[aPlayer instantiatedUserScriptsDo: [:aScriptInstantiation |							(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) 								ifTrue:									[candidateList add: aPlayer]]]]].	newList := OrderedCollection new.	candidateList do:		[:aPlayer | aPlayer instantiatedUserScriptsDo:			[:aScriptInstantiation |				(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) ifTrue:					[newList add: aScriptInstantiation]]].	oldList asSet = newList asSet		ifFalse:			[anAllScriptsTool removeAllMorphs; addAllMorphs: firstTwo.			morphList := newList collect:				[:aScriptInstantiation |  aScriptInstantiation statusControlRowIn: anAllScriptsTool].			anAllScriptsTool addAllMorphs: morphList.			newList do:				[:aScriptInstantiation | aScriptInstantiation updateAllStatusMorphs]]! !!EtoysPresenter methodsFor: 'intialize' stamp: 'nice 8/19/2010 16:39'!allExtantPlayers	"The initial intent here was to produce a list of Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  whether it is the submorph tree or perhaps off on unseen bookPages.  We have for the moment moved away from that initial intent, and in the current version we only deliver up players associated with the submorph tree only.  <-- this note dates from 4/21/99Call #flushPlayerListCache; to force recomputation."	| fullList |	playerList ifNotNil:		[^ playerList].	fullList := associatedMorph allMorphs select: 		[:m | m player ~~ nil] thenCollect: [:m | m player].	fullList copy do:		[:aPlayer |			aPlayer class scripts do:				[:aScript |  aScript isTextuallyCoded ifFalse:					[aScript currentScriptEditor ifNotNil: [:ed |						| objectsReferredToByTiles |						objectsReferredToByTiles := ed allMorphs							select:								[:aMorph | (aMorph isKindOf: TileMorph) and: [aMorph type == #objRef]]							thenCollect:								[:aMorph | aMorph actualObject].						fullList addAll: objectsReferredToByTiles]]]].	^ playerList := fullList asSet asArray sort:			[:a :b | a externalName < b externalName]! !!EventManager methodsFor: 'accessing' stamp: 'nice 9/21/2010 10:23'!updateableActionMap	^actionMap ifNil:		[actionMap := self createActionMap]! !!EventManager methodsFor: 'copying' stamp: 'nice 10/2/2010 00:09'!postCopy	super postCopy.	self release! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:23'!readFrom: aStream	"Private"	| header |	header := aStream nextLine.	(header = 'Event Tape v1 BINARY') ifTrue:[^aStream fileInObjectAndCode].	(header = 'Event Tape v1 ASCII') ifTrue:[^self readFromV1: aStream].	"V0 had no header so guess"	aStream reset.	header first isDigit ifFalse:[^self convertV0Tape: (aStream fileInObjectAndCode)].	^self convertV0Tape: (self readFromV0: aStream).! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:23'!readFromV0: aStream	^Array streamContents:[:tStream | | evt line t lineStream |		[aStream atEnd] whileFalse:			[line := aStream nextLine.			line isEmpty "Some MW tapes have an empty record at the end"				ifFalse: [lineStream := ReadStream on: line.						t := Integer readFrom: lineStream.						[lineStream peek isLetter] whileFalse: [lineStream next].						evt := MorphicEvent readFromObsolete: lineStream.						tStream nextPut: t -> evt]]].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:24'!readFromV1: aStream	^Array streamContents:[:tStream |		[aStream atEnd] whileFalse:[			tStream nextPut: (MorphicEvent readFromString: aStream nextLine)]]! !!EventSensor methodsFor: 'private' stamp: 'nice 3/31/2011 01:12'!eventTickler	"Poll infrequently to make sure that the UI process is not been stuck. 	If it has been stuck, then spin the event loop so that I can detect the 	interrupt key."	| delay |	delay := Delay forMilliseconds: self class eventPollPeriod.	self lastEventPoll.	"ensure not nil."	[| delta | 	[ delay wait.	delta := Time millisecondClockValue - lastEventPoll.	(delta < 0			or: [delta > self class eventPollPeriod])		ifTrue:			["force check on rollover"			self fetchMoreEvents]]		on: Error do: [:ex | ]] repeat.! !!EventSensor methodsFor: 'private-I/O' stamp: 'ael 7/8/2011 19:26'!processEvent: evt 	"Process a single event. This method is run at high priority."	| type buttons |	type := evt at: 1.	"Tackle mouse events first"	type = EventTypeMouse		ifTrue: [buttons := (ButtonDecodeTable at: (evt at: 5) + 1). 				evt at: 5 put: (Smalltalk platformName = 'Mac OS'							ifTrue: [ buttons ]							ifFalse: [ self mapButtons: buttons modifiers: (evt at: 6) ]).				self queueEvent: evt.				self processMouseEvent: evt . 				^self].			"Store the event in the queue if there's any"	type = EventTypeKeyboard		ifTrue: [ "Check if the event is a user interrupt"			((evt at: 4) = 0				and: [((evt at: 3)						bitOr: (((evt at: 5)							bitAnd: 8)							bitShift: 8))							= interruptKey])					ifTrue: ["interrupt key is meta - not reported as event"							^ interruptSemaphore signal].			"Else swap ctrl/alt keys if neeeded.			Look at the Unicode char first, then ascii."			KeyDecodeTable				at: {evt at: 6. evt at: 5}				ifPresent: [:a | evt at: 6 put: a first;						 at: 5 put: a second]. 			KeyDecodeTable				at: {evt at: 3. evt at: 5}				ifPresent: [:a | evt at: 3 put: a first;						 at: 5 put: a second]. 			self queueEvent: evt. 			self processKeyboardEvent: evt . 			^self ].					"Handle all events other than Keyborad or Mouse."	self queueEvent: evt.	! !!Exception methodsFor: 'handling' stamp: 'mtf 6/3/2010 09:42'!rearmHandlerDuring: aBlock"Make the current error handler re-entrant while it is running aBlock. Only works in a closure-enabled image"	^ handlerContext rearmHandlerDuring: aBlock! !!ExceptionTests methodsFor: 'testing' stamp: 'ar 9/1/2010 22:43'!testHandlerReentrancy	| callingOrder |	"Handlers are not re-entrant by default, so inner is not activated twice"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex pass]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sio'.	"Now make inner re-entrant"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex rearmHandlerDuring: [ex pass]]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sioi'.! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'ar 1/8/2011 20:28'!testHandlerFromAction	"A test ensuring that nested exceptions work as expected."	| result |	result := [		[			[self error: 'trigger error'] on: ZeroDivide do: [ :ex | 'inner' ]		] on: Error do: [ :ex | 3 / 0 ]	] on: ZeroDivide do: [ :ex | 'outer' ].	self assert: result = 'outer'.! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'ul 11/15/2010 11:39'!testResumableOuter	| result |	result := [Notification signal. 4] 		on: Notification 		do: [:ex | ex outer. ex return: 5].	self assert: result = 5! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'ul 11/15/2010 11:39'!testResumablePass	| result |	result := [Notification signal. 4] 		on: Notification 		do: [:ex | ex pass. ex return: 5].	self assert: result = 4! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'ul 11/15/2010 11:39'!testChangesFileAddressRange	"Test file position to source pointer address translation for the changes file"		| sf i p a a2 |	sf := ExpandedSourceFileArray new.	0 to: 16r1FFFFFFF by: 4093 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i = 2.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 2 andPosition: p.		self assert: a2 = a].	0 to: 16rFFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r2000000 and: 16r2FFFFFF)].	16r1000000 to: 16r1FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r4000000 and: 16r4FFFFFF)].	16r2000000 to: 16r2FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r6000000 and: 16r6FFFFFF)].	16r3000000 to: 16r3FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r8000000 and: 16r8FFFFFF)].	16r4000000 to: 16r4FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rA000000 and: 16rAFFFFFF)].	16r5000000 to: 16r5FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rC000000 and: 16rCFFFFFF)].	16r6000000 to: 16r6FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rE000000 and: 16rEFFFFFF)].	16r7000000 to: 16r7FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r10000000 and: 16r10FFFFFF)]! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'ul 11/15/2010 11:39'!testSourcesFileAddressRange	"Test file position to source pointer address translation for the sources file"		| sf i p a a2 |	sf := ExpandedSourceFileArray new.	0 to: 16r1FFFFFFF by: 4093 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i = 1.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 1 andPosition: p.		self assert: a2 = a].	0 to: 16rFFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r1000000 and: 16r1FFFFFF)].	16r1000000 to: 16r1FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r3000000 and: 16r3FFFFFF)].	16r2000000 to: 16r2FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r5000000 and: 16r5FFFFFF)].	16r3000000 to: 16r3FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r7000000 and: 16r7FFFFFF)].	16r4000000 to: 16r4FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r9000000 and: 16r9FFFFFF)].	16r5000000 to: 16r5FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rB000000 and: 16rBFFFFFF)].	16r6000000 to: 16r6FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rD000000 and: 16rDFFFFFF)].	16r7000000 to: 16r7FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rF000000 and: 16rFFFFFFF)]! !!ExternalDropHandler methodsFor: 'accessing' stamp: 'ul 11/15/2010 11:39'!handle: dropStream in: pasteUp dropEvent: anEvent	| numArgs |	numArgs := action numArgs.	numArgs = 1		ifTrue: [^action value: dropStream].	numArgs = 2		ifTrue: [^action value: dropStream value: pasteUp].	numArgs = 3		ifTrue: [^action value: dropStream value: pasteUp value: anEvent].	self error: 'Wrong number of args for dop action.'! !!FFT methodsFor: 'bulk processing' stamp: 'ul 8/3/2010 15:43'!transformDataFrom: anIndexableCollection startingAt: index	"Forward transform a block of real data taken from from the given indexable collection starting at the given index. Answer a block of values representing the normalized magnitudes of the frequency components."	| j real imag out |	j := 0.	index to: index + n - 1 do: [:i |		realData at: (j := j + 1) put: (anIndexableCollection at: i)].	realData *= window.	imagData := FloatArray new: n.	self transformForward: true.	"compute the magnitudes of the complex results"	"note: the results are in bottom half; the upper half is just its mirror image"	real := realData copyFrom: 1 to: (n / 2).	imag := imagData copyFrom: 1 to: (n / 2).	out := (real * real) + (imag * imag).	1 to: out size do: [:i | out at: i put: (out at: i) sqrt].	^ out! !!FFT methodsFor: 'transforming' stamp: 'ul 8/3/2010 15:43'!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i |	<primitive: 'primitiveFFTTransformData' module: 'FFTPlugin'>	self permuteData.	1 to: nu do:		[:level |		lev := 1 bitShift: level.		lev1 := lev // 2.		1 to: lev1 do:			[:j |			theta := j-1 * (n // lev).   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < (n//4)  "Compute U, the complex multiplier for each level"				ifTrue:					[realU := sinTable at: sinTable size - theta.					imagU := sinTable at: theta + 1]				ifFalse:					[realU := (sinTable at: theta - (n//4) + 1) negated.					imagU := sinTable at: (n//2) - theta + 1].			forward ifFalse: [imagU := imagU negated]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i := j.			[i <= n] whileTrue:				[ip := i + lev1.				realT := ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT := ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: i) - realT.				imagData at: ip put: (imagData at: i) - imagT.				realData at: i put: (realData at: i) + realT.				imagData at: i put: (imagData at: i) + imagT.				i := i + lev]]].	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !!FMSound methodsFor: 'sound generation' stamp: 'ul 11/2/2010 03:08'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy."	"(FMSound pitch: 440.0 dur: 1.0 loudness: 0.5) play"	| doingFM lastIndex sample offset i s |	<primitive:'primitiveMixFMSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #waveTable declareC: 'short int *waveTable'>	doingFM := (normalizedModulation ~= 0) and: [scaledOffsetIndexIncr ~= 0].	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sample := (scaledVol * (waveTable at: (scaledIndex // ScaleFactor) + 1)) // ScaleFactor.		doingFM			ifTrue: [				offset := normalizedModulation * (waveTable at: (scaledOffsetIndex // ScaleFactor) + 1).				scaledOffsetIndex := (scaledOffsetIndex + scaledOffsetIndexIncr) \\ scaledWaveTableSize.				scaledOffsetIndex < 0					ifTrue: [scaledOffsetIndex := scaledOffsetIndex + scaledWaveTableSize].				scaledIndex := (scaledIndex + scaledIndexIncr + offset) \\ scaledWaveTableSize.				scaledIndex < 0					ifTrue: [scaledIndex := scaledIndex + scaledWaveTableSize]]			ifFalse: [				scaledIndex := (scaledIndex + scaledIndexIncr) \\ scaledWaveTableSize].		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	count := count - n.! !!FTPClient methodsFor: 'private protocol' stamp: 'eem 10/22/2010 09:34'!lookForCode: code ifDifferent: handleBlock 	"We are expecting a certain numeric code next.  	However, in the FTP protocol, multiple lines are allowed.  	If the response is multi-line, the fourth character of the first line is a  	$- and the last line repeats the numeric code but the code is followed by 	a space. So it's possible that there are more lines left of the last response that 	we need to throw away. We use peekForAll: so that we don't discard the	next response that is not a continuation line."		"check for multi-line response"	(self lastResponse size > 3			and: [(self lastResponse at: 4) = $-])		ifTrue: "Discard continuation lines."			[ | headToDiscard |			headToDiscard := self lastResponse first: 4.			[[self stream peekForAll: headToDiscard]				whileTrue: [self stream nextLine]]				on: Exception				do: [:ex | ^handleBlock value: nil]].	^ super lookForCode: code ifDifferent: handleBlock! !!False methodsFor: 'logical operations' stamp: 'nice 2/1/2011 21:50'!==> aBlock	^true! !!FatBitsPaint methodsFor: 'menu' stamp: 'ar 9/5/2010 09:06'!editSelection       FatBitsPaint new openWith: (self selectionAsForm ifNil: [^ nil])! !!FieldNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitFieldNode: self! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForLoad: stack encoder: encoder	rcvrNode emitCodeForValue: stack encoder: encoder.	fieldDef accessKey ifNotNil:[		super emitCodeForValue: stack encoder: encoder.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForStore: stack encoder: encoder	fieldDef accessKey ifNil:[		writeNode emitCode: stack args: 1 encoder: encoder super: false.	] ifNotNil:[		writeNode emitCode: stack args: 2 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:18'!emitCodeForStorePop: stack encoder: encoder	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	fieldDef accessKey ifNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 0 encoder: encoder super: false.	] ifNotNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		super emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 1 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	^0! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForStore: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		writeNode ifNil:[writeNode := encoder encodeSelector: fieldDef toSet].		^(rcvrNode sizeCodeForValue: encoder) + 			(writeNode sizeCode: encoder args: 1 super: false)		].	writeNode ifNil:[writeNode := encoder encodeSelector: #set:to:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) +			(writeNode sizeCode: encoder args: 2 super: false)! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:17'!sizeCodeForStorePop: encoder	^(self sizeCodeForStore: encoder) + encoder sizePop! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		readNode ifNil:[readNode := encoder encodeSelector: fieldDef toGet].		^(rcvrNode sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 0 super: false)	].	readNode ifNil:[readNode := encoder encodeSelector: #get:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 1 super: false)! !!FileContentsBrowser methodsFor: 'accessing' stamp: 'fbs 3/3/2011 17:51'!selectedPackage	| cat |	cat := self selectedSystemCategory.	cat isNil ifTrue:[^nil].	^self packages at: cat asString ifAbsent:[nil]! !!FileContentsBrowser methodsFor: 'class list' stamp: 'fbs 3/3/2011 23:02'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	(self hasSystemCategorySelected not or:[self selectedPackage isNil])		ifTrue: [^Array new]		ifFalse: [^self selectedPackage classes keys asArray sort].! !!FileContentsBrowser methodsFor: 'class list' stamp: 'fbs 3/5/2011 20:57'!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self classNotFound].	pattern := (UIManager default request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	self packages do:[:p| classNames addAll: p classes keys].	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index := classNames size = 1				ifTrue:	[1]				ifFalse:	[(UIManager default chooseFrom: classNames lines: #())].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.	self packages do:[:p| 		(p classes includesKey: (classNames at: index)) ifTrue:[			foundClass := p classes at: (classNames at: index).			foundPackage := p]].	foundClass isNil ifTrue:[^self]. 	self selectSystemCategory: foundPackage packageName asSymbol.	self classListIndex: (self classList indexOf: foundClass name). ! !!FileContentsBrowser methodsFor: 'class list' stamp: 'fbs 3/4/2011 20:55'!renameClass	| oldName newName |	self hasClassSelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	oldName := self selectedClass name.	newName := (self request: 'Please type new class name'						initialAnswer: oldName) asSymbol.	(newName isEmpty or:[newName = oldName]) ifTrue: [^ self].	(self selectedPackage classes includesKey: newName)		ifTrue: [^ self error: newName , ' already exists in the package'].	systemOrganizer classify: newName under: self selectedSystemCategory.	systemOrganizer removeElement: oldName.	self selectedPackage renameClass: self selectedClass to: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategory) indexOf: newName).! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'nice 8/27/2010 20:31'!infoString	^infoString ifNil: [infoString := StringHolder new]! !!FileContentsBrowser methodsFor: 'metaclass' stamp: 'fbs 3/4/2011 20:55'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer := nil.	metaClassOrganizer := nil.	self hasClassSelected ifFalse: [^ self].	classOrganizer := (theClass := self selectedClass) organization.	metaClassOrganizer := theClass metaClass organization.! !!FileContentsBrowser methodsFor: 'other' stamp: 'fbs 3/17/2011 17:32'!browseSenders	"Create and schedule a message set browser on all senders of the 	currently selected message selector. Do nothing if no message is selected."	self hasMessageSelected 		ifTrue: [self systemNavigation browseAllCallsOn: self selectedMessageName]! !!FileContentsBrowser methodsFor: 'other' stamp: 'fbs 3/15/2011 22:41'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self unlock.	self editClass.	self selectClassNamed: selectedClassName.	^ true! !!FileContentsBrowser methodsFor: 'other' stamp: 'fbs 3/3/2011 17:52'!labelString	"Answer the string for the window title"	^ 'File Contents Browser ', (self selectedSystemCategory ifNil: [''])! !!FileContentsBrowser methodsFor: 'removing' stamp: 'fbs 3/4/2011 20:55'!removeClass	| class |	self hasClassSelected ifFalse: [^ self].	class := self selectedClass.	(self confirm:'Are you certain that youwant to delete the class ', class name, '?') ifFalse:[^self].	self selectedPackage removeClass: class.	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'fbs 3/17/2011 17:34'!removeMessage	| messageName |	self hasMessageSelected		ifFalse: [^ self].	self okToChange		ifFalse: [^ self].	messageName := self selectedMessageName.	(self selectedClass confirmRemovalOf: messageName)		ifFalse: [^ false].	self selectedClassOrMetaClass removeMethod: self selectedMessageName.	self selectMessageNamed: nil.	self setClassOrganizer.	"In case organization not cached"	self changed: #messageList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'fbs 3/30/2011 07:50'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	self hasMessageCategorySelected ifFalse: [^ self].	self okToChange ifFalse: [^ self].	messageCategoryName := self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse: [^ self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'fbs 3/5/2011 20:57'!removePackage	self hasSystemCategorySelected ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(self confirm: 'Are you sure you want toremove this package and all its classes?') ifFalse:[^self].	(systemOrganizer listAtCategoryNamed: self selectedSystemCategory) do:[:el|		systemOrganizer removeElement: el].	self packages removeKey: self selectedPackage packageName.	systemOrganizer removeCategory: self selectedSystemCategory.	self selectSystemCategory: nil.	self changed: #systemCategoryList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 3/2/2010 15:59'!removeUnmodifiedClasses	| packageList |	self okToChange ifFalse:[^self].	packageList := self selectedPackage						ifNil: [ self packages] 						ifNotNil: [ Array with: self selectedPackage].	packageList do:[:package|		package classes copy do:[:theClass|			Cursor wait showWhile:[				theClass removeAllUnmodified.			].			theClass hasChanges ifFalse:[				package removeClass: theClass.			].		]].	self classListIndex: 0.	self changed: #classList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'jmv 3/2/2010 15:59'!removeUnmodifiedMethods	| theClass cat |	self okToChange ifFalse:[^self].	theClass := self selectedClassOrMetaClass.	theClass ifNil: [ ^self].	cat := self selectedMessageCategoryName.	cat ifNil: [ ^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass organization listAtCategoryNamed: cat).	].	self messageListIndex: 0.	self changed: #messageList.! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nice 8/5/2011 13:30'!browseCompressedCodeStream: aStandardFileStream 	"Browse the selected file in fileIn format."	| unzipped |	unzipped :=  [MultiByteBinaryOrTextStream			with:  (GZipReadStream on: aStandardFileStream) contents asString]		ensure: [aStandardFileStream close].	unzipped reset.	self browseStream: unzipped named: aStandardFileStream name! !!FileContentsBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/15/2011 22:40'!expectedFailures	^ #(testChangeMessageCategoriesLeavesClassSelected) "See Mantis #7615"! !!FileContentsBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/15/2011 21:23'!setUp	| fileout testCat package packageDict organizer |	testCat := self class category.	fileout := ReadWriteStream on: (String new: 10000).	SystemOrganization fileOutCategory: testCat on: fileout.	packageDict := Dictionary new.	browser := FileContentsBrowser new.	organizer := SystemOrganizer defaultList: Array new.	package := (FilePackage new fullName: testCat; fileInFrom: fileout).	packageDict 		at: package packageName 		put: package.	organizer 		classifyAll: package classes keys 		under: package packageName.	(browser := FileContentsBrowser systemOrganizer: organizer)		packages: packageDict.! !!FileContentsBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:26'!testChangeMessageCategoriesLeavesClassSelected	browser selectSystemCategory: browser systemCategoryList first.	browser selectClassNamed: browser classList first.		"This is a no-op."	browser changeMessageCategories: browser classOrMetaClassOrganizer printString.	self assert: browser selectedClassName = browser class name.! !!FileDirectory methodsFor: 'file directory' stamp: 'bf 9/5/2010 00:02'!assureExistence	"Make sure the current directory exists. If necessary, create all parts in between"	self exists ifFalse: [ 		self containingDirectory			assureExistence;			createDirectory: self localName]! !!FileDirectory methodsFor: 'file directory' stamp: 'bf 9/9/2010 12:37'!assureExistenceOfPath: lPath	"Make sure the local directory exists. If necessary, create all parts in between"	| localPath |	localPath := lPath.	localPath isEmpty ifTrue: [ ^self ]. "Assumed to exist"	self assureExistence.	(self directoryExists: localPath) ifTrue: [^ self]. "exists"	self createDirectory: localPath! !!FileDirectory methodsFor: 'file status' stamp: 'ul 8/2/2011 19:59'!entryAt: fileName ifAbsent: aBlock	"Find the entry with local name fileName and answer it.	If not found, answer the result of evaluating aBlock."	| comparisonBlock |	self isCaseSensitive		ifTrue: [comparisonBlock := [:entry | entry name = fileName]]		ifFalse: [comparisonBlock := [:entry | entry name sameAs: fileName]].	^ self entries detect: comparisonBlock ifNone: aBlock! !!FileDirectory methodsFor: 'testing' stamp: 'eem 12/15/2011 15:08'!directoryExists: filenameOrPath	"Answer true if a directory of the given name exists. The given name may be either a full path name or a local directory within this directory."	"FileDirectory default directoryExists: FileDirectory default pathName"	| fName dir |	DirectoryClass		splitName: filenameOrPath		to: [:filePath :name |			fName := name.			dir := filePath isEmpty					ifTrue: [self]					ifFalse: [self directoryNamed: filePath]].	^dir exists	  and: [self class currentDirectoryNickname = fName		   or: [self class parentDirectoryNickname = fName		   or: [self isCaseSensitive 				ifTrue:[dir directoryNames includes: fName]				ifFalse:[dir directoryNames anySatisfy: [:name| name sameAs: fName]]]]]! !!FileDirectory methodsFor: '*network-uri' stamp: 'fbs 12/13/2010 20:21'!uri	"Convert my path into a file:// type url.  Use slash instead of the local delimiter (:), and convert odd characters to %20 notation."	"If slash (/) is not the file system delimiter, encode slashes before converting."	| list |	list := self pathParts.	^(String streamContents: [:strm |		strm nextPutAll: 'file:'.		list do: [:each | strm nextPut: $/; nextPutAll: each encodeForHTTP].		strm nextPut: $/]) asURI! !!FileDirectory methodsFor: 'private' stamp: 'mtf 6/1/2010 18:47'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	^Array new: 200 streamContents: [:stream |		self directoryContentsFor: fullPath do: [:ea | stream nextPut: ea]].! !!FileDirectory methodsFor: 'private' stamp: 'ul 4/26/2011 04:08'!directoryContentsFor: fullPath do: aBlock"Do aBlock for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	| f entryArray index |	f := fullPath asVmPathName.	index := 1.	[(entryArray := self primLookupEntryIn: f index: index) == nil] whileFalse: [		#badDirectoryPath == entryArray ifTrue: [			^(InvalidDirectoryError pathName: pathName) signal].		index := index + 1.		aBlock value: (DirectoryEntry fromArray: entryArray directory: self) convertFromSystemName]! !!FileDirectory methodsFor: 'private' stamp: 'ar 9/3/2010 16:20'!directoryEntryForName: aFileName	"Return a single DirectoryEntry for the given (non-path) entry name,	 or nil if the entry could not be found.	 Raises InvalidDirectoryError if this directory's path does not identify a directory."	| entryArray sysPath sysName |	sysPath := pathName asVmPathName.	sysName := aFileName asVmPathName.	"New linear-time primitive."	entryArray := self primLookupEntryIn: sysPath name: sysName.	entryArray == #primFailed ifFalse:[		^ entryArray ifNotNil: [(DirectoryEntry fromArray: entryArray directory: self) convertFromSystemName]	].	"If the new primitive fails, use the old slow method. 	 (This fallback can be changed to signal InvalidDirectoryError once	  VM's with FilePlugin #primitiveDirectoryEntry have been distributed everywhere;	  the new primitive was introduced 6/13/2007."	^self isCaseSensitive ifTrue: [		self entries detect: [:entry | entry name = aFileName ] ifNone: [ nil ]	] ifFalse: [		self entries detect: [:entry | entry name sameAs: aFileName ] ifNone: [ nil ]	]! !!FileDirectory methodsFor: 'utilities' stamp: 'ar 8/9/2010 10:44'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	"Write the source code from aStream into a file."	| extension converter f fileName |	aStream contents isAsciiString ifTrue: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st).		] ifFalse: [			extension := (FileDirectory dot, FileStream cs).		].		converter := MacRomanTextConverter new.	] ifFalse: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st "multiSt").		] ifFalse: [			extension := (FileDirectory dot, FileStream cs "multiCs").		].		converter := UTF8TextConverter new.	].	fileName := useHtml ifTrue: [baseName, '.html'] ifFalse: [baseName, extension].	fileName := self checkName: fileName fixErrors: true.	f := self newFileNamed: fileName.	f ifNil: [^ self error: 'Cannot open file'].	(converter isMemberOf: UTF8TextConverter)		ifTrue: [f binary.			UTF8TextConverter writeBOMOn: f].	f text.	f converter: converter.	f nextPutAll: aStream contents.	f close.! !!FileDirectory methodsFor: '*network-url' stamp: 'gk 2/10/2004 13:22'!asUrl	"Convert my path into a file:// type url - a FileUrl."		^FileUrl pathParts: (self pathParts copyWith: '')! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 16:09'!eToyBaseFolderSpec	^ServerDirectory eToyBaseFolderSpecForFileDirectory: self! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 16:09'!eToyBaseFolderSpec: aString	^ServerDirectory eToyBaseFolderSpecForFileDirectory: self put: aString! !!FileDirectory methodsFor: '*Etoys' stamp: 'stephaneducasse 2/4/2006 20:31'!eToyUserList	| spec index fd list match |	spec := self eToyBaseFolderSpec. "something like 'U:\Squeak\users\*-Squeak'."	spec ifNil:[^ServerDirectory eToyUserListForFileDirectory: self].	"Compute list of users based on base folder spec"	index := spec indexOf: $*. "we really need one"	index = 0 ifTrue:[^ServerDirectory eToyUserListForFileDirectory: self].	fd := FileDirectory on: (FileDirectory dirPathFor: (spec copyFrom: 1 to: index)).	"reject all non-directories"	list := fd entries select:[:each| each isDirectory].	"reject all non-matching entries"	match := spec copyFrom: fd pathName size + 2 to: spec size.	list := list collect:[:each| each name].	list := list select:[:each| match match: each].	"extract the names (e.g., those positions that match '*')"	index := match indexOf: $*.	list := list collect:[:each|		each copyFrom: index to: each size - (match size - index)].	^list! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 15:41'!eToyUserListUrl	^ServerDirectory eToyUserListUrlForFileDirectory: self! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 15:48'!eToyUserListUrl: urlString	^ServerDirectory eToyUserListUrlForFileDirectory: self put: urlString.! !!FileDirectory methodsFor: '*Etoys' stamp: 'stephaneducasse 2/4/2006 20:31'!eToyUserName: aString	"Set the default directory from the given user name"	| dirName |	dirName := self eToyBaseFolderSpec. "something like 'U:\Squeak\users\*-Squeak'"	dirName ifNil:[^self].	dirName := dirName copyReplaceAll:'*' with: aString."	dirName last = self class pathNameDelimiter ifFalse:[dirName := dirName, self slash].	FileDirectory setDefaultDirectoryFrom: dirName.	dirName := dirName copyFrom: 1 to: dirName size - 1."	pathName := FilePath pathName: dirName! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 16:13'!hasEToyUserList	^self eToyUserListUrl notNil or:[self eToyBaseFolderSpec notNil]! !!FileDirectory class methodsFor: 'platform specific' stamp: 'eem 12/15/2011 14:56'!currentDirectoryNickname	"Answer the nick-name for the current directory (e.g. '.' on Unix and Windows).	 Answer the common default."	^'.'! !!FileDirectory class methodsFor: 'platform specific' stamp: 'eem 12/15/2011 15:06'!parentDirectoryNickname	"Answer the nick-name for the parent directory (e.g. '..' on Unix and Windows).	 Answer the common default."	^'..'! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'laza 12/19/2011 08:40'!testDirectoryNicknames	| defaultDirectory |	defaultDirectory := FileDirectory default.	#('/.' '/../../.' '/././.') do: [:each |		self assert: (defaultDirectory directoryExists: defaultDirectory fullName, each).	].! !!FileDoesNotExistException methodsFor: 'exceptionDescription' stamp: 'mtf 1/20/2011 14:16'!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [StandardFileStream readOnlyFileDoesNotExistUserHandling: self fileName			ifDebug: [super defaultAction]]		ifFalse: [StandardFileStream fileDoesNotExistUserHandling: self fileName			ifDebug: [super defaultAction]]! !!FileExistsException methodsFor: 'exceptionDescription' stamp: 'mtf 1/20/2011 14:17'!defaultAction	"The default action taken if the exception is signaled."	^ self fileClass fileExistsUserHandling: self fileName ifDebug: [super defaultAction]! !!FileList methodsFor: 'file list' stamp: 'cmm 6/20/2010 16:35'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := self isGraphicsFileSelected		ifTrue: [#needToGetGraphic]		ifFalse: [#needToGetBrief]..	self 		changed: #fileListIndex ;		changed: #contents ;		changed: #labelString.	self updateButtonRow! !!FileList methodsFor: 'file list menu' stamp: 'cao 4/26/2010 09:36'!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| services maybeLine extraLines |	shifted ifTrue:		[^ aMenu addList: StringHolder shiftedYellowButtonMenuItems].	fileName ifNotNil:		[services := OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		(#(needToGetShiftJIS needToGetEUCJP needToGetCNGB needToGetEUCKR needToGetUTF8) includes: brevityState) ifFalse:			[services add: self serviceGetEncodedText].		maybeLine := services size.		(FileStream sourceFileSuffixes includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines := OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.		#find}.			{'find again (g)' translated.		#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.		#again}.			{'undo (z)' translated.			#undo}.			#-.			{'copy (c)' translated.			#copySelection}.			{'cut (x)' translated.			#cut}.			{'paste (v)' translated.		#paste}.			{'paste...' translated.			#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			{'print it (p)' translated.		#printIt}.			{'inspect it (i)' translated.		#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.		#accept}.			{'cancel (l)' translated.		#cancel}.			#-.			{'more...' translated.			#shiftedYellowButtonActivity}}.	^ aMenu! !!FileList methodsFor: 'initialization' stamp: 'cmm 6/20/2010 16:30'!labelString	^ directory		ifNil: [ 'File List' ]		ifNotNil:			[ fileName				ifNil: [ directory fullName ]				ifNotNil: [ directory fullNameFor: fileName ] ]! !!FileList methodsFor: 'initialization' stamp: 'cmm 6/20/2010 16:34'!setFileStream: aStream	"Used to initialize a spawned file editor.  Sets directory too."	self directory: aStream directory.	fileName := aStream localName.	pattern := '*'.	listIndex := 1.  "pretend a file is selected"	aStream close.	brevityState := #needToGetBrief.	self 		changed: #contents ; 		changed: #labelString! !!FileList methodsFor: 'private' stamp: 'nice 5/8/2011 10:26'!addPath: aString	"Add the given string to the list of recently visited directories."	| full |	aString ifNil: [^self].	full := String streamContents: 		[ :strm | 2 to: volList size do: 			[ :i | strm nextPutAll: (volList at: i) withBlanksTrimmed.			strm nextPut: FileDirectory pathNameDelimiter]].	full := full, aString."Remove and super-directories of aString from the collection."	RecentDirs removeAllSuchThat: [ :aDir | ((aDir, '*') match: full)]."If a sub-directory is in the list, do nothing."	(RecentDirs anySatisfy: [ :aDir | ((full, '*') match: aDir)])		ifTrue: [^self].	[RecentDirs size >= 10]		whileTrue: [RecentDirs removeFirst].	RecentDirs addLast: full! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:58'!availableGraphicsExtent	self dependents do: [:each |		((each isKindOf: PluggableTextMorph) and: [each getTextSelector == #contents]) ifTrue: [^each innerBounds extent - (6@22)]].	^nil! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 12:47'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #graphic ifTrue: [^ contents].	brevityState == #needToGetGraphic ifTrue: [^self readGraphicContents].		brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	(TextConverter allEncodingNames includes: brevityState) 		ifTrue: [ ^self readContentsAsEncoding: brevityState].	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:22'!defaultContents	contents := list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState := #FileList.	^ contents! !!FileList methodsFor: 'private' stamp: 'jmv 3/2/2010 16:00'!isFileSelected	"return if a file is currently selected"	^ fileName notNil! !!FileList methodsFor: 'private' stamp: 'nice 5/8/2011 10:27'!isGraphicsFileSelected	^fileName notNil		and: [(self itemsForFile: self fullName) anySatisfy: [:each | each provider == Form and: [each selector == #importImage:]]]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 20:45'!readGraphicContents	| form maxExtent ext |	form := Form fromFileNamed: self fullName.	maxExtent := lastGraphicsExtent := self availableGraphicsExtent.	ext := form extent.	(maxExtent notNil and: [form extent <= maxExtent]) ifFalse: [		form := form magnify: form boundingBox by: (maxExtent x / form width min: maxExtent y / form height) asPoint smoothing: 3].	contents :=  ('Image extent: ', ext printString) asText,				(String with: Character cr),				(Text string: ' '					attribute: (TextFontReference toFont: 						(FormSetFont new							fromFormArray: (Array with: form)							asciiStart: Character space asInteger							ascent: form height))).	brevityState := #graphic.	^contents! !!FileList methodsFor: 'private' stamp: 'cmm 6/20/2010 16:33'!resort: newMode 	"Re-sort the list of files."	| name |	listIndex > 0 ifTrue: [ name := self fileNameFromFormattedItem: (list at: listIndex) ].	sortMode := newMode.	self pattern: pattern.	name ifNotNil:		[ fileName := name.		listIndex := list findFirst:			[ : item | (self fileNameFromFormattedItem: item) = name ].		self			 changed: #fileListIndex ;			 changed: #labelString ].	listIndex = 0 ifTrue: [ self changed: #contents ].	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:02'!step	| ext |	brevityState = #graphic ifTrue: [		ext := self availableGraphicsExtent.		ext = lastGraphicsExtent ifFalse: [			lastGraphicsExtent := ext.			brevityState := #needToGetGraphic.			self changed: #contents]]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:03'!stepTimeIn: aWindow	^500! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:56'!wantsSteps	^true! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 20:48'!buildFileListWith: builder	| buttons listSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttons := self buildButtonPaneWith: builder.	buttons frame: (self topConstantHeightFrame: self buttonHeight fromLeft: 0 width: 1).	top children add: buttons.		listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #fileList; 		getIndex: #fileListIndex; 		setIndex: #fileListIndex:; 		menu: #fileListMenu:; 		keyPress: nil;		frame: (self frameOffsetFromTop: self buttonHeight + 4 fromLeft: 0 width: 1 bottomFraction: 1);		color: Color white.	top children add: listSpec.	^top.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 16:20'!buildWith: builder	"FileList open"	| windowSpec window |	windowSpec := 	self buildWindowWith: builder specs: {		(0@0 corner: 1@0.06) -> [self buildPatternInputWith: builder].		(0.25@0.06 corner: 1@0.5) -> [self buildFileListWith: builder].		(0@0.06 corner: 0.25@1) -> [self buildDirectoryTreeWith: builder].		(0.25@0.5 corner: 1@1) -> [self buildContentPaneWith: builder].	}.	window := builder build: windowSpec.	self changed: #selectedPath.	^window! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 4/30/2010 14:53'!buttonHeight	^Preferences standardButtonFont height + 12! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 23:00'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 22:56'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !!FileList commentStamp: 'nk 11/26/2002 11:52' prior: 0!I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.The FileList now provides a registration mechanism to which any tools the filelist uses ***MUST*** register.  This way it is possible to dynamically load or unload a new tool and have the FileList automatically updated.  This change supports a decomposition of Squeak and removes a problem with dead reference to classes after a major shrink.Tools should implement the following methods (look for implementors in the image):#fileReaderServicesForFile:suffix: (appropriate services for given file, takes a file name and a lowercased suffix)#services (all provided services, to be displayed in full list)These methods both return a collection of SimpleServiceEntry instances.  These contain a class, a menu label and a method selector having one argument.  They may also provide separate button labels and description.The argument to the specified method will be a string representing the full name of a file when one is selected or the file list itself when there is no selected file.Tools must register with the FileList calling the class method #registerFileReader: when they load. They also must call #unregisterFileReader: when they unload.There is a testSuite called FileListTest that presents some examples. Stef (I do not like really this distinction passing always a file list could be better)Old Comments: FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!FileList2 methodsFor: 'initialize-release' stamp: 'ul 11/23/2010 10:46'!initialize	super initialize.	showDirsInFileList := false.	fileSelectionBlock := [ :entry :myPattern |		entry isDirectory ifTrue: [			showDirsInFileList		] ifFalse: [			myPattern = '*' or: [myPattern match: entry name]		]	].	dirSelectionBlock := [ :dirName | true].! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'ul 2/22/2010 22:28'!modalFolderSelector: aDir	| window fileModel |	window := self morphicViewFolderSelector: aDir.	fileModel := window model.	window openInWorld: self currentWorld extent: 300@400.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!FilePackage methodsFor: 'reading' stamp: 'ul 6/17/2011 12:26'!fileInFrom: aStream	| changes |	changes := ChangeSet scanFile: aStream from: 0 to: aStream size.	aStream close.	('Processing ', self packageName) 		displayProgressFrom: 1		to: changes size		during:[:bar| | chgRec |			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbolwith: chgRec.			].		].! !!FilePackage methodsFor: 'reading' stamp: 'ul 6/17/2011 12:27'!fromStream: aStream named: aName	| changes |	changes := ChangeSet scanFile: aStream from: 0 to: aStream size.	aStream close.	('Processing ', aName) 		displayProgressFrom: 1		to: changes size		during:[:bar| | chgRec |			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbolwith: chgRec.			].		].! !!FilePath methodsFor: 'conversion' stamp: 'ul 3/14/2011 21:48'!converter: aTextConverter	converter class ~= aTextConverter class ifTrue: [		converter := aTextConverter.		vmPathName := squeakPathName convertToWithConverter: converter	].! !!FileServices class methodsFor: 'accessing' stamp: 'nk 12/7/2002 12:52'!suffixOf: aName	"Answer the file extension of the given file"	^ aName		ifNil:			['']		ifNotNil:			[(FileDirectory extensionFor: aName) asLowercase]! !!FileStream methodsFor: '*network-url' stamp: 'gk 2/10/2004 13:21'!asUrl	"Convert my path into a file:// type url - a FileUrl."		^FileUrl pathParts: (self directory pathParts copyWith: self localName)! !!FileStream methodsFor: '*Compression' stamp: 'laza 11/27/2010 18:39'!viewGZipContents	"View the contents of a gzipped file"	| stringContents |	self binary.	stringContents := self contentsOfEntireFile.	stringContents := Cursor wait showWhile: [(GZipReadStream on: stringContents) upToEnd].	stringContents := stringContents asString withSqueakLineEndings.	UIManager default		edit: stringContents		label: 'Decompressed contents of: ', self localName! !!FileStream methodsFor: '*Tools-Changes' stamp: 'di 5/20/1998 23:20'!edit	"Create and schedule an editor on this file."	FileList openEditorOn: self editString: nil.! !!FileStream methodsFor: '*Tools-Changes' stamp: 'ar 9/6/2010 10:34'!fileIntoNewChangeSet	"File all of my contents into a new change set." 	self readOnly.	ChangesOrganizer newChangesFromStream: self named: self localName! !!FileStream commentStamp: '<historical>' prior: 0!I represent a Stream that accesses a FilePage from a File. One use for my instance is to access larger "virtual Strings" than can be stored contiguously in main memory. I restrict the objects stored and retrieved to be Integers or Characters. An end of file pointer terminates reading; it can be extended by writing past it, or the file can be explicitly truncated.	To use the file system for most applications, you typically create a FileStream. This is done by sending a message to a FileDirectory (file:, oldFile:, newFile:, rename:newName:) which creates an instance of me. Accesses to the file are then done via my instance.*** On DOS, files cannot be shortened!!  ***  To overwrite a file with a shorter one, first delete the old file (FileDirectory deleteFilePath: 'Hard Disk:aFolder:dataFolder:foo') or (aFileDirectory deleteFileNamed: 'foo').  Then write your new shorter version.!!FileStream class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 08:54'!unload	FileServices unregisterFileReader: self ! !!FileStream class methodsFor: 'file reader services' stamp: 'ar 8/9/2010 10:46'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	"Write the source code from aStream into a file. 	Uses ChangeSet defaultChangeSetDirectory for consistency."	^(ChangeSet defaultChangeSetDirectory)		writeSourceCodeFrom: aStream 		baseName: baseName 		isSt: stOrCsFlag 		useHtml: useHtml! !!FileStream class methodsFor: 'initialize-release' stamp: 'ul 1/24/2011 03:08'!initialize	FileServices registerFileReader: self.	EncodeAndDecodeStdioFiles := true.	TheStdioHandles := Array new: 3.	Smalltalk		addToStartUpList: self after: SecurityManager; "the intent being before: AutoStart"		addToShutDownList: self after: SecurityManager! !!FileStream class methodsFor: 'instance creation' stamp: 'ul 7/16/2011 11:22'!detectFile: aBlockOrFileStream do: anotherBlock	^aBlockOrFileStream value "Assume that FileStreams return self for #value."		ifNotNil: [ :file | [ anotherBlock value: file ] ensure: [ file close ] ]! !!FileStream class methodsFor: 'instance creation' stamp: 'ul 7/16/2011 11:23'!fileNamed: fileName do: aBlock	"Avi Bryant says, ''This idiom is quite common in other languages that make heavy use of closures (i.e. Lisp (with-file 'foo' (f) ...) and Ruby (File.open('foo'){|f|...})).  It's time Squeak had it, too.''		Returns the result of aBlock."		^self detectFile: (self fileNamed: fileName) do: aBlock! !!FileStream class methodsFor: 'instance creation' stamp: 'ul 7/16/2011 11:24'!forceNewFileNamed: fileName do: aBlock	"Avi Bryant says, ''This idiom is quite common in other languages that make heavy use of closures (i.e. Lisp (with-file 'foo' (f) ...) and Ruby (File.open('foo'){|f|...})).  It's time Squeak had it, too.''		Returns the result of aBlock."		^self detectFile: (self forceNewFileNamed: fileName) do: aBlock! !!FileStream class methodsFor: 'instance creation' stamp: 'ul 7/16/2011 11:24'!newFileNamed: fileName do: aBlock	"Avi Bryant says, ''This idiom is quite common in other languages that make heavy use of closures (i.e. Lisp (with-file 'foo' (f) ...) and Ruby (File.open('foo'){|f|...})).  It's time Squeak had it, too.''		Returns the result of aBlock."		^self detectFile: (self newFileNamed: fileName) do: aBlock! !!FileStream class methodsFor: 'instance creation' stamp: 'ul 7/16/2011 11:24'!oldFileNamed: fileName do: aBlock	"Avi Bryant says, ''This idiom is quite common in other languages that make heavy use of closures (i.e. Lisp (with-file 'foo' (f) ...) and Ruby (File.open('foo'){|f|...})).  It's time Squeak had it, too.''		Returns the result of aBlock."		^self detectFile: (self oldFileNamed: fileName) do: aBlock! !!FileStream class methodsFor: 'instance creation' stamp: 'ul 7/16/2011 11:24'!readOnlyFileNamed: fileName do: aBlock	"Avi Bryant says, ''This idiom is quite common in other languages that make heavy use of closures (i.e. Lisp (with-file 'foo' (f) ...) and Ruby (File.open('foo'){|f|...})).  It's time Squeak had it, too.''		Returns the result of aBlock."		^self detectFile: (self readOnlyFileNamed: fileName) do: aBlock! !!FileStream class methodsFor: '*network' stamp: 'stephaneducasse 2/4/2006 20:32'!httpPostDocument: url args: argsDict	| argString |	argString := argsDict		ifNotNil: [argString := HTTPSocket argString: argsDict]		ifNil: [''].	^self post: argString url: url , argString ifError: [self halt]! !!FileStream class methodsFor: '*network' stamp: 'nice 12/27/2009 03:11'!httpPostMultipart: url args: argsDict	| mimeBorder argsStream crLf resultStream result |	" do multipart/form-data encoding rather than x-www-urlencoded "	crLf := String crlf.	mimeBorder := '----squeak-', Time millisecondClockValue printString, '-stuff-----'.	"encode the arguments dictionary"	argsStream := WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value | | fieldValue |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, crLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue := value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', crLf, 'Content-Type: ', value contentType.				fieldValue := (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: crLf, crLf, fieldValue, crLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	resultStream := self		post: 			('Content-type: multipart/form-data; boundary=', mimeBorder, crLf,			'Content-length: ', argsStream contents size printString, crLf, crLf, 			argsStream contents)		url: url ifError: [^'Error in post ' url asString].	"get the header of the reply"	result := resultStream upToEnd.	^MIMEDocument content: result! !!FileStream class methodsFor: '*network' stamp: 'mir 2/2/2001 14:23'!post: data target: target url: url ifError: errorBlock	^self concreteStream new post: data target: target url: url ifError: errorBlock! !!FileStream class methodsFor: '*network' stamp: 'mir 2/2/2001 14:23'!post: data url: url ifError: errorBlock	^self post: data target: nil url: url ifError: errorBlock! !!FileStream class methodsFor: '*network' stamp: 'stephaneducasse 2/4/2006 20:32'!requestURL: url target: target	"FileStream requestURL:'http://isgwww.cs.uni-magdeburg.de/~raab' target: ':=blank' "	^self concreteStream new requestURL: url target: target! !!FileStream class methodsFor: '*network'!requestURLStream: url	"FileStream requestURLStream:'http://isgwww.cs.uni-magdeburg.de/~raab'"	^self concreteStream new requestURLStream: url! !!FileStream class methodsFor: '*network'!requestURLStream: url ifError: errorBlock	"FileStream requestURLStream:'http://isgwww.cs.uni-magdeburg.de/~raab'"	^self concreteStream new requestURLStream: url ifError: errorBlock! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/4/2011 07:30'!encodeAndDecodeStdioFiles		<preference: 'Encode and decode the contents of stdio files.'		category: 'Files'		description: 'It true, then the contents of stdin, stdout and stderr are encoded/decoded using the system default text converter.'		type: #Boolean>	^EncodeAndDecodeStdioFiles ifNil: [ true ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/4/2011 07:29'!encodeAndDecodeStdioFiles: aBoolean		EncodeAndDecodeStdioFiles := aBoolean.	self updateStdioFiles! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/23/2011 19:03'!flushAndVoidStdioFiles	StdioFiles ifNotNil: [		StdioFiles do: [ :file |			file ifNotNil: [ 				file isReadOnly ifFalse: [					[ file flush ]						on: Error						do: [ :ex | "care less" ] ] ] ].		self voidStdioFiles ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/30/2011 04:41'!new	^self basicNew initialize! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/4/2011 07:50'!newForStdio	"This is a hook for subclasses to initialize themselves properly."	^self new! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:19'!standardIOStreamNamed: moniker forWrite: forWrite		| index |	index := #(stdin stdout stderr) identityIndexOf: moniker.	^((StdioFiles ifNil: [ StdioFiles := Array new: 3 ]) at: index)		ifNil: [			StdioFiles				at: index 				put: (					(TheStdioHandles at: index)						ifNil: [ ^self error: moniker, ' is unavailable' ]						ifNotNil: [ :handle |							self stdioStreamClass newForStdio								openOnHandle: handle								name: moniker								forWrite: forWrite ]) ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:04'!stderr	^Stderr ifNil: [ Stderr := self standardIOStreamNamed: #stderr forWrite: true ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:03'!stdin	^Stdin ifNil: [ Stdin := self standardIOStreamNamed: #stdin forWrite: false ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/1/2011 09:16'!stdioHandles	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>	self primitiveFailed! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/4/2011 07:30'!stdioStreamClass	^self encodeAndDecodeStdioFiles		ifTrue: [ MultiByteFileStream ]		ifFalse: [ StandardFileStream ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:04'!stdout	^Stdout ifNil: [ Stdout := self standardIOStreamNamed: #stdout forWrite: true ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:16'!updateStdioFiles	"Make sure that all existing stdio files are instances of #stdioStreamClass."	StdioFiles ifNil: [ ^self ].	Stdin := Stdout := Stderr := nil.	StdioFiles := StdioFiles collect: [ :file |		file ifNotNil: [			file class == self stdioStreamClass				ifTrue: [ file ]				ifFalse: [					self stdioStreamClass newForStdio						copyFrom: file;						yourself ] ] ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/23/2011 19:03'!voidStdioFiles	 Stdin := Stdout := Stderr := StdioFiles := nil! !!FileStream class methodsFor: 'system startup' stamp: 'ul 1/4/2011 07:35'!shutDown: quitting	quitting ifTrue: [ self flushAndVoidStdioFiles ]! !!FileStream class methodsFor: 'system startup' stamp: 'ul 1/4/2011 07:37'!startUp: resuming		resuming ifTrue: [		self voidStdioFiles.		[ TheStdioHandles := self stdioHandles ]			on: Error			do: [:ex|				TheStdioHandles isArray ifFalse: [					TheStdioHandles := Array new: 3 ] ] ]! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'jcg 4/15/2010 16:27'!testFileTruncation	"Ensure that nextChunkPut:/nextChunk works properly on a caching file"	| file |	file := nil.	[			file := FileDirectory default forceNewFileNamed: 'TruncationTest.txt'.		file nextPutAll: '1234567890'.	] ensure: [file close].	[		file := FileDirectory default oldFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234567890'].		file truncate: 4.	] ensure: [file close].	[		file := FileDirectory default readOnlyFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234'].	] ensure: [		file close.		FileDirectory default deleteFileNamed: file name ifAbsent:[]	].! !!FileUrl methodsFor: 'copying' stamp: 'nice 10/2/2010 00:49'!postCopy	"Be sure not to share the path with the copy."	super postCopy.	path := path copy! !!FileUrl methodsFor: 'paths' stamp: 'nice 10/12/2010 20:58'!pathString	"Path as it appears in a URL with $/ as delimiter."		^String streamContents: [ :s |		"isAbsolute ifTrue:[ s nextPut: $/ ]."		self path			do: [ :p | s nextPutAll: p encodeForHTTP ]			separatedBy: [ s nextPut: $/]]! !!FlapTab methodsFor: 'event handling' stamp: 'sw 10/31/2001 15:46'!mouseMove: evt	| aPosition newReferentThickness adjustedPosition thick |	dragged ifFalse: [(thick := self referentThickness) > 0			ifTrue: [lastReferentThickness := thick]].	((self containsPoint: (aPosition := evt cursorPoint)) and: [dragged not])		ifFalse:			[flapShowing ifFalse: [self showFlap].			adjustedPosition := aPosition - evt hand targetOffset.			(edgeToAdhereTo == #bottom)				ifTrue:					[newReferentThickness := inboard						ifTrue:							[self world height - adjustedPosition y]						ifFalse:							[self world height - adjustedPosition y - self height]].			(edgeToAdhereTo == #left)					ifTrue:						[newReferentThickness :=							inboard								ifTrue:									[adjustedPosition x + self width]								ifFalse:									[adjustedPosition x]].			(edgeToAdhereTo == #right)					ifTrue:						[newReferentThickness :=							inboard								ifTrue:									[self world width - adjustedPosition x]								ifFalse:									[self world width - adjustedPosition x - self width]].			(edgeToAdhereTo == #top)					ifTrue:						[newReferentThickness :=							inboard								ifTrue:									[adjustedPosition y + self height]								ifFalse:									[adjustedPosition y]].					self isCurrentlySolid ifFalse:				[(#(left right) includes: edgeToAdhereTo)					ifFalse:						[self left: adjustedPosition x]					ifTrue:						[self top: adjustedPosition y]].			self applyThickness: newReferentThickness.			dragged := true.			self fitOnScreen.			self computeEdgeFraction]! !!FlapTab methodsFor: 'misc' stamp: 'nice 12/29/2010 14:43'!fitContents	self isCurrentlyTextual ifFalse: [^ super fitContents].	self ifVertical:		[self extent: submorphs first extent + (2 * self borderWidth) + (0 @ 4).		submorphs first position: self position + self borderWidth + (1 @ 4)]	ifHorizontal:		[self extent: submorphs first extent + (2 * self borderWidth) + (8 @ -1).		submorphs first position: self position + self borderWidth + (5 @ 1)]! !!Flaps class methodsFor: 'construction support' stamp: 'ul 8/2/2011 20:00'!addMorph: aMorph asElementNumber: aNumber inGlobalFlapSatisfying: flapBlock	"If any global flap satisfies flapBlock, add aMorph to it at the given position.  Applies to flaps that are parts bins and that like thumbnailing"	| aFlapTab flapPasteUp |	aFlapTab := self globalFlapTabsIfAny detect: flapBlock ifNone: [^ self].	flapPasteUp := aFlapTab referent.	flapPasteUp addMorph: aMorph asElementNumber: aNumber.	flapPasteUp replaceTallSubmorphsByThumbnails; setPartsBinStatusTo: true! !!Flaps class methodsFor: 'construction support' stamp: 'ul 8/2/2011 20:00'!deleteMorphsSatisfying: deleteBlock fromGlobalFlapSatisfying: flapBlock	"If any global flap satisfies flapBlock, then delete objects satisfying from deleteBlock from it.  Occasionally called from do-its in updates or other fileouts."	| aFlapTab flapPasteUp |	aFlapTab := self globalFlapTabsIfAny detect: flapBlock ifNone: [^ self].	flapPasteUp := aFlapTab referent.	flapPasteUp submorphs do:		[:aMorph | (deleteBlock value: aMorph) ifTrue: [aMorph delete]]! !!Flaps class methodsFor: 'replacement' stamp: 'ul 8/2/2011 20:01'!replacePartSatisfying: elementBlock inGlobalFlapSatisfying: flapBlock with: replacement	"If any global flap satisfies flapBlock, look in it for a part satisfying elementBlock; if such a part is found, replace it with the replacement morph, make sure the flap's layout is made right, etc."	| aFlapTab flapPasteUp anElement |	aFlapTab := self globalFlapTabsIfAny detect: flapBlock ifNone: [^ self].	flapPasteUp := aFlapTab referent.	anElement := flapPasteUp submorphs detect: elementBlock ifNone: [^ self].	flapPasteUp replaceSubmorph: anElement by: replacement.	flapPasteUp replaceTallSubmorphsByThumbnails; setPartsBinStatusTo: true."Flaps replacePartSatisfying: [:el |  (el isKindOf: MorphThumbnail) and: [(el morphRepresented isKindOf: SystemWindow) and: [el morphRepresented label = 'scripting area']]]inGlobalFlapSatisfying: [:fl | (fl submorphs size > 0) and:  [(fl submorphs first isKindOf: TextMorph) and: [(fl submorphs first contents string copyWithout: Character cr) = 'Tools']]] with: ScriptingSystem newScriptingSpace"! !!Float methodsFor: 'arithmetic' stamp: 'hh 10/3/2000 11:46'!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber isZero ifTrue: [^(ZeroDivide dividend: self) signal].	^ aNumber adaptToFloat: self andSend: #/! !!Float methodsFor: 'arithmetic' stamp: 'nice 8/21/2010 22:31'!abs	"This is faster than using Number abs and works for negativeZero."	self <= 0.0		ifTrue: [^ 0.0 - self]		ifFalse: [^ self]! !!Float methodsFor: 'converting' stamp: 'nice 4/23/2011 02:24'!withNegativeSign	"Same as super, but handle the subtle case of Float negativeZero"		self = 0.0 ifTrue: [^self class negativeZero].  	^super withNegativeSign! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:10'!arCosh	"Answer receiver's area hyperbolic cosine.	That is the inverse function of cosh."	self < 1 		ifTrue: 			[^DomainError signal: 'Receiver must be greater or equal to 1'].	^self + 1 = self 		ifTrue: [self abs ln + 2 ln]		ifFalse: [((self squared - 1) sqrt + self) ln]! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:10'!arSinh	"Answer receiver's area hyperbolic sine.	That is the inverse function of sinh."	self = 0.0 ifTrue: [^self].	"Handle negativeZero"  	^self + 1 = self 		ifTrue: [(self abs ln + 2 ln) * self sign]		ifFalse: [((self squared + 1) sqrt + self) ln]! !!Float methodsFor: 'mathematical functions' stamp: 'nice 5/4/2011 21:29'!arTanh	"Answer receiver's area hyperbolic tangent.	That is the inverse function of tanh."	self = 0.0 ifTrue: [^self].	"Handle negativeZero"	self abs = 1 ifTrue: [^self copySignTo: Float infinity].	self abs > 1 		ifTrue: 			[^DomainError signal: 'Receiver must be between -1.0 and 1.0'].	^((1 + self) / (1 - self)) ln / 2! !!Float methodsFor: 'mathematical functions'!arcCos	"Answer the angle in radians."	^ Halfpi - self arcSin! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:17'!arcSin	"Answer the angle in radians."	((self < -1.0) or: [self > 1.0]) ifTrue: [DomainError signal: 'arcSin only takes values between -1 and 1'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi * self]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]! !!Float methodsFor: 'mathematical functions'!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| theta eps step sinTheta cosTheta |	<primitive: 57>	"Newton-Raphson"	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"first guess"	theta := (self * Halfpi) / (self + 1.0).	"iterate"	eps := Halfpi * Epsilon.	step := theta.	[(step * step) > eps] whileTrue: [		sinTheta := theta sin.		cosTheta := theta cos.		step := (sinTheta * cosTheta) - (self * cosTheta * cosTheta).		theta := theta - step].	^ theta! !!Float methodsFor: 'mathematical functions' stamp: 'nice 10/30/2009 22:21'!arcTan: denominator	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive.	Implementation note: use sign in order to catch cases of negativeZero"	^self = 0.0		ifTrue: [denominator sign >= 0			ifTrue: [ 0 ]			ifFalse: [ self sign >= 0				ifTrue: [ Pi ]				ifFalse: [ Pi negated ]]]		ifFalse: [denominator = 0.0			ifTrue: [self > 0.0				ifTrue: [ Halfpi ]				ifFalse: [ Halfpi negated ]]			ifFalse: [denominator > 0				ifTrue: [ (self / denominator) arcTan ]				ifFalse: [self > 0					ifTrue: [ ((self / denominator) arcTan) + Pi ]					ifFalse: [ ((self / denominator) arcTan) - Pi ]]]]! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:26'!copySignTo: aNumber	"Return a number with same magnitude as aNumber and same sign as self.	Implementation note: take care of Float negativeZero, which is considered as having a negative sign."	(self > 0.0 or: [(self at: 1) = 0]) ifTrue: [^ aNumber abs].	^aNumber withNegativeSign! !!Float methodsFor: 'mathematical functions'!cos	"Answer the cosine of the receiver taken as an angle in radians."	^ (self + Halfpi) sin! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:35'!cosh	"Answer receivers hyperbolic cosine."		| ex |	ex := self abs exp.	^(ex + ex reciprocal) / 2! !!Float methodsFor: 'mathematical functions' stamp: 'nice 11/1/2010 11:56'!degreeCos	"Take care of exceptional values"		self isFinite ifTrue: [^super degreeCos].	^self degreesToRadians cos! !!Float methodsFor: 'mathematical functions' stamp: 'nice 11/1/2010 11:56'!degreeSin	"Take care of exceptional values"		self isFinite ifTrue: [^super degreeSin].	^self degreesToRadians sin! !!Float methodsFor: 'mathematical functions'!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	| base fract correction delta div |	<primitive: 59>	"Taylor series"	"check the special cases"	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].	self = 0.0 ifTrue: [^ 1].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power"	base := E raisedToInteger: (self truncated).	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract := self fractionPart.	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"	correction := 1.0 + fract.	delta := fract * fract / 2.0.	div := 2.0.	[delta > Epsilon] whileTrue: [		correction := correction + delta.		div := div + 1.0.		delta := delta * fract / div].	correction := correction + delta.	^ base * correction! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:16'!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [DomainError signal: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt := self exponent.	n := Ln2 * expt.	mant := self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x := mant - 1.0.	div := 1.0.	pow := delta := sum := x.	x := x negated.  "x <= 0"	eps := Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta.		"pass two: delta is negative"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Float methodsFor: 'mathematical functions'!log	"Answer the base 10 logarithm of the receiver."	^ self ln / Ln10! !!Float methodsFor: 'mathematical functions' stamp: 'jmv 10/13/2011 09:03'!nthRoot: aPositiveInteger	"Answer the nth root of the receiver."	aPositiveInteger = 2 ifTrue: [		^self sqrt ].	(aPositiveInteger isInteger not or: [ aPositiveInteger negative ])		ifTrue: [^ ArithmeticError signal: 'nth root only defined for positive Integer n.'].		^self negative		ifTrue: [			aPositiveInteger odd				ifTrue: [ (self negated raisedTo: 1.0 / aPositiveInteger) negated ]				ifFalse: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ]]		ifFalse: [ self raisedTo: 1.0 / aPositiveInteger ]! !!Float methodsFor: 'mathematical functions' stamp: 'jm 4/28/1998 01:10'!sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.	Handle IEEE-754 negative-zero by reporting a sign of -1"	self > 0 ifTrue: [^ 1].	(self < 0 or: [((self at: 1) bitShift: -31) = 1]) ifTrue: [^ -1].	^ 0! !!Float methodsFor: 'mathematical functions' stamp: 'nice 9/21/2010 23:30'!sign: aNumber	"Return a Number with the same sign as aNumber and same magnitude as self.	Implementation is different from super to handle the special case of Float negativeZero."	(self = 0.0 and: [aNumber sign negative]) ifTrue: [^Float negativeZero].	^aNumber copySignTo: self! !!Float methodsFor: 'mathematical functions'!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| sum delta self2 i |	<primitive: 56>	"Taylor series"	"normalize to the range [0..Pi/2]"	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^ (self \\ Twopi) sin].	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^ (Pi - self) sin].	"unroll loop to avoid use of abs"	sum := delta := self.	self2 := 0.0 - (self * self).	i := 2.0.	[delta > Epsilon] whileTrue: [		"once"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta.		"twice"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta].	^ sum! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 01:55'!sinh	"Answer receivers hyperbolic sine"		| ex |	ex := self abs exp.	^self copySignTo: (ex - ex reciprocal) / 2! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/22/2011 02:29'!sqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	"Newton-Raphson"	self <= 0.0		ifTrue: [self = 0.0				ifTrue: [^ 0.0]				ifFalse: ["v Chg"					^ DomainError signal: 'sqrt undefined for number less than zero.']].	"first guess is half the exponent"	exp := self exponent // 2.	guess := self timesTwoPower: 0 - exp.	"get eps value"	eps := guess * Epsilon.	eps := eps * eps.	delta := self - (guess * guess) / (guess * 2.0).	[delta * delta > eps]		whileTrue: 			[guess := guess + delta.			delta := self - (guess * guess) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'mathematical functions'!tan	"Answer the tangent of the receiver taken as an angle in radians."	^ self sin / self cos! !!Float methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:08'!tanh	"Answer hyperbolic tangent of receiver.	Trivial implementation is:		^self sinh/self cosh	This implementation takes care not to overflow."	| ex emx |	self = 0.0 ifTrue: [^self].	"Handle negativeZero"	self > 20.0 ifTrue: [^1.0].	self < -20.0 ifTrue: [^-1.0].	ex := self exp.	emx := ex reciprocal.	^(ex - emx) / (ex + emx)! !!Float methodsFor: 'mathematical functions'!timesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 54>	anInteger < -29 ifTrue: [^ self * (2.0 raisedToInteger: anInteger)].	anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].	^ self * (2.0 raisedToInteger: anInteger)! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:48'!absPrintExactlyOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version guarantees that the printed representation exactly represents my value	by using exact integer arithmetic."	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significand := self significandAsInteger.	roundingIncludesLimits := significand even.	exp := (self exponent - 52) max: MinValLogBase2.	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[significand ~= 16r10000000000000				ifTrue:					[r := significand bitShift: 1 + exp.					s := 2.					mPlus := mMinus := 1 bitShift: exp]				ifFalse:					[r := significand bitShift: 2 + exp.					s := 4.					mPlus := 2 * (mMinus := 1 bitShift: exp)]]		ifFalse:			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000])				ifTrue:					[r := significand bitShift: 1.					s := 1 bitShift: 1 - exp.					mPlus := mMinus := 1]				ifFalse:					[r := significand bitShift: 2.					s := 1 bitShift: 2 - exp.					mPlus := 2.					mMinus := 1]].	baseExpEstimate >= 0		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]		ifFalse:			[scale := base raisedToInteger: baseExpEstimate negated.			r := r * scale.			mPlus := mPlus * scale.			mMinus := mMinus * scale].	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[r := r * base.			mPlus := mPlus * base.			mMinus := mMinus * base].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	slowbit := 1 - s lowBit .	shead := s bitShift: slowbit.	[d := (r bitShift: slowbit) // shead.	r := r - (d * s).	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * base.		mPlus := mPlus * base.		mMinus := mMinus * base.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:32'!absPrintOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significantBits := 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase := base asFloat.	exp := self exponent.	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r := self.			s := 1.0.			mPlus := 1.0 timesTwoPower: exp - significantBits.			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r := self timesTwoPower: significantBits.			s := 1.0 timesTwoPower:  significantBits.			mMinus := 1.0 timesTwoPower: (exp max: -1024).			mPlus :=				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r := r / fBase.					s := s * (fBase raisedToInteger: baseExpEstimate - 1).					mPlus := mPlus / fBase.					mMinus := mMinus / fBase]				ifFalse:					[s := s * (fBase raisedToInteger: baseExpEstimate)]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale := fBase raisedToInteger: d.					r := r * scale.					mPlus := mPlus * scale.					mMinus := mMinus * scale.					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale := fBase raisedToInteger: baseExpEstimate negated].			s := s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[s := s / fBase].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	[d := (r / s) truncated.	r := r - (d * s).	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * fBase.		mPlus := mPlus * fBase.		mMinus := mMinus * fBase.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'printing' stamp: 'dtl 2/27/2011 21:39'!printPaddedWith: aCharacter to: aNumber 	"Answer the string containing the ASCII representation of the receiver 	padded on the left with aCharacter to be at least on aNumber 	integerPart characters and padded the right with aCharacter to be at 	least anInteger fractionPart characters."	| aStream digits fPadding fLen iPadding iLen curLen periodIndex |	#Numeric.	"2000/03/04  Harmon R. Added Date and Time support"	aStream := WriteStream on: (String new: 10).	self printOn: aStream.	digits := aStream contents.	periodIndex := digits indexOf: $..	curLen := periodIndex - 1.	iLen := aNumber integerPart.	curLen < iLen		ifTrue: [iPadding := (String new: (iLen - curLen) asInteger) atAllPut: aCharacter;					 yourself]		ifFalse: [iPadding := ''].	curLen := digits size - periodIndex.	"n.b. Treat aNumber as a string format specifier rather than as a number, because	floating point truncation can produce incorrect results for the fraction part."	fLen := (aNumber asString copyAfterLast: $. )		ifNotEmpty: [:s | s asInteger]		ifEmpty: [ 0 ].	curLen < fLen		ifTrue: [fPadding := (String new: fLen - curLen) atAllPut: aCharacter;					 yourself]		ifFalse: [fPadding := ''].	^ iPadding , digits , fPadding! !!Float methodsFor: 'truncation and round off'!fractionPart	"Primitive. Answer a Float whose value is the difference between the 	receiver and the receiver's asInteger value. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 52>	^self - self truncated asFloat! !!Float methodsFor: 'truncation and round off' stamp: 'nice 5/4/2011 21:45'!ulp	"Answer the unit of least precision of self (the power of two corresponding to last bit of mantissa)"		| exponent |	self isFinite ifFalse: [^self abs].	self = 0.0 ifTrue: [^Float fmin].	exponent := self exponent.	^exponent < self class emin		ifTrue: [Float fminDenormalized] 		ifFalse: [Float epsilon timesTwoPower: exponent]! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index 	"Avoid primitive in Object>>at:"	^self basicAt: index! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index put: value 	"Avoid primitive in Object>>at:put:"	^self basicAt: index put: value! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:34'!basicAt: index	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 38 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index].	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:35'!basicAt: index put: value	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 39 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index put: value].	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Float commentStamp: '<historical>' prior: 0!My instances represent IEEE-754 floating-point double-precision numbers.  They have about 16 digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:		8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:	3r20.2 --> 6.66666666666667	8r20.2 --> 16.25If you don't have access to the definition of IEEE-754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...	sign		1 bit	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent						in the range -1023 .. +1024				- 16r000:					significand = 0: Float zero					significand ~= 0: Denormalized number (exp = -1024, no hidden '1' bit)				- 16r7FF:					significand = 0: Infinity					significand ~= 0: Not A Number (NaN) representation	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE-754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.The single-precision format is...	sign		1 bit	exponent	8 bits, with bias of 127, to represent -126 to +127                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)	mantissa	24 bits, but only 23 are storedThis format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.Thanks to Rich Harmon for asking many questions and to Tim Olson, Bruce Cohen, Rick Zaccone and others for the answers that I have collected here.!!Float class methodsFor: 'class initialization' stamp: 'nice 3/15/2008 22:42'!initialize	"Float initialize"	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288		Pi/2 = 1.57079632679489661923132169163975144		Pi*2 = 6.28318530717958647692528676655900576		Pi/180 = 0.01745329251994329576923690768488612		2.0 ln = 0.69314718055994530941723212145817657		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi := 3.14159265358979323846264338327950288.	Halfpi := Pi / 2.0.	Twopi := Pi * 2.0.	ThreePi := Pi * 3.0.	RadiansPerDegree := Pi / 180.0.	Ln2 := 0.69314718055994530941723212145817657.	Ln10 := 10.0 ln.	Sqrt2 := 1.41421356237309504880168872420969808.	E := 2.718281828459045235360287471353.	Epsilon := 0.000000000001.  "Defines precision of mathematical functions"	MaxVal := 1.7976931348623157e308.	MaxValLn := 709.782712893384.	MinValLogBase2 := -1074.	Infinity := MaxVal * MaxVal.	NegativeInfinity := 0.0 - Infinity.	NaN := Infinity - Infinity.	NegativeZero := 1.0 / Infinity negated.! !!Float class methodsFor: 'constants' stamp: 'mtf 3/7/2011 10:42'!ln10	^ Ln10! !!Float class methodsFor: 'constants' stamp: 'mtf 3/7/2011 10:41'!ln2	^ Ln2! !!Float class methodsFor: 'constants' stamp: 'jmv 10/13/2011 19:57'!maxExactInteger	"Answer the biggest integer such that it is exactly represented in a float, and all smaller integers also are"	^1 bitShift: self precision! !!FloatArray methodsFor: 'arithmetic' stamp: 'ul 2/2/2011 23:42'!dot: aFloatVector	"Primitive. Return the dot product of the receiver and the argument.	Fail if the argument is not of the same size as the receiver."	| result |	<primitive: 'primitiveDotProduct' module: 'FloatArrayPlugin'>	self size = aFloatVector size ifFalse:[^self error:'Must be equal size'].	result := 0.0.	1 to: self size do:[:i|		result := result + ((self at: i) * (aFloatVector at: i)).	].	^result! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 12/14/2010 08:20'!normalize	"Unsafely normalize the receiver in-place (become a unit vector). 	 Div-by-Zero raised if len 0."	<primitive: 'primitiveNormalize' module: 'FloatArrayPlugin'>	self /= self length.! !!FloatTest methodsFor: 'testing - arithmetic' stamp: 'nice 10/14/2011 21:43'!testZeroRaisedToNegativePower	"this is a test related to http://bugs.squeak.org/view.php?id=6781"		self should: [0.0 raisedTo: -1] raise: ZeroDivide.	self should: [0.0 raisedTo: -1.0] raise: ZeroDivide.! !!FloatTest methodsFor: 'zero behavior' stamp: 'nice 4/23/2011 02:58'!testCopySign	self assert: (0.0 copySignTo: 1) = 1.	self assert: (Float negativeZero copySignTo: 1) = -1.	self assert: (-1 copySignTo: 0.0) = 0.0.	self assert: (-1 copySignTo: 0.0) sign = -1.	self assert: (1 copySignTo: Float negativeZero) sign = 0.! !!FloatTest methodsFor: 'zero behavior' stamp: 'nice 8/21/2010 22:29'!testNegativeZeroAbs	self assert: Float negativeZero abs sign positive description: 'the absolute value of a negative zero is zero'! !!FloatTest methodsFor: 'zero behavior' stamp: 'nice 8/21/2010 22:30'!testNegativeZeroSign	self assert: Float negativeZero sign = -1! !!FloatTest methodsFor: 'NaN behavior' stamp: 'StephaneDucasse 5/28/2011 13:45'!testNaN2	"Two NaN values are always considered to be different.	On an little-endian machine (32 bit Intel), Float nan is 16rFFF80000 16r00000000.	On a big-endian machine (PowerPC), Float nan is 16r7FF80000 16r00000000. Changing	the bit pattern of the first word of a NaN produces another value that is still	considered equal to NaN. This test should work on both little endian and big	endian machines. However, it is not guaranteed to work on future 64 bit versions	of Squeak, for which Float may have different internal representations."	"FloatTest new testNaN2"	| nan1 nan2 |	nan1 := Float nan copy.	nan2 := Float nan copy.	"test two instances of NaN with the same bit pattern"	self deny: nan1 = nan2.	self deny: nan1 == nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1.	"change the bit pattern of nan1"	self assert: nan1 size = 2.	self assert: (nan1 at: 2) = 0.	nan1 at: 1 put: (nan1 at: 1) + 999.	self assert: nan1 isNaN.	self assert: nan2 isNaN.	self deny: (nan1 at: 1) = (nan2 at: 1).	"test two instances of NaN with different bit patterns"	self deny: nan1 = nan2.	self deny: nan1 == nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 6/3/2011 21:28'!testCeiling	self assert: 1.0 ceiling = 1.	self assert: 1.1 ceiling = 2.	self assert: -2.0 ceiling = -2.	self assert: -2.1 ceiling = -2.! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 6/3/2011 21:29'!testFloor	self assert: 1.0 floor = 1.	self assert: 1.1 floor = 1.	self assert: -2.0 floor = -2.	self assert: -2.1 floor = -3.! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 7/15/2011 14:53'!testFractionAsFloatWithUnderflow	"test rounding to nearest even"	| underflowPower |	underflowPower := Float emin - Float precision.	self assert: (2 raisedTo: underflowPower) asFloat = 0.0.		self assert: (2 raisedTo: underflowPower) negated asFloat = 0.0.	self assert: (2 raisedTo: underflowPower) negated asFloat sign = -1 description: 'a negative underflow should return a negative zero'.! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 6/3/2011 21:37'!testRounded	self assert: 0.9 rounded = 1.	self assert: 1.0 rounded = 1.	self assert: 1.1 rounded = 1.	self assert: -1.9 rounded = -2.	self assert: -2.0 rounded = -2.	self assert: -2.1 rounded = -2.		"In case of tie, round to upper magnitude"	self assert: 1.5 rounded = 2.	self assert: -1.5 rounded = -2.! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 6/3/2011 21:34'!testTruncated	self assert: 1.0 truncated = 1.	self assert: 1.1 truncated = 1.	self assert: -2.0 truncated = -2.	self assert: -2.1 truncated = -2.! !!FloatTest methodsFor: 'printing' stamp: 'dtl 2/27/2011 21:01'!testPrintPaddedWithTo	"This bug was reported in http://lists.gforge.inria.fr/pipermail/pharo-users/2011-February/001569.html.	The problem was caused by treating the format specifier as a number rather than	as a string, such the the number may be a Float subject to floating point rounding	errors. The solution to treat the format specifier as a string, and extract the integer	fields before and after the decimal point in the string."	self assert: [(1.0 printPaddedWith: $0 to: 2.2) = '01.00'].	self assert: [(1.0 printPaddedWith: $X to: 2.2) = 'X1.0X'].	self assert: [(1.0 printPaddedWith: $0 to: 2) = '01.0'].	self assert: [(12345.6789 printPaddedWith: $0 to: 2) = '12345.6789'].	self assert: [(12345.6789 printPaddedWith: $0 to: 2.2) = '12345.6789'].	self assert: [(12.34 printPaddedWith: $0 to: 2.2) = '12.34'].	self assert: [(12345.6789 printPaddedWith: $0 to: 2.2) = '12345.6789'].	self assert: [(123.456 printPaddedWith: $X to: 4.4) = 'X123.456X'].	self assert: [(1.0 printPaddedWith: $0 to: 2.1) = '01.0'].	self assert: [(1.0 printPaddedWith: $0 to: 2.2) = '01.00'].	self assert: [(1.0 printPaddedWith: $0 to: 2.3) = '01.000']. "previously failed due to float usage"	self assert: [(1.0 printPaddedWith: $0 to: 2.4) = '01.0000']. "previously failed due to float usage"	self assert: [(1.0 printPaddedWith: $0 to: 2.5) = '01.00000']! !!FloatTest methodsFor: 'testing' stamp: 'jmv 10/11/2011 08:55'!testMaxExactInteger	"	FloatTest new testMaxExactInteger	"	self assert: Float maxExactInteger asFloat truncated = Float maxExactInteger.	0 to: 10000 do: [ :j |		self assert: (Float maxExactInteger-j) asFloat truncated = (Float maxExactInteger-j) ].	self deny: (Float maxExactInteger+1) asFloat truncated = (Float maxExactInteger+1)	! !!FloatTest methodsFor: 'testing' stamp: 'nice 9/22/2010 00:10'!testSign	"Set up"	| negatives negz positives strictNegatives strictPositives zero |	strictPositives := {2. 2.5. Float infinity}.	strictNegatives := {-3. -3.25. Float infinity negated}.	zero := 0.0.	negz := Float negativeZero.	positives := strictPositives copyWith: zero.	negatives := strictNegatives copyWith: negz.		"The sign of non zeros"	strictPositives do: [:aPositive | self assert: aPositive sign = 1].	strictNegatives do: [:aNegative | self assert: aNegative sign = -1].		"The sign of zeros"	self assert: zero sign = 0.	self assert: negz sign = -1. "remark though that negz >= 0.0, and is thus considered positive... Weird"		"Test the copy sign functions"	positives do: [:aPositiveSign |		positives do: [:aPositive | 			self assert: (aPositive sign: aPositiveSign) = aPositive].		negatives do: [:aNegative | 			self assert: (aNegative sign: aPositiveSign) = aNegative negated].		(zero sign: aPositiveSign) sign = 0.		(negz sign: aPositiveSign) sign = 0].		negatives do: [:aNegativeSign |		positives do: [:aPositive | 			self assert: (aPositive sign: aNegativeSign) = aPositive negated].		negatives do: [:aNegative | 			self assert: (aNegative sign: aNegativeSign) = aNegative].		(zero sign: aNegativeSign) sign = -1.		(negz sign: aNegativeSign) sign = -1].! !!FloatTest methodsFor: 'characterization' stamp: 'nice 5/6/2011 23:18'!testUlp	{Float pi predecessor. Float pi. Float pi successor} do:		[:f |		self assert: (f * 2) ulp = (f ulp * 2).		self assert: (f / 2) ulp = (f ulp / 2).		self deny: f + f ulp = f.		self deny: f - f ulp = f.		"Tests below are valid as long as default rounding mode (to nearest even) is used"		self assert: f significandAsInteger odd ==> (f ulp / 2.0 + f = f successor).		self assert: f significandAsInteger even ==> (f ulp / 2.0 + f = f)].		self assert: 0.0 ulp = Float fmin.	self assert: 1.0 ulp = Float epsilon.	self assert: Float nan ulp isNaN.	self assert: Float infinity ulp = Float infinity.	self assert: Float infinity negated ulp = Float infinity.	self assert: ((0 to: Float precision - 1) allSatisfy: [:each | (Float fmin timesTwoPower: each) ulp = Float fmin]).	! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 4/23/2011 02:55'!testArCosh	self assert: 1.0 arCosh = 0.0.	self deny: Float infinity arCosh isFinite.	self assert: (2.5 arCosh cosh closeTo: 2.5).! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 4/23/2011 02:53'!testArSinh	self assert: 0.0 arSinh = 0.0.	self assert: Float negativeZero arSinh = 0.0.	self assert: Float negativeZero arSinh sign = -1.	self deny: Float infinity arSinh isFinite.	self assert: (0.5 arSinh negated closeTo: 0.5 negated arSinh).	self assert: (0.5 arSinh sinh closeTo: 0.5).	self assert: (-2.5 arSinh sinh closeTo: -2.5).! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 4/23/2011 02:52'!testArTanh	self assert: 0.0 arTanh = 0.0.	self assert: Float negativeZero arTanh = 0.0.	self assert: Float negativeZero arTanh sign = -1.	self deny: 1 arTanh isFinite.	self assert: (0.5 arTanh negated closeTo: 0.5 negated arTanh).	self assert: (0.5 arTanh tanh closeTo: 0.5).	self assert: (-0.5 arTanh tanh closeTo: -0.5).! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 4/23/2011 02:49'!testCosh	self assert: (0.0 cosh closeTo: 1).	self deny: Float infinity cosh isFinite.	self assert: (2.0 cosh squared - 2.0 sinh squared closeTo: 1).	self assert: (2.0 cosh closeTo: 2.0 negated cosh).! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:50'!testDegreeCos		self shouldnt: [ 45.0 degreeCos] raise: Error.	"Following tests use approximate equality, because cosine are generally evaluated using inexact Floating point arithmetic"	self assert: (45.0 degreeCos squared - 0.5) abs <= Float epsilon.	self assert: (60.0 degreeCos - 0.5) abs <= Float epsilon.	self assert: (120.0 degreeCos + 0.5) abs <= Float epsilon.	-360.0 to: 360.0 do: [:i |		self assert: (i degreeCos closeTo: i degreesToRadians cos)].		"Following tests use strict equality which is a requested property of degreeCos"	-10.0 to: 10.0 do: [:k |		self assert: (k*360 + 90) degreeCos = 0.		self assert: (k*360 - 90) degreeCos = 0.		self assert: (k*360 + 180) degreeCos + 1 = 0.		self assert: (k*360) degreeCos - 1 = 0.].! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:49'!testDegreeCosForExceptionalValues	self assert: Float nan degreeCos isNaN.	self assert: Float infinity degreeCos isNaN.	self assert: Float infinity negated degreeCos isNaN.! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:51'!testDegreeSin		self shouldnt: [ 45.0 degreeSin] raise: Error.	"Following tests use approximate equality, because sine are generally evaluated using inexact Floating point arithmetic"	self assert: (45.0 degreeSin squared - 0.5) abs <= Float epsilon.	self assert: (30.0 degreeSin - 0.5) abs <= Float epsilon.	self assert: (-30.0 degreeSin + 0.5) abs <= Float epsilon.	-360.0 to: 360.0 do: [:i |		self assert: (i degreeSin closeTo: i degreesToRadians sin)].		"Following tests use strict equality which is a requested property of degreeSin"	-10.0 to: 10.0 do: [:k |		self assert: (k*360 + 90) degreeSin - 1 = 0.		self assert: (k*360 - 90) degreeSin + 1= 0.		self assert: (k*360 + 180) degreeSin = 0.		self assert: (k*360) degreeSin = 0.].! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:49'!testDegreeSinForExceptionalValues	self assert: Float nan degreeSin isNaN.	self assert: Float infinity degreeSin isNaN.	self assert: Float infinity negated degreeSin isNaN.! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 4/23/2011 02:48'!testSinh	self assert: 0.0 sinh = 0.0.	self assert: Float negativeZero sinh = 0.0.	self assert: Float negativeZero sinh sign = -1.	self deny: Float infinity sinh isFinite.	self assert: (2.0 cosh squared - 2.0 sinh squared closeTo: 1).	self assert: (2.0 sinh negated closeTo: 2.0 negated sinh).! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 4/23/2011 02:50'!testTanh	self assert: 0.0 tanh = 0.0.	self assert: Float negativeZero tanh = 0.0.	self assert: Float negativeZero tanh sign = -1.	self assert: (Float infinity tanh closeTo: 1).	self assert: (2.0 cosh squared - 2.0 sinh squared closeTo: 1).	self assert: (2.0 tanh negated closeTo: 2.0 negated tanh).! !!FloatTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 09:06'!testNthRoot	"	FloatTest new testNthRoot	"	self should: [ -1.23 nthRoot: 4 ] raise: ArithmeticError! !!FloatTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 09:06'!testRaisedTo	"	FloatTest new testRaisedTo	"	self should: [ -1.23 raisedTo: 1/4 ] raise: ArithmeticError! !!FloatingBookControlsMorph methodsFor: 'stepping and presenter' stamp: 'cmm 12/6/2010 16:19'!step	owner == self world ifFalse: [^ self].	owner addMorphInLayer: self.	self position: (owner bottomCenter) - ((self width//2)@self height)! !!Form methodsFor: 'display box access' stamp: 'tk 3/9/97'!center	"Note that offset is ignored here.  Are we really going to embrace offset?  "	^ (width @ height) // 2! !!Form methodsFor: 'display box access'!height	^ height! !!Form methodsFor: 'display box access'!width	^ width! !!Form methodsFor: 'filling' stamp: 'nice 12/29/2010 14:44'!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all := self boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBlt current toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0 @ 0 rule: Form erase.  "Clear any in black"	previousSmear := smearForm deepCopy.	count := 1.	[count = 10 and:   "check for no change every 10 smears"		[count := 1.		previousSmear copy: all from: 0 @ 0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1 @ 0 rule: Form under.			smearPort copyForm: smearForm to: -1 @ 0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0 @ 0 rule: Form erase.			smearPort copyForm: smearForm to: 0 @ 1 rule: Form under.			smearPort copyForm: smearForm to: 0 @ -1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0 @ 0 rule: Form erase.			count := count + 1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0 @ 0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:44'!fadeImageCoarse: otherImage at: topLeft	"Display fadeImageCoarse: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| d pix|	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask | | j |		i=1 ifTrue: [pix := (1 bitShift: d) - 1.					1 to: 8//d-1 do: [:q | pix := pix bitOr: (pix bitShift: d*4)]]			.		i <= 16 ifTrue:[		j := i-1//4+1.		(0 to: 28 by: 4) do: [:k |			mask bits at: j+k				put: (pix bitOr: (mask bits at: j+k))].		true]		ifFalse: [false]]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:45'!fadeImageFine: otherImage at: topLeft	"Display fadeImageFine: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| d pix|	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask | | j ii  |		i=1 ifTrue: [pix := (1 bitShift: d) - 1.					1 to: 8//d-1 do:						[:q | pix := pix bitOr: (pix bitShift: d*4)]].		i <= 16 ifTrue:		[ii := #(0 10 2 8 7 13 5 15 1 11 3 9 6 12 4 14) at: i.		j := ii//4+1.		(0 to: 28 by: 4) do:			[:k | mask bits at: j+k put:				((mask bits at: j+k) bitOr: (pix))].		true]		ifFalse: [false]]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 16:29'!fadeImageSquares: otherImage at: topLeft 	"Display fadeImageSquares: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: ((16-i) asPoint extent: (i*2) asPoint) fillColor: Color black.		i <= 16]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:53'!fadeImageVert: otherImage at: topLeft	"Display fadeImageVert: (Form fromDisplay: (10@10 extent: 300@300)) reverse at: 10@10"	| d |	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: ((mask width//2//d-i*d)@0 extent: i*2*d@mask height) fillColor: Color black.		i <= (mask width//d)]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:43'!fadeImage: otherImage at: topLeft	indexAndMaskDo: indexAndMaskBlock		"This fade uses halftones as a blending hack.	Zeros in the halftone produce the original image (self), and 	ones in the halftone produce the 'otherImage'.	IndexAndMaskBlock gets evaluated prior to each cycle,	and the resulting boolean determines whether to continue cycling."	| index imageRect maskForm resultForm pix returnPix|	imageRect := otherImage boundingBox.	resultForm := self copy: (topLeft extent: imageRect extent).	maskForm := Form extent: 32@32.	index := 0.	[indexAndMaskBlock value: (index := index+1) value: maskForm]	whileTrue:		[maskForm reverse.		resultForm copyBits: imageRect from: resultForm at: 0@0			clippingBox: imageRect rule: Form over fillColor: maskForm.		maskForm reverse.		resultForm copyBits: imageRect from: otherImage at: 0@0			clippingBox: imageRect rule: Form under fillColor: maskForm.		self copyBits: imageRect from: resultForm at: topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate]! !!Form methodsFor: 'transitions' stamp: 'nice 12/29/2010 14:46'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize := 10.	bb := otherImage boundingBox.	resultForm := self copy: (topLeft extent: bb extent).	maskForm := Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc := starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta := 1 @ 0.					maskLoc := bb topLeft - (corner = 1						ifTrue: [maskForm width @ 0]						ifFalse: [maskForm width @ stepSize])]					ifFalse:					["motion is to the left"					delta := -1 @ 0.					maskLoc := bb topRight - (corner = 2						ifTrue: [0 @ 0]						ifFalse: [0 @ stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta := 0 @ 1.					maskLoc := bb topLeft - (corner = 1						ifTrue: [0 @ maskForm height]						ifFalse: [stepSize @ maskForm height])]					ifFalse:					["motion is upward"					delta := 0 @ -1.					maskLoc := bb bottomLeft - (corner = 3						ifTrue: [stepSize @ 0]						ifFalse: [0 @ 0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) in: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0 @ 0; turn: 135; go: maskForm width * 3 // 2]			ifFalse: [p place: 0 @ (maskForm height - 1); turn: 45; go: maskForm width * 3 // 2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm := (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0 @ 0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel := #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize) + 1 do:		[:i |		"Determine the affected square"		maskRect := (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x * delta x) + (maskLoc y * delta y)) < 0 ifTrue:			[smallRect := 0 @ 0 extent: (maskRect width min: maskRect height) asPoint.			maskRect := smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0 @ 0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc := maskLoc + (delta * stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form methodsFor: '*Morphic' stamp: 'ar 11/7/1999 20:29'!asMorph	^ImageMorph new image: self! !!Form class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:09'!unload	FileServices unregisterFileReader: self ! !!Form class methodsFor: 'examples' stamp: 'ul 6/17/2011 12:37'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors := Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade := Form extent: diam@diam offset: (diam // -2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam // 2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x * diam // 5) displayOn: facade			at: (diam * 2 // 5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball := Form dotOfSize: diam.	color := 8.	[port := BitBlt current toForm: Display.	"Expand 1-bit forms to any pixel depth"	port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	queue := OrderedCollection new: 32.	16 timesRepeat: [queue addLast: -20 @ -20].	Sensor waitButton.	Sensor yellowButtonPressed ifTrue: [^ self].	filter := Sensor cursorPoint.	colr := colors atWrap: (color := color + 5).  "choose increment relatively prime to colors size"	colr2 := colr alphaMixed: 0.3 with: Color white.	[Sensor redButtonPressed or: [queue size > 0]] whileTrue:		[filter := filter * 4 + Sensor cursorPoint  //  5.		point := Sensor redButtonPressed			ifTrue: [filter] ifFalse: [-20 @ -20].		port copyForm: ball to: point rule: Form paint fillColor: colr.		(q := queue removeFirst) == nil ifTrue: [^ self].	"exit"		Display depth = 1			ifTrue: [port copyForm: facade to: q rule: Form erase]			ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].		Sensor redButtonPressed ifTrue: [queue addLast: point]]] repeat.! !!Form class methodsFor: 'examples' stamp: 'nice 12/29/2010 16:55'!xorHack: size  "Display restoreAfter: [Form xorHack: 256]"	"Draw a smiley face or stick figure, and end with option-click.	Thereafter image gets 'processed' as long as you have button down.	If you stop at just the right time, you'll see you figure upside down,	and at the end of a full cycle, you'll see it perfectly restored.	Dude -- this works in color too!!"	| rect form i bb |	rect := 5 @ 5 extent: size @ size.	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.	Display border: (rect topRight - (0 @ 2) extent: rect extent * 2 + 4) width: 2.	Form exampleSketch.	form := Form fromDisplay: rect.	bb := form boundingBox.	i := 0.	[Sensor yellowButtonPressed] whileFalse:		[[Sensor redButtonPressed] whileTrue:			[i := i + 1.			(Array with: 0 @ 1 with: 0 @ -1 with: 1 @ 0 with: -1 @ 0) do:				[:d | form copyBits: bb from: form at: d					clippingBox: bb rule: Form reverse fillColor: nil].			form displayAt: rect topLeft.			i+2\\size < 4 ifTrue: [(Delay forMilliseconds: 300) wait]].		(form magnify: form boundingBox by: 2 @ 2) displayAt: rect topRight + (2 @ 0).		Sensor waitButton].! !!Form class methodsFor: 'initialize-release' stamp: 'ar 9/5/2010 09:09'!initialize	FileServices registerFileReader: self! !!Form class methodsFor: 'mode constants' stamp: 'mt 11/16/2010 20:31'!blendAlphaScaled	"Answer the integer denoting BitBlt's blend-with-alpha-scaled rule."	^ 34! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ul 8/2/2011 20:01'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect := aClipRect.	patchRect := (aDisplayTransform globalBoundsToLocal: innerRect) truncated.	sourceQuad := (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas			translateBy: patchRect topLeft negated			during: aBlock.		warp sourceForm: subCanvas form; cellSize: cellSize; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!FormCanvas methodsFor: 'initialization' stamp: 'ar 12/30/2010 18:01'!reset	origin := 0@0.							"origin of the top-left corner of this cavas"	form ifNil:[		"This code path will never be executed after the changes in setForm:		are installed, so it can be removed in due time."		clipRect := (0@0 corner: 10000@10000).	] ifNotNil:[		clipRect := (0@0 corner: form extent).	"default clipping rectangle"	].	self shadowColor: nil.! !!FormCanvas methodsFor: 'private' stamp: 'bf 5/8/2011 16:40'!image: aForm at: aPoint sourceRect: sourceRect rule: rule 	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	port colorMap: (aForm colormapIfNeededFor: form); fillColor: nil.	port image: aForm at: aPoint + origin sourceRect: sourceRect rule: rule.	(form depth = 32 and: [aForm depth = 16])		ifTrue: [port image: nil at: aPoint + origin sourceRect: sourceRect rule: 40 "fixAlpha:with:"].! !!FormCanvas methodsFor: 'private' stamp: 'ar 12/30/2010 17:49'!setForm: aForm	form := aForm.	port := self portClass toForm: form.	self reset.! !!FormCanvas class methodsFor: 'instance creation' stamp: 'nk 7/4/2003 10:11'!extent: extent depth: depth origin: aPoint clipRect: aRectangle	^ self new		setForm: (Form extent: extent depth: depth);		setOrigin: aPoint clipRect: aRectangle;		yourself! !!FormCanvasTest methodsFor: 'tests' stamp: 'ar 12/30/2010 17:51'!testDefaultClipRect	self assert: (FormCanvas extent: 222@111) clipRect = (0@0 corner: 222@111).	self assert: (FormCanvas extent: 2222@11) clipRect = (0@0 corner: 2222@11).	self assert: (FormCanvas extent: 22222@1) clipRect = (0@0 corner: 22222@1).! !!FormHolderView methodsFor: 'menu messages' stamp: 'ul 9/28/2011 14:10'!cancel 	"Refer to the comment in FormView|cancel."	displayedForm becomeForward: model deepCopy.	displayedForm changed: self.	self display! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 11:40'!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex = 0 ifTrue: [^ self].	scale := self insetDisplayBox extent / model selection extent.	scale := (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self insetDisplayBox topLeft - model selection offset)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor! !!Fraction methodsFor: 'comparing' stamp: 'nice 6/11/2009 02:52'!hash	"Hash is reimplemented because = is implemented.	Care is taken that a Fraction equal to a Float also have an equal hash"	| tmp |	denominator isPowerOfTwo ifTrue: [		"If denominator is a power of two, I can be exactly equal to a Float"		tmp := self asFloat.		tmp isFinite ifTrue: [^tmp hash]].		"Else, I cannot be exactly equal to a Float, use own hash algorithm.	(Assume the fraction is already reduced)"	^numerator hash bitXor: denominator hash! !!Fraction methodsFor: 'converting' stamp: 'nice 9/7/2011 21:56'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Fraction."	^ (Fraction numerator: rcvr denominator: 1) perform: selector with: self! !!Fraction methodsFor: 'converting' stamp: 'nice 9/25/2011 12:47'!asFloat	"Answer a Float that closely approximates the value of the receiver.	This implementation will answer the closest floating point number to the receiver.	In case of a tie, it will use the IEEE 754 round to nearest even mode.	In case of overflow, it will answer +/- Float infinity."	| a b mantissa exponent hasTruncatedBits lostBit n ha hb hm |	a := numerator abs.	b := denominator.	"denominator is always positive"	ha := a highBit.	hb := b highBit.		"Number of bits to keep in mantissa plus one to handle rounding."	n := 1 + Float precision.	"If both numerator and denominator are represented exactly in floating point number,	then fastest thing to do is to use hardwired float division."	(ha < n and: [hb < n]) ifTrue: [^numerator asFloat / denominator asFloat].	"Shift the fraction by a power of two exponent so as to obtain a mantissa with n bits.	First guess is rough, the mantissa might have n+1 bits."	exponent := ha - hb - n.	exponent >= 0		ifTrue: [b := b bitShift: exponent]		ifFalse: [a := a bitShift: exponent negated].	mantissa := a quo: b.	hasTruncatedBits := a > (mantissa * b).	hm := mantissa highBit.		"Check for gradual underflow, in which case the mantissa will loose bits.	Keep at least one bit to let underflow preserve the sign of zero."	lostBit := Float emin - (exponent + hm - 1).	lostBit > 0 ifTrue: [n := n - lostBit max: 1].	"Remove excess bits in the mantissa."	hm > n		ifTrue:			[exponent := exponent + hm - n.			hasTruncatedBits := hasTruncatedBits or: [mantissa anyBitOfMagnitudeFrom: 1 to: hm - n].			mantissa := mantissa bitShift: n - hm].	"Check if mantissa must be rounded upward.	The case of tie (mantissa odd & hasTruncatedBits not)	will be handled by Integer>>asFloat."	(hasTruncatedBits and: [mantissa odd])		ifTrue: [mantissa := mantissa + 1].	^ (self positive			ifTrue: [mantissa asFloat]			ifFalse: [mantissa asFloat negated])		timesTwoPower: exponent! !!Fraction methodsFor: 'converting' stamp: 'wiz 5/29/2011 18:33'!asNonFraction		"Answer a number equivalent to the receiver that is not a fraction."	^self asFloat! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 11/1/2011 18:09'!ln	"This function is defined because super ln might overflow."	| res |	self <= 0 ifTrue: [DomainError signal: 'ln is only defined for x > 0'].	"Test self < 1 before converting to float in order to avoid precision loss due to gradual underflow."	numerator < denominator ifTrue: [^self reciprocal ln negated].	res := super ln.	res isFinite ifTrue: [^res].	^numerator ln - denominator ln! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 11/1/2011 18:08'!log	"This function is defined because super log might overflow."	| res |	self <= 0 ifTrue: [DomainError signal: 'log is only defined for x > 0'].	"Test self < 1 before converting to float in order to avoid precision loss due to gradual underflow."	numerator < denominator ifTrue: [^self reciprocal log negated].	res := super log.	res isFinite ifTrue: [^res].	^numerator log - denominator log! !!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 10/13/2011 21:38'!nthRoot: aPositiveInteger	"Answer the nth root of the receiver."	| d n |	n := numerator nthRoot: aPositiveInteger.	d := denominator nthRoot: aPositiveInteger.	"The #sqrt method in integer will only answer a Float if there's no exact square root.	So, we need a float anyway."	(n isInfinite or: [ d isInfinite ]) ifTrue: [		^self asFloat nthRoot: aPositiveInteger ].	^n / d! !!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 10/13/2011 20:16'!sqrt	| d n |	n := numerator sqrt.	d := denominator sqrt.	"The #sqrt method in integer will only answer a Float if there's no exact square root.	So, we need a float anyway."	(n isInfinite or: [ d isInfinite ]) ifTrue: [		^self asFloat sqrt ].	^n / d! !!Fraction methodsFor: 'printing' stamp: 'nice 3/29/2011 22:56'!printOn: aStream showingDecimalPlaces: placesDesired	"Same as super, but provides a faster implementation by inlining some Fraction protocol thus avoiding intermediate Fraction creation."		| roundedFractionPart integerPart scaling |	placesDesired <= 0		ifTrue: [self rounded printOn: aStream]		ifFalse:			[scaling := 10 raisedToInteger: placesDesired.			integerPart := numerator abs quo: denominator.			roundedFractionPart := (numerator abs - (integerPart * denominator)) * scaling * 2 + denominator quo: denominator * 2.			roundedFractionPart = scaling				ifTrue:					[integerPart := integerPart + 1.					roundedFractionPart := 0].			"Don't print minus sign if result is rouded to zero"			(numerator negative and: [integerPart > 0 or: [roundedFractionPart > 0]]) ifTrue: [aStream nextPut: $-].			integerPart printOn: aStream.			aStream nextPut: $..			roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true].! !!Fraction methodsFor: 'printing' stamp: 'nice 3/29/2011 21:45'!printTruncatedOn: aStream showingDecimalPlaces: placesDesired	"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator.	Print as if the receiver was truncated to requested precision."		| truncatedFractionPart integerPart scaling |	placesDesired <= 0		ifTrue: [self truncated printOn: aStream]		ifFalse:			[scaling := 10 raisedToInteger: placesDesired.			integerPart := numerator abs quo: denominator.			truncatedFractionPart := (numerator abs - (integerPart * denominator)) * scaling quo: denominator.			numerator negative ifTrue: [aStream nextPut: $-].			integerPart printOn: aStream.			aStream nextPut: $..			truncatedFractionPart printOn: aStream base: 10 length: placesDesired padded: true].! !!Fraction methodsFor: 'testing' stamp: 'ul 11/29/2010 20:05'!negative	^numerator negative! !!FractionTest methodsFor: 'tests - printing' stamp: 'nice 7/24/2010 18:43'!testFractionPrinting	self assert: (353/359) printString = '(353/359)'.	self assert: ((2/3) printStringBase: 2) = '(10/11)'.	self assert: ((2/3) storeStringBase: 2) = '(2r10/2r11)'.	self assert: ((5/7) printStringBase: 3) = '(12/21)'.	self assert: ((5/7) storeStringBase: 3) = '(3r12/3r21)'.	self assert: ((11/13) printStringBase: 4) = '(23/31)'.	self assert: ((11/13) storeStringBase: 4) = '(4r23/4r31)'.	self assert: ((17/19) printStringBase: 5) = '(32/34)'.	self assert: ((17/19) storeStringBase: 5) = '(5r32/5r34)'.	self assert: ((23/29) printStringBase: 6) = '(35/45)'.	self assert: ((23/29) storeStringBase: 6) = '(6r35/6r45)'.	self assert: ((31/37) printStringBase: 7) = '(43/52)'.	self assert: ((31/37) storeStringBase: 7) = '(7r43/7r52)'.	self assert: ((41/43) printStringBase: 8) = '(51/53)'.	self assert: ((41/43) storeStringBase: 8) = '(8r51/8r53)'.	self assert: ((47/53) printStringBase: 9) = '(52/58)'.	self assert: ((47/53) storeStringBase: 9) = '(9r52/9r58)'.	self assert: ((59/61) printStringBase: 10) = '(59/61)'.	self assert: ((59/61) storeStringBase: 10) = '(59/61)'.	self assert: ((67/71) printStringBase: 11) = '(61/65)'.	self assert: ((67/71) storeStringBase: 11) = '(11r61/11r65)'.	self assert: ((73/79) printStringBase: 12) = '(61/67)'.	self assert: ((73/79) storeStringBase: 12) = '(12r61/12r67)'.	self assert: ((83/89) printStringBase: 13) = '(65/6B)'.	self assert: ((83/89) storeStringBase: 13) = '(13r65/13r6B)'.	self assert: ((97/101) printStringBase: 14) = '(6D/73)'.	self assert: ((97/101) storeStringBase: 14) = '(14r6D/14r73)'.	self assert: ((103/107) printStringBase: 15) = '(6D/72)'.	self assert: ((103/107) storeStringBase: 15) = '(15r6D/15r72)'.	self assert: ((109/113) printStringBase: 16) = '(6D/71)'.	self assert: ((109/113) storeStringBase: 16) = '(16r6D/16r71)'.	self assert: ((127/131) printStringBase: 17) = '(78/7C)'.	self assert: ((127/131) storeStringBase: 17) = '(17r78/17r7C)'.	self assert: ((137/139) printStringBase: 18) = '(7B/7D)'.	self assert: ((137/139) storeStringBase: 18) = '(18r7B/18r7D)'.	self assert: ((149/151) printStringBase: 19) = '(7G/7I)'.	self assert: ((149/151) storeStringBase: 19) = '(19r7G/19r7I)'.	self assert: ((157/163) printStringBase: 20) = '(7H/83)'.	self assert: ((157/163) storeStringBase: 20) = '(20r7H/20r83)'.	self assert: ((167/173) printStringBase: 21) = '(7K/85)'.	self assert: ((167/173) storeStringBase: 21) = '(21r7K/21r85)'.	self assert: ((179/181) printStringBase: 22) = '(83/85)'.	self assert: ((179/181) storeStringBase: 22) = '(22r83/22r85)'.	self assert: ((191/193) printStringBase: 23) = '(87/89)'.	self assert: ((191/193) storeStringBase: 23) = '(23r87/23r89)'.	self assert: ((197/199) printStringBase: 24) = '(85/87)'.	self assert: ((197/199) storeStringBase: 24) = '(24r85/24r87)'.	self assert: ((211/223) printStringBase: 25) = '(8B/8N)'.	self assert: ((211/223) storeStringBase: 25) = '(25r8B/25r8N)'.	self assert: ((227/229) printStringBase: 26) = '(8J/8L)'.	self assert: ((227/229) storeStringBase: 26) = '(26r8J/26r8L)'.	self assert: ((233/239) printStringBase: 27) = '(8H/8N)'.	self assert: ((233/239) storeStringBase: 27) = '(27r8H/27r8N)'.	self assert: ((241/251) printStringBase: 28) = '(8H/8R)'.	self assert: ((241/251) storeStringBase: 28) = '(28r8H/28r8R)'.	self assert: ((257/263) printStringBase: 29) = '(8P/92)'.	self assert: ((257/263) storeStringBase: 29) = '(29r8P/29r92)'.	self assert: ((269/271) printStringBase: 30) = '(8T/91)'.	self assert: ((269/271) storeStringBase: 30) = '(30r8T/30r91)'.	self assert: ((277/281) printStringBase: 31) = '(8T/92)'.	self assert: ((277/281) storeStringBase: 31) = '(31r8T/31r92)'.	self assert: ((283/293) printStringBase: 32) = '(8R/95)'.	self assert: ((283/293) storeStringBase: 32) = '(32r8R/32r95)'.	self assert: ((307/311) printStringBase: 33) = '(9A/9E)'.	self assert: ((307/311) storeStringBase: 33) = '(33r9A/33r9E)'.	self assert: ((313/317) printStringBase: 34) = '(97/9B)'.	self assert: ((313/317) storeStringBase: 34) = '(34r97/34r9B)'.	self assert: ((331/337) printStringBase: 35) = '(9G/9M)'.	self assert: ((331/337) storeStringBase: 35) = '(35r9G/35r9M)'.	self assert: ((347/349) printStringBase: 36) = '(9N/9P)'.	self assert: ((347/349) storeStringBase: 36) = '(36r9N/36r9P)'.	self assert: ((-2/3) printStringBase: 2) = '(-10/11)'.	self assert: ((-2/3) storeStringBase: 2) = '(-2r10/2r11)'.	self assert: ((5 / -7) printStringBase: 3) = '(-12/21)'.	self assert: ((5 / -7) storeStringBase: 3) = '(-3r12/3r21)'.! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/31/2010 21:12'!testDegreeCos	"self run: #testDegreeCos"		self shouldnt: [ (4/3) degreeCos] raise: Error.	-361/3 to: 359/3 do: [:i |		self assert: (i degreeCos closeTo: i degreesToRadians cos)].! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/31/2010 21:15'!testDegreeSin	"self run: #testDegreeSin"		self shouldnt: [ (4/3) degreeSin] raise: Error.	-361/3 to: 359/3 do: [:i |		self assert: (i degreeSin closeTo: i degreesToRadians sin)].! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/11/2011 22:27'!testExactRaisedTo	"	FractionTest new testExactRaisedTo	"	| f |	self assert: (4/9 raisedTo: 1/2) classAndValueEquals: 2/3.	self assert: (9/4 raisedTo: 1/2) classAndValueEquals: 3/2.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [ :a :b |		f := a / b.		self assert: (f squared raisedTo: 1/2) classAndValueEquals: f.		self assert: (f negated squared raisedTo: 1/2) classAndValueEquals: f.		f := b / a.		self assert: (f squared raisedTo: 1/2) classAndValueEquals: f.		self assert: (f negated squared raisedTo: 1/2) classAndValueEquals: f ].	self assert: (8/27 raisedTo: 1/3) classAndValueEquals: 2/3.	self assert: (27/8 raisedTo: 1/3) classAndValueEquals: 3/2.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [ :a :b |		f := a / b.		self assert: ((f raisedTo: 3) raisedTo: 1/3) classAndValueEquals: f.		self assert: ((f negated raisedTo: 3) raisedTo: 1/3) classAndValueEquals: f negated.		f := b / a.		self assert: ((f raisedTo: 3) raisedTo: 1/3) classAndValueEquals: f.		self assert: ((f negated raisedTo: 3) raisedTo: 1/3) classAndValueEquals: f negated ].	self assert: (4/9 raisedTo: 3/2) classAndValueEquals: 8/27.	self assert: (8/27 raisedTo: 2/3) classAndValueEquals: 4/9.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [ :a :b |		f := a / b.		self assert: ((f raisedTo: 3) raisedTo: 2/3) classAndValueEquals: f*f.		self assert: ((f raisedTo: 2) raisedTo: 3/2) classAndValueEquals: f*f*f.		self assert: ((f negated raisedTo: 3) raisedTo: 2/3) classAndValueEquals: f*f.		self assert: ((f negated raisedTo: 2) raisedTo: 3/2) classAndValueEquals: f*f*f.		f := b / a.		self assert: ((f raisedTo: 3) raisedTo: 2/3) classAndValueEquals: f*f.		self assert: ((f raisedTo: 2) raisedTo: 3/2) classAndValueEquals: f*f*f.		self assert: ((f negated raisedTo: 3) raisedTo: 2/3) classAndValueEquals: f*f.		self assert: ((f negated raisedTo: 2) raisedTo: 3/2) classAndValueEquals: f*f*f ].	self assert: (32/243 raisedTo: 3/5) classAndValueEquals: 8/27.	self assert: (8/27 raisedTo: 5/3) classAndValueEquals: 32/243.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [ :a :b |		f := a / b.		self assert: ((f raisedTo: 5) raisedTo: 3/5) classAndValueEquals: f*f*f.		self assert: ((f raisedTo: 3) raisedTo: 5/3) classAndValueEquals: f*f*f*f*f.		self assert: ((f negated raisedTo: 5) raisedTo: 3/5) classAndValueEquals: (f*f*f) negated.		self assert: ((f negated raisedTo: 3) raisedTo: 5/3) classAndValueEquals: (f*f*f*f*f) negated.		self assert: ((f raisedTo: -5) raisedTo: 3/5) classAndValueEquals: 1/(f*f*f).		self assert: ((f raisedTo: -3) raisedTo: 5/3) classAndValueEquals: 1/(f*f*f*f*f).		self assert: ((f negated raisedTo: -5) raisedTo: 3/5) classAndValueEquals: -1/(f*f*f).		self assert: ((f negated raisedTo: -3) raisedTo: 5/3) classAndValueEquals: -1/(f*f*f*f*f).		self assert: ((f raisedTo: 5) raisedTo: -3/5) classAndValueEquals: 1/(f*f*f).		self assert: ((f raisedTo: 3) raisedTo: -5/3) classAndValueEquals: 1/(f*f*f*f*f).		self assert: ((f negated raisedTo: 5) raisedTo: -3/5) classAndValueEquals: -1/(f*f*f).		self assert: ((f negated raisedTo: 3) raisedTo: -5/3) classAndValueEquals: -1/(f*f*f*f*f).		"No exact result => Float result"		self assert: ((f raisedTo: 3) +1 raisedTo: 5/3) isFloat.		self assert: ((f negated raisedTo: 3) -1 raisedTo: 5/3) isFloat.		f := b / a.		self assert: ((f raisedTo: 5) raisedTo: 3/5) classAndValueEquals: f*f*f.		self assert: ((f raisedTo: 3) raisedTo: 5/3) classAndValueEquals: f*f*f*f*f.		self assert: ((f negated raisedTo: 5) raisedTo: 3/5) classAndValueEquals: (f*f*f) negated.		self assert: ((f negated raisedTo: 3) raisedTo: 5/3) classAndValueEquals: (f*f*f*f*f) negated.		"No exact result => Float result"		self assert: ((f raisedTo: 3) +1 raisedTo: 5/3) isFloat.		self assert: ((f negated raisedTo: 3) -1 raisedTo: 5/3) isFloat ].! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/11/2011 22:12'!testExactSqrt	"	FractionTest new testExactSqrt	"	| f |	self assert: (4/9) sqrt classAndValueEquals: 2/3.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [ :i :j |		f := i / j.		self assert: f squared sqrt classAndValueEquals: f.		f := j / i.		self assert: f squared sqrt classAndValueEquals: f ]! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 21:38'!testInexactRaisedTo	"	FractionTest new testInexactRaisedTo	"	self assert: (((1 << 1024 + 1) / (1 << 1024 + 3)) raisedTo: 1/3) = 1.0.	self assert: (((1 << 1024 + 1) / (1 << 1024 + 3)) negated raisedTo: 1/3) = -1.0! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 21:27'!testInexactSqrt	"	FractionTest new testInexactSqrt	"	self assert: ((1 << 1024 + 1) / (1 << 1024 + 3)) sqrt = 1.0! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:35'!testLn	self assert: ((1/100) ln closeTo: -2 * 10 ln).	self assert: (((2 raisedTo: Float emax + 11)/3) ln closeTo: (Float emax + 11)*2 ln - 3 ln) description: 'Fraction>>ln should not overflow'.	self assert: ((3/(2 raisedTo: Float precision - Float emin)) ln closeTo: (Float emin - Float precision)*2 ln + 3 ln) description: 'Fraction>>ln should not underflow'! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:37'!testLog	self assert: ((1/100) log closeTo: -2).	self assert: (((2 raisedTo: Float emax + 11)/3) log closeTo: (Float emax + 11)*2 log - 3 log) description: 'Fraction>>log should not overflow'.	self assert: ((3/(2 raisedTo: Float precision - Float emin)) log closeTo: (Float emin - Float precision)*2 log + 3 log) description: 'Fraction>>log should not underflow'! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/19/2011 20:48'!testNthRoot	self assert: ((-2 raisedTo: 35) / (3 raisedTo: 20) raisedTo: 1/5) equals: (-2 raisedTo: 7) / (3 raisedTo: 4).	self assert: (1 / (1 << 2000) raisedTo: 1/100) equals: 1 / (1 << 20)! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 21:49'!testRaisedToErrorConditions	"	FractionTest new testRaisedToErrorConditions	"	self should: [ (-1/16) raisedTo: 1/4 ] raise: ArithmeticError.	self should: [ ((1 << 1024 + 1) / (1 << 1024 + 3)) negated raisedTo: 1/4 ] raise: ArithmeticError! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 21:48'!testSqrtErrorConditions	"	FractionTest new testSqrtErrorConditions	"	self should: [ (-1/4) sqrt ] raise: DomainError.	self should: [ ((1 << 1024 + 1) / (1 << 1024 + 3)) negated sqrt ] raise: DomainError! !!FractionTest methodsFor: 'tests - conversions' stamp: 'nice 6/3/2011 21:32'!testCeiling	self assert: (3 / 2) ceiling = 2.	self assert: (-3 / 2) ceiling = -1.! !!FractionTest methodsFor: 'tests - conversions' stamp: 'nice 6/3/2011 21:32'!testFloor	self assert: (3 / 2) floor = 1.	self assert: (-3 / 2) floor = -2.! !!FractionTest methodsFor: 'tests - conversions' stamp: 'nice 6/3/2011 21:39'!testRounded	self assert: (4 / 5) rounded = 1.	self assert: (6 / 5) rounded = 1.	self assert: (-4 / 5) rounded = -1.	self assert: (-6 / 5) rounded = -1.		"In case of tie, round to upper magnitude"	self assert: (3 / 2) rounded = 2.	self assert: (-3 / 2) rounded = -2.! !!FractionTest methodsFor: 'tests - conversions' stamp: 'nice 6/3/2011 21:35'!testTruncated	self assert: (3 / 2) truncated = 1.	self assert: (-3 / 2) truncated = -1.! !!FractionTest methodsFor: 'private' stamp: 'jmv 10/11/2011 22:12'!assert: a classAndValueEquals: b	self assert: a class = b class.	self assert: a = b! !!FrameRateMorph methodsFor: 'stepping and presenter' stamp: 'ul 11/15/2010 11:40'!step	"Compute and display (every half second or so) the current framerate"	| now mSecs mSecsPerFrame framesPerSec newContents |	framesSinceLastDisplay := framesSinceLastDisplay + 1.	now := Time millisecondClockValue.	mSecs := now - lastDisplayTime.	(mSecs > 500 or: [mSecs < 0 "clock wrap-around"]) ifTrue: 		[mSecsPerFrame := mSecs // framesSinceLastDisplay.		framesPerSec := (framesSinceLastDisplay * 1000) // mSecs.		newContents := mSecsPerFrame printString, ' mSecs (', framesPerSec printString, ' frame', (framesPerSec = 1 ifTrue: [''] ifFalse: ['s']), '/sec)'.		self contents: newContents.		lastDisplayTime := now.		framesSinceLastDisplay := 0]! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block."	^effectNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	^effectNode emitCodeForEffect: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	^valueNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28'!sizeCodeForBlockValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForValue: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:27'!sizeCodeForEffect: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForEffect: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28'!sizeCodeForValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	valueNode := MessageNode new		receiver: receiver		selector: #futureSend:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^valueNode sizeCodeForValue: encoder! !!GZipReadStream class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 08:39'!unload	FileServices unregisterFileReader: self ! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'ul 6/17/2011 12:27'!saveContents: fullFileName	"Save the contents of a gzipped file"	| zipped buffer unzipped newName |	newName := fullFileName copyUpToLast: FileDirectory extensionDelimiter.	unzipped := FileStream newFileNamed: newName.	unzipped binary.	zipped := GZipReadStream on: (FileStream readOnlyFileNamed: fullFileName).	buffer := ByteArray new: 50000.	'Extracting ' , fullFileName		displayProgressFrom: 0		to: zipped sourceStream size		during: 			[:bar | 			[zipped atEnd]				whileFalse: 					[bar value: zipped sourceStream position.					unzipped nextPutAll: (zipped nextInto: buffer)].			zipped close.			unzipped close].	^ newName! !!GZipSurrogateStream commentStamp: 'nice 3/24/2010 07:36' prior: 0!A pseudo stream that allows SmartRefStream to write directly to a gzipped file. There are some peculiarities of the project exporting process that require:1. We ignore #close since the file is closed and may be reopened to continue writing. We implement #reallyClose for when we know that all writing is over.2. We use a BitBlt to write WordArrayForSegment objects. Bit of a hack, but there it is.| fileStream wa |wa := WordArrayForSegment new: 30000.1 to: wa size do: [ :i | wa at: i put: i].fileStream := GZipSurrogateStream newFileNamed: 'xxx3.gz' inDirectory: FileDirectory default.fileStream nextPutAll: 'this is a test'.fileStream nextPutAll: wa.fileStream reallyClose.!!GZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 08:39'!initialize	FileServices registerFileReader: self! !!GZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 08:39'!unload	FileServices unregisterFileReader: self! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/4/2010 15:10'!colorPickerFor: target getter: getterSymbol setter: setterSymbol 	^ NewColorPickerMorph useIt		ifTrue:			[ NewColorPickerMorph				on: target				originalColor: (target perform: getterSymbol)				setColorSelector: setterSymbol ]		ifFalse:			[ ColorPickerMorph new				 initializeForPropertiesPanel ;				 target: target ;				 selector: setterSymbol ;				 originalColor: (target perform: getterSymbol) ]! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/4/2010 14:26'!openNearTarget	self openNearMorph: myTarget! !!GradientFillStyle methodsFor: 'accessing' stamp: 'egp 3/6/2011 14:28'!pixelRamp"Compute a pixel ramp, and cache it for future accesses"^pixelRamp ifNil:[	"Insure the PixelRampCache is in place"	PixelRampCache ifNil:[ self class initPixelRampCache  ].	"Ask my cache for an existing instance if one is available"	pixelRamp := PixelRampCache at: colorRamp deepCopy	].! !!GradientFillStyle methodsFor: '*Morphic-Balloon' stamp: 'cmm 12/4/2010 15:10'!changeColorSelector: aSymbol hand: aHand morph: aMorph originalColor: originalColor 	"Change either the firstColor or the lastColor (depending on aSymbol).  Put up a color picker to hande it.  We always use a modal picker so that the user can adjust both colors concurrently."	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: originalColor				setColorSelector: aSymbol) openNear: aMorph fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 initializeModal: false ;				 sourceHand: aHand ;				 target: self ;				 selector: aSymbol ;				 argument: aMorph ;				 originalColor: originalColor ;								putUpFor: aMorph				near: aMorph fullBoundsInWorld ]! !!GradientFillStyleTest methodsFor: 'tests' stamp: 'egp 3/6/2011 15:38'!testLRUCacheHits	| gradient greenWhiteRamp redWhiteRamp |		"This test proves the bug fix where modifing the LRUCache key resulted in false 	cache hits. The affect was that a gradient could not be modifed from the user interface."		GradientFillStyle cleanUp.	gradient := GradientFillStyle new colorRamp: {0.0->Color red. 1.0->Color white}. 	redWhiteRamp := gradient pixelRamp.       	"Change the first color in colorRamp"      gradient firstColor: Color green forMorph: nil hand: nil. 	greenWhiteRamp := gradient pixelRamp.	"Ensure the pixelRamp has changed"        self assert: (redWhiteRamp ~= greenWhiteRamp).! !!GradientFillStyleTest commentStamp: 'egp 3/6/2011 15:10' prior: 0!This tests the LRUCache operation.!!GrafPort methodsFor: 'copying' stamp: 'jmv 3/2/2010 16:02'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31]) 		ifTrue: [			self copyBitsTranslucent: (alpha ifNil: [255])]		ifFalse: [super copyBits]! !!GraphicSymbolInstance class methodsFor: 'examples' stamp: 'nice 12/29/2010 16:53'!example	"Simply evaluate the method and two GraphicSymbolInstances, each	displaying a transformation of the same graphic symbol, will be	presented on the screen. Clears the screen to white."	| gate instance1 instance2 trans1 trans2 line arc f|	Display fillWhite.			"clear the Screen."	f := Form extent: 2 @ 2.	f fillBlack.	gate:= GraphicSymbol new.		"make a logic gate out of lines and arcs."	line:=Line new.  line beginPoint: -20 @ -20.  line endPoint: 0 @ -20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: -20 @ 20.  line endPoint: 0 @ 20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: 0 @ -40.  line endPoint: 0 @ 40. line form: f.	gate add: line.	arc := Arc new. arc center: 0 @ 0 radius: 40 quadrant: 1.	arc form: f.	gate add: arc.	arc := Arc new. arc center: 0 @ 0 radius: 40 quadrant: 4.	arc form: f.	gate add: arc.			"one instance at 1/2 scale."	trans1:=WindowingTransformation identity.		trans1:= trans1 scaleBy: 0.5 @ 0.5.	trans1:= trans1 translateBy: 100 @ 100.			"the other instance at 2 times scale"	trans2:=WindowingTransformation identity.		trans2:= trans2 scaleBy: 2.0 @ 2.0.	trans2:= trans2 translateBy: 200 @ 200.	instance1 := GraphicSymbolInstance new.	instance1 transformation: trans1.	instance1 graphicSymbol: gate.	instance2 := GraphicSymbolInstance new.	instance2 transformation: trans2.	instance2 graphicSymbol: gate.			"display both instances of the logic gate"	instance1 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil.	instance2 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil	"GraphicSymbolInstance example"! !!HColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 14:13'!color: aColor	"Ignore to preserve fill style."	! !!HColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:44'!defaultFillStyle	"Answer the hue gradient."	^(GradientFillStyle colors: ((0.0 to: 359.9 by: 0.1) collect: [:a | Color h: a s: 1.0 v: 1.0]))		origin: self topLeft;		direction: (self bounds isWide					ifTrue: [self width@0]					ifFalse: [0@self height])! !!HColorSelectorMorph commentStamp: 'gvc 5/18/2007 12:58' prior: 0!ColorComponentSelector showing a hue rainbow palette.!!HSVAColorSelectorMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:43'!aMorph	"The alpha-selector morph."	^ aMorph! !!HSVAColorSelectorMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:43'!aMorph: anAColorSelectorMorph	"The alpha-selector morph."	aMorph := anAColorSelectorMorph! !!HSVAColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/20/2006 14:05'!hsvMorph	"Answer the value of hsvMorph"	^ hsvMorph! !!HSVAColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/20/2006 14:05'!hsvMorph: anObject	"Set the value of hsvMorph"	hsvMorph := anObject! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 09:58'!alphaSelected: aFloat	"The alpha has changed."	self triggerSelectedColor! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 09:58'!colorSelected: aColor	"A color has been selected. Set the base color for the alpha channel."	self aMorph color: aColor.	self triggerSelectedColor! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 13:44'!defaultColor	"Answer the default color/fill style for the receiver."		^Color transparent! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 16:47'!initialize	"Initialize the receiver."	super initialize.	self		extent: 180@168;		changeTableLayout;		cellInset: 4;		aMorph: self newAColorMorph;		hsvMorph: self newHSVColorMorph;		addMorphBack: self hsvMorph;		addMorphBack: self aMorph.	self aMorph color: self hsvMorph selectedColor! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 10:11'!newAColorMorph	"Answer a new alpha color morph."	^AColorSelectorMorph new		model: self;		hResizing: #spaceFill;		vResizing: #rigid;		setValueSelector: #alphaSelected:;		extent: 24@24! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 14:00'!newHSVColorMorph	"Answer a new hue/saturation/volume color morph."	^HSVColorSelectorMorph new		hResizing: #spaceFill;		vResizing: #spaceFill;		when: #colorSelected send: #colorSelected: to: self! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 14:18'!selectedColor	"Answer the selected color."	^self hsvMorph selectedColor alpha: self aMorph value! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 11:12'!selectedColor: aColor	"Set the hue and sv components."	self aMorph value: aColor alpha.	self hsvMorph selectedColor: aColor asNontranslucentColor! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/3/2010 14:24'!triggerSelectedColor	"Trigger the event for the selected colour"	self		triggerEvent: #selectedColor		with: self selectedColor.	self changed: #selectedColor! !!HSVAColorSelectorMorph commentStamp: 'gvc 5/18/2007 12:55' prior: 0!Colour selector featuring a saturation/volume area, hue selection strip and alpha selection strip.!!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 16:28'!colorSelected: aColor	"A color has been selected. Make the hue match."	"self hMorph value: aColor hue / 360.	self svMorph basicColor: (Color h: aColor hue s: 1.0 v: 1.0)."	self triggerEvent: #colorSelected with: aColor! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 13:44'!defaultColor	"Answer the default color/fill style for the receiver."		^Color transparent! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 16:23'!hue: aFloat	"Set the hue in the range 0.0 - 1.0. Update the SV morph and hMorph."	self hMorph value: aFloat.	self svMorph color: (Color h: aFloat * 359.9 s: 1.0 v: 1.0)! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/26/2006 12:25'!initialize	"Initialize the receiver."	super initialize.	self		borderWidth: 0;		changeTableLayout;		cellInset: 4;		listDirection: #leftToRight;		cellPositioning: #topLeft;		svMorph: self newSVColorMorph;		hMorph: self newHColorMorph;		addMorphBack: self svMorph;		addMorphBack: self hMorph;		extent: 192@152;		hue: 0.5! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 12:33'!newHColorMorph	"Answer a new hue color morph."	^HColorSelectorMorph new		model: self;		setValueSelector: #hue:;		hResizing: #rigid;		vResizing: #spaceFill;		extent: 36@36! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 5/18/2007 12:54'!newSVColorMorph	"Answer a new saturation/volume color morph."	^SVColorSelectorMorph new		extent: 152@152;		hResizing: #spaceFill;		vResizing: #spaceFill;		when: #colorSelected send: #colorSelected: to: self! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 13:41'!selectedColor	"Answer the selected color."	^self svMorph selectedColor! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 13:38'!selectedColor: aColor	"Set the hue and sv components."	self hue: aColor hue / 360.	self svMorph selectedColor: aColor! !!HSVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/21/2006 13:30'!hMorph	"Answer the value of hMorph"	^ hMorph! !!HSVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/21/2006 13:30'!hMorph: anObject	"Set the value of hMorph"	hMorph := anObject! !!HSVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 12:26'!svMorph	"Answer the value of svMorph"	^ svMorph! !!HSVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 12:26'!svMorph: anObject	"Set the value of svMorph"	svMorph := anObject! !!HSVColorSelectorMorph commentStamp: 'gvc 5/18/2007 12:55' prior: 0!Colour selector featuring a saturation/volume area and a hue selection strip.!!HTTPClient class methodsFor: 'testing' stamp: 'mir 8/4/2003 13:44'!isRunningInBrowser: aBoolean	"Override the automatic process.	This should be used with caution.	One way to determine it without using the primitive is to check for parameters typically only encountered when running as a plugin."	RunningInBrowser := aBoolean! !!HTTPSocket commentStamp: 'ar 7/10/2010 14:05' prior: 0!HTTPSockets is a facade for handling common HTTP requests. It provides a minimal implementation of the HTTP protocol, but can be extended by third party clients that register themselves as #httpRequestHandler (see class-side protocol).A third-party request handler needs to implement the single method	#httpRequest:url:headers:content:response:in a way that is compatible with the baseline implementation in HTTPSocket.!!HTTPSocket class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 07:17'!defaultPort	"default port to connect on"	^80! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'ar 7/10/2010 13:59'!initialize	"HTTPSocket initialize"	HTTPPort := 80.	self httpProxyServer: nil.	HTTPBlabEmail := ''.  "	'From: somebody@no.where', CrLf	"	HTTPProxyCredentials := ''.	ExternalSettings registerClient: self.	self removeHTTPProxyPreferences.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/12/2010 18:54'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	args ifNotNil: [		urlString := urlString, (self argString: args) 	].	^(self httpRequestHandler) 		httpRequest: 'GET' url: urlString headers:(			(mimeType ifNil:[''] ifNotNil:['Accept: ', mimeType, String crlf]),			'Accept: text/html', String crlf,			HTTPProxyCredentials,			HTTPBlabEmail,			requestString		) content: nil response: nil.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/27/2010 12:21'!httpGet: url args: args user: user passwd: passwd	"Upload the contents of the stream to a file on the server.	WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| authorization result |	authorization := (user , ':' , passwd) base64Encoded.	result := self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf.	^result! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:52'!httpPost: url content: postData type: contentType accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	^(self httpRequestHandler) 		httpRequest: 'POST' url: urlString headers:(			'Accept: ', mimeType, String crlf,			'Accept: text/html', String crlf,			'Content-Type: ', contentType, String crlf,			'Content-Length: ', (postData ifNil:['']) size, String crlf,			HTTPProxyCredentials,			HTTPBlabEmail,			requestString "extra user request. Authorization"		) content: (postData ifNil:['']) response: nil! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 2/25/2010 15:49'!httpPostDocument: url  args: args accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| argString  |	args ifNotNil: [		argString := self argString: args.		argString first = $? ifTrue: [argString := argString allButFirst].	].	^self httpPost: url 			content: argString 			type: 'application/x-www-form-urlencoded' 			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/17/2010 20:31'!httpPostMultipart: url args: argsDict accept: mimeType request: requestString	" do multipart/form-data encoding rather than x-www-urlencoded "	| mimeBorder argsStream |	mimeBorder := '----squeak-georgia-tech-', Time millisecondClockValue printString, '-csl-cool-stuff-----'.	"encode the arguments dictionary"	argsStream := WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value | | fieldValue |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, String crlf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: multipart/form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue := value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', String crlf, 'Content-Type: ', value contentType.				fieldValue := (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: String crlf, String crlf, fieldValue, String crlf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	^self httpPost: url 			content: argsStream contents			type:  'multipart/form-data; boundary=', mimeBorder			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/17/2010 20:30'!httpPostToSuperSwiki: url args: argsDict accept: mimeType request: requestString	| mimeBorder argString |	mimeBorder := '---------SuperSwiki',Time millisecondClockValue printString,'-----'.	argString := String streamContents: [ :strm |		strm nextPutAll: mimeBorder, String crlf.		argsDict associationsDo: [:assoc |			assoc value do: [ :value |				strm					nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"';					nextPutAll: String crlf;					nextPutAll: String crlf;					nextPutAll: value;					nextPutAll: String crlf;					nextPutAll: String crlf;					nextPutAll: mimeBorder;					nextPutAll: String crlf.			]		].	].	^self httpPost: url 			content: argString 			type:  'multipart/form-data; boundary=', mimeBorder			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/27/2010 12:23'!httpPost: url args: args user: user passwd: passwd	"WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| authorization |	authorization := (user , ':' , passwd) base64Encoded.	^self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:53'!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server		WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| urlString resp header |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	resp := (self httpRequestHandler) 		httpRequest: 'PUT' url: urlString headers:(			'Authorization: Basic ', (user, ':', passwd) base64Encoded, String crlf,			'Accept: */*', String crlf,			'Content-Type: application/octet-stream', String crlf,			'Content-Length: ', (contents ifNil:['']) size, String crlf,			HTTPProxyCredentials,			HTTPBlabEmail		) content: contents response:[:rr| header := rr].	^resp isString ifTrue:[header, resp] ifFalse:[header, resp content]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 9/4/2010 10:47'!httpRequest: method url: urlString headers: hdrs content: contentOrNil response: responseBlock	"Sends an HTTP request to the server. Returns a MIMEDocument if successful,	a string indicating the error otherwise. If a response block is provided, the	response is fed into into so that the sender can see all the headers.	The url string is assumed to be properly escaped by the sender."	| index serverAndPort server port rawUrl stream resp code headers 	  contentLength contentType contentStream |	(urlString beginsWith: 'http://') ifFalse:[self error: 'Not a http url'].	"Extract server, port, and url"	index := urlString indexOf: $/ startingAt: 8 ifAbsent:[urlString size+1]. "past http://"	serverAndPort := urlString copyFrom: 8 to: index-1.	server := serverAndPort copyUpTo: $:.	port := ((serverAndPort copyAfter: $:) ifEmpty:['80']) asNumber.	"Prepare the request URI"	rawUrl := urlString copyFrom: index to: urlString size.	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].	"Check for proxy"	(self shouldUseProxy: server) ifTrue:[		self httpProxyServer ifNotEmpty:[			rawUrl := 'http://', serverAndPort, rawUrl. "per RFC 2616"			server := self httpProxyServer.			port := self httpProxyPort.		].	].	"Fire off the request"	stream := SocketStream openConnectionToHostNamed: server port: port.	stream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: 'HTTP/1.0'; crlf.	stream nextPutAll: 'Host: ', serverAndPort; crlf.	stream nextPutAll: 'Connection: close'; crlf.	stream nextPutAll: 'User-Agent: ', self userAgentString; crlf.	stream nextPutAll: hdrs.	stream crlf.	contentOrNil ifNotNil:[		"Upload request content"		contentStream := contentOrNil readStream.		[contentStream atEnd] whileFalse:[			(HTTPProgress new) total: contentOrNil size; 				amount: contentStream position; signal: 'Uploading...'.			stream nextPutAll: (contentStream next: 4096).			stream flush.		].	].	stream flush.	"Read the response"	resp := stream upToAll: String crlfcrlf.	"Extract the response code"	code := ((resp copyUpTo: String cr) findTokens: ' ') second asNumber.	"And the response headers"	headers := Dictionary new.	resp lines allButFirst allButLast do:[:nextLine|		headers at: (nextLine copyUpTo: $:) asLowercase 			put: (nextLine copyAfter: $:) withBlanksTrimmed.	].	"Read response content"	contentLength := headers at: 'content-length' ifAbsent:[nil].	contentType := headers at: 'content-type' ifAbsent:['application/octet-stream'].	"Fixme - Provide HTTProgress"	contentLength 		ifNil:[contentStream := WriteStream with: stream upToEnd]		ifNotNil:[			contentLength := contentLength asNumber.			contentStream := (String new: contentLength) writeStream. 			[contentStream position < contentLength] whileTrue:[				contentStream nextPutAll: 					(stream next: (contentLength - contentStream position min: 4096)).				(HTTPProgress new) total: contentLength; 					amount: contentStream position; signal: 'Downloading...'.			].		].	stream close.	responseBlock ifNotNil:[responseBlock value: resp].	^(code between: 200 and: 299) 		ifTrue:[MIMEDocument contentType: contentType 				content: contentStream contents url: urlString]		ifFalse:[resp asString, contentStream contents].! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42'!httpProxyPort	"answer the httpProxyPort"	<preference: 'HTTP Proxy Port'		category: 'HTTP Proxy'		description: 'HTTP Proxy Port'		type: #Number>	^HTTPProxyPort ifNil:[80]! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42'!httpProxyPort: aPortNumber	"Set the proxy port"	HTTPProxyPort := aPortNumber.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42'!httpProxyServer	"answer the httpProxyServer. Take into account that as a Preference the Server might appear as an empty string but HTTPSocket expect it to be nil"	<preference: 'HTTP Proxy Server'		category: 'HTTP Proxy'		description: 'HTTP Proxy Server. Leave blank if you don''t want to use a Proxy'		type: #String>	^HTTPProxyServer ifNil:['']! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:43'!httpProxyServer: aString	"answer the httpProxyServer. Take into account that as a Preference the Server might appear as an empty string but HTTPSocket expect it to be nil"	HTTPProxyServer := aString.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 7/10/2010 14:01'!removeHTTPProxyPreferences	" This method will remove the old HTTP Proxy preferences. "	(Preferences valueOfPreference: #httpProxyServer) ifNotNil:[		HTTPProxyServer := Preferences valueOfPreference: #httpProxyServer.		Preferences removePreference: #httpProxyServer.	].	(Preferences valueOfPreference: #httpProxyPort) ifNotNil:[		HTTPProxyPort := Preferences valueOfPreference: #httpProxyPort.		Preferences removePreference: #httpProxyPort.	].! !!HTTPSocket class methodsFor: 'handler' stamp: 'ar 7/10/2010 13:34'!httpRequestHandler	"Answer the registered handler for http requests. The handler needs to implement 	#httpRequest:url:headers:content:response: compatible with the baseline version	in HTTPSocket. If no handler is registered, answer the receiver"	^HTTPRequestHandler ifNil:[self]! !!HTTPSocket class methodsFor: 'handler' stamp: 'ar 7/10/2010 13:35'!httpRequestHandler: anObject	"Set the registered handler for http requests. The handler needs to implement 	#httpRequest:url:headers:content:response: compatible with the baseline version	in HTTPSocket."	HTTPRequestHandler := anObject! !!HaloMorph methodsFor: 'drawing' stamp: 'cmm 1/10/2011 14:58'!drawOn: aCanvas 	"Draw this morph only if it has no target."	target isNil		ifTrue: [^ super drawOn: aCanvas].	(Preferences showBoundsInHalo			and: [target isWorldMorph not])		ifTrue: [| boundsColor |			boundsColor := Preferences menuSelectionColor						ifNil: [Color blue].			aCanvas				frameAndFillRectangle: self bounds				fillColor: Color transparent				borderWidth: 2				borderColor: 					(boundsColor isTranslucent						ifTrue: [boundsColor]						ifFalse: [boundsColor alpha: 0.8])]! !!HaloMorph methodsFor: 'event handling' stamp: 'cmm 11/7/2011 22:28'!mouseMove: evt	"Drag our target around or resize it"	growingOrRotating		ifTrue: [			| oldExtent newExtent newPosition |			newExtent := originalExtent + (evt position - positionOffset * 2).			(newExtent x > 1 and: [newExtent y > 1])				ifTrue: [					oldExtent := target extent.					target setExtentFromHalo: (newExtent min: owner extent).					newPosition := target position - (target extent - oldExtent // 2).					newPosition := (newPosition x min: owner extent x - newExtent x max: 0) @ (newPosition y min: owner extent y - newExtent y max: 0).					target setConstrainedPosition: newPosition hangOut: true]]		ifFalse: [			| thePoint |			thePoint := target point: (evt position - positionOffset) from: owner.			target setConstrainedPosition: thePoint hangOut: true.		]! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:56'!dragTarget: event	"Begin dragging the target"	| thePoint |	event controlKeyPressed ifTrue: [^self growTarget: event].	growingOrRotating := false.	thePoint := target point: event position - positionOffset from: owner.	target setConstrainedPosition: thePoint hangOut: true.	event hand newMouseFocus: self.! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:44'!growTarget: event	"Begin resizing the target"	growingOrRotating := true.	positionOffset := event position.	originalExtent := target extent.	self removeAllHandlesBut: nil.	event hand newMouseFocus: self.	event hand addMouseListener: self. "add handles back on mouse-up"! !!HaloMorph methodsFor: 'geometry testing' stamp: 'jmv 3/2/2010 16:02'!containsPoint: aPoint 	"This method is overridden so that, once up, the handles will stay up as long as the mouse is within the box that encloses all the handles even if it is not over any handle or over its owner."	^target		ifNil: [super containsPoint: aPoint] 		ifNotNil: [false]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:26'!doDupOrMakeSibling: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *not* pressed, or make a sibling if shift key *is* pressed"	^ (evt shiftPressed and: [target couldMakeSibling])		ifTrue:			[dupHandle color: Color green muchDarker.			self doMakeSibling: evt with: dupHandle]		ifFalse:			[self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:28'!doMakeSiblingOrDup: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *is* pressed, or make a sibling if shift key *not* pressed"	^ (evt shiftPressed or: [target couldMakeSibling not])		ifFalse:			[self doMakeSibling: evt with: dupHandle]		ifTrue:			[dupHandle color: Color green.			self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'meta-actions' stamp: 'mtf 2/20/2011 20:41'!blueButtonDown: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	event hand obtainHalo: self.	positionOffset := event position - (target point: target position in: owner).	self isMagicHalo ifTrue:[		self isMagicHalo: false.		^self magicAlpha: 1.0].	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		selectors: { #transferHalo:. nil. nil. #dragTarget:. }		threshold: HandMorph dragThreshold! !!HaloMorph methodsFor: 'private' stamp: 'cmm 1/10/2011 14:59'!addHandleAt: aPoint color: aColor icon: iconName on: eventName send: selector to: recipient 	"Add a handle centered at the given point with the given color, 	and set it up to respond to the given event by sending the 	given selector to the given recipient. Return the handle."	| handle |	handle := self createHandleAt: aPoint color: (aColor alpha: 0.8) iconName: iconName.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.	^ handle ! !!HaloMorph methodsFor: 'private' stamp: 'cmm 1/10/2011 15:00'!createHandleAt: aPoint color: aColor iconName: iconName 	| bou handle |	bou := Rectangle center: aPoint extent: self handleSize asPoint.	Preferences alternateHandlesLook		ifTrue: [handle := RectangleMorph newBounds: bou color: aColor.			handle useRoundedCorners.			self setColor: aColor toHandle: handle]		ifFalse: [handle := EllipseMorph newBounds: bou color: aColor].	handle borderWidth: 0;		 wantsYellowButtonMenu: false.	""	iconName isNil		ifFalse: [| form |			form := ScriptingSystem formAtKey: iconName.			form isNil				ifFalse: [| image |					image := ImageMorph new.					image image: form.					image color: aColor makeForegroundColor.					image lock.					handle addMorphCentered: image]].	""	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'nk 9/4/2004 17:38'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	(target isSelectionMorph) ifTrue:		[^ target doDup: evt fromHalo: self handle: dupHandle].	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dupHandle.	self setTarget: (target duplicateMorph: evt).	evt hand grabMorph: target.	self step. "update position if necessary"	evt hand addMouseListener: self. "Listen for the drop"! !!HaloMorph methodsFor: 'private' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!mouseDownInDimissHandle: evt with: dismissHandle	evt hand obtainHalo: self.	SoundService soundEnabled ifTrue: [TrashCanMorph playMouseEnterSound].	self removeAllHandlesBut: dismissHandle.	self setColor: Color darkGray toHandle: dismissHandle.! !!HandMorph methodsFor: 'cursor' stamp: 'ar 6/17/2010 17:01'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset 	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	temporaryCursorOffset 		ifNotNil: [bounds := bounds translateBy: temporaryCursorOffset negated].	cursorOrNil isNil 		ifTrue: [temporaryCursor := temporaryCursorOffset := hardwareCursor := nil]		ifFalse: 			[temporaryCursor := cursorOrNil asCursorForm.			temporaryCursorOffset := temporaryCursor offset - hotSpotOffset.			(cursorOrNil isKindOf: Cursor) ifTrue: [hardwareCursor := cursorOrNil]].	bounds := self cursorBounds.	self		userInitials: userInitials andPicture: self userPicture;		layoutChanged;		changed;		showHardwareCursor: (temporaryCursor isNil).! !!HandMorph methodsFor: 'double click support' stamp: 'mtf 2/20/2011 20:41'!waitForClicksOrDrag: aMorph event: evt	"Wait for mouse button and movement events, informing aMorph about events interesting to it via callbacks.	This message is typically sent to the Hand by aMorph when it first receives a mouse-down event.	The callback methods invoked on aMorph (which are passed a copy of evt) are:		#click:	sent when the mouse button goes up within doubleClickTime.		#doubleClick:	sent when the mouse goes up, down, and up again all within DoubleClickTime.		#doubleClickTimeout:  sent when the mouse does not have a doubleClick within DoubleClickTime.		#startDrag:	sent when the mouse moves more than 10 pixels from evt's position within DoubleClickTime.	Note that mouseMove: and mouseUp: events are not sent to aMorph until it becomes the mouse focus,	which is typically done by aMorph in its click:, doubleClick:, or drag: methods."		^self waitForClicksOrDrag: aMorph event: evt selectors: #( #click: #doubleClick: #doubleClickTimeout: #startDrag:) threshold: HandMorph dragThreshold! !!HandMorph methodsFor: 'drawing' stamp: 'bf 5/23/2011 12:05'!fullDrawOn: aCanvas 	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds roundCorners rounded |	self visible ifFalse: [^self].	(aCanvas isVisible: self fullBounds) ifFalse: [^self].	(self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].	disableCaching := false.	disableCaching 		ifTrue: 			[self nonCachingFullDrawOn: aCanvas.			^self].	submorphs isEmpty 		ifTrue: 			[cacheCanvas := nil.			^self drawOn: aCanvas].	"just draw the hand itself"	subBnds := Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvas: aCanvas.	(cacheCanvas isNil 		or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]]) 			ifTrue: 				["could not use caching due to translucency; do full draw"				self nonCachingFullDrawOn: aCanvas.				^self].	"--> begin rounded corners hack <---"	roundCorners := cachedCanvasHasHoles == false 				and: [submorphs size = 1 and: [submorphs first wantsRoundedCorners]].	roundCorners 		ifTrue: 			[rounded := submorphs first.			aCanvas asShadowDrawingCanvas translateBy: self shadowOffset				during: 					[:shadowCanvas | 					shadowCanvas roundCornersOf: rounded						during: 							[(subBnds areasOutside: (rounded boundsWithinCorners 										translateBy: self shadowOffset negated)) 								do: [:r | shadowCanvas fillRectangle: r color: Color black]]].			aCanvas roundCornersOf: rounded				during: 					[aCanvas 						drawImage: cacheCanvas form						at: subBnds origin						sourceRect: cacheCanvas form boundingBox].			^self drawOn: aCanvas	"draw the hand itself in front of morphs"].	"--> end rounded corners hack <---"	"draw the shadow"	aCanvas asShadowDrawingCanvas translateBy: self shadowOffset		during: 			[:shadowCanvas | 			cachedCanvasHasHoles 				ifTrue: 					["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]				ifFalse: 					["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) 						do: [:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	cachedCanvasHasHoles 		ifTrue: [aCanvas paintImage: cacheCanvas form at: subBnds origin]		ifFalse: 			[aCanvas 				drawImage: cacheCanvas form				at: subBnds origin				sourceRect: cacheCanvas form boundingBox].	self drawOn: aCanvas	"draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 17:00'!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil		or: [ (submorphs anySatisfy: [ :ea | ea visible ])			or: [ (temporaryCursor notNil and: [hardwareCursor isNil])				or: [ self hasUserInformation ]]])		ifTrue: [			"using the software cursor; hide the hardware one"			self showHardwareCursor: false.			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:28'!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged := false.	savedPatch ifNotNil: 			[aCanvas drawImage: savedPatch at: savedPatch offset.			self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"			submorphs notEmpty ifTrue: [^self].			(temporaryCursor notNil and: [hardwareCursor isNil]) ifTrue: [^self].			"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset 						extent: savedPatch extent + self shadowOffset)				from: self.			self showHardwareCursor: true.			savedPatch := nil]! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:52'!showHardwareCursor: aBool	"Show/hide the current hardware cursor as indicated."	| cursor |	cursor :=  hardwareCursor ifNil:[aBool ifTrue:[Cursor normal] ifFalse:[Cursor blank]].	Sensor currentCursor == cursor ifFalse: [cursor show].! !!HandMorph methodsFor: 'private events' stamp: 'bf 9/29/2011 11:01'!generateKeyboardEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type pressType stamp keyValue |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	modifiers := evtBuf fifth.	buttons := (modifiers bitShift: 3) bitOr: (lastMouseEvent buttons bitAnd: 7).	type = #keystroke		ifTrue: [keyValue := (self keyboardInterpreter nextCharFrom: Sensor firstEvt: evtBuf) asInteger]		ifFalse: [keyValue := evtBuf third].	^ KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: keyValue		hand: self		stamp: stamp.! !!HandMorph methodsFor: 'private events' stamp: 'mka 2/21/2009 20:00'!generateMouseEvent: evtBuf 	"Generate the appropriate mouse event for the given raw event buffer"	| position buttons modifiers type trail stamp oldButtons evtChanged |	evtBuf first = lastEventBuffer first 		ifTrue: 			["Workaround for Mac VM bug, *always* generating 3 events on clicks"			evtChanged := false.			3 to: evtBuf size				do: [:i | (lastEventBuffer at: i) = (evtBuf at: i) ifFalse: [evtChanged := true]].			evtChanged ifFalse: [^nil]].	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	position := evtBuf third @ evtBuf fourth.	buttons := evtBuf fifth.	modifiers := evtBuf sixth.	type := buttons = 0 		ifTrue:[				lastEventBuffer fifth = 0 							ifTrue: [#mouseMove] 	"this time no button and previously no button .. just mouse move"					ifFalse: [#mouseUp]		"this time no button but previously some button ... therefore button was released"		]		ifFalse:[				buttons = lastEventBuffer fifth						ifTrue: [#mouseMove]		"button states are the same .. now and past .. therfore a mouse movement"						ifFalse: [					"button states are different .. button was pressed or released"							buttons > lastEventBuffer fifth								ifTrue: [#mouseDown]								ifFalse:[#mouseUp].						].		].	buttons := buttons bitOr: (modifiers bitShift: 3).	oldButtons := lastEventBuffer fifth 				bitOr: (lastEventBuffer sixth bitShift: 3).	lastEventBuffer := evtBuf.	type == #mouseMove 		ifTrue: 			[trail := self mouseTrailFrom: evtBuf.			^MouseMoveEvent new 				setType: type				startPoint: (self position)				endPoint: trail last				trail: trail				buttons: buttons				hand: self				stamp: stamp].	^MouseButtonEvent new 		setType: type		position: position		which: (oldButtons bitXor: buttons)		buttons: buttons		hand: self		stamp: stamp! !!HandMorph commentStamp: '<historical>' prior: 0!The cursor may be thought of as the HandMorph.  The hand's submorphs hold anything being carried by dragging.  There is some minimal support for multiple hands in the same world.!!HandMorph class methodsFor: 'accessing' stamp: 'mtf 2/20/2011 20:39'!dragThreshold	^ DragThreshold! !!HandMorph class methodsFor: 'accessing' stamp: 'mtf 2/20/2011 20:39'!dragThreshold: pixels	DragThreshold := pixels! !!HandMorph class methodsFor: 'class initialization' stamp: 'cmm 3/5/2011 13:54'!initialize	"HandMorph initialize"	PasteBuffer := nil.	DoubleClickTime := 350 "milliseconds".	DragThreshold := 10 "pixels".	NormalCursor := CursorWithMask normal asCursorForm! !!HashedCollection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:38'!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."		anInteger < 1 ifTrue: [ ^newObject ].	^self add: newObject "I can only store an object once."	! !!HashedCollection methodsFor: 'private' stamp: 'ul 4/12/2010 22:53'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: tally * 4 // 3.	self growTo: newCapacity! !!HashedCollection methodsFor: 'objects from disk' stamp: 'ul 10/17/2010 03:51'!comeFullyUpOnReload: smartRefStream	"Symbols have new hashes in this image."	self compact! !!HashedCollection commentStamp: 'ul 4/12/2010 22:37' prior: 0!I am an abstract collection of objects that implement hash and equality in a consitent way. This means that whenever two objects are equal, their hashes have to be equal too. If two objects are equal then I can only store one of them. Hashes are expected to be integers (preferably SmallIntegers). I also expect that the objects contained by me do not change their hashes. If that happens, hash invariants have to be re-established, which can be done by #rehash.Since I'm abstract, no instances of me should exist. My subclasses should implement #scanFor:, #fixCollisionsFrom: and #noCheckNoGrowFillFrom:.Instance Variables	array:		<ArrayedCollection> (typically Array or WeakArray)	tally:		<Integer> (non-negative)array	- An array whose size is a prime number, it's non-nil elements are the elements of the collection, and whose nil elements are empty slots. There is always at least one nil. In fact I try to keep my "load" at 75% or less so that hashing will work well.tally	- The number of elements in the collection. The array size is always greater than this.Implementation details:I implement a hash table which uses open addressing with linear probing as the method of collision resolution. Searching for an element or a free slot for an element is done by #scanFor: which should return the index of the slot in array corresponding to it's argument. When an element is removed #fixCollisionsFrom: should rehash all elements in array between the original index of the removed element, wrapping around after the last slot until reaching an empty slot. My maximum load factor (75%) is hardcoded in #atNewIndex:put:, so it can only be changed by overriding that method. When my load factor reaches this limit I replace my array with a larger one (see #grow) ensuring that my load factor will be less than or equal to 50%. The new array is filled by #noCheckNoGrowFillFrom: which should use #scanForEmptySlotFor: instead of #scanFor: for better performance. I do not shrink.!!HashedCollection class methodsFor: 'sizing' stamp: 'ul 4/7/2010 00:17'!goodPrimes	"Answer a sorted array of prime numbers less than one billion that make good	hash table sizes. Should be expanded as needed.  See comments below code"		^#(		5 11 17 23 31 43 59 79 107 149 199 269 359 479 641 857 1151 1549 2069		2237 2423 2617 2797 2999 3167 3359 3539 3727 3911		4441 4787 5119 5471 5801 6143 6521 6827 7177 7517 7853		8783 9601 10243 10867 11549 12239 12919 13679 14293 15013 15731		17569 19051 20443 21767 23159 24611 25847 27397 28571 30047 31397		35771 38201 40841 43973 46633 48989 51631 54371 57349 60139 62969		70589 76091 80347 85843 90697 95791 101051 106261 111143 115777 120691 126311		140863 150523 160969 170557 181243 190717 201653 211891 221251 232591 242873 251443		282089 300869 321949 341227 362353 383681 401411 422927 443231 464951 482033 504011		562621 605779 647659 681607 723623 763307 808261 844709 886163 926623 967229 1014617		1121987 1201469 1268789 1345651 1429531 1492177 1577839 1651547 1722601 1800377 1878623 1942141 2028401		2242727 2399581 2559173 2686813 2836357 3005579 3144971 3283993 3460133 3582923 3757093 3903769 4061261		4455361 4783837 5068529 5418079 5680243 6000023 6292981 6611497 6884641 7211599 7514189 7798313 8077189		9031853 9612721 10226107 10745291 11338417 11939203 12567671 13212697 13816333 14337529 14938571 15595673 16147291		17851577 18993941 20180239 21228533 22375079 23450491 24635579 25683871 26850101 27921689 29090911 30153841 31292507 32467307		35817611 37983761 40234253 42457253 44750177 46957969 49175831 51442639 53726417 55954637 58126987 60365939 62666977 64826669		71582779 76039231 80534381 84995153 89500331 93956777 98470819 102879613 107400389 111856841 116365721 120819287 125246581 129732203		143163379 152076289 161031319 169981667 179000669 187913573 196826447 205826729 214748357 223713691 232679021 241591901 250504801 259470131		285162679 301939921 318717121 335494331 352271573 369148753 385926017 402603193 419480419 436157621 453034849 469712051 486589307 503366497 520043707 		570475349 603929813 637584271 671138659 704693081 738247541 771801929 805356457 838910803 872365267 905919671 939574117 973128521 1006682977 1040137411 		1073741833)"The above primes past 2069 were chosen carefully so that they do not interact badly with 1664525 (used by hashMultiply), and so that gcd(p, (256^k) +/- a) = 1, for 0<a<=32 and 0<k<=8.  See Knuth's TAOCP for details.""The above primes also try to map the values of ((0 to: 4095) collect: [ :each | each << 18 \\ prime ]) sort to an equidistant sequence of numbers. This helps to avoid the collision of chains in identity-based hashed collections. To do that  they were chosen to return a low value when the following block is evaluated with them as argument: [ :prime |	| slots cost optimalDistance previous |	slots := Array new: 4097.	0 to: 4095 do: [ :ea | slots at: ea + 1 put: ea *  262144 \\ prime ].	slots at: 4097 put: prime.	slots sort.	cost := 0.	optimalDistance := prime // 4096.	2 to: 4097 do: [ :index |		| newCost |		newCost := optimalDistance - ((slots at: index) - (slots at: index - 1)).		newCost > cost ifTrue: [ cost := newCost ] ].	cost ]."! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 1/31/2011 00:05'!cleanUp: aggressive	"Rehash all instances when cleaning aggressively"	aggressive ifTrue: [ self compactAll ]! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAll	"HashedCollection compactAll"				self allSubclassesDo: #compactAllInstances! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 10/17/2010 03:32'!compactAllInstances	"Do not use #allInstancesDo: because #compact may create new instances."	self allInstances do: [ :each | each compact ]! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 10/17/2010 03:33'!rehashAllInstances	"Do not use #allInstancesDo: because #rehash may create new instances."	self allInstances do: [ :each | each rehash ]! !!HashedCollectionIntegrityTest methodsFor: 'as yet unclassified' stamp: 'ul 4/13/2010 00:19'!testCapacity	| inconsistentCollections |	inconsistentCollections := HashedCollection allSubInstances reject: [ :each |		each class == MethodDictionary "MethodDictionary is the only HashedCollection which doesn't have prime array size"			ifTrue: [ each capacity isPowerOfTwo ]			ifFalse: [ each capacity isPrime ] ].	self assert: inconsistentCollections isEmpty! !!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 4/7/2010 00:18'!testPrimes: primes	| badPrimes |	badPrimes := #(3 5 71 139 479 5861 277421). "These primes are less than the hashMultiply constant (1664525) and 1664525 \\ prime is close to 0 (mod prime). The following snippet reproduces these numbers: 	| hashMultiplyConstant |	hashMultiplyConstant := 1 hashMultiply.	(Integer primesUpTo: hashMultiplyConstant) select: [ :each |		| remainder |		remainder := hashMultiplyConstant \\ each.		remainder <= 1 or: [ remainder + 1 = each ] ]."	self assert: primes isSorted.	primes do: [ :each |		self assert: each isPrime.		self deny: (each > 2069 and: [ badPrimes includes: each ]) ].	self assert: (		primes select: [ :p |			| result |			result := false.			p > 2069 ifTrue: [			1 to: 8 do: [ :k |				1 to: 32 do: [ :a |					(p gcd: (256 raisedTo: k) + a) = 1 ifFalse: [						result := true ].					(p gcd: (256 raisedTo: k) - a) = 1 ifFalse: [						result := true ] ] ] ].			result ]) isEmpty.! !!Heap methodsFor: 'accessing' stamp: 'nice 9/30/2010 23:27'!fullySort	"Fully sort the heap.	This method preserves the heap invariants and can thus be sent safely"	self privateReverseSort.	1 to: tally // 2 do: [:i | array swap: i with: 1 + tally - i]! !!Heap methodsFor: 'enumerating' stamp: 'nice 8/21/2010 15:40'!collect: aBlock	^self collect: aBlock as: Array! !!Heap methodsFor: 'enumerating' stamp: 'nice 8/21/2010 15:49'!select: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect into	a new collection like the receiver, only those elements for which aBlock	evaluates to true."	| newCollection |	newCollection := self copyEmpty.	self do:		[:each |		(aBlock value: each)			ifTrue: [newCollection add: each]].	^ newCollection! !!Heap methodsFor: 'private' stamp: 'nice 9/30/2010 23:26'!privateReverseSort	"Arrange to have the array sorted in reverse order.	WARNING: this method breaks the heap invariants. It's up to the sender to restore them afterwards."	| oldTally |	oldTally := tally.	[tally > 1] whileTrue:		[array swap: 1 with: tally.		tally := tally - 1.		self downHeapSingle: 1].	tally := oldTally! !!Heap methodsFor: 'copying' stamp: 'nice 8/21/2010 15:53'!copyEmpty	"Answer a copy of the receiver without any of the receiver's elements."	^self class sortBlock: sortBlock! !!Heap commentStamp: 'nice 9/30/2010 23:22' prior: 0!Class Heap implements a special data structure commonly referred to as 'heap' [ http://en.wikipedia.org/wiki/Heap_%28data_structure%29 ]A Heap is a kind of binary tree stored in a linear array - see details after the instance variables description.Heaps are good at handling priority queues because:1) greatest priority element according to the sort block will be stored in first position and thus accessed in O(1) operations2) worse time for inserting or removing an element is in O(log n) operations, where n is the size of the Heap	Insertion/Removal times are more efficient than above upper bound, provided that:	a) Elements are only removed at the beginning	b) Elements are added with arbitrary sort order.3) there is no need to fully sort the Heap, which makes it more efficient than a SortedCollectionThe heap can be fully sorted by sending the message #fullySort.Worse time for fully sorting the Heap is in O(n log n) operations, but this is rarely used a feature.Remind that the Heap does not fully sort the collection if you don't ask.Thus don't expect #do: and other iterators to enumerate elements according to the sortBlock order.Instance variables:	array		<Array>		The data repository	tally		<Integer>	The number of elements in the heap	sortBlock	<Block|nil>	A two-argument block defining the sort order,							or nil in which case the default sort order is								[:element1 :element2| element1 <= element2]	indexUpdateBlock 	<Block|nil> 							A two-argument block of the form [:data :index | ... ]							which allows an application object to keep track of its							index within the heap.  Useful for quick heap update							when object's sort value changes (for example, when an							object in a priority queue has its priority increased							by an external event, you don't want to have to search							through the whole heap to find the index before fixing							the heap).  No update occurs if nil.									The Heap can be viewed as a binary tree (every node in the tree has at most two children).The root is stored in first slot of internal array.The children are stored in next two slots.The children of children in next four slots.etc...For a node A of index i (1 based), the two children B1 and B2 are thus stored in indices (2*i) and (2*i+1).Of course, the children indices must be less than the tally otherwise they are considered inexistent.The Heap does arrange to preserve the following invariant:For any children B of a node A, A is sorted before B, in other words, (self sort: A before: B) = trueThis implies that the root is always the first element according to sort order.!!HeapTest methodsFor: 'testing' stamp: 'nice 8/21/2010 16:33'!testIfEqualIsTransitive	"This is http://bugs.squeak.org/view.php?id=6943"    | anArray heap1 heap2 |    anArray := #(1 2 3).    heap1 := Heap withAll: (1 to: 3) sortBlock: [:a :b | a < b].    heap2 := Heap withAll: (1 to: 3) sortBlock: [:a :b | b > a].    self		assert: (heap1 = anArray) & (heap2 = anArray) ==> (heap1 = heap2)		description: 'Heap equality should be transitive'! !!HeapTest methodsFor: 'basic tests' stamp: 'nice 8/21/2010 16:11'!testSortBlock	"self run: #testSortBlock"	| heap |	heap := Heap withAll: #(1 3 5).	self assert: heap asArray = #(1 3 5).		heap sortBlock: [ :e1 :e2 | e1 >= e2 ].	self assert: heap asArray = #(5 3 1)! !!HelpAPIDocumentation commentStamp: 'tbn 4/30/2010 15:12' prior: 0!This class represents the browsable package API help for the help system.Instance Variables!!HelpAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:50'!bookName	^'API Documentation'! !!HelpAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 3/11/2010 23:55'!packages	^#('HelpSystem-Core-Model' 'HelpSystem-Core-Utilities' 'HelpSystem-Core-UI')! !!HelpAPIDocumentation class methodsFor: 'defaults' stamp: 'tbn 3/11/2010 23:57'!builder	^PackageAPIHelpBuilder! !!HelpBrowser methodsFor: 'ui' stamp: 'tbn 2/12/2010 12:57'!close	window notNil ifTrue: [window delete]! !!HelpBrowser methodsFor: 'ui' stamp: 'tbn 3/3/2010 23:32'!open	 	"Open the receivers window" 	self refresh.		window openInWorld.	 ! !!HelpBrowser methodsFor: 'defaults' stamp: 'tbn 3/5/2010 22:27'!defaultRoot	^CustomHelp! !!HelpBrowser methodsFor: 'defaults' stamp: 'tbn 4/30/2010 12:39'!defaultViewerClass	 	^PluggableTextMorph! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 5/2/2010 22:20'!initWindow	window := SystemWindow labelled: 'Help Browser'.	window model: self.	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph frame: (0@0 corner: 0.3@1).		"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph frame: (0.3@0 corner: 1@1).					! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 3/5/2010 23:39'!initialize 	super initialize. 	self initWindow. ! !!HelpBrowser methodsFor: 'events' stamp: 'tbn 9/20/2010 09:55'!onItemClicked: anItem	anItem isNil ifTrue: [^contentMorph setText: rootTopic asHelpTopic contents].	contentMorph setText: anItem contents! !!HelpBrowser methodsFor: 'actions' stamp: 'tbn 9/20/2010 09:38'!refresh        |helpTopic items|        helpTopic := rootTopic asHelpTopic.        window setLabel: helpTopic title.        items := helpTopic subtopics collect: [:each | HelpTopicListItemWrapper with: each ].        treeMorph list: items.        contentMorph setText: helpTopic contents! !!HelpBrowser methodsFor: 'accessing' stamp: 'tbn 3/5/2010 22:56'!rootTopic	^rootTopic! !!HelpBrowser methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:11'!rootTopic: aHelpTopic	rootTopic := aHelpTopic. 	self refresh ! !!HelpBrowser methodsFor: 'stepping' stamp: 'tbn 8/19/2010 09:47'!step	 "Do nothing when the window dispatches stepping back to the model"! !!HelpBrowser commentStamp: 'tbn 3/8/2010 09:33' prior: 0!A HelpBrowser is used to display a hierarchy of help topics and their contents.Instance Variables	rootTopic: 		<HelpTopic>	window:			<StandardWindow>	 	treeMorph:		<PluggableTreeMorph>	contentMorph:		<Morph>			rootTopic	- xxxxxwindow	- xxxxxtreeMorph 	- xxxxxcontentMorph 	- xxxxx!!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 5/3/2010 18:37'!open	^self openOn: SystemHelp! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 9/20/2010 09:36'!openOn: aHelpTopic        "Open the receiver on the given help topic or any other object that can be transformed into         a help topic by sending #asHelpTopic."                ^(self defaultHelpBrowser new)                rootTopic: aHelpTopic;                open;                yourself! !!HelpBrowser class methodsFor: 'class initialization' stamp: 'tbn 5/2/2010 22:20'!initialize	"Initializes the receiver class" 	 TheWorldMenu registerOpenCommand: {'Help Browser'. {self. #open}}. ! !!HelpBrowser class methodsFor: 'accessing' stamp: 'tbn 5/3/2010 18:37'!defaultHelpBrowser	DefaultHelpBrowser isNil ifTrue: [DefaultHelpBrowser := self].	^DefaultHelpBrowser	! !!HelpBrowser class methodsFor: 'accessing' stamp: 'tbn 5/3/2010 18:42'!defaultHelpBrowser: aClass	"Use a new help browser implementation"		DefaultHelpBrowser := aClass	! !!HelpBrowserTest methodsFor: 'accessing' stamp: 'tbn 5/3/2010 19:35'!defaultTestClass	^HelpBrowser! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 20:22'!testDefaultHelpBrowser		| current replacement instance |	current := self defaultTestClass defaultHelpBrowser.	replacement := AdvancedHelpBrowserDummy.	[	  self defaultTestClass defaultHelpBrowser: replacement.	  self assert: self defaultTestClass defaultHelpBrowser == replacement. 	  instance := self defaultTestClass open.	  self assert: instance rootTopic notNil.	  self assert: instance isOpen.	] ensure: [ self defaultTestClass defaultHelpBrowser: current ]	 ! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:28'!testDefaultHelpBrowserIsReplacable		| current replacement instance |	"save the one that is registered"	current := self defaultTestClass defaultHelpBrowser.	replacement := AdvancedHelpBrowserDummy.	[	  self defaultTestClass defaultHelpBrowser: replacement.	  self assert: self defaultTestClass defaultHelpBrowser == replacement.	  	  instance := self defaultTestClass open.	  	] ensure: [		self defaultTestClass defaultHelpBrowser: current	]	 ! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 18:43'!testLazyDefaultHelpBrowser		self assert: self defaultTestClass defaultHelpBrowser notNil! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 12/22/2010 08:48'!testOpen	|block|	block := [		|browser|		browser := self defaultTestClass open.		World doOneCycleNow. 		browser close ].		self shouldnt: block raise: Error		! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/2/2010 22:20'!testRegistration	        	TheWorldMenu registeredOpenCommands detect: [:each | each first = 'Help Browser'] ifNone: [self fail].	! !!HelpBuilder methodsFor: 'building' stamp: 'tbn 3/3/2010 22:55'!build	self subclassResponsibility ! !!HelpBuilder methodsFor: 'initialize-release' stamp: 'tbn 3/5/2010 23:12'!initialize 	"Initializes the receiver"		super initialize.	topicToBuild := self topicClass new.	 ! !!HelpBuilder methodsFor: 'accessing' stamp: 'tbn 2/12/2010 14:53'!rootToBuildFrom: anObject	rootToBuildFrom := anObject! !!HelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:15'!topicToBuild	^topicToBuild! !!HelpBuilder methodsFor: 'private accessing' stamp: 'tbn 3/5/2010 23:13'!topicClass	^HelpTopic! !!HelpBuilder commentStamp: 'tbn 2/12/2010 14:54' prior: 0!This is an utility class that builds the books for a help system.Instance Variables	rootTopics:		<OrderedCollection>rootTopics	- a collection of books !!HelpBuilder class methodsFor: 'building' stamp: 'tbn 3/5/2010 23:25'!buildHelpTopicFrom: aHelpTopicDescription	"Start building from the given help topic description"		^(self new)		rootToBuildFrom: aHelpTopicDescription;		build;		topicToBuild ! !!HelpHowToHelpTopics class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:47'!bookName	^'Implementation'! !!HelpHowToHelpTopics class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 19:21'!pages	^#(overview page1 page2 page3 page4 page5)! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:59'!overview	^HelpTopic 		title: 'Overview'		contents:		'THE IMPLEMENTATIONThe help system typically consists of help books including one or more pages. A book or page is therefore a "topic of interest"  providing contents for help to a user. A topic has a title and an icon and is able to have subtopics forming a hierarchy of topics. This simple model is reflected in the class HelpTopic.Since this model forms a hierarchical structure of help topics there is a browser with a tree to display the help contents. This browser is implemented in class HelpBrowser.You can open this browser programmatically using:   HelpBrowser open' ! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:03'!page1	^HelpTopic 		title: '1. Simple help topics'		contents: 'The help browser usually operates on a hierarchy of help topics with one help topic at the root level. Evaluate the following expression in a workspace to contruct a simple help topic and open it as a root topic in the help browser.				|root|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.									HelpBrowser openOn: root				Note that the help browser displays the contents of our topic in the right page and uses the topics title as the title for the help browser window.			'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:03'!page2	^HelpTopic 		title: '2. Forming a hierarchy'		contents: 'To form a hierarchy we just have to add new subtopics on our root topic.				|root sub1 sub2|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.				sub1 := HelpTopic 			title: ''My first subtopic''			contents: ''First subsection''.				sub2 := HelpTopic 			title: ''My second subtopic''			contents: ''Second subsection''.				root 			addSubtopic: sub1; 			addSubtopic: sub2.		HelpBrowser openOn: root				'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:10'!page3	^HelpTopic 		title: '3. Adding icons'		contents: 'If you dont like the default icon you can add own custom icons to the topics. See the class HelpIcons for more details.				|root sub1 sub2|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.				sub1 := HelpTopic 			title: ''My first subtopic''			contents: ''First subsection''.				sub2 := HelpTopic 		     			title: ''My second subtopic''			 icon: (HelpIcons iconNamed: #packageIcon)			contents: ''Second subsection''.				root 			addSubtopic: sub1; 			addSubtopic: sub2.		HelpBrowser openOn: root				'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 15:01'!page4	^HelpTopic 		title: '4. Own help objects'		contents:		'You can open this help browser directly on an instance of HelpTopic, but it is more common to open it on any object that understands the message #asHelpTopic.So you can write for instance:   HelpBrowser openOn: Integeropening a short API help/system reference on the Integer class.The above expression is the short form for:   HelpBrowser openOn: (SystemReference forClass: Integer)If you want you can include the subclasses:   HelpBrowser openOn: (SystemReference hierarchyFor: Integer)or even methods   HelpBrowser openOn: (SystemReference hierarchyWithMethodsFor: Integer)You can browse the whole system reference documentation using:    HelpBrowser openOn: SystemReferenceBut these are only a few examples what we can extract from the system. However - the major goal is NOT an API browser, the idea is to provide a simple architecture to provide browsable help contents depending on the context. For instance it should also be possibleto use the help system to provide end user help on any commercialapplication that is written with the Smalltalk system.' ! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 19:23'!page5	^HelpTopic 		title: '5. Help sources'		contents:		'Since the underlying model is very simple you can easily fill it with nearly any information from different sources. Try this:|topic day url sub|topic := HelpTopic named: ''Last week on Squeak IRC''.0 to: 7 do: [:index |	day := (Date today subtractDays: index) printFormat: #(3 2 1 $. 1 2 2).	url := ''http://tunes.org/~nef/logs/squeak/'' , day.	sub := HelpTopic 			title: day contents: (HTTPLoader default retrieveContentsFor: url) contents.	topic addSubtopic: sub.].HelpBrowser openOn: topic  ' ! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:06'!bookName	^'Custom help from code'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 9/30/2010 23:46'!pages	^#(overview step1 step2 step3 step4 step5 step6 step7)! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/29/2010 13:52'!overview	^HelpTopic		title: 'Overview'		contents:		'OVERVIEW	The help system allows you to provide own books and help texts. You can open the help browser on any object that is able to understand #asHelpTopic.This method returns the root node of the displayed topic hierarchy:      HelpBrowser openOn: myObjectTypically the object does not convert itself to a help topic structure, usually it dispatches to a builder (see HelpBuilder and subclasses) who does all this. 	A much more convenient and reproducable way is to implement custom help classes. This allows you to implement and manage your help texts using the standard development and code management tools. These custom help classes are subclasses of "CustomHelp" and are automatically included into the standard help browser. '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:36'!step1	^HelpTopic 		title: 'Step 1 - Create a class for the book'		contents:		'STEP 1 - CREATE A CLASS FOR THE BOOK		There is a predefined class CustomHelp which you have to subclass for a custom help book to show up as a book in the Help browser:	  CustomHelp subclass: #MyAppHelp    	instanceVariableNames: ''''	  classVariableNames: ''''	  poolDictionaries: ''''	  category: ''MyApp-Help'' Class methods on this class can reflect pages and if you want to provide nested help books just subclass your own help class to form a hierarchy. Any new subclass of MyAppHelp will then be a new book in your hierarchy.The class category used should end with "-Help" so it is easy to recognize that it includes the help support of your project.'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:36'!step2	^HelpTopic		title: 'Step 2 - Provide a book name'		contents:	'STEP 2 - PROVIDE A BOOK NAME	Now implement the class method #bookName to return the name of your help book.   bookName	    ^''My App help''	By implementing this method the system knows how you would like to name your book and uses the given string as a label in the HelpBrowser later.'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/29/2010 13:41'!step3	^HelpTopic		title: 'Step 3 - Implement pages using methods'		contents:	'STEP 3 - IMPLEMENT PAGES USING METHODS Implement a page by defining a method that returns an instance of HelpPage defining a page title and a help text displayed in the help browser.      firstPage     	    ^HelpTopic	           title: ''First Page''                  contents: ''Hello world''Define a new method for each page of your book. Please group the pages in a method category called "pages".You can also define an icon for the specific page:     secondPage     	    ^HelpTopic	           title: ''Second Page''     	           icon: (HelpIcons iconNamed: #packageIcon)                 contents: ''More to come''Note: =====Later we may add support for better help contents than just plain text (markup descriptions, active morphs, ...)  '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:41'!step4	^HelpTopic		title: 'Step 4 - Defining the page order'		contents:	'STEP 4 - DEFINING THE PAGE ORDER By implementing the class method #pages you return a collection of method selectors to define the order in which the pages appear in your book:      pages     	    ^#(firstPage secondPage)'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/28/2010 22:56'!step5	^HelpTopic		title: 'Step 5 - Test your help'		contents:	'STEP 5 - TEST YOUR HELP	By using              HelpBrowser open '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 9/30/2010 23:48'!step6	^HelpTopic		title: 'Step 6 - Add more structure'		contents:	'STEP 6 - ADD MORE STRUCTUREIf you add a new subclass to your custom help class and repeating step 2 to 4 you canprofide new substructures (subbooks) since the help books are mapped to the class hierarchy. Example: MyAppHelp subclass: #MyAppTutorial    	instanceVariableNames: ''''	  classVariableNames: ''''	  poolDictionaries: ''''	  category: ''MyApp-Help'' then implement a #bookName, the pages and a #pages method as before on this new class and reopen the help browser. 		'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 9/30/2010 23:54'!step7	^HelpTopic		title: 'Step 7 - Tips and Tricks'		contents:	'STEP 7 - TIPS AND TRICKSTip1:          If you implement the #pages method you can also           use the name of a custom help class that should be           integrated between the specific pages:               #pages                   ^(firstPage MyAppTutorial secondPage)Tip2:          You can easily edit the help contents of a page by           using the #edit: message. For our example just evaluate:			MyAppHelp edit: #firstPage				     This will open a workspace with the help contents and 	     when you accept it it will be saved back to the help 	     method defining the topic.		  		'! !!HelpIcons commentStamp: 'tbn 3/8/2010 09:29' prior: 0!This class is used to store help icons for the help browser. Typically one implements a method returning a 12x12 Form instance whichshould not be called directly.Since the class provides an internal icon cache (so the icons can be reused without creating too many new instances) the icons should be accessed using the #iconNamed: message with the method selector as argument.To create a form from an icon file stored on disk you can use the following code:   | image stream |	image := ColorForm fromFileNamed: '/path/to/icon.png'.	stream := WriteStream with: String new.	image storeOn: stream.	stream contents inspect.!!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/3/2010 23:53'!blankIcon	^Form extent: 12 @ 1 depth:8! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 2/12/2010 14:17'!bookIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 0 284817913 552924404 0 0 0 0 0 0 0 0 0 817149108 3747766882 4287730065 2679749049 549766340 0 0 0 0 0 0 1086110908 4016202338 4287137928 4288914339 4288914339 4289111718 3216290996 1086505666 0 0 0 816754350 4014952271 4287137928 4289309097 4289769648 4289111718 4288453788 4288453788 4288453788 2947658161 0 814846353 4283782485 4287072135 4288059030 4288059030 4288387995 4289243304 4289309097 4287927444 4287598479 2411050421 1081900156 4283585106 4286611584 4287532686 4287532686 4287466893 4287466893 4287401100 4287401100 4287401100 4288716960 2946868645 3211290728 4288651167 4287269514 4287006342 4287006342 4287006342 4286940549 4286940549 4287203721 4289177511 3483213213 281725642 2677183122 4293190884 4292861919 4289177511 4286874756 4286611584 4286611584 4287006342 4289638062 4020084125 549042617 0 282054607 2677643673 4289572269 4293256677 4292796126 4288980132 4287137928 4290164406 4020215711 816754350 0 0 0 0 551082200 2677643673 4289572269 4293256677 4292401368 4289177511 1085584564 0 0 0 0 0 0 0 551213786 2677643673 4288651167 1623244992 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/6/2010 01:23'!packageIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 1075649821 3744937783 3208395836 807016986 0 0 0 0 0 0 537857807 2939368243 4283256141 4284045657 4284572001 4284111450 2671524924 269488144 0 0 0 2150575919 4014820685 4284111450 4284374622 4284769380 4285098345 4285295724 4286216826 4017057647 1883456323 0 1076505130 4283848278 4284769380 4284966759 4285624689 4285690482 4285887861 4286611584 4287269514 4287861651 4287269514 1074597133 1076965681 4283914071 4283848278 4285953654 4286216826 4286414205 4286940549 4287466893 4287335307 4286808963 4286743170 1074399754 1077163060 4284637794 4284045657 4284835173 4285887861 4287269514 4287335307 4286282619 4286216826 4286874756 4287006342 1074465547 1077294646 4284835173 4284703587 4285361517 4285624689 4286414205 4285624689 4286085240 4286677377 4287269514 4287401100 1074465547 1077426232 4285098345 4285032552 4286019447 4285822068 4286743170 4286348412 4286677377 4287203721 4287730065 4287795858 1074531340 1077492025 4285229931 4285427310 4286808963 4286216826 4287137928 4287072135 4287401100 4287795858 4288256409 4288190616 1074531340 269356558 2672051268 4285493103 4287598479 4286940549 4287532686 4287795858 4287993237 4288387995 4287006342 2404668500 268501249 0 0 1075912993 3479726184 4287598479 4287927444 4288453788 4287993237 2943118444 539371046 0 0 0 0 0 0 1615086660 4017781370 3749148535 1078347334 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 2/12/2010 14:18'!pageIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 221196079 1366981242 1366915449 1366915449 1366849656 1366783863 1128876361 33554432 0 0 0 0 726552142 4294309365 4294243572 4294111986 4294046193 4293914607 4292861919 2843705215 319885585 0 0 0 726551886 4294177779 4294111986 4293980400 4293914607 4293848814 4293717228 4292138196 3734147730 269619730 0 0 726486349 4294046193 4293980400 4293914607 4293783021 4293717228 4293585642 4293454056 4291085508 639705377 0 0 726420557 4293980400 4293848814 4293783021 4293651435 4293585642 4293519849 4293388263 4292993505 640034342 0 0 726420556 4293848814 4293717228 4293651435 4293585642 4293454056 4293388263 4293256677 4293190884 623322919 0 0 726354764 4293717228 4293651435 4293519849 4293454056 4293322470 4293256677 4293125091 4293059298 623257126 0 0 726354507 4293585642 4293519849 4293388263 4293322470 4293190884 4293125091 4293059298 4292993505 623191333 0 0 726288970 4293454056 4293388263 4293256677 4293190884 4293125091 4292993505 4292993505 4292993505 623191333 0 0 726223178 4293322470 4293256677 4293190884 4293059298 4292993505 4292993505 4292993505 4292993505 623191333 0 0 726223177 4293256677 4293125091 4293059298 4292993505 4292993505 4292993505 4292993505 4292993505 623191333 0 0 490092087 3080033685 3079967892 3079967892 3079967892 3079967892 3079967892 3079967892 3079967892 454629657 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/3/2010 00:47'!refreshIcon	^(Form		extent: 16@16		depth: 32		fromArray: #( 0 0 0 0 0 0 0 895969127 526080859 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1884706390 4168710521 2288675434 271330348 0 0 0 0 0 0 0 0 0 828465505 2609087363 3615917702 4269439610 4285887861 4285624689 3899156584 1766607948 67569415 0 0 0 0 0 50529027 2306242166 4237069452 4286940549 4286611584 4286282619 4285887861 4285558896 4285229931 4268189543 2235514687 0 0 0 0 0 2590862701 4287598479 4287269514 4270097540 3329652342 3312217196 4285887861 4285558896 3345179491 1011567435 0 0 0 0 0 1263423054 4287532686 4287532686 3867378563 1096835168 0 1885166941 3681579120 1549227863 50923785 0 0 0 0 0 0 3061545851 4287795858 4236937866 811951461 0 0 641547581 137441585 0 0 0 0 0 0 0 34936085 4102720138 4287795858 3011016824 0 0 0 0 0 0 0 0 0 0 0 0 272317243 4287861651 4287795858 2489607268 0 0 0 0 0 0 0 0 68095759 0 0 0 204682035 4287730065 4287795858 2658432116 0 0 0 0 0 0 0 34014983 3965146967 4283979864 3125694030 0 0 3767044232 4287795858 3884287365 137244206 0 0 0 0 0 0 1129863256 4284769380 4284506208 2739423304 0 0 2189459584 4287795858 4287532686 2541123190 16843009 0 0 0 0 305805882 3597166696 4284703587 4250885983 910114623 0 0 273698896 3834218889 4287532686 4287335307 3094442353 1094532413 101255433 286199567 1582124365 3731318631 4284966759 4284703587 2689946965 0 0 0 0 879126118 3985082247 4287269514 4286940549 4286611584 4285624689 4285558896 4285624689 4285229931 4284966759 3227212635 220998700 0 0 0 0 0 509698401 2977659771 4286743170 4286545791 4286282619 4285887861 4285558896 4100417383 2170116441 103295016 0 0 0 0 0 0 0 0 575820370 1734895720 2121298032 2037017194 1448564567 255013683 0 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 15:54'!iconNamed: aSymbol	^self icons at: aSymbol ifAbsentPut: [self perform: aSymbol]! !!HelpIcons class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 15:55'!icons	Icons isNil ifTrue: [Icons := Dictionary new].	^Icons! !!HelpIcons class methodsFor: '*help-squeak-project' stamp: 'mha 5/2/2010 20:58'!squeakIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 75398782 26843545 0 0 1159996452 1378823983 338044454 0 0 0 0 455682345 1295266868 1126376227 0 0 1040582150 0 1328097577 0 0 0 23488102 1277502757 0 1076834095 0 0 1075781407 0 287647013 472854319 0 0 471472666 204089898 0 1092756002 0 0 1041963803 36909875 0 1880232466 454761243 287515427 1342572038 0 104939841 974460181 0 0 270080281 354690084 86846765 3674539269 1394219546 1611599631 3557427722 86123042 388244516 204287277 0 26843545 605558808 1025055001 1008014613 1159141143 522264865 739710743 1159141143 571083274 570820102 188891714 0 942550574 1411391520 1143021857 1312241463 1428563494 3205040393 3708159494 1663576104 1511067921 1579887403 1629758500 958472481 656679972 439563059 1294608938 839913488 739644950 172246084 221459251 840900383 1075978786 1209933342 724512559 707077413 0 0 0 0 0 0 0 0 0 0 38488907 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !!HelpIconsTest methodsFor: 'accessing' stamp: 'tbn 2/12/2010 14:23'!defaultTestClass 	^HelpIcons! !!HelpIconsTest methodsFor: 'testing' stamp: 'tbn 3/3/2010 00:50'!testIconCaching	 	| first second |	#(bookIcon pageIcon refreshIcon) do: [:iconSymbol |		first := self defaultTestClass iconNamed: iconSymbol.		second := self defaultTestClass iconNamed: iconSymbol.			self assert: first notNil.		self assert: first == second.	]	! !!HelpOnHelp commentStamp: 'tbn 2/12/2010 14:27' prior: 0!Welcome to Pharo Smalltalk Help System!!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:21'!bookName	^'Help on Help'! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:56'!key	^'HelpOnHelp'! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 10/1/2010 00:27'!pages	^#(introduction HelpHowToHelpTopics HelpAPIDocumentation)! !!HelpOnHelp class methodsFor: 'pages' stamp: 'tbn 9/21/2010 21:34'!introduction	"This method was automatically generated. Edit it using:"	"HelpOnHelp edit: #introduction"	^HelpTopic		title: 'Introduction'		contents: 'WELCOME TO THE HELP SYSTEMThe help system is a simple user interface to display help contents to the user. It can be accessed from the world menu using "Tools" -> "Help Browser" or by evaluating ''HelpBrowser open'' in a workspace.There is a predefined mechanism allowing you to have help contents stored as source code using methods in specific help provider classes. This allows you to manage the help texts using the standard development tools. But this is only one possible representation.!!' readStream nextChunkText! !!HelpTopic methodsFor: 'comparing' stamp: 'tbn 3/8/2010 09:11'!<= anotherHelpTopic	"Use sorting by title as the default sort order"		^self title <= anotherHelpTopic title ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:40'!addSubtopic: aTopic	"Adds the given topic to the receivers collection of subtopics"		self subtopics add: aTopic.	^aTopic! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!contents	"Returns the receivers contents"		^ contents! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!contents: anObject	"Sets the receivers contents to the given object" 			contents := anObject! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!icon  	"Returns the receivers icon"		^icon! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!icon: aSymbol	"Sets the receivers icon"		icon := aSymbol ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!key 		"Returns a unique key identifying the receiver in the help system"				^key! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!key: aUniqueKey	"Sets a unique key identifying the receiver in the help system"				key := aUniqueKey ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:21'!subtopics 	"Returns the receivers list of subtopics"		subtopics isNil ifTrue: [subtopics := OrderedCollection new].	^subtopics! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!subtopics: aCollection 	"Sets the receivers subtopics"		subtopics := aCollection ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!title	"Returns the receivers title"		^ title! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!title: anObject	"Sets the receivers title"		title := anObject! !!HelpTopic methodsFor: 'conversion' stamp: 'tbn 3/8/2010 09:09'!asHelpTopic 	"Converts the receiver to a help topic"		^self! !!HelpTopic methodsFor: 'defaults' stamp: 'tbn 3/5/2010 21:31'!defaultTitle	"Returns the receivers default title"		^'Unnamed Topic'	! !!HelpTopic methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:23'!hasSubtopics 	"Returns true if the receiver has subtopics, false otherwise"		^self subtopics notEmpty ! !!HelpTopic methodsFor: 'initialize-release' stamp: 'tbn 3/8/2010 08:44'!initialize 	"Initializes the receiver"		super initialize.	self title: self defaultTitle.	self contents: ''.	self key: '' ! !!HelpTopic methodsFor: 'operating' stamp: 'tbn 3/8/2010 09:12'!sortSubtopicsByTitle	"Sort the subtopics by title"		subtopics := SortedCollection withAll: self subtopics  ! !!HelpTopic commentStamp: 'tbn 3/29/2010 14:53' prior: 0!A HelpTopic provides content information that can be used as a help to the user.It can be labeled with a title, identified using an (optional) unique key and marked with an (optional) icon.Help topics form a hierarchy since any topic is able to have zero or moresubtopics. Instance Variables	contents:		<Object>      The help topic contents	icon:			<Form|nil>	   An optional icon for the topic	key:			<String|nil>    An optional unique key	subtopics:	      <Collection>  A collection of subtopics	title:			<String>        The titlecontents	- The help topic contents - typically containing the help topics informationicon	- An optional icon for the topickey	- An optional unique key which can be used to identify the topic. subtopics	- A collection of subtopics. 	  By default the subtopics are not sorted, so the insertion order is used. 	  If necessary it is possible to sort the subtopics by title.title	- A meaninful title for the help topic!!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!named: aString	"Create a new instance with given title and empty contents"		^(self new)		title: aString;		yourself! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!title: aTitle contents: aText	"Create a new instance with given title and content"		^(self new)		title: aTitle;		contents: aText;		yourself.		! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!title: aTitle icon: anIcon contents: aText	"Create a new instance with given title, icon and content"		^(self new)		title: aTitle;		icon: anIcon;		contents: aText;		yourself.		! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:25'!asString	"Returns a string used as a label"		^item title! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:26'!balloonText	"Returns a string used for fly by help"		^self item title! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:26'!contents	"Returns subnodes (if any)"	 	item hasSubtopics ifFalse: [^#()].		^(item subtopics) collect: [ :each | 		HelpTopicListItemWrapper with: each	].! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:27'!highlightingColor	"Returns the text color when the receiver is selected in a list."	^Color blue  ! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/5/2010 22:55'!icon	"Either return the icon for the given topic"		| symbol |	item icon notNil ifTrue: [^item icon].	symbol := item hasSubtopics 					 ifTrue: [#bookIcon] 			  		 ifFalse: [#pageIcon].	^HelpIcons iconNamed: symbol! !!HelpTopicListItemWrapper commentStamp: 'tbn 3/8/2010 09:30' prior: 0!This class implements a list item wrapper for help topics.Instance Variables!!HelpTopicListItemWrapperTest methodsFor: 'accessing' stamp: 'tbn 2/12/2010 13:16'!defaultTestClass 	^HelpTopicListItemWrapper 	! !!HelpTopicListItemWrapperTest methodsFor: 'testing' stamp: 'tbn 3/5/2010 21:46'!testDisplayLabel	|instance|	instance := self defaultTestClass with: (HelpTopic named: 'My Topic').	self assert: instance asString = 'My Topic'	! !!HelpTopicTest methodsFor: 'accessing' stamp: 'tbn 3/5/2010 21:47'!defaultTestClass	^HelpTopic ! !!HelpTopicTest methodsFor: 'running' stamp: 'tbn 3/5/2010 21:49'!setUp	super setUp.	topic := self defaultTestClass new.! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:44'!testAddingSubtopic	|subtopic returned|	subtopic := self defaultTestClass named: 'Subtopic'.	returned := topic addSubtopic: subtopic.	self assert: returned == subtopic.	self assert: (topic subtopics includes: subtopic) ! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:07'!testInitialization	self assert: topic title = 'Unnamed Topic'.	self assert: topic key isEmpty.	self assert: topic contents isEmpty ! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:06'!testInstanceCreation	|instance|	instance := self defaultTestClass named: 'My Topic'.	self assert: instance title = 'My Topic'.! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:06'!testSortOrder	|a b c sorted |	a := self defaultTestClass named: 'A'.	b := self defaultTestClass named: 'B'.	c := self defaultTestClass named: 'C'.	sorted := (OrderedCollection with: b with: c with: a) asSortedCollection.	self assert: sorted first = a.	self assert: sorted last = c.	! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:26'!testCharacterHex| result |result := $a hex.self assert: result = '61'.result := $A hex.self assert: result = '41'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'eem 5/21/2010 11:12'!testIntegerHex	| result |	result := 15 asInteger hex.	self assert: result = '16rF'.	result := 0 asInteger hex.	self assert: result = '16r0'.	result := 255 asInteger hex.	self assert: result = '16rFF'.	result := 90 asInteger hex.	self assert: result = '16r5A'! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:44'!testStringAsHex| result |result := 'abc' asHex.self assert: result = '616263'.! !!HierarchicalURI methodsFor: 'private' stamp: 'ul 11/15/2010 11:40'!relativeFromString: aString	| remainder authorityEnd |	remainder := (aString beginsWith: '//')		ifTrue: [			authorityEnd := aString indexOf: $/ startingAt: 3.			authorityEnd = 0				ifTrue: [authorityEnd := aString size+1].			self extractAuthority: (aString copyFrom: 3 to: authorityEnd-1)]		ifFalse: [aString].	self extractSchemeSpecificPartAndFragment: remainder! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'topa 5/4/2010 14:30'!privateInitializeFromText: aString 	| remainder ind specifiedSchemeName |	remainder := aString.	schemeName ifNil: 			[specifiedSchemeName := Url schemeNameForString: remainder.			specifiedSchemeName ifNotNil: 					[schemeName := specifiedSchemeName.					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].			schemeName ifNil: 					["assume HTTP"					schemeName := 'http']].	"remove leading // if it's there"	(remainder beginsWith: '//') 		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].	"get the query"	ind := remainder indexOf: $?.	ind > 0 		ifTrue: 			[query := remainder copyFrom: ind + 1 to: remainder size.			remainder := remainder copyFrom: 1 to: ind - 1].	"get the authority"	ind := remainder indexOf: $/.	ind > 0 		ifTrue: 			[ind = 1 				ifTrue: [authority := '']				ifFalse: 					[authority := remainder copyFrom: 1 to: ind - 1.					remainder := remainder copyFrom: ind + 1 to: remainder size]]		ifFalse: 			[authority := remainder.			remainder := ''].	"extract the username+password"	(authority includes: $@) 		ifTrue: 			[username := authority copyUpTo: $@.			authority := authority copyFrom: (authority indexOf: $@) + 1						to: authority size.			(username includes: $:) 				ifTrue: 					[password := (username copyFrom: (username indexOf: $:) + 1 to: username size) unescapePercents.					username := username copyUpTo: $:].			username := username unescapePercents].	"Extract the port"	(authority includes: $:) 		ifTrue: 			[| lastColonIndex portString |			lastColonIndex := authority findLast: [:c | c = $:].			portString := authority copyFrom: lastColonIndex + 1 to: authority size.			portString isAllDigits 				ifTrue: 					[port := Integer readFromString: portString.					(port > 65535) ifTrue: [self error: 'Invalid port number'].					 authority := authority copyFrom: 1 to: lastColonIndex - 1]				ifFalse:[self error: 'Invalid port number']].	"get the path"	path := self privateParsePath: remainder relativeTo: #() .! !!HierarchicalUrl methodsFor: 'printing' stamp: 'topa 5/5/2010 13:47'!printOn: aStream	aStream nextPutAll: self schemeName.	aStream nextPutAll: '://'.	self username ifNotNil: [		aStream nextPutAll: self username encodeForHTTP.		self password ifNotNil: [			aStream nextPutAll: ':'.			aStream nextPutAll: self password encodeForHTTP].		aStream nextPutAll: '@' ].	aStream nextPutAll: self authority.	port ifNotNil: [aStream nextPut: $:; print: port].	path do: [ :pathElem |		aStream nextPut: $/.		aStream nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		aStream nextPut: $?.		aStream nextPutAll: self query. ].	self fragment isNil ifFalse: [		aStream nextPut: $#.		aStream nextPutAll: self fragment encodeForHTTP. ].! !!HierarchicalUrl methodsFor: 'copying' stamp: 'nice 10/2/2010 00:47'!postCopy	"Be sure not to share the path with the original"	super postCopy.	path := path copy! !!HierarchyBrowser methodsFor: 'class list' stamp: 'fbs 3/30/2011 08:54'!assureSelectionsShow	"This is a workaround for the fact that a hierarchy browser, when launched, often does not show the selected class"	| saveMsgName saveCatName |	saveCatName := self selectedMessageCategoryName.	saveMsgName := self selectedMessageName.	self selectClassNamed: selectedClassName.	self selectMessageCategoryNamed: saveCatName.	self selectMessageNamed: saveMsgName! !!HierarchyBrowser methodsFor: 'class list' stamp: 'fbs 3/9/2011 11:42'!classList	classDisplayList := classDisplayList select: [:each | Smalltalk includesKey: each withBlanksTrimmed asSymbol].	^ classDisplayList! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'fbs 3/14/2011 17:31'!classListIndex: newIndex	"Cause system organization to reflect appropriate category"	| newClassName ind |	newIndex ~= 0 ifTrue:		[newClassName := (classDisplayList at: newIndex) copyWithout: $ .		selectedSystemCategory := (systemOrganizer categories at:			(systemOrganizer numberOfCategoryOfElement: newClassName))].	ind := super classListIndex: newIndex.	"What I'd like to write:"	"self selectedClassName ifNotNil:		[ selectedSystemCategory := self selectedClass category ]."	self changed: #systemCategorySingleton.	^ ind! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'fbs 3/9/2011 11:42'!initAlphabeticListing	| tab stab index |	self systemOrganizer: SystemOrganization.	metaClassIndicated := false.	classDisplayList := Smalltalk classNames.! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'cmm 5/21/2011 12:49'!initHierarchyForClass: aClassOrMetaClass 	| nonMetaClass superclasses |	centralClass := aClassOrMetaClass.	nonMetaClass := aClassOrMetaClass theNonMetaClass.	self systemOrganizer: SystemOrganization.	metaClassIndicated := aClassOrMetaClass isMeta.	classDisplayList := OrderedCollection new.	(superclasses := nonMetaClass allSuperclasses reversed) withIndexDo:		[ : each : indent | classDisplayList add:			(String streamContents:				[ : stream | indent - 1 timesRepeat: [ stream nextPutAll: '  ' ].				stream nextPutAll: each name ]) ].	nonMetaClass		allSubclassesWithLevelDo:			[ : eachClass : lvl | classDisplayList add:				(String streamContents:					[ : stream | lvl timesRepeat: [ stream nextPutAll: '  ' ].					stream nextPutAll: eachClass name ]) ]		startingLevel: superclasses size.	self selectClass: nonMetaClass! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'fbs 3/16/2011 10:51'!selectClassNamed: aSymbolOrString	| newClassName |	newClassName := aSymbolOrString ifNotNil: [ aSymbolOrString asSymbol ].	selectedSystemCategory := (systemOrganizer categories at:			(systemOrganizer numberOfCategoryOfElement: newClassName) ifAbsent: [ nil ]).				super selectClassNamed: newClassName.	self changed: #systemCategorySingleton.			^ newClassName.! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'fbs 3/5/2011 22:31'!selectedClassName	"Answer the name of the class currently selected.   di	  bug fix for the case where name cannot be found -- return nil rather than halt"	| aName |	aName := super selectedClassName.	aName ifNil: [ ^ nil ].	^ (aName copyWithout: Character space) asSymbol! !!HierarchyBrowser methodsFor: '*morphic' stamp: 'cmm 5/12/2011 18:03'!postAcceptBrowseFor: aHierarchyBrowser 	(aHierarchyBrowser selectedClass ~= self selectedClass or: [ aHierarchyBrowser selectedMessageName notNil ]) ifTrue: [ self selectMessageCategoryNamed: nil ].	aHierarchyBrowser instanceMessagesIndicated		ifTrue: [ self indicateInstanceMessages ]		ifFalse: [ self indicateClassMessages ].	self		 selectClass: aHierarchyBrowser selectedClass ;		 selectedMessageName: aHierarchyBrowser selectedMessageName ;		 showHomeCategory! !!HierarchyBrowser methodsFor: '*morphic' stamp: 'fbs 3/9/2011 11:43'!representsSameBrowseeAs: anotherModel	^ self hasUnacceptedEdits not		and: [ classDisplayList size = anotherModel classList size		and: [ classDisplayList includesAllOf: anotherModel classList ] ]! !!HierarchyBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^true! !!HierarchyBrowser commentStamp: 'fbs 3/9/2011 12:02' prior: 0!I provide facilities to explore classes in the context of their subclass hierarchy.My classDisplayList instvar uses indentation to show the subclassing relationship between the displayed classes.!!HierarchyBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 22:22'!setUp	browser := HierarchyBrowser new.! !!HierarchyBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/12/2011 20:48'!testClassList	| c displayedClasses hierarchy |	browser initHierarchyForClass: browser class.		c := browser class theNonMetaClass.	displayedClasses := browser classList collect: [:each | each withoutLeadingBlanks ].	hierarchy := (c allSuperclasses reversed, {browser class}, c allSubclasses) collect: [ :each | each name ].	self assert: displayedClasses = hierarchy.! !!HierarchyBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/14/2011 07:35'!testClassListIndex	| expectedCat |	expectedCat := [:i | (Smalltalk at: (browser classList at: i) withoutLeadingBlanks asSymbol) category ].	browser initHierarchyForClass: browser class.	self deny: browser classListIndex = 0.		1 to: 3 do:		[:n |		browser classListIndex: n.		self assert: browser classListIndex = n.		self assert: browser selectedSystemCategory = (expectedCat value: n)]! !!HierarchyBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/12/2011 21:08'!testClassListSansWhitespace	| c displayedClasses hierarchy |	browser initHierarchyForClass: browser class.		c := browser class theNonMetaClass.	displayedClasses := browser classList collect: [:each | each withoutLeadingBlanks ].	hierarchy := (c allSuperclasses reversed, {browser class}, c allSubclasses) collect: [ :each | each name ].	self assert: displayedClasses = hierarchy.! !!HierarchyBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 10:12'!testInitHierarchyForClass	| b |	b := HierarchyBrowser new initHierarchyForClass: browser class.	self assert: b selectedClassName = browser class name.! !!HierarchyBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/14/2011 17:30'!testSelectClass	browser initHierarchyForClass: browser class.	browser selectClass: ProtoObject.	self assert: browser selectedClass = ProtoObject.		browser selectClass: CodeHolder.	self assert: browser selectedClass = CodeHolder.! !!HierarchyBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/12/2011 20:48'!testSelectedClassName	browser initHierarchyForClass: browser class.	self assert: browser selectedClassName = browser class name.		browser classListIndex: 0.	self assert: browser selectedClassName isNil.! !!HostFont class methodsFor: 'accessing' stamp: 'cmm 6/15/2011 10:59'!textStyleFrom: fontName	"HostFont textStyleFromUser"	| styleName fonts |	styleName := fontName asSymbol.	"(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]]."	fonts := #(10 11 12 13 14 16 18 20 22 24 26 28 30 36 48 60 72 90).	('Rendering ', styleName) displayProgressFrom: 1 to: fonts size during:[:bar|			fonts := fonts				collect:[:ptSize| bar value: (fonts indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	TextConstants		at: styleName		put: (TextStyle fontArray: fonts).! !!HostFont class methodsFor: 'accessing' stamp: 'cmm 6/15/2011 10:59'!textStyleFrom: fontName sizes: ptSizes	| styleName fonts |	styleName := fontName asSymbol.	(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	('Rendering ', styleName) displayProgressFrom: 1 to: ptSizes size during:[:bar|			fonts := ptSizes				collect:[:ptSize| bar value: (ptSizes indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	TextConstants		at: styleName		put: (TextStyle fontArray: fonts).! !!HostFont class methodsFor: 'accessing' stamp: 'cmm 6/15/2011 10:59'!textStyleFrom: fontName sizes: ptSizes ranges: ranges	| styleName fonts |	styleName := fontName asSymbol.	(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	('Rendering ', styleName) displayProgressFrom: 1 to: ptSizes size during:[:bar|			fonts := ptSizes				collect:[:ptSize| bar value: (ptSizes indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0 rangesArray: ranges				]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	TextConstants		at: styleName		put: (TextStyle fontArray: fonts).! !!HostFont class methodsFor: 'accessing' stamp: 'cmm 6/15/2011 10:59'!textStyleFromUser	"HostFont textStyleFromUser"	| styleName fonts |	styleName := self fontNameFromUser ifNil:[^self].	styleName := styleName asSymbol.	(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	fonts := #(10 12 14 16 18 20 22 24 26 28 30 36 48 60 72 90).	('Rendering ', styleName) displayProgressFrom: 1 to: fonts size during:[:bar|			fonts := fonts				collect:[:ptSize| bar value: (fonts indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	TextConstants		at: styleName		put: (TextStyle fontArray: fonts).! !!HttpUrlTest methodsFor: 'as yet unclassified' stamp: 'ar 9/1/2010 00:31'!testHttps	self assert: 'https://encrypted.google.com' asUrl class == HttpUrl! !!IdentitySet commentStamp: 'nice 8/26/2010 22:00' prior: 0!The same as a Set, except that items are compared using #== instead of #=.Almost any class named IdentityFoo is the same as Foo except for the way items are compared.  In Foo, #= is used, while in IdentityFoo, #== is used.  That is, identity collections will treat items as the same only if they have the same identity.For example, note that copies of a string are equal:	('abc' copy) = ('abc' copy)but they are not identical:	('abc' copy) == ('abc' copy)A regular Set will only include equal objects once:	| aSet |	aSet := Set new.	aSet add: 'abc' copy.	aSet add: 'abc' copy.	aSetAn IdentitySet will include multiple equal objects if they are not identical:	| aSet |	aSet := IdentitySet new.	aSet add: 'abc' copy.	aSet add: 'abc' copy.	aSet!!ImageMorph methodsFor: 'accessing' stamp: 'ul 11/15/2010 11:40'!color: aColor        super color: aColor.        (image depth = 1 and: [aColor isColor]) ifTrue: [                image colors: {Color transparent. aColor}.                self changed]! !!ImageMorph methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 11:40'!wantsRecolorHandle	^ image isNil not		and: [image depth = 1]! !!ImageReadWriter class methodsFor: '*network' stamp: 'nice 12/27/2009 03:11'!formFromServerFile: fileName	"Answer a ColorForm stored on the file with the given name.  Meant to be called from during the getting of updates from the server.  That assures that (Utilities serverUrls) returns the right group of servers."	| urls |	urls := Utilities serverUrls collect:		[:url | url, fileName].  " fileName starts with: 'updates/'  "	urls do: [:aURL | | form doc |		(fileName findTokens: '.') last asLowercase = 'gif' ifTrue: [			form := HTTPSocket httpGif: aURL.			form = (ColorForm extent: 20@20 depth: 8) 				ifTrue: [self inform: 'The file ',aURL,' is ill formed.'].			^ form].		(fileName findTokens: '.') last asLowercase = 'bmp' ifTrue: [			doc := HTTPSocket httpGet: aURL accept: 'image/bmp'.			form := Form fromBMPFile: doc.			doc close.			form ifNil: [self inform: 'The file ',aURL,' is ill formed.'. ^ Form new]				ifNotNil: [^ form]].		self inform: 'File ', fileName, 'does not end with .gif or .bmp'].	self inform: 'That file not found on any server we know'.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'nice 2/23/2011 21:51'!acceptSingleMethodSource: aDictionary	| oldClassInfo oldClassName ismeta newName actualClass selector |	oldClassInfo := (aDictionary at: #oldClassName) findTokens: ' '.	"'Class' or 'Class class'"	oldClassName := oldClassInfo first asSymbol.	ismeta := oldClassInfo size > 1.	"must use class var since we may not be the same guy who did the initial work"	newName := RecentlyRenamedClasses ifNil: [		oldClassName	] ifNotNil: [		RecentlyRenamedClasses at: oldClassName ifAbsent: [oldClassName]	].	actualClass := Smalltalk at: newName.	ismeta ifTrue: [actualClass := actualClass class].	selector := actualClass newParser parseSelector: (aDictionary at: #methodText).	(actualClass compiledMethodAt: selector ifAbsent: [^self "hosed input"]) 		putSource: (aDictionary at: #methodText)		fromParseNode: nil		class: actualClass		category: (aDictionary at: #category)		withStamp: (aDictionary at: #changeStamp)		inFile: 2		priorMethod: nil.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 10/17/2010 03:33'!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	inSeg := true.	[object := object nextObject.  		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			object isBlock ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				]. 		object == 0] whileFalse.	hashedCollections do: [ :each | each compact ]. "our purpose"	^ receiverClasses	"our secondary job"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 10/17/2010 03:33'!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.  Do this by discovering classes that need a startUp message sent to each instance, and sending it.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks which refer to instance variables.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg noStartUpNeeded startUps cls msg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	noStartUpNeeded := IdentitySet new.	"classes that don't have a per-instance startUp message"	startUps := IdentityDictionary new.	"class -> MessageSend of a startUp message"	inSeg := true.	[object := object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			(object isKindOf: ContextPart) ifTrue: [				(inSeg and: [object hasInstVarRef]) ifTrue: [					receiverClasses add: object receiver class]].			inSeg ifTrue: [				(noStartUpNeeded includes: object class) ifFalse: [					cls := object class.					(msg := startUps at: cls ifAbsent: [nil]) ifNil: [						msg := cls startUpFrom: self.	"a Message, if we need to swap bytes this time"						msg ifNil: [noStartUpNeeded add: cls]							ifNotNil: [startUps at: cls put: msg]].					msg ifNotNil: [msg sentTo: object]]]]. 		object == 0] whileFalse.	hashedCollections do: [ :each | each compact ]. "our purpose"	^ receiverClasses	"our secondary job"! !!ImageSegment methodsFor: 'instance change shape' stamp: 'ul 8/2/2011 20:02'!allInstancesOf: aClass do: aBlock	| withSymbols oldInstances segSize |	"Bring me in, locate instances of aClass and submit them to the block.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols := state = #onFileWithSymbols.	(outPointers includes: aClass) ifFalse: [^ self].		"If has instances, they point out at the class"	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize := segment size.	self install.	oldInstances := OrderedCollection new.	self allObjectsDo: [:obj | obj class == aClass ifTrue: [		oldInstances add: obj]].	oldInstances do: aBlock.	"do the work"	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ImageSegment methodsFor: 'instance change shape' stamp: 'ul 8/2/2011 20:02'!ifOutPointer: anObject thenAllObjectsDo: aBlock	| withSymbols segSize |	"If I point out to anObject, bring me in, Submit all my objects to the block.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols := state = #onFileWithSymbols.	(outPointers includes: anObject) ifFalse: [^ self].	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize := segment size.	self install.	self allObjectsDo: aBlock.	"do the work"	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ul 6/17/2011 12:20'!copyFromRootsForExport: rootArray 	"When possible, use copySmartRootsExport:.  This way may not copy a complete tree of objects.  Add to roots: all of the methods pointed to from the outside by blocks."	| newRoots list segSize symbolHolder |	arrayOfRoots := rootArray.	"self halt."	symbolHolder := Symbol allSymbols.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	(newRoots := self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots := newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize := segment size.	[(newRoots := self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots := self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	"classes of receivers of blocks"	list := self compactClassesArray.	outPointers := outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	"Zap sender of a homeContext. Can't send live stacks out."	1 to: outPointers size do: [:ii | 		(outPointers at: ii) isBlock ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil]].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ul 6/17/2011 12:20'!copyFromRootsLocalFileFor: rootArray sizeHint: segSize	"If the roots include a World, add its Player classes to the roots."	| newRoots |	arrayOfRoots := rootArray.	[(newRoots := self rootsIncludingPlayers) == nil] whileFalse: [		arrayOfRoots := newRoots].		"world, presenter, and all Player classes"	self copyFromRoots: arrayOfRoots sizeHint: segSize.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ul 6/17/2011 12:20'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder replacements naughtyBlocks allClasses sizeHint proj dummy |	"self halt."	symbolHolder := Symbol allSymbols.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy := ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	(proj :=dummy project) ifNotNil: [self dependentsSave: dummy].	allClasses := SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	allClasses do: [:cls | 		dummy references at: cls class put: false.	"put Player5 class in roots"		dummy blockers removeKey: cls class ifAbsent: []].	"refs := dummy references."	arrayOfRoots := self smartFillRoots: dummy.	"guaranteed none repeat"	self savePlayerReferences: dummy references.	"for shared References table"	replacements := dummy blockers.	dummy project "recompute it" ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy := nil.	"force GC?"	naughtyBlocks := arrayOfRoots select: [ :each |		(each isKindOf: ContextPart) and: [each hasInstVarRef]	].	"since the caller switched ActiveWorld, put the real one back temporarily"	naughtyBlocks isEmpty ifFalse: [		World becomeActiveDuring: [ | goodToGo |			goodToGo := (UIManager default				chooseFrom: #('keep going' 'stop and take a look')				title:'Some block(s) which reference instance variables are included in this segment. These may fail whenthe segment is loaded if the class has been reshaped.What would you like to do?') = 1.			goodToGo ifFalse: [				naughtyBlocks inspect.				self error: 'Here are the bad blocks'].		].	].	"Creation of the segment happens here"	"try using one-quarter of memory min: four megs to publish (will get bumped later)"	sizeHint := (Smalltalk garbageCollect // 4 // 4) min: 1024*1024.	self copyFromRoots: arrayOfRoots sizeHint: sizeHint areUnique: true.	segSize := segment size.	[(newRoots := self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods pointed at from outside"	[(newRoots := self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods, blocks from outPointers"	list := self compactClassesArray.	outPointers := outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) isBlock ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	proj ifNotNil: [self dependentsCancel: proj].	symbolHolder.! !!ImageSegment methodsFor: 'testing' stamp: 'ul 6/17/2011 12:20'!findRogueRootsImSeg: rootArray	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) Break all owner pointers in submorphs and all scripts.2) Create the segment and look at outPointers.3) Remove those we expect.4) Remember to quit without saving -- the owner pointers are smashed."| newRoots suspects bag1 bag2 |arrayOfRoots := rootArray.[(newRoots := self rootsIncludingPlayers) == nil] whileFalse: [	arrayOfRoots := newRoots].		"world, presenter, and all Player classes"self findRogueRootsPrep.	"and free that context!!"Smalltalk garbageCollect.self copyFromRoots: arrayOfRoots sizeHint: 0.suspects := outPointers select: [:oo | oo isMorph].suspects size > 0 ifTrue: [suspects inspect].bag1 := Bag new.  bag2 := Bag new.outPointers do: [:key | 	(key isKindOf: Class) 		ifTrue: [bag2 add: key class name]		ifFalse: [(#(Symbol Point Rectangle True False String Float Color Form ColorForm StrikeFont Metaclass UndefinedObject TranslucentColor) includes: key class name)			ifTrue: [bag2 add: key class name]			ifFalse: [bag1 add: key class name]]]."(bag sortedCounts) is the SortedCollection"(StringHolder new contents: bag1 sortedCounts printString, '', bag2 sortedCounts printString) 	openLabel: 'Objects pointed at by the outside'.self halt: 'Examine local variables pointIn and inSeg'."Use this in inspectors:	outPointers select: [:oo | oo class == <a Class>].		"! !!IndentingListItemMorph methodsFor: 'enumeration' stamp: 'ul 8/2/2011 20:02'!childrenDo: aBlock	firstChild ifNotNil: [		firstChild withSiblingsDo: aBlock ]! !!InflateStream methodsFor: 'accessing' stamp: 'ul 12/6/2011 11:47'!next: n into: buffer startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| c numRead count |	n = 0 ifTrue: [ ^buffer ].	numRead := 0.	["Force decompression if necessary"	(c := self next) == nil 		ifTrue:[^buffer copyFrom: 1 to: startIndex+numRead-1].	"Store the first value which provoked decompression"	buffer at: startIndex + numRead put: c.	numRead := numRead + 1.	"After collection has been filled copy as many objects as possible"	count := (readLimit - position) min: (n - numRead).	buffer 		replaceFrom: startIndex + numRead 		to: startIndex + numRead + count - 1 		with: collection 		startingAt: position+1.	position := position + count.	numRead := numRead + count.	numRead = n] whileFalse.	^buffer! !!InflateStream methodsFor: 'accessing' stamp: 'ul 12/6/2011 12:16'!readInto: buffer startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	| c numRead count |	n = 0 ifTrue: [ ^n ].	numRead := 0.	["Force decompression if necessary"	(c := self next) == nil 		ifTrue: [^numRead].	"Store the first value which provoked decompression"	buffer at: startIndex + numRead put: c.	numRead := numRead + 1.	"After collection has been filled copy as many objects as possible"	count := (readLimit - position) min: (n - numRead).	buffer 		replaceFrom: startIndex + numRead 		to: startIndex + numRead + count - 1 		with: collection 		startingAt: position+1.	position := position + count.	numRead := numRead + count.	numRead = n] whileFalse.	^n! !!InflateStream commentStamp: 'nice 3/24/2010 07:37' prior: 0!This class implements the Inflate decompression algorithm as defined by RFC1951 and used in PKZip, GZip and ZLib (and many, many more). It is a variant of the LZ77 compression algorithm described in[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data Compression", IEEE Transactions on Information Theory", Vol. 23, No. 3, pp. 337-343.[RFC1951] Deutsch. P, "DEFLATE Compressed Data Format Specification version 1.3"For more information see the above mentioned RFC 1951 which can for instance be found at	http://www.leo.org/pub/comp/doc/standards/rfc/index.htmlHuffman Tree Implementation Notes:===========================================The huffman tree used for decoding literal, distance and length codes in the inflate algorithm has been encoded in a single Array. The tree is made up of subsequent tables storing all entries at the current bit depth. Each entry in the table (e.g., a 32bit Integer value) is either a leaf or a non-leaf node. Leaf nodes store the immediate value in its low 16 bits whereas non-leaf nodes store the offset of the subtable in its low 16bits. The high 8 bits of non-leaf nodes contain the number of additional bits needed for the sub table (the high 8 bits of leaf-nodes are always zero). The first entry in each table is always a non-leaf node indicating how many bits we need to fetch initially. We can thus travel down the tree as follows (written in sort-of-pseudocode the actual implementation can be seen in InflateStream>>decodeValueFrom:):	table := initialTable.	bitsNeeded := high 8 bits of (table at: 1).		"Determine initial bits"	table := initialTable + (low 16 bits of (table at: 1)). "Determine start of first real table"	[bits := fetch next bitsNeeded bits.			"Grab the bits"	value := table at: bits.						"Lookup the value"	value has high 8 bit set] whileTrue:[		"Check if it's leaf"		table := initialTable + (low 16 bits of value).	"No - compute new sub table start"		bitsNeeded := high 8 bit of value].		"Compute additional number of bits needed"	^value!!InputSensor methodsFor: 'user interrupts' stamp: 'nice 3/31/2011 01:37'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[ InterruptSemaphore wait.	Display deferUpdates: false.	SoundService default shutDown.	Smalltalk handleUserInterrupt ] repeat! !!Inspector methodsFor: 'menu commands' stamp: 'ul 11/15/2010 11:43'!chasePointers	| selected  saved |	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	selected := self selection.	saved := self object.	[self object: nil.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [PointerFinder on: selected]		ifFalse: [self inspectPointers]]		ensure: [self object: saved]! !!Inspector methodsFor: 'menu commands' stamp: 'mtf 4/25/2008 14:17'!explorePointers	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	PointerExplorer new openExplorerFor: self selection! !!Inspector methodsFor: 'menu commands' stamp: 'cmm 5/2/2011 09:56'!fieldListMenu: aMenu	"Arm the supplied menu with items for the field-list of the receiver"	aMenu addStayUpItemSpecial.	aMenu addList: #(		('inspect (i)'						inspectSelection)		('explore (I)'						exploreSelection)).	self addCollectionItemsTo: aMenu.	aMenu addList: #(		-		('method refs to this inst var'		referencesToSelection)		('methods storing into this inst var'	defsOfSelection)		('objects pointing to this value'		objectReferencesToSelection)		('chase pointers'					chasePointers)		('explore pointers'				explorePointers)		-		('browse full (b)'					browseMethodFull)		('browse class'						browseClass)		('browse hierarchy (h)'					classHierarchy)		('browse protocol (p)'				browseFullProtocol)		-		('references... (r)'					browseVariableReferences)		('assignments... (a)'					browseVariableAssignments)		('class refs (N)'						browseClassRefs)		-		('copy name (c)'					copyName)				('basic inspect'						inspectBasic)).	Smalltalk isMorphic ifTrue:		[aMenu addList: #(			-			('tile for this value	(t)'			tearOffTile)			('viewer for this value (v)'		viewerForValue))].	^ aMenu"			-			('alias for this value'			aliasForValue)			('watcher for this slot'			watcherForSlot)"! !!Inspector methodsFor: 'menu commands' stamp: 'ul 11/15/2010 11:43'!inspectElement	| sel selSize countString count nameStrs |	"Create and schedule an Inspector on an element of the receiver's model's currently selected collection."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	((sel := self selection) isKindOf: SequenceableCollection) ifFalse:		[(sel isKindOf: MorphExtension) ifTrue: [^ sel inspectElement].		^ sel inspect].	(selSize := sel size) = 1 ifTrue: [^ sel first inspect].	selSize <= 20 ifTrue:		[nameStrs := (1 to: selSize) asArray collect: [:ii | 			ii printString, '   ', (((sel at: ii) printStringLimitedTo: 25) replaceAll: Character cr with: Character space)].		count := UIManager default chooseFrom: (nameStrs substrings) title: 'which element?'.		count = 0 ifTrue: [^ self].		^ (sel at: count) inspect].	countString := UIManager default request: 'Which element? (1 to ', selSize printString, ')' initialAnswer: '1'.	countString isEmptyOrNil ifTrue: [^ self].	count := Integer readFrom: (ReadStream on: countString).	(count > 0 and: [count <= selSize])		ifTrue: [(sel at: count) inspect]		ifFalse: [Beeper beep]! !!Inspector methodsFor: 'menu commands' stamp: 'ul 11/15/2010 11:44'!objectReferencesToSelection	"Open a list inspector on all the objects that point to the value of the selected instance variable, if any.  "	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	self systemNavigation		browseAllObjectReferencesTo: self selection		except: (Array with: self object)		ifNone: [:obj | self changed: #flash].! !!Inspector methodsFor: 'menu commands' stamp: 'ul 11/15/2010 11:44'!viewerForValue	"Open up a viewer on the value of the receiver's current selection"	| objectToRepresent |	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	objectToRepresent beViewed	! !!Inspector methodsFor: 'selecting' stamp: 'nice 3/31/2011 22:00'!accept: aString 	| result |	result := self doItReceiver class evaluatorClass new				evaluate: (ReadStream on: aString)				in: self doItContext				to: self doItReceiver				notifying: nil  "fix this"				ifFail: [self changed: #flash.					^ false].	self replaceSelectionValue: result.	self changed: #contents.	^ true! !!Inspector methodsFor: 'toolbuilder' stamp: 'bf 9/6/2011 13:30'!buildFieldListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #fieldList; 		getIndex: #selectionIndex; 		setIndex: #toggleIndex:; 		menu: #fieldListMenu:; 		dragItem: #dragFromFieldList:;		dropItem: #dropOnFieldList:at:;		keyPress: #inspectorKey:from:.	^listSpec! !!Inspector methodsFor: '*Protocols-Tools' stamp: 'ul 11/15/2010 11:43'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.  If in mvc, an old-style protocol browser is opened instead."	| objectToRepresent |	Smalltalk isMorphic ifFalse: [^ self spawnProtocol].	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	InstanceBrowser new openOnObject: objectToRepresent showingSelector: nil! !!Inspector methodsFor: '*Protocols-Tools' stamp: 'ul 11/15/2010 11:44'!spawnFullProtocol	"Spawn a window showing full protocol for the receiver's selection"	| objectToRepresent |	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openFullProtocolForClass: objectToRepresent class! !!Inspector methodsFor: '*Protocols-Tools' stamp: 'ul 11/15/2010 11:44'!spawnProtocol	"Spawn a protocol on browser on the receiver's selection"	| objectToRepresent |	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openSubProtocolForClass: objectToRepresent class! !!Inspector methodsFor: '*Etoys-menu commands' stamp: 'ul 11/15/2010 11:44'!tearOffTile	"Tear off a tile that refers to the receiver's selection, and place it in the mophic hand"	| objectToRepresent |	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	self currentHand attachMorph: (TileMorph new referTo: objectToRepresent)	! !!Inspector methodsFor: 'drag-drop' stamp: 'bf 9/6/2011 13:25'!dragFromFieldList: index	selectionIndex = index ifFalse: [self toggleIndex: index].	^self selection! !!Inspector methodsFor: 'drag-drop' stamp: 'bf 9/6/2011 13:38'!dropOnFieldList: anObject at: index	selectionIndex = index ifFalse: [self toggleIndex: index].	self replaceSelectionValue: anObject.	self changed: #contents.	^ true! !!Installer methodsFor: 'public interface' stamp: 'spd 9/6/2010 16:06'!install: packageNameCollectionOrDetectBlock	"The parameter specifies the package to be installed in one of the following ways:		- By Name e.g. install: 'Kernel'		- Acceptable Versions e.g. install: #('Comet-lr' 'Comet-pmm') i.e. either of these		- Specific version e.g. install: 'Scriptaculous-lr.148'		- By Predicate e.g. install: [ :packageName | packageName beginsWith: 'Dynamic' ]"	self addPackage: packageNameCollectionOrDetectBlock.	self install! !!Installer class methodsFor: 'repositories' stamp: 'mtf 2/3/2011 03:56'!cobalt	^ self monticello http: 'http://croquet-src-01.oit.duke.edu:8886'! !!Installer class methodsFor: 'repositories' stamp: 'ul 12/6/2011 16:06'!gemsource	^ self monticello http: 'http://seaside.gemstone.com/ss'! !!Installer class methodsFor: 'repositories' stamp: 'topa 11/18/2011 15:24'!gs	^ self gemsource! !!Installer class methodsFor: 'repositories' stamp: 'jmg 9/14/2011 21:17'!squeaksource3	^ self monticello http: 'http://ss3.gemstone.com/ss/'! !!Installer class methodsFor: 'repositories' stamp: 'jmg 9/14/2011 21:16'!ss3	^ self squeaksource3.! !!Installer class methodsFor: 'repositories' stamp: 'topa 11/18/2011 15:23'!swa	^ self swasource! !!Installer class methodsFor: 'repositories' stamp: 'topa 11/18/2011 15:23'!swasource	^ self monticello http: 'http://www.hpi.uni-potsdam.de/hirschfeld/squeaksource'! !!Installer class methodsFor: 'during' stamp: 'cmm 10/19/2011 20:45'!noProgressDuring: block	[ block value: self ] 		on: ProgressInitiationException 		do: [ : note | note sendNotificationsTo: [ :min :max :curr | "ignore" ] ]! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'cmm 3/5/2011 18:22'!basicAvailablePackages	^ self mc allPackageNames! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'ul 10/17/2010 03:33'!basicBrowse	 "Installer ss project: 'Installer'; browse: 'Installer-Core'."	| it |	it := self mcThing.		(it class includesSelector: #browse) ifTrue: [ ^ it browse ].		(it instVarNamed: 'versions') do: [ :each | each browse ].! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'ul 10/17/2010 03:33'!basicView	 "Installer ss project: 'Installer'; view: 'Installer-Core'. "	| it |		packages isEmptyOrNil ifTrue: [ self mc morphicOpen: nil ].		it := self mcThing. 	(it respondsTo: #open) ifTrue: [ ^ it open ].	"in case an old mc doesnt have #open"		(it instVarNamed: 'versions') do: [ :each | each open ].! !!InstallerMonticello methodsFor: 'monticello' stamp: 'nice 5/8/2011 10:34'!mcDetectFileBlock: pkg	pkg isString ifTrue: [  ^ [ :aFile | aFile beginsWith: pkg ] ].	(pkg isKindOf: Array) 			ifTrue: [  ^  [ :aFile | pkg anySatisfy: [ :item | aFile beginsWith: item ] ] ].	pkg isBlock ifTrue: [ ^ pkg ].   ! !!InstallerMonticello methodsFor: 'monticello' stamp: 'cmm 4/6/2011 13:05'!mcThing	| loader |	loader := self classMCVersionLoader new.	self logCR: 'reading ' , mc description , '...'.	"several attempts to read files - repository readableFileNames	sometimes fails"	self packages		do: [:pkg | 			| versionNames fileToLoad version |			versionNames := mc versionNamesForPackageNamed:				(pkg asMCVersionName versionNumber = 0 					ifTrue: [ "Just a package name specified, use it whole." pkg ] 					ifFalse: [pkg asMCVersionName packageName]).			versionNames sort: self mcSortFileBlock.			fileToLoad := versionNames						detect: (self mcDetectFileBlock: pkg)						ifNone: [ nil ].			fileToLoad				ifNotNil: [version := mc versionNamed: fileToLoad.					(version isKindOf: MCConfiguration)						ifTrue: [^ version]						ifFalse: [MCRepositoryGroup default addRepository: self normalizedRepository.							version workingCopy repositoryGroup addRepository: self normalizedRepository.							loader addVersion: version].					self logCR: ' found ' , version fileName , '...']].	^ loader! !!InstallerUniverse methodsFor: 'basic interface' stamp: 'nice 5/8/2011 10:35'!basicInstall	self packages do: [ :packageName |		| potentials pkg pkgAndVersion version |			pkgAndVersion := self packageAndVersionFrom: packageName.		pkg := pkgAndVersion first.		version := pkgAndVersion last.			potentials := universe packageVersionsForPackage: pkg.			pkg := version isEmpty 			ifTrue: [ potentials last ]			ifFalse: [ 				version := self classUVersion readFrom: version readStream.  				(potentials anySatisfy: [ :p | p version = version]) ifFalse: [ ^ self error: 'version not found']			].				universe planToInstallPackage: pkg.	].	self uniDoInstall! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'ul 11/15/2010 11:44'!loadUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Installer new loadUpdatesFromDiskToUpdateNumber: 100020 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."		"apparently does not use the updatelist too bad!! and to rewrite - sd 7 March 2008"	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory := self updateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest := SystemVersion current highestUpdate.	currentUpdateNumber := previousHighest.	done := false.	loaded := 0.	[done]		whileFalse: [currentUpdateNumber := currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done := true]				ifFalse: [fileNames := updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size = 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done := stopIfGapFlag]						ifFalse: [ChangeSet								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							SystemVersion current registerUpdate: currentUpdateNumber.							loaded := loaded + 1]]].	aMessage := loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!InstallerUpdateStream methodsFor: 'updates' stamp: 'nice 6/11/2010 21:25'!parseUpdateListContents: listContentString	"Parse the contents of an updates.list into {{releaseTag. {fileNames*}}*}, and return it."	| sections releaseTag strm line fileNames |	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	releaseTag := nil.	strm := ReadStream on: listContentString.	[strm atEnd] whileFalse:		[line := strm nextLine.		line size > 0 ifTrue:			[line first = $#				ifTrue: [releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].						releaseTag := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].	^ sections asArray! !!InstanceBrowser methodsFor: 'menu commands' stamp: 'cmm 5/2/2011 09:57'!offerMenu	"Offer a menu to the user, in response to the hitting of the menu button on the tool pane"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Messages of ', objectViewed nameForViewer.	aMenu addStayUpItem.	aMenu addList: #(		('vocabulary...' 			chooseVocabulary)		('what to show...'			offerWhatToShowMenu)		-		('inst var refs (here)'		setLocalInstVarRefs)		('inst var defs (here)'		setLocalInstVarDefs)		('class var refs (here)'		setLocalClassVarRefs)		-		('navigate to a sender...' 	navigateToASender)		('recent...' 					navigateToRecentMethod)		('show methods in current change set'									showMethodsInCurrentChangeSet)		('show methods with initials...'									showMethodsWithInitials)		-		"('toggle search pane' 		toggleSearch)"		-		-		('browse full (b)' 			browseMethodFull)		('browse hierarchy (h)'		classHierarchy)		('browse method (O)'		openSingleMessageBrowser)		('browse protocol (p)'		browseFullProtocol)		-		('fileOut'					fileOutMessage)		('printOut'					printOutMessage)		-		('senders of... (n)'			browseSendersOfMessages)		('implementors of... (m)'		browseMessages)		('versions (v)' 				browseVersions)		('inheritance (i)'			methodHierarchy)		-		('references... (r)' 				browseVariableReferences)		('assignments... (a)' 				browseVariableAssignments)		-		('viewer on me'				viewViewee)		('inspector on me'			inspectViewee)		-		('more...'					shiftedYellowButtonActivity)).	aMenu popUpInWorld: ActiveWorld! !!InstanceVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitInstanceVariableNode: self! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:05'!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVar: index.	stack pop: 1! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57'!sizeCodeForStore: encoder	^encoder sizeStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53'!sizeCodeForValue: encoder	^encoder sizePushInstVar: index! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingBytecode	"Answer the bytecode of the following bytecode (different to nextByte)."	^self method at: self followingPc! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingPc	"Answer the pc of the following bytecode."	^self nextPc: (self method at: pc)! !!InstructionStream methodsFor: 'scanning' stamp: 'mha 9/23/2010 10:30'!scanFor: scanBlock	"Check all bytecode instructions with scanBlock, answer true if scanBlock answers true.	This can be used to, e.g., check whether a method contains 'push closure' bytecodes like this:	aMethod scanFor: [ :b | b = 143 ]"	| method end byte |	method := self method.	end := method endPC.	[pc <= end] whileTrue: 		[(scanBlock value: (byte := method at: pc)) ifTrue:			[^true].		 pc := self nextPc: byte].	^false! !!InstructionStream methodsFor: 'testing' stamp: 'ul 11/15/2010 10:11'!willReallySend	"Answer whether the next bytecode is a real message-send,	not blockCopy:."	| byte |	byte := self method at: pc.	^byte >= 131	  and: [byte ~= 200	  and: [byte >= 176   "special send or short send"		or: [byte <= 134 "long sends"				and: [| litIndex |				"long form support demands we check the selector"				litIndex := byte = 132							ifTrue: [(self method at: pc + 1) // 32 > 1 ifTrue: [^false].									self method at: pc + 2]							ifFalse: [byte = 134										ifTrue: [(self method at: pc + 1) bitAnd: 2r111111]										ifFalse: [(self method at: pc + 1) bitAnd: 2r11111]].				(self method literalAt: litIndex + 1) ~~ #blockCopy:]]]]! !!InstructionStream methodsFor: 'private' stamp: 'eem 8/13/2010 11:38'!nextPc: currentByte	"Answer the pc of the next bytecode following the current one, given the current bytecode.."	| type |	type := currentByte // 16.	^type = 8 "extensions"				ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 1 3 3 3 4) at: currentByte \\ 16 + 1)]				ifFalse: [type = 10 "long jumps"							ifTrue: [pc + 2]							ifFalse: [pc + 1]]! !!Integer methodsFor: 'arithmetic' stamp: 'nice 9/2/2010 21:29'!reciprocalModulo: n	"Answer an integer x such that (self * x) \\ n = 1, x > 0, x < n.	Raise an error if there is no such integer.	The algorithm is a non extended euclidean modular inversion called NINV.	It is described in this article:		'Using an RSA Accelerator for Modular Inversion'	by Martin Seysen. See http://www.iacr.org/archive/ches2005/017.pdf"	| u v f fPlusN b result result2 |	((self <= 0) or: [n <= 0]) ifTrue: [self error: 'self and n must be greater than zero'].	self >= n ifTrue: [self error: 'self must be < n'].	b := n highBit + 1.	f := 1 bitShift: b.	v := (self bitShift: b) + 1.	u := n bitShift: b.	fPlusN := f + n.	[v >= fPlusN] whileTrue:		[v := u \\\ (u := v)].	result := v - f.	(result2 := result + n) > 0		ifFalse: [self error: 'no inverse'].	^result positive		ifTrue: [result]		ifFalse: [result2]! !!Integer methodsFor: 'bit manipulation' stamp: 'cmm 4/11/2011 20:43'!bitReverse: highBit 	"Reverse the bits of the receiver so that the lsb is the highBit'th bit of the answer.  Translated from C code at:  http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious."	| v r s |	highBit < self highBit ifTrue: [ self error: 'Not enough bits.' ].	v := self.	r := v bitAnd: 1.	s := highBit - 1.	[ v := v bitShift: -1.	v = 0 ] whileFalse:		[ r := r bitShift: 1.		r := r bitOr: (v bitAnd: 1).		s := s - 1 ].	^ r bitShift: s! !!Integer methodsFor: 'bit manipulation' stamp: 'ul 7/18/2011 17:28'!lowBit	"Answer the index of the low order bit of this number."		| index digit |	index := 0.	[ (digit := self digitAt: (index := index + 1)) = 0 ] whileTrue.	^(LowBitPerByteTable at: digit) + (index - 1 * 8)! !!Integer methodsFor: 'comparing' stamp: 'ul 7/4/2011 03:16'!= aNumber	aNumber isInteger ifTrue: [		aNumber class == self class ifFalse: [ ^false ].		^(self digitCompare: aNumber) = 0 ].	aNumber isNumber ifFalse: [ ^false ].	^aNumber adaptToInteger: self andCompare: #=! !!Integer methodsFor: 'converting' stamp: 'nice 9/7/2011 22:03'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert me to a Fraction."	^ rcvr perform: selector with: (Fraction numerator: self denominator: 1)! !!Integer methodsFor: 'converting' stamp: 'nice 9/22/2011 01:39'!asFloat	"Answer a Float that best approximates the value of the receiver."		self subclassResponsibility! !!Integer methodsFor: 'converting' stamp: 'nice 9/7/2011 22:21'!asFraction	"Answer a Fraction that represents the value of the receiver.	Since an Integer already behaves as a special kind of Fraction, no conversion is required, see #isFraction."	^self! !!Integer methodsFor: 'converting' stamp: 'brp 5/13/2003 10:12'!asYear	^ Year year: self ! !!Integer methodsFor: 'mathematical functions' stamp: 'jmv 10/19/2011 22:39'!nthRoot: aPositiveInteger	"Answer the nth root of the receiver.	See #nthRootAlt: for an alternative implementation."	| selfAsFloat floatResult guess delta higher lower raised |	selfAsFloat := self asFloat.	"If we can't do Float arithmetic because we are too big, then look for an exact answer in exact arithmetic"	selfAsFloat isInfinite ifTrue: [		guess := self nthRootTruncated: aPositiveInteger.		(guess raisedToInteger: aPositiveInteger) = self			ifTrue: [ ^ guess ].		"Nothing else can be done. No exact answer means answer must be a Float.		Answer the best we have."		^guess asFloat ].	floatResult := selfAsFloat nthRoot: aPositiveInteger.	guess := floatResult rounded.	"If got an exact answer, answer it."	raised := guess raisedToInteger: aPositiveInteger.	raised = self		ifTrue: [ ^ guess ].	"In this case, maybe it failed because we are such a big integer that the Float	method gets inexact, even if we are a whole square number.	Note 1(jmv): This algorithm is faster than #nthRootTruncated: for big n (aPositiveInteger)	but fails if self asFloat isInfinite.	Note 2(jmv): The algorithms I found for computing the nthRoot would havily use	very large fractions. I wrote this one, that doesn't create fractions."	selfAsFloat abs >= (Float maxExactInteger asFloat raisedToInteger: aPositiveInteger)		ifTrue: [			raised > self				ifTrue: [					higher := guess.					delta :=  floatResult predecessor - floatResult.					[						floatResult := floatResult + delta.						lower := floatResult rounded.						(lower raisedToInteger: aPositiveInteger) > self ] whileTrue: [							delta := delta * 2.							higher := lower ] ]				ifFalse: [					lower := guess.					delta :=  floatResult successor - floatResult.					[						floatResult := floatResult + delta.						higher := floatResult rounded.						(higher raisedToInteger: aPositiveInteger) < self ] whileTrue: [							delta := delta * 2.							lower := higher ]].			[ higher - lower > 1 ] whileTrue: [				guess := lower + higher // 2.				raised := guess raisedToInteger: aPositiveInteger.				raised = self					ifTrue: [						^ guess ].				raised > self					ifTrue: [ higher := guess ]					ifFalse: [ lower := guess ]]].	"We need an approximate result"	^floatResult! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 10/19/2011 20:21'!nthRootTruncated: aPositiveInteger	"Answer the integer part of the nth root of the receiver."	| guess guessToTheNthMinusOne delta |	self = 0 ifTrue: [^0].	self negative		ifTrue:			[aPositiveInteger even ifTrue: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ].			^(self negated nthRootTruncated: aPositiveInteger) negated].	guess := 1 bitShift: self highBitOfMagnitude + aPositiveInteger - 1 // aPositiveInteger.	[		guessToTheNthMinusOne := guess raisedTo: aPositiveInteger - 1.		delta := (guess * guessToTheNthMinusOne - self) // (guessToTheNthMinusOne * aPositiveInteger).		delta = 0 ] whileFalse:			[ guess := guess - delta ].	( (guess := guess - 1) raisedTo: aPositiveInteger) > self  ifTrue:			[ guess := guess - 1 ].	^guess! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 5/19/2011 02:10'!raisedToInteger: exp modulo: m	self deprecated: 'rather use #raisedTo:modulo: for efficiency'.	(exp = 0) ifTrue: [^ 1].	exp even		ifTrue: [^ (self raisedToInteger: (exp // 2) modulo: m) squared \\ m]		ifFalse: [^ (self * (self raisedToInteger: (exp - 1) modulo: m)) \\ m].! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 5/19/2011 02:08'!raisedTo: n modulo: m	"Answer the modular exponential.	Note: this implementation is optimized for case of large integers raised to large powers."	| a s mInv |	n = 0 ifTrue: [^1].	(self >= m or: [self < 0]) ifTrue: [^self \\ m raisedTo: n modulo: m].	n < 0 ifTrue: [^(self reciprocalModulo: m) raisedTo: n negated modulo: m].	(n < 4096 or: [m even])		ifTrue:			["Overhead of Montgomery method might cost more than naive divisions, use naive"			^self slidingLeftRightRaisedTo: n modulo: m].		mInv := 256 - ((m bitAnd: 255) reciprocalModulo: 256). 	"Initialize the result to R=256 raisedTo: m digitLength"	a := (1 bitShift: m digitLength*8) \\ m.		"Montgomerize self (multiply by R)"	(s := self montgomeryTimes: (a*a \\ m) modulo: m mInvModB: mInv)		ifNil:			["No Montgomery primitive available ? fallback to naive divisions"			^self slidingLeftRightRaisedTo: n modulo: m].	"Exponentiate self*R"	a := s montgomeryRaisedTo: n times: a modulo: m mInvModB: mInv.	"Demontgomerize the result (divide by R)"	^a montgomeryTimes: 1 modulo: m mInvModB: mInv! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 10/29/2011 15:00'!sqrt	"Answer the square root of the receiver."	| selfAsFloat floatResult guess |	selfAsFloat := self asFloat.	floatResult := selfAsFloat sqrt.	floatResult isInfinite ifFalse: [		guess := floatResult truncated.		"If got an exact answer, answer it. Otherwise answer float approximate answer."		guess squared = self			ifTrue: [ ^ guess ]].	"In this case, maybe it failed because we are such a big integer that the Float method becomes	inexact, even if we are a whole square number. So, try the slower but more general method"	selfAsFloat >= Float maxExactInteger asFloat squared		ifTrue: [			guess := self sqrtFloor.			guess squared = self ifTrue: [				^guess ].						"Nothing else can be done. No exact answer means answer must be a Float.			Answer the best we have which is the rounded sqrt."			guess := (self * 4) sqrtFloor.			^(guess // 2 + (guess \\ 2)) asFloat].	"We need an approximate result"	^floatResult! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 10/17/2011 22:53'!sqrtFloor	"Return the integer part of the square root of self"	| guess delta |	guess := 1 bitShift: self highBit + 1 // 2.	[		delta := guess squared - self // (guess bitShift: 1).		delta = 0 ] whileFalse: [			guess := guess - delta ].	^guess - 1! !!Integer methodsFor: 'printing' stamp: 'eem 5/21/2010 11:06'!hex	"Print the receiver as hex, prefixed with 16r.  DO NOT CHANGE THIS!!  The Cog VMMaker depends on this.	 Consider using any of		printStringHex		printStringBase: 16		printStringBase: 16 length: 8 padded: true		storeStringHex		storeStringBase: 16		storeStringBase: 16 length: 11 padded: true"	^self storeStringBase: 16! !!Integer methodsFor: 'printing' stamp: 'nice 6/17/2011 04:10'!numberOfDigitsInBase: b 	"Return how many digits are necessary to print this number in base b.	This does not count any place for minus sign, radix prefix or whatever.	Note that this algorithm may cost a few operations on LargeInteger."	| nDigits q total |	self negative ifTrue: [^self negated numberOfDigitsInBase: b].	self < b ifTrue: [^1].	b isPowerOfTwo ifTrue: [^self highBit + b highBit - 2 quo: b highBit - 1].		"A conversion from base 2 to base b has to be performed.	This algorithm avoids Float computations like (self log: b) floor + 1,	1) because they are inexact	2) because LargeInteger might overflow	3) because this algorithm might be cheaper than conversion"	q := self.	total := 0.	["Make an initial nDigits guess that is lower than or equal to required number of digits"	nDigits := b = 10		ifTrue: [((q highBit - 1) * 1233 >> 12) + 1. "This is because (2 log)/(10 log)*4096 is slightly greater than 1233"]		ifFalse: [q highBit quo: b highBit].	total := total + nDigits.		"See how many digits remains above these first nDigits guess"	(q := q quo: (b raisedToInteger: nDigits)) < b] whileFalse.	^q = 0		ifTrue: [total]		ifFalse: [total + 1]! !!Integer methodsFor: 'printing' stamp: 'nice 3/29/2011 21:58'!printOn: aStream showingDecimalPlaces: placesDesired	"Same as super, but provides a faster implementation because fraction part and rounding are trivial."		self printOn: aStream base: 10.	placesDesired <= 0		ifFalse:			[aStream nextPut: $..			0 printOn: aStream base: 10 length: placesDesired padded: true].! !!Integer methodsFor: 'printing' stamp: 'nice 9/8/2011 22:07'!printTruncatedOn: aStream showingDecimalPlaces: placesDesired	"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator.	Print as if the receiver was truncated to requested precision."	self printOn: aStream.	placesDesired > 0		ifTrue:			[aStream nextPut: $..			aStream next: placesDesired put: $0]! !!Integer methodsFor: 'testing' stamp: 'nice 9/7/2011 22:20'!isFraction	"Each Integer is considered as a special kind of Fraction with self as numerator and a unit denominator.	Rationale: A Fraction with a unit denominator will be automatically reduced to an Integer.	Hence Integer has to be polymorphic to Fraction."	^true! !!Integer methodsFor: 'testing' stamp: 'nice 11/14/2011 21:59'!isProbablyPrime	"See isProbablyPrimeWithK:andQ: for the algoritm description."		| k q |	self <= 1 ifTrue: [ ^false ].	self even ifTrue: [ ^self = 2 ].	"Factor self into (2 raisedTo: k) * q + 1, where q odd"	q := self bitShift: -1.	k := q lowBit.	q := q bitShift: 1 - k.	"Repeat the probabilistic until false (the probability of false negative is null) or until probability is very low."	25 timesRepeat: [ (self isProbablyPrimeWithK: k andQ: q) ifFalse: [ ^false ] ].	"The probability of false positive after 25 iterations is less than (1/4 raisedTo: 25) < 1.0e-15"	^true! !!Integer methodsFor: 'private' stamp: 'nice 9/24/2011 22:50'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	<primitive: 'primDigitDivNegative' module:'LargeIntegers'>	arg = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	"TFEI added this line"	l := self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^ Array with: 0 with: self].	"shortcut against #highBit"	d := 8 - arg lastDigit highBitOfByte.	div := arg digitLshift: d.	div := div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem := self digitLshift: d.	rem digitLength = self digitLength ifTrue: [rem := rem growto: self digitLength + 1].	"makes a copy and shifts"	quo := Integer new: l neg: ng.	dl := div digitLength - 1.	"Last actual byte of data"	ql := l.	dh := div digitAt: dl.	dnh := dl = 1				ifTrue: [0]				ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j := rem digitLength + 1 - k.		"r1 := rem digitAt: j."		(rem digitAt: j)			= dh			ifTrue: [qhi := qlo := 15				"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13  				bits."				"r2 := (rem digitAt: j - 1)."				t := ((rem digitAt: j)							bitShift: 4)							+ ((rem digitAt: j - 1)									bitShift: -4).				qhi := t // dh.				t := (t \\ dh bitShift: 4)							+ ((rem digitAt: j - 1)									bitAnd: 15).				qlo := t // dh.				t := t \\ dh.				"Next compute (hi,lo) := q*dnh"				hi := qhi * dnh.				lo := qlo * dnh + ((hi bitAnd: 15)								bitShift: 4).				hi := (hi bitShift: -4)							+ (lo bitShift: -8).				lo := lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 := j < 3							ifTrue: [0]							ifFalse: [rem digitAt: j - 2].				[(t < hi					or: [t = hi and: [r3 < lo]])					and: 						["i.e. (t,r3) < (hi,lo)"						qlo := qlo - 1.						lo := lo - dnh.						lo < 0							ifTrue: 								[hi := hi - 1.								lo := lo + 256].						hi >= dh]]					whileTrue: [hi := hi - dh].				qlo < 0					ifTrue: 						[qhi := qhi - 1.						qlo := qlo + 16]].		"Subtract q*div from rem"		l := j - dl.		a := 0.		1 to: div digitLength do: 			[:i | 			hi := (div digitAt: i)						* qhi.			lo := a + (rem digitAt: l) - ((hi bitAnd: 15)							bitShift: 4) - ((div digitAt: i)							* qlo).			rem digitAt: l put: lo - (lo // 256 * 256).			"sign-tolerant form of (lo bitAnd: 255)"			a := lo // 256 - (hi bitShift: -4).			l := l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo := qlo - 1.				l := j - dl.				a := 0.				1 to: div digitLength do: 					[:i | 					a := (a bitShift: -8)								+ (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l := l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4)				+ qlo].	rem := rem				digitRshift: d				bytes: 0				lookfirst: dl.	^ Array with: quo with: rem! !!Integer methodsFor: 'private' stamp: 'nice 11/15/2011 23:13'!isProbablyPrimeWithK: k andQ: q 	"Algorithm P, probabilistic primality test, from	Knuth, Donald E. 'The Art of Computer Programming', Vol 2,	Third Edition, section 4.5.4, page 395, P1-P5 refer to Knuth description..	Note that this is a Miller Rabin test which may answer false positives (known as pseudoprimes) for at most 1/4 of the possible bases x."	| x j y minusOne |	"P1"	x := (self - 2) atRandom + 1.	"P2"	j := 0.	y := x raisedTo: q modulo: self.	minusOne := self - 1.		["P3"	y = 1 ifTrue: [^j = 0].	y = minusOne ifTrue: [^true].	"P4"	(j := j + 1) < k]		whileTrue:			[y := y squared \\ self].	"P5"	^false! !!Integer methodsFor: 'private' stamp: 'nice 5/19/2011 02:08'!montgomeryRaisedTo: n times: y modulo: m mInvModB: mInv	"Private - do a Montgomery exponentiation of self modulo m.	The operation is equivalent to (self/y raisedTo: n)*y \\ m,	with y is (256 raisedTo: m digitLength),	with (m bitAnd: 255) * mInv \\ 256 = 255."		| pow j k w index oddPowersOfSelf square |		"Precompute powers of self for odd bit patterns xxxx1 up to length w + 1.	The width w is chosen with respect to the total bit length of n,	such that each bit pattern will on average be encoutered P times in the whole bit sequence of n.	This costs (2 raisedTo: w) multiplications, but more will be saved later (see below)."	k := n highBit.	w := (k highBit - 1 >> 1 min: 16) max: 1.	oddPowersOfSelf := Array new: 1 << w.	oddPowersOfSelf at: 1 put: (pow := self).	square := self montgomeryTimes: self modulo: m mInvModB: mInv.	2 to: oddPowersOfSelf size do: [:i | pow := oddPowersOfSelf at: i put: (pow montgomeryTimes: square modulo: m mInvModB: mInv)].		"Now exponentiate by searching precomputed bit patterns with a sliding window"	pow := y.	[k > 0]		whileTrue:			[pow := pow montgomeryTimes: pow modulo: m mInvModB: mInv.			"Skip bits set to zero (the sliding window)"			(n bitAt: k) = 0				ifFalse:					["Find longest odd bit pattern up to window length (w + 1)"					j := k - w max: 1.					[j < k and: [(n bitAt: j) = 0]] whileTrue: [j := j + 1].					"We found a bit pattern of length k-j+1;					perform the square powers for each bit					(same cost as bitwise algorithm);					compute the index of this bit pattern in the precomputed powers."					index := 0.					[k > j] whileTrue:						[pow := pow montgomeryTimes: pow modulo: m mInvModB: mInv.						index := index << 1 + (n bitAt: k).						k := k - 1].					"Perform a single multiplication for the whole bit pattern.					This saves up to (k-j) multiplications versus a naive algorithm operating bit by bit"					pow := pow montgomeryTimes: (oddPowersOfSelf at: index + 1) modulo: m mInvModB: mInv].			k := k - 1].	^pow! !!Integer methodsFor: 'private' stamp: 'nice 5/18/2011 22:29'!montgomeryTimes: a modulo: m mInvModB: mInv	"Answer the result of a Montgomery multiplication	self * a * (256 raisedTo: m digitLength) inv \\ m	NOTE: it is assumed that:	self digitLength <= m digitLength	a digitLength <= m digitLength	mInv * m \\ 256 = (-1 \\ 256) = 255 (this implies m odd)		Answer nil in case of absent plugin or other failure."		<primitive: 'primMontgomeryTimesModulo' module:'LargeIntegers'>	^nil! !!Integer methodsFor: 'private' stamp: 'nice 5/19/2011 02:00'!slidingLeftRightRaisedTo: n modulo: m	"Private - compute (self raisedTo: n) \\ m,	Note: this method has to be fast because it is generally used with large integers in cryptography.	It thus operate on exponent bits from left to right by packets with a sliding window rather than bit by bit (see below)."		| pow j k w index oddPowersOfSelf square |		"Precompute powers of self for odd bit patterns xxxx1 up to length w + 1.	The width w is chosen with respect to the total bit length of n,	such that each bit pattern will on average be encoutered P times in the whole bit sequence of n.	This costs (2 raisedTo: w) multiplications, but more will be saved later (see below)."	k := n highBit.	w := (k highBit - 1 >> 1 min: 16) max: 1.	oddPowersOfSelf := Array new: 1 << w.	oddPowersOfSelf at: 1 put: (pow := self).	square := self * self \\\ m.	2 to: oddPowersOfSelf size do: [:i | pow := oddPowersOfSelf at: i put: pow * square \\\ m].		"Now exponentiate by searching precomputed bit patterns with a sliding window"	pow := 1.	[k > 0]		whileTrue:			[pow := pow * pow \\\ m.			"Skip bits set to zero (the sliding window)"			(n bitAt: k) = 0				ifFalse:					["Find longest odd bit pattern up to window length (w + 1)"					j := k - w max: 1.					[j < k and: [(n bitAt: j) = 0]] whileTrue: [j := j + 1].					"We found an odd bit pattern of length k-j+1;					perform the square powers for each bit					(same cost as bitwise algorithm);					compute the index of this bit pattern in the precomputed powers."					index := 0.					[k > j] whileTrue:						[pow := pow * pow \\\ m.						index := index << 1 + (n bitAt: k).						k := k - 1].					"Perform a single multiplication for the whole bit pattern.					This saves up to (k-j) multiplications versus a naive algorithm operating bit by bit"					pow := pow * (oddPowersOfSelf at: index + 1) \\\ m].			k := k - 1].	^pow normalize! !!Integer methodsFor: 'accessing' stamp: 'nice 9/7/2011 21:47'!denominator	"Let an Integer be polymorphic to a Fraction. See #isFraction."	^1! !!Integer methodsFor: 'accessing' stamp: 'nice 9/7/2011 21:47'!numerator	"Let an Integer be polymorphic to a Fraction. See #isFraction."	^self! !!Integer commentStamp: '<historical>' prior: 0!I am a common abstract superclass for all Integer implementations. My implementation subclasses are SmallInteger, LargePositiveInteger, and LargeNegativeInteger.	Integer division consists of:	/	exact division, answers a fraction if result is not a whole integer	//	answers an Integer, rounded towards negative infinity	\\	is modulo rounded towards negative infinity	quo: truncated division, rounded towards zero!!Integer class methodsFor: 'prime numbers' stamp: 'nice 6/15/2011 00:21'!largePrimesUpTo: max do: aBlock	"Evaluate aBlock with all primes up to maxValue.	The Algorithm is adapted from http://www.rsok.com/~jrm/printprimes.html	It encodes prime numbers much more compactly than #primesUpTo: 	38.5 integer per byte (2310 numbers per 60 byte) allow for some fun large primes.	(all primes up to SmallInteger maxVal can be computed within ~27MB of memory;	the regular #primesUpTo: would require 4 *GIGA*bytes).	Note: The algorithm could be re-written to produce the first primes (which require	the longest time to sieve) faster but only at the cost of clarity."	| limit flags maskBitIndex bitIndex maskBit byteIndex index primesUpTo2310 indexLimit |	limit := max asInteger - 1.	indexLimit := max asInteger sqrtFloor + 1.	"Create the array of flags."	flags := ByteArray new: (limit + 2309) // 2310 * 60 + 60.	flags atAllPut: 16rFF. "set all to true"	"Compute the primes up to 2310"	primesUpTo2310 := self primesUpTo: 2310.	"Create a mapping from 2310 integers to 480 bits (60 byte)"	maskBitIndex := Array new: 2310.	bitIndex := -1. "for pre-increment"	maskBitIndex at: 1 put: (bitIndex := bitIndex + 1).	maskBitIndex at: 2 put: (bitIndex := bitIndex + 1).	1 to: 5 do:[:i| aBlock value: (primesUpTo2310 at: i)].	index := 6.	2 to: 2309 do:[:n|		[(primesUpTo2310 at: index) < n] 			whileTrue:[index := index + 1].		n = (primesUpTo2310 at: index) ifTrue:[			maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1).		] ifFalse:[			"if modulo any of the prime factors of 2310, then could not be prime"			(n \\ 2 = 0 or:[n \\ 3 = 0 or:[n \\ 5 = 0 or:[n \\ 7 = 0 or:[n \\ 11 = 0]]]]) 				ifTrue:[maskBitIndex at: n+1 put: 0]				ifFalse:[maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1)].		].	].	"Now the real work begins...	Start with 13 since multiples of 2,3,5,7,11 are handled by the storage method;	increment by 2 for odd numbers only."	13 to: limit by: 2 do:[:n|		(maskBit := maskBitIndex at: (n \\ 2310 + 1)) = 0 ifFalse:["not a multiple of 2,3,5,7,11"			byteIndex := n // 2310 * 60 + (maskBit-1 bitShift: -3) + 1.			bitIndex := 1 bitShift: (maskBit bitAnd: 7).			((flags at: byteIndex) bitAnd: bitIndex) = 0 ifFalse:["not marked -- n is prime"				aBlock value: n.				"Start with n*n since any integer < n has already been sieved 				(e.g., any multiple of n with a number k < n has been cleared 				when k was sieved); add 2 * i to avoid even numbers and				mark all multiples of this prime. Note: n < indexLimit below				limits running into LargeInts -- nothing more."				n < indexLimit ifTrue:[					index := n * n.					[index <= limit] whileTrue:[						(maskBit := maskBitIndex at: (index \\ 2310 + 1)) = 0 ifFalse:[							byteIndex := (index // 2310 * 60) + (maskBit-1 bitShift: -3) + 1.							maskBit := 255 - (1 bitShift: (maskBit bitAnd: 7)).							flags at: byteIndex put: ((flags at: byteIndex) bitAnd: maskBit).						].						index := index + (2 * n)].				].			].		].	].! !!Integer class methodsFor: 'prime numbers' stamp: 'nice 6/17/2011 02:21'!primesUpTo: max do: aBlock	"Compute aBlock with all prime integers up to the given integer."	"Integer primesUpTo: 100"	| index limit limitSqrtFloor sieve increment |	limit := max asInteger.	limit <= 1 ifTrue: [ ^self ].	"Fall back into #largePrimesUpTo:do: if we'd require more than 100k of memory; 	the alternative will only requre 1/154th of the amount we need here and is almost as fast."	limit > 25000 ifTrue:[ ^self largePrimesUpTo: limit do: aBlock ].	limit := limit - 1. "upTo:"	sieve := Array new: limit withAll: true.	sieve at: 1 put: false.	index := 2.	limitSqrtFloor := limit sqrtFloor.	increment := 1.	[ index <= limitSqrtFloor ] whileTrue: [		(sieve at: index) ifTrue: [			| notPrimeIndex notPrimeIncrement |			aBlock value: index.			notPrimeIndex := index * index.			notPrimeIncrement := increment * index.			[ notPrimeIndex <= limit ] whileTrue: [				sieve at: notPrimeIndex put: false.				notPrimeIndex := notPrimeIndex + notPrimeIncrement ] ].		index := index + increment.		increment := 2].	[ index <= limit ] whileTrue: [		(sieve at: index) ifTrue: [			aBlock value: index ].		index := index + increment.		increment := 2]! !!Integer class methodsFor: 'class initialization' stamp: 'ul 7/18/2011 17:23'!initialize	"Integer initialize"	"Ensure we have the right compact class index"	"LPI has been a compact class forever - just ensure basic correctness"	(LargePositiveInteger indexIfCompact = 5) ifFalse:[		(Smalltalk compactClassesArray at: 5)			ifNil:[LargePositiveInteger becomeCompactSimplyAt: 5]			ifNotNil:[self error: 'Unexpected compact class setup']].	"Cog requires LNI to be compact at 4 (replacing PseudoContext)"	(LargeNegativeInteger indexIfCompact = 4) ifFalse:[		"PseudoContext will likely get removed at some point so write this test		without introducing a hard dependency"		(Smalltalk compactClassesArray at: 4) name == #PseudoContext			ifTrue:[Smalltalk compactClassesArray at: 4 put: nil].		(Smalltalk compactClassesArray at: 4)			ifNil:[LargeNegativeInteger becomeCompactSimplyAt: 4]			ifNotNil:[self error: 'Unexpected compact class setup']].			self initializeLowBitPerByteTable! !!Integer class methodsFor: 'class initialization' stamp: 'ul 7/18/2011 17:24'!initializeLowBitPerByteTable	"Initialize LowBitPerByteTable which is a ByteArray that contains the index of the lowest set bit of the integers between 1 and 255. It's defined as a class variable because it's used from the instance side and subclasses."	"The low bits table can be obtained with:	((1 to: 8) inject: #[1] into: [:lowBits :rank | (lowBits copy at: 1 put: lowBits first + 1; yourself) , lowBits]) allButFirst	or with it's symmetric pair:	((1 to: 8) inject: #[1] into: [:lowBits :rank | lowBits, (lowBits copy atLast: 1 put: lowBits last + 1; yourself)]) allButLast."		LowBitPerByteTable := #[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'cmm 4/13/2011 16:28'!testBitReversal	{ 0. 1. SmallInteger maxVal-1. SmallInteger maxVal. SmallInteger maxVal+1. (2 raisedTo: 64)-1091. (2 raisedTo: 64)-1090. (2 raisedTo: 64)-1 } do: 		[ : fixture |		| printedThenReversed reversedThenPrinted |		printedThenReversed := (fixture printPaddedWith: $0 to: 64 base: 2) reversed.		reversedThenPrinted := (fixture bitReverse: 64) printPaddedWith: $0 to: 64 base: 2.		self assert: printedThenReversed = reversedThenPrinted ]! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'ul 11/15/2010 11:44'!testReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.		rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i = 123.0.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'ul 11/15/2010 11:49'!testStringAsNumber	"This covers parsing in Number>>readFrom:	Trailing decimal points should be ignored."	#(		('123' isInteger 123)		('-123' isInteger -123)		('123.' isFloat 123)		('-123.' isFloat -123)		('123This is not to be read' isInteger 123)		('123s could be confused with a ScaledDecimal' isInteger 123)		('123e could be confused with a Float' isInteger 123)) do: [ :each |			[ :string :typeSelector :numericValue |				| result |				result := string asNumber.				self assert: (result perform: typeSelector).				self assert: result = numericValue ] valueWithArguments: each ]! !!IntegerTest methodsFor: 'testing - arithmetic' stamp: 'nice 6/4/2011 21:00'!testMontgomeryMultiplication	| a m mInv |	m := 15485863.	mInv := 256 - ((m bitAnd: 255) reciprocalModulo: 256).	a := (256 raisedTo: m digitLength) \\ m.	#(483933 3871465 8951195) do: [:s |		(s montgomeryTimes: a modulo: m mInvModB: mInv) ifNotNil: [:s1 |			| s2 sa ssa |			self assert: s = s1.			sa := s montgomeryTimes: (a * a \\ m) modulo: m mInvModB: mInv.			self assert: sa = (s * a \\ m).			ssa := sa montgomeryTimes: sa modulo: m mInvModB: mInv.			self assert: ssa = (s * s * a \\ m).			s2 := ssa montgomeryTimes: 1 modulo: m mInvModB: mInv.			self assert: s2 = (s * s \\ m)]].! !!IntegerTest methodsFor: 'testing - arithmetic' stamp: 'nice 6/4/2011 20:46'!testRaisedToModulo	#(301 2047) do: [:m |		1 to: m - 1 by: (m // 30) do: [:x |			11 to: m - 1 by: (m // 40) do: [:y |				self assert: (x raisedTo: y) \\ m = (x raisedTo: y modulo: m)]]].	self assert: (8951195 raisedTo: 7742931 modulo: 15485863) = 15485862.! !!IntegerTest methodsFor: 'testing - arithmetic' stamp: 'nice 9/6/2010 21:48'!testReciprocalModulo	1 to: 512 do: [:a |		a + 1 to: 512 do: [:b |			| c |			(a gcd: b) = 1				ifTrue:					[c := a reciprocalModulo: b.					self assert: (a * c) \\ b = 1]				ifFalse: [self should: [ a reciprocalModulo: b ] raise: Error]]].! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/19/2011 22:59'!testBigReceiverInexactNthRoot	"	IntegerTest new testBigReceiverInexactNthRoot	"	"Inexact 3rd root (not a whole cube number), so a Float must be answered.	However, receiver is too big for Float arithmethic."	| bigNum result |	bigNum := (100 factorial raisedTo: 3) + 1.		"Add 1 so it is not a whole cube"	self assert: bigNum asFloat isInfinite.			"Otherwise, we chose a bad sample"	result := bigNum nthRoot: 3.	self assert: result class == Float.	self deny: result isInfinite.	self assert: result = 100 factorial asFloat.		"No other float is closer. See following line"	self assert: 100 factorial asFloat = (100 factorial+1) asFloat! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/29/2011 15:13'!testBigReceiverInexactSqrt	"	IntegerTest new testBigReceiverInexactSqrt	"	"Inexact 3rd root (not a whole cube number), so a Float must be answered.	However, receiver is too big for Float arithmethic."	| bigNum result |	bigNum := 100 factorial squared + 1.		"Add 1 so it is not a whole square"	self assert: bigNum asFloat isInfinite.			"Otherwise, we chose a bad sample"	result := bigNum sqrt.	self assert: result class == Float.	self deny: result isInfinite.	self assert: result = 100 factorial asFloat.		"No other float is closer. See following lines"	self assert: (result successor asFraction squared - bigNum) abs >= (result asFraction squared - bigNum) abs.	self assert: (result predecessor asFraction squared - bigNum) abs >= (result asFraction squared - bigNum) abs.! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/31/2010 21:50'!testDegreeCos	"self run: #testDegreeCos"		self shouldnt: [ 45 degreeCos] raise: Error.	"Following tests use approximate equality, because cosine are generally evaluated using inexact Floating point arithmetic"	self assert: (45 degreeCos squared - (1/2)) abs <= Float epsilon.	self assert: (60 degreeCos - (1/2)) abs <= Float epsilon.	self assert: (120 degreeCos + (1/2)) abs <= Float epsilon.	-360 to: 360 do: [:i |		self assert: (i degreeCos closeTo: i degreesToRadians cos)].		"Following tests use strict equality which is a requested property of degreeCos"	-10 to: 10 do: [:k |		self assert: (k*360 + 90) degreeCos = 0.		self assert: (k*360 - 90) degreeCos = 0.		self assert: (k*360 + 180) degreeCos + 1 = 0.		self assert: (k*360) degreeCos - 1 = 0.].! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/31/2010 21:39'!testDegreeSin	"self run: #testDegreeSin"		self shouldnt: [ 45 degreeSin] raise: Error.		"Following tests use approximate equality, because sine are generally evaluated using inexact Floating point arithmetic"	self assert: (45 degreeSin squared - (1/2)) abs <= Float epsilon.	self assert: (30 degreeSin - (1/2)) abs <= Float epsilon.	self assert: (-30 degreeSin + (1/2)) abs <= Float epsilon.	-360 to: 360 do: [:i |		self assert: (i degreeSin closeTo: i degreesToRadians sin)].		"Following tests use strict equality which is a requested property of degreeSin"	-10 to: 10 do: [:k |		self assert: (k*360 + 90) degreeSin - 1 = 0.		self assert: (k*360 - 90) degreeSin + 1= 0.		self assert: (k*360 + 180) degreeSin = 0.		self assert: (k*360) degreeSin = 0].! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 21:46'!testExactRaisedTo	"	IntegerTest new testExactRaisedTo	"	self assert: (4 raisedTo: 1/2) classAndValueEquals: 2.	self assert: (9 raisedTo: 1/2) classAndValueEquals: 3.	self assert: (9 raisedTo: -1/2) classAndValueEquals: 1/3.	self assert: (-1 raisedTo: 1/3) classAndValueEquals: -1.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [ :i |		self assert: (i squared raisedTo: 1/2) classAndValueEquals: i.		self assert: (i negated squared raisedTo: 1/2) classAndValueEquals: i ].	self assert: (8 raisedTo: 1/3) classAndValueEquals: 2.	self assert: (27 raisedTo: 1/3) classAndValueEquals: 3.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [ :i |		self assert: ((i raisedTo: 3) raisedTo: 1/3) classAndValueEquals: i.		self assert: ((i negated raisedTo: 3) raisedTo: 1/3) classAndValueEquals: i negated ].	self assert: (4 raisedTo: 3/2) classAndValueEquals: 8.	self assert: (8 raisedTo: 2/3) classAndValueEquals: 4.	self assert: (8 raisedTo: -2/3) classAndValueEquals: 1/4.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [ :i |		self assert: ((i raisedTo: 3) raisedTo: 2/3) classAndValueEquals: i*i.		self assert: ((i raisedTo: 2) raisedTo: 3/2) classAndValueEquals: i*i*i.		self assert: ((i negated raisedTo: 3) raisedTo: 2/3) classAndValueEquals: i*i.		self assert: ((i negated raisedTo: 2) raisedTo: 3/2) classAndValueEquals: i*i*i ].	self assert: (32 raisedTo: 3/5) classAndValueEquals: 8.	self assert: (8 raisedTo: 5/3) classAndValueEquals: 32.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [ :i |		self assert: ((i raisedTo: 5) raisedTo: 3/5) classAndValueEquals: i*i*i.		self assert: ((i raisedTo: 3) raisedTo: 5/3) classAndValueEquals: i*i*i*i*i.		self assert: ((i negated raisedTo: 5) raisedTo: 3/5) classAndValueEquals: (i*i*i) negated.		self assert: ((i negated raisedTo: 3) raisedTo: 5/3) classAndValueEquals: (i*i*i*i*i) negated.		self assert: ((i raisedTo: -5) raisedTo: 3/5) classAndValueEquals: 1/(i*i*i).		self assert: ((i raisedTo: -3) raisedTo: 5/3) classAndValueEquals: 1/(i*i*i*i*i).		self assert: ((i negated raisedTo: -5) raisedTo: 3/5) classAndValueEquals: -1/(i*i*i).		self assert: ((i negated raisedTo: -3) raisedTo: 5/3) classAndValueEquals: -1/(i*i*i*i*i).		self assert: ((i raisedTo: 5) raisedTo: -3/5) classAndValueEquals: 1/(i*i*i).		self assert: ((i raisedTo: 3) raisedTo: -5/3) classAndValueEquals: 1/(i*i*i*i*i).		self assert: ((i negated raisedTo: 5) raisedTo: -3/5) classAndValueEquals: -1/(i*i*i).		self assert: ((i negated raisedTo: 3) raisedTo: -5/3) classAndValueEquals: -1/(i*i*i*i*i).		"No exact result => Float result"		self assert: ((i raisedTo: 3) +1 raisedTo: 5/3) isFloat.		self assert: ((i negated raisedTo: 3) -1 raisedTo: 5/3) isFloat ].! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/11/2011 22:09'!testExactSqrt	"	IntegerTest new testExactSqrt	"	self assert: 4 sqrt classAndValueEquals: 2.	self assert: 9 sqrt classAndValueEquals: 3.	self assert: Float maxExactInteger squared sqrt classAndValueEquals: Float maxExactInteger.	self assert: (Float maxExactInteger+1) squared sqrt classAndValueEquals: Float maxExactInteger+1.	#( 1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [ :i |		self assert: i squared sqrt classAndValueEquals: i ]! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 5/28/2010 21:28'!testLn	self assert: (100 ln closeTo: 10 ln*2).	self assert: ((2 raisedTo: Float emax + 3) ln closeTo: 2 ln*(Float emax + 3)) description: 'Integer>>ln should not overflow'! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:37'!testLog	self assert: (100 log closeTo: 2).	self assert: ((2 raisedTo: Float emax + 3) log closeTo: 2 log*(Float emax + 3)) description: 'Integer>>log should not overflow'! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/19/2011 20:28'!testNthRoot		self shouldnt: [ (1 << 2000 nthRoot: 100) ] raise: ArithmeticError.	self assert: (1 << 2000 nthRoot: 100) equals: 1 << 20! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 09:09'!testNthRootErrorConditions	"	IntegerTest new testExactRaisedToErrorConditions	"	self should: [ -2 nthRoot: 1/4 ] raise: ArithmeticError.	self should: [ -2 nthRoot: 1.24 ] raise: ArithmeticError.! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/19/2011 21:03'!testNthRootTruncated	<timeout:  5 "seconds">	| tooBigToBeAFloat large |	tooBigToBeAFloat := 1 << 2000.	self assert: (tooBigToBeAFloat nthRootTruncated: 100) equals: 1 << 20.	self assert: (tooBigToBeAFloat + 1 nthRootTruncated: 100) equals: 1 << 20.	self assert: (tooBigToBeAFloat - 1 nthRootTruncated: 100) equals: 1 << 20 - 1.		large := -3 raisedTo: 255.	self assert: (large nthRootTruncated: 17) equals: (-3 raisedTo: 15).	self assert: (large + 11 nthRootTruncated: 17) equals: (-3 raisedTo: 15) + 1.	self assert: (large - 11 nthRootTruncated: 17) equals: (-3 raisedTo: 15).		2 to: 10 do: [:thePower |		1 to: 10000 do: [:n |			| theTruncatedRoot |			theTruncatedRoot := n nthRootTruncated: thePower.			self assert: (theTruncatedRoot raisedTo: thePower) <= n.			self assert: (theTruncatedRoot + 1 raisedTo: thePower) > n]]! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 21:45'!testRaisedToErrorConditions	"	IntegerTest new testRaisedToErrorConditions	"	self should: [ -2 raisedTo: 1/4 ] raise: ArithmeticError.	self should: [ -2 raisedTo: 1.24 ] raise: ArithmeticError.! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'jmv 10/13/2011 21:46'!testSqrtErrorConditions	"	IntegerTest new testSqrtErrorConditions	"	self should: [ -1 sqrt ] raise: ArithmeticError! !!IntegerTest methodsFor: 'private' stamp: 'jmv 10/11/2011 08:14'!assert: a classAndValueEquals: b	self assert: a class = b class.	self assert: a = b! !!InterpolatedGradientFillStyle methodsFor: 'as yet unclassified' stamp: 'nice 1/5/2010 15:59'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver."		| bits ramp lastColor lastIndex lastWord |	ramp := colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits := Bitmap new: length.	lastColor := ramp first value.	lastWord := lastColor pixelWord32.	lastIndex := 0.	ramp do:[:assoc| | distance nextColor theta nextWord nextIndex step |		nextIndex := (assoc key * length) rounded.		nextColor := assoc value.		nextWord := nextColor pixelWord32.		distance := nextIndex - lastIndex.		distance = 0 ifTrue: [distance := 1].		step := 1.0 / distance.		theta := 0.0.		lastIndex+1 to: nextIndex do: [:i|			theta := theta + step.			bits at: i put: (self interpolatedAlphaMix: theta of: lastWord and: nextWord)].		lastIndex := nextIndex.		lastColor := nextColor.		lastWord := nextWord].	lastIndex+1 to: length do: [:i| bits at: i put: lastWord].	^bits! !!InterpolatedGradientFillStyle methodsFor: 'as yet unclassified' stamp: 'gvc 5/18/2007 12:48'!interpolatedAlphaMix: ratio of: rgba1 and: rgba2	"Answer a proper interpolated value between two RGBA color words.	Theta is 0..1.."	| a1 a2 ra ira rgb1 rgb2 alpha br1 br2 bg1 bg2 bb1 bb2 result |	a1 := rgba1 bitShift: -24. a2 := rgba2 bitShift: -24.	alpha := ratio * (a2 - a1) + a1.	ra := ratio * alpha.	ira := (1.0 - ratio) * alpha.	rgb1 := rgba1 bitAnd: 16rFFFFFF. rgb2 := rgba2 bitAnd: 16rFFFFFF.	br1 := (rgb1 bitAnd: 255). br2 := (rgb2 bitAnd: 255).	bg1 := ((rgb1 bitShift:  -8) bitAnd: 255). bg2 := ((rgb2 bitShift: -8) bitAnd: 255).	bb1 := ((rgb1 bitShift: -16) bitAnd: 255). bb2 := ((rgb2 bitShift: -16) bitAnd: 255).	result :=  (ra * br2 + (ira * br1)) rounded // 255.	result :=  result bitOr: ((ra * bg2 + (ira * bg1)) rounded // 255 bitShift: 8).	result :=  result bitOr: ((ra * bb2 + (ira * bb1)) rounded // 255 bitShift: 16).	^result bitOr: (alpha rounded bitShift: 24)! !!InterpolatedGradientFillStyle commentStamp: 'gvc 5/18/2007 12:49' prior: 0!Gradient fill style that uses proper alpha-aware interpolation.!!IntervalTest methodsFor: 'tests' stamp: 'nice 11/15/2010 21:02'!testPermutationsDo	| i oc |	i := (1.234 to: 4.234).	oc := OrderedCollection new.	i permutationsDo: [:e | oc add: e].	self assert: (oc size = i size factorial).	^ oc! !!KedamaExamplerPlayer methodsFor: 'deleting' stamp: 'ul 9/28/2011 14:05'!delete	turtles delete.	sequentialStub delete.	self class removeFromSystem: false.	self becomeForward: UnscriptedPlayer new! !!KedamaPatchType methodsFor: 'tile protocol' stamp: 'ul 11/15/2010 11:50'!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	| aTile displayer actualSetter |	actualSetter := setter ifNotNil:		[(#(none nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile := self newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: #externalName;		target: (aTarget perform: getter) costume renderedMorph;		growable: true;		minimumWidth: 24;		putSelector: nil.	displayer stepTime: 1000.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs = 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	displayer useStringFormat.	^ aTile! !!KedamaSequenceExecutionStub methodsFor: 'deleting' stamp: 'ul 9/28/2011 14:05'!delete	arrays := nil.	exampler := nil.	self class removeFromSystem: false.	self becomeForward: UnscriptedPlayer new! !!KedamaTurtleVectorPlayer methodsFor: 'deleting' stamp: 'ul 9/28/2011 14:06'!delete	exampler := nil.	arrays := nil.	whoTable := nil.	turtlesMap := nil.	self class removeFromSystem: false.	self becomeForward: UnscriptedPlayer new! !!KeyboardEvent methodsFor: 'private' stamp: 'djr 3/30/2010 12:38'!scanCode: ignore	" OB-Tests expects this "! !!KeyboardEvent methodsFor: 'private' stamp: 'djr 3/30/2010 11:55'!setType: aSymbol buttons: anInteger position: pos keyValue: aValue charCode: ignoredUsedInOBTesting hand: aHand stamp: stamp	self setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp! !!KeyedIdentitySet commentStamp: 'nice 8/26/2010 22:01' prior: 0!A KeyedIdentitySet is like a Bag, except that items are compared with #== instead of #= .See the comment of IdentitySet for more information.!!KeyedSet methodsFor: 'accessing' stamp: 'ajh 12/10/2000 15:42'!at: key ifAbsentPut: aBlock 	"Answer the value associated with the key or, if key isn't found,	add the result of evaluating aBlock to self"	^ self at: key ifAbsent: [self add: aBlock value]! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 7/3/2004 17:54'!keysDo: block	self do: [:item | block value: (keyBlock value: item)]! !!KeyedSet methodsFor: 'adding' stamp: 'ajh 12/4/2001 05:27'!addAll: aCollection 	"Include all the elements of aCollection as the receiver's elements"	(aCollection respondsTo: #associationsDo:)		ifTrue: [aCollection associationsDo: [:ass | self add: ass]]		ifFalse: [aCollection do: [:each | self add: each]].	^ aCollection! !!KeyedSet methodsFor: 'testing' stamp: 'ul 2/12/2011 01:08'!includes: anObject 		(array at: (self scanFor: (keyBlock value: anObject))) ifNil: [ ^false ] ifNotNil: [ ^true ]! !!KeyedSet class methodsFor: 'instance creation' stamp: 'ajh 10/23/2000 23:16'!keyBlock: oneArgBlock	"Create a new KeySet whose way to access an element's key is by executing oneArgBlock on the element"	^ self new keyBlock: oneArgBlock! !!LangEnvBugs methodsFor: 'as yet unclassified' stamp: 'ar 7/21/2010 20:13'!testIsFontAvailable	"self new testIsFontAvailable"	"self run: #testIsFontAvailable"	| oldPref |	oldPref := Preferences valueOfPreference: #tinyDisplay.	Preferences restoreFontsAfter:[	[Preferences enable: #tinyDisplay .	self 		shouldnt:[(LanguageEnvironment localeID: 'en' ) isFontAvailable] 		raise: Error.	] ensure: [Preferences setPreference: #tinyDisplay toValue: oldPref].	].! !!LanguageEditor methodsFor: 'stef' stamp: 'ul 7/17/2011 19:31'!identifyUnusedStrings	"(self on: 'en') identifyUnusedStrings"		translationsList getList do: [ :each | 		Transcript 			nextPutAll: each;			show: (self numberOfTimesStringIsUsed: each);			cr ]! !!LanguageEditor methodsFor: 'stef' stamp: 'ul 7/17/2011 17:39'!numberOfTimesStringIsUsed: aString	| count |	count := 0.	self systemNavigation allSelectorsAndMethodsDo: [ :behavior :selector :method |		(method hasLiteralSuchThat: [:lit |			lit isString and: [lit includesSubstring: aString caseSensitive: true] ]) ifTrue: [				count := count + 1 ] ].	^count! !!LanguageEditor methodsFor: 'stef' stamp: 'ul 7/17/2011 19:29'!removeTranslatedButUnusedStrings	(self confirm: 'Are you sure that you want to remove unused strings?' translated)		ifFalse: [^ self].	translationsList getList		do: [:each | 			| timesUsed | 			timesUsed := self numberOfTimesStringIsUsed: each.			Transcript 				nextPutAll: each;				show: timesUsed;				cr.			timesUsed isZero				ifTrue: [self translator removeTranslationFor: each]]! !!LanguageEditor methodsFor: 'stef' stamp: 'ul 7/17/2011 19:29'!removeUntranslatedButUnusedStrings	(self confirm: 'Are you sure that you want to remove unused strings?' translated)		ifFalse: [^ self].	untranslatedList getList		do: [:each | 			| timesUsed | 			timesUsed := self numberOfTimesStringIsUsed: each.			Transcript 				nextPutAll: each;				show: timesUsed;				 cr.			timesUsed isZero 				ifTrue: [self translator removeUntranslated: each]].	self update: #untranslated.! !!LanguageEnvironment class methodsFor: 'subclass responsibilities' stamp: 'nice 5/1/2011 21:40'!leadingChar	"The default for most environment is to use unicode without leadingChar.	However, environment for east asian language (CJKV) shall refine this default in order to handle han-unification properly."	^ 0! !!LargeNegativeInteger methodsFor: 'bit manipulation' stamp: 'nice 5/20/2011 23:01'!bitAt: anInteger	"super would not work because we have to pretend we are in two-complement.	this has to be tricky..."		| digitIndex bitIndex i |	digitIndex := anInteger - 1 // 8 + 1.	digitIndex > self digitLength ifTrue: [^1].	bitIndex := (anInteger - 1 bitAnd: 2r111) + 1.	i := 1.	[i = digitIndex		ifTrue:			["evaluate two complement (bitInvert + 1) on the digit :			(if digitIndex > 1, we must still add 1 due to the carry).			but x bitInvert is -1-x, bitInvert+1 is just x negated..."			^(self digitAt: digitIndex) negated bitAt: bitIndex].	(self digitAt: i) = 0]		whileTrue: [			"two complement (bitInvert + 1) raises a carry:			0 bitInvert -> 2r11111111.  2r11111111 + 1 -> 0 with carry...			Thus we must inquire one digit forward"			i := i + 1].		"We escaped the while loop, because there is no more carry.	Do a simple bitInvert without a carry"	^1 - ((self digitAt: digitIndex) bitAt: bitIndex)! !!LargeNegativeInteger methodsFor: 'converting' stamp: 'nice 9/22/2011 01:36'!asFloat	^self negated asFloat negated! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'nice 7/15/2011 14:06'!ln	^DomainError signal: 'ln is only defined for x > 0' from: 0! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'nice 7/15/2011 14:06'!log	^DomainError signal: 'log is only defined for x > 0' from: 0! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'jmv 10/13/2011 21:40'!sqrt	"Answer the square root of the receiver."	^ DomainError signal: 'sqrt undefined for number less than zero.'! !!LargeNegativeIntegerTest methodsFor: 'tests' stamp: 'ul 11/15/2010 11:51'!testDenormalizedPrintString	"Check that an un-normalized instance behaves reasonably."	| i i0 |	i := LargeNegativeInteger new: 4.	i basicAt: 2 put: 255.	self assert: i size = 4.	self assert: i printString = '-65280'.	"-256*255"	self assert: i normalize = -65280.	self assert: (i normalize isMemberOf: SmallInteger).		i0 := LargeNegativeInteger new: 0.	self assert: i0 size = 0.	self assert: i0 printString = '-0'.	self assert: i0 normalize = 0.	self assert: (i0 normalize isMemberOf: SmallInteger)! !!LargeNegativeIntegerTest methodsFor: 'tests' stamp: 'ul 11/15/2010 11:52'!testEmptyTemplate	"Check that an uninitialized instance behaves reasonably."	| i |	i := LargeNegativeInteger new: 4.	self assert: i size = 4.	self assert: i printString = '-0'.	self assert: i normalize = 0.	self assert: (i normalize isMemberOf: SmallInteger)! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'nice 5/20/2011 23:00'!bitAt: anInteger	"Optimize super algorithm to avoid long bit operations.	Instead work on digits which are known to be SmallInteger and fast.	Note that this algorithm does not work for negative integers."		| digitIndex bitIndex |	digitIndex := anInteger - 1 // 8 + 1.	digitIndex > self digitLength ifTrue: [^0].	bitIndex := (anInteger - 1 bitAnd: 2r111) + 1.	^(self digitAt: digitIndex) bitAt: bitIndex! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'nice 4/12/2011 08:59'!bitReverse: highBit 	"This implementation is faster than super"		| digitSize reversed |	highBit < self highBit ifTrue: [ self error: 'Not enough bits.' ].	digitSize := highBit + 7 // 8.	reversed := self class new: digitSize.	1 to: self digitLength do: [:i |		reversed digitAt: digitSize + 1 - i put: (self digitAt: i) byteReversed].	^reversed bitShift: highBit - (digitSize * 8)! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'nice 9/22/2011 01:59'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero.  	This method is used for LargeNegativeIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."	| realLength lastDigit |	realLength := self digitLength.	[(lastDigit := self digitAt: realLength) = 0]		whileTrue: [(realLength := realLength - 1) = 0 ifTrue: [^ 0]].	^ lastDigit highBitOfByte + (8 * (realLength - 1))! !!LargePositiveInteger methodsFor: 'converting' stamp: 'nice 9/22/2011 01:53'!asFloat	"Answer a Float that best approximates the value of the receiver.	This algorithm is optimized to process only the significant digits of a LargeInteger.	And it does honour IEEE 754 round to nearest even mode in case of excess precision (see details below)."		"How numbers are rounded in IEEE 754 default rounding mode:	A shift is applied so that the highest 53 bits are placed before the floating point to form a mantissa.	The trailing bits form the fraction part placed after the floating point.	This fractional number must be rounded to the nearest integer.	If fraction part is 2r0.1, exactly between two consecutive integers, there is a tie.	The nearest even integer is chosen in this case.	Examples (First 52bits of mantissa are omitted for brevity):	2r0.00001 is rounded downward to 2r0	2r1.00001 is rounded downward to 2r1	2r0.1 is a tie and rounded to 2r0 (nearest even)	2r1.1 is a tie and rounded to 2r10 (nearest even)	2r0.10001 is rounded upward to 2r1	2r1.10001 is rounded upward to 2r10	Thus, if the next bit after floating point is 0, the mantissa is left unchanged.	If next bit after floating point is 1, an odd mantissa is always rounded upper.	An even mantissa is rounded upper only if the fraction part is not a tie."		"Algorihm details:	Floating point hardware will correctly handle the rounding by itself with a single inexact operation if mantissa has one excess bit of precision.	Except in the last case when extra bits are present after an even mantissa, we must round upper by ourselves.	Note 1: the inexact flag in floating point hardware must not be trusted because it won't take into account the bits we truncated by ourselves.	Note 2: the floating point hardware is presumed configured in default rounding mode."		| mantissa shift sum excess |	"Check how many bits excess the maximum precision of a Float mantissa."	excess := self highBitOfMagnitude - Float precision.	excess > 1		ifTrue:			["Remove the excess bits but one."			mantissa := self bitShift: 1 - excess.			shift := excess - 1.			"Handle the case of extra bits truncated after an even mantissa."			((mantissa bitAnd: 2r11) = 2r01 and: [self anyBitOfMagnitudeFrom: 1 to: shift])				ifTrue: [mantissa := mantissa + 1]]		ifFalse:			[mantissa := self.			shift := 0].	"Now that mantissa has at most 1 excess bit of precision, let floating point operations perform the final rounding."	sum := 0.0.	1 to: mantissa digitLength do:		[:byteIndex | 		sum := sum + ((mantissa digitAt: byteIndex) asFloat timesTwoPower: shift).		shift := shift + 8].	^sum! !!LargePositiveInteger methodsFor: 'printing' stamp: 'nice 6/17/2011 04:12'!printOn: aStream base: b	"Append a representation of this number in base b on aStream.	In order to reduce cost of LargePositiveInteger ops, split the number in approximately two equal parts in number of digits."		| halfDigits halfPower head tail nDigitsUnderestimate |	"Don't engage any arithmetic if not normalized"	(self digitLength = 0 or: [(self digitAt: self digitLength) = 0]) ifTrue: [^self normalize printOn: aStream base: b].		nDigitsUnderestimate := b = 10		ifTrue: [((self highBit - 1) * 1233 >> 12) + 1. "This is because (2 log)/(10 log)*4096 is slightly greater than 1233"]		ifFalse: [self highBit quo: b highBit].			"splitting digits with a whole power of two is more efficient"	halfDigits := 1 bitShift: nDigitsUnderestimate highBit - 2.		halfDigits <= 1		ifTrue: ["Hmmm, this could happen only in case of a huge base b... Let lower level fail"			^self printOn: aStream base: b nDigits: (self numberOfDigitsInBase: b)].		"Separate in two halves, head and tail"	halfPower := b raisedToInteger: halfDigits.	head := self quo: halfPower.	tail := self - (head * halfPower).		"print head"	head printOn: aStream base: b.		"print tail without the overhead to count the digits"	tail printOn: aStream base: b nDigits: halfDigits! !!LargePositiveInteger methodsFor: 'printing' stamp: 'ul 8/23/2010 13:56'!printOn: aStream base: b nDigits: n	"Append a representation of this number in base b on aStream using n digits.	In order to reduce cost of LargePositiveInteger ops, split the number of digts approximatily in two	Should be invoked with: 0 <= self < (b raisedToInteger: n)"		| halfPower half head tail |	n <= 1 ifTrue: [		n <= 0 ifTrue: [self error: 'Number of digits n should be > 0'].				"Note: this is to stop an infinite loop if one ever attempts to print with a huge base		This can happen because choice was to not hardcode any limit for base b		We let Character>>#digitValue: fail"		^aStream nextPut: (Character digitValue: self) ].	halfPower := n bitShift: -1.	half := b raisedToInteger: halfPower.	head := self quo: half.	tail := self - (head * half).	head printOn: aStream base: b nDigits: n - halfPower.	tail printOn: aStream base: b nDigits: halfPower! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'nice 7/15/2011 14:06'!ln	"This function is defined because super ln might overflow."	| res h |	res := super ln.	res isFinite ifTrue: [^res].	h := self highBit.	^2 ln * h + (self / (1 << h)) asFloat ln! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'nice 7/15/2011 14:05'!log	"This function is defined because super log might overflow."	| res h |	res := super log.	res isFinite ifTrue: [^res].	h := self highBit.	^2 log * h + (self / (1 << h)) asFloat log! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'nice 10/14/2011 23:38'!mightBeASquare	"In base 16, a square number can end only with 0,1,4 or 9 and	- in case 0, only 0,1,4,9 can precede it,	- in case 4, only even numbers can precede it.	See http://en.wikipedia.org/wiki/Square_number	So, in hex, the last byte must be one of:		00		10		40		90		x1		e4		x9	where x is any hex digit and e is any even digit	Also, the receiver must be an aven power of two."	| lsb |	lsb := self digitAt: 1.	^(lsb = 0 and: [ self lowBit odd ])	"00 (and even power of 2)"		or: [ lsb = 16r40				"40"		or: [ (lsb bitAnd: 16r7) = 1		"any|1 or any|9"		or: [ (lsb bitAnd: 16r1F) = 4		"even|4"		or: [ (lsb bitAnd: 16r7F) = 16 ]]]]	"10 or 90"! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'nice 10/29/2011 15:07'!sqrt	"If we know for sure no exact solution exists, then just answer the cheap float approximation without wasting time."	| selfAsFloat |	self mightBeASquare		ifFalse:			[selfAsFloat := self asFloat.			selfAsFloat isFinite ifTrue: [^self asFloat sqrt ]].	"If some exact solution might exist, or self asFloat isInfinite, call potentially expensive super"	^super sqrt! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'nice 10/14/2011 23:50'!sqrtFloor	"Return the integer part of the square root of self"	| powerOfTwo |	(powerOfTwo := self lowBit - 1 // 2) > 1		ifFalse: [^super sqrtFloor].	^(self bitShift: -2 * powerOfTwo) sqrtFloor bitShift: powerOfTwo! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'ul 11/15/2010 11:52'!testDenormalizedPrintString	"Check that an un-normalized instance behaves reasonably."	| i i0 |	i := LargePositiveInteger new: 4.	i basicAt: 2 put: 255.	self assert: i size = 4.	self assert: i printString = '65280'.	"256*255"	self assert: i normalize = 65280.	self assert: (i normalize isMemberOf: SmallInteger).		i0 := LargePositiveInteger new: 0.	self assert: i0 size = 0.	self assert: i0 printString = '0'.	self assert: i0 normalize = 0.	self assert: (i0 normalize isMemberOf: SmallInteger)! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'ul 11/15/2010 11:52'!testEmptyTemplate	"Check that an uninitialized instance behaves reasonably."	| i |	i := LargePositiveInteger new: 4.	self assert: i size = 4.	self assert: i printString = '0'.	self assert: i normalize = 0.	self assert: (i normalize isMemberOf: SmallInteger)! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'nice 9/6/2010 21:51'!testReciprocalModulo	| large r |	large := 1 bitShift: 48.	r := Random seed: 46912151.	4691 timesRepeat:		[| a b c t |		a := (r nextInt: large) + 1.		b := (r nextInt: large) + 1.		a > b ifTrue: [t := a. a:= b. b := t].		(a gcd: b) = 1			ifTrue:				[c := a reciprocalModulo: b.				self assert: (a * c) \\ b = 1.]			ifFalse: [self should: [ a reciprocalModulo: b ] raise: Error]].! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'sn 11/8/2010 00:47'!fileNameConverterClass	^ self systemConverterClass! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'sn 11/8/2010 00:47'!inputInterpreterClass	| platformName osVersion |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current osVersion.	(platformName = 'Win32' and: [osVersion ~= 'CE'])		ifTrue: [^ (self win32VMUsesUnicode) ifTrue: [UTF32InputInterpreter] ifFalse: [MacRomanInputInterpreter]].	platformName = 'Mac OS'		ifTrue: [^ MacUnicodeInputInterpreter].	platformName = 'unix'		ifTrue: [^ UTF32InputInterpreter].	^ MacUnicodeInputInterpreter! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'sn 11/8/2010 00:47'!systemConverterClass	| platformName osVersion |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current getSystemAttribute: 1002.	(platformName = 'Win32'			and: [osVersion = 'CE'])		ifTrue: [^ MacRomanTextConverter].	platformName = 'Win32'		ifTrue: [^ (self win32VMUsesUnicode) ifTrue: [UTF8TextConverter] ifFalse: [Latin1TextConverter]].	platformName = 'Mac OS'		ifTrue: [^ ('10*' match: SmalltalkImage current osVersion)				ifTrue: [UTF8TextConverter]				ifFalse: [MacRomanTextConverter]].	platformName = 'unix'		ifTrue: [^ UTF8TextConverter].	^ MacRomanTextConverter! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomFraction	^bottomFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomFraction: aNumber	bottomFraction := aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomFraction: aNumber offset: anInteger	bottomFraction := aNumber.	bottomOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomOffset	^bottomOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomOffset: anInteger	bottomOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftFraction	^leftFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftFraction: aNumber	leftFraction := aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftFraction: aNumber offset: anInteger	leftFraction := aNumber.	leftOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftOffset	^leftOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!leftOffset: anInteger	leftOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightFraction	^rightFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightFraction: aNumber	rightFraction := aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightFraction: aNumber offset: anInteger	rightFraction := aNumber.	rightOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightOffset	^rightOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightOffset: anInteger	rightOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!topFraction	^topFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!topFraction: aNumber	topFraction := aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37'!topFraction: aNumber offset: anInteger	topFraction := aNumber.	topOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37'!topOffset	^topOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37'!topOffset: anInteger	topOffset := anInteger! !!LayoutFrame methodsFor: 'layout' stamp: 'JW 2/1/2001 13:04'!layout: oldBounds in: newBounds	"Return the proportional rectangle insetting the given bounds"	| left right top bottom |	leftFraction ifNotNil:[		left := newBounds left + (newBounds width * leftFraction).		leftOffset ifNotNil:[left := left + leftOffset]].	rightFraction ifNotNil:[		right := newBounds right - (newBounds width * (1.0 - rightFraction)).		rightOffset ifNotNil:[right := right + rightOffset]].	topFraction ifNotNil:[		top := newBounds top + (newBounds height * topFraction).		topOffset ifNotNil:[top := top + topOffset]].	bottomFraction ifNotNil:[		bottom := newBounds bottom - (newBounds height * (1.0 - bottomFraction)).		bottomOffset ifNotNil:[bottom := bottom + bottomOffset]].	left ifNil:[ right 			ifNil:[left := oldBounds left. right := oldBounds right]			ifNotNil:[left := right - oldBounds width]].	right ifNil:[right := left + oldBounds width].	top ifNil:[ bottom 			ifNil:[top := oldBounds top. bottom := oldBounds bottom]			ifNotNil:[top := bottom - oldBounds height]].	bottom ifNil:[bottom := top + oldBounds height].	^(left rounded @ top rounded) corner: (right rounded @ bottom rounded)! !!LayoutFrame methodsFor: 'layout' stamp: 'ml 10/4/2009 15:18'!minExtentFrom: minExtent	"Return the minimal extent the given bounds can be represented in"	| width height left right top bottom |	left := leftFraction ifNil: [0.0].	right := rightFraction ifNil: [1.0].	width := left = right		ifTrue: [0]		ifFalse: [minExtent x / (right - left)].	top := topFraction ifNil: [0.0].	bottom := bottomFraction ifNil: [1.0].	height := bottom = top		ifTrue: [0]		ifFalse: [minExtent y / (bottom - top)].	leftOffset ifNotNil:[width := width + leftOffset].	rightOffset ifNotNil:[width := width + rightOffset].	topOffset ifNotNil:[height := height + topOffset].	bottomOffset ifNotNil:[height := height + bottomOffset].	^width truncated @ height truncated! !!LayoutFrame methodsFor: 'objects from disk' stamp: 'JW 2/1/2001 13:33'!convertToCurrentVersion: varDict refStream: smartRefStrm	| className oldClassVersion |	"JW 2/1/2001"	"Since class version isn't passed in varDict, look it up through smartRefSrm."	className := varDict at: #ClassName.	oldClassVersion := (smartRefStrm structures at: className) first.	(oldClassVersion = 0) ifTrue: [ self negateBottomRightOffsets ].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!LayoutFrame methodsFor: 'objects from disk' stamp: 'JW 2/1/2001 14:37'!negateBottomRightOffsets	bottomOffset ifNotNil: [ bottomOffset := bottomOffset negated ].	rightOffset ifNotNil: [ rightOffset := rightOffset negated ].! !!LayoutFrame commentStamp: '<historical>' prior: 0!I define a frame for positioning some morph in a proportional layout.Instance variables:	leftFraction 	topFraction 	rightFraction 	bottomFraction 	<Float>		The fractional distance (between 0 and 1) to place the morph in its owner's bounds	leftOffset 	topOffset 	rightOffset 	bottomOffset 	<Integer>	Fixed pixel offset to apply after fractional positioning (e.g., "10 pixel right of the center of the owner")!!LayoutFrame class methodsFor: 'accessing' stamp: 'JW 2/1/2001 12:48'!classVersion	^1 "changed treatment of bottomOffset and rightOffset"! !!LayoutFrame class methodsFor: 'instance creation' stamp: 'ar 2/5/2002 00:07'!fractions: fractionsOrNil	^self fractions: fractionsOrNil offsets: nil! !!LayoutFrame class methodsFor: 'instance creation' stamp: 'RAA 1/8/2001 21:22'!fractions: fractionsOrNil offsets: offsetsOrNil	| fractions offsets |	fractions := fractionsOrNil ifNil: [0@0 extent: 0@0].	offsets := offsetsOrNil ifNil: [0@0 extent: 0@0].	^self new		topFraction: fractions top offset: offsets top;		leftFraction: fractions left offset: offsets left;		bottomFraction: fractions bottom offset: offsets bottom;		rightFraction: fractions right offset: offsets right! !!LayoutFrame class methodsFor: 'instance creation' stamp: 'ar 2/5/2002 20:06'!offsets: offsetsOrNil	^self fractions: nil offsets: offsetsOrNil! !!LazyListMorph methodsFor: 'accessing' stamp: 'bf 6/25/2011 13:36'!userString	"Do I have a text string to be searched on?"	^ String streamContents: [:strm |		1 to: self getListSize do: [:i |			"must use asStringOrText because that's what the drawing uses, too"			strm nextPutAll: (self getListItem: i) asStringOrText; cr]]! !!LazyListMorph methodsFor: 'drawing' stamp: 'mha 4/27/2010 09:33'!drawBackgroundForMulti: row on: aCanvas 	"shade the background paler, if this row is selected, but not the current selected row"	| selectionDrawBounds thisColor |	thisColor := selectedRow = row		ifTrue: [ self class listSelectionColor twiceDarker ]		ifFalse: [ self class listSelectionColor ].	selectionDrawBounds := self drawBoundsForRow: row.	selectionDrawBounds := selectionDrawBounds intersect: self bounds.	aCanvas		fillRectangle: selectionDrawBounds		color: thisColor! !!LazyListMorph methodsFor: 'drawing' stamp: 'cmm 2/27/2011 15:30'!drawOn: aCanvas	| |	listItems size = 0 ifTrue: [ ^self ]. 	self drawSelectionOn: aCanvas.	(self topVisibleRowForCanvas: aCanvas) to: (self bottomVisibleRowForCanvas: aCanvas) do: [ :row |		(listSource itemSelectedAmongMultiple:  row) ifTrue: [			self drawBackgroundForMulti: row on: aCanvas. ].		self display: (self item: row) asStringOrText atRow: row on: aCanvas.	].	listSource potentialDropRow > 0 ifTrue: [		self highlightPotentialDropRow: listSource potentialDropRow on: aCanvas ].! !!LazyListMorph methodsFor: 'list access' stamp: 'cmm 2/27/2011 15:26'!item: index	"return the index-th item, using the 'listItems' cache"	| newItem itemWidth |	(index between: 1 and: listItems size)		ifFalse: [ "there should have been an update, but there wasn't!!"  ^self getListItem: index].	(listItems at: index) ifNil: [ 		newItem := self getListItem: index.		"Update the width cache."		maxWidth ifNotNil:[			itemWidth := self widthToDisplayItem: newItem asStringOrText contents.			itemWidth > maxWidth ifTrue:[				maxWidth := itemWidth.				self adjustWidth.			]].		listItems at: index put: newItem ].	^listItems at: index! !!LazyListMorph methodsFor: 'scroll range' stamp: 'cmm 2/27/2011 15:21'!hUnadjustedScrollRange"Ok, this is a bit messed up. We need to return the width of the widest item in the list. If we grab every item in the list, it defeats the purpose of LazyListMorph. If we don't, then we don't know the size. This is a compromise -- find the widest of the first 30 items, then double it, This width will be updated as new items are installed, so it will always be correct for the visible items. If you know a better way, please chime in."	| itemsToCheck item index |	"Check for a cached value"	maxWidth ifNotNil:[^maxWidth].	"Compute from scratch"	itemsToCheck := 30 min: (listItems size).	maxWidth := 0. 	"Check the first few items to get a representative sample of the rest of the list."	index := 1.	[index < itemsToCheck] whileTrue:		[ item := self getListItem: index. "Be careful not to actually install this item"		maxWidth := maxWidth max: (self widthToDisplayItem: item asStringOrText contents).		index:= index + 1.		].	"Add some initial fudge if we didn't check all the items."	(itemsToCheck < listItems size) ifTrue:[maxWidth := maxWidth*2].	^maxWidth! !!LazyListMorph methodsFor: 'scroll range' stamp: 'cmm 2/27/2011 15:19'!widthToDisplayItem: item 	^ self font widthOfStringOrText: item asStringOrText! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	^self! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:25'!emitCodeForLoad: stack encoder: encoder	"Default is to do nothing.	 Subclasses may need to override."! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:24'!sizeCodeForLoad: encoder	"Default is to do nothing.	 Subclasses may need to override."	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:10'!sizeCodeForValue: encoder	self subclassResponsibility! !!LedCharacterMorph commentStamp: 'cbr 7/27/2010 18:47' prior: 0!I represent a character to be displayed on an LedMorph; I am a peer to LedDigitMorph. The char 36 is SPACE.I can live outside of LedMorphs, however. If you'd like to play with me, evaluate the following line:LedCharacterMorph new char: $e; openInWorld!!LeftGripMorph methodsFor: 'target resize' stamp: 'ael 6/3/2011 00:38'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner)! !!LeftGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:27'!defaultWidth	^ 5! !!LeftGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!LeftGripMorph methodsFor: 'accessing' stamp: 'ar 6/23/2010 16:51'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 0 @ 1)		offsets: (0 @ 0 negated corner: self defaultWidth @ 0)! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!ptName	^#left! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!resizeCursor	^ Cursor resizeForEdge: #left! !!Lexicon methodsFor: 'category list' stamp: 'ael 12/19/2011 15:11'!selectorsReferringToClassVar	"Return a list of methods that refer to given class var that are in the 	protocol of this object"	| aList aClass nonMeta poolAssoc |	nonMeta := targetClass theNonMetaClass.	aClass := nonMeta classThatDefinesClassVariable: currentQueryParameter.	aList := OrderedCollection new.	poolAssoc := aClass classPool associationAt: currentQueryParameter asSymbol.	(self systemNavigation allCallsOn: poolAssoc)		do: [:elem | (nonMeta inheritsFrom: elem actualClass)				ifTrue: [aList add: elem methodSymbol]].	^ aList! !!Lexicon methodsFor: 'history' stamp: 'ul 11/15/2010 11:52'!navigateToNextMethod	"Navigate to the 'next' method in the current viewing sequence"	| anIndex aSelector |	self selectorsVisited size = 0 ifTrue: [^ self].	anIndex := (aSelector := self selectedMessageName) notNil ifTrue: [selectorsVisited indexOf: aSelector ifAbsent: [selectorsVisited size]] ifFalse: [1].	self selectedCategoryName == self class viewedCategoryName 		ifTrue:			[self selectWithinCurrentCategory: (selectorsVisited atWrap: (anIndex + 1))]		ifFalse:			[self displaySelector: (selectorsVisited atWrap: (anIndex + 1))]! !!Lexicon methodsFor: 'history' stamp: 'ul 11/15/2010 11:52'!navigateToPreviousMethod	"Navigate to the 'previous' method in the current viewing sequence"	| anIndex aSelector |	self selectorsVisited size = 0 ifTrue: [^ self].	anIndex := (aSelector := self selectedMessageName) notNil		ifTrue: [selectorsVisited indexOf: aSelector ifAbsent: [selectorsVisited size]]		ifFalse: [selectorsVisited size].	self selectedCategoryName == self class viewedCategoryName 		ifTrue:			[self selectWithinCurrentCategory: (selectorsVisited atWrap: (anIndex - 1))]		ifFalse:			[self displaySelector: (selectorsVisited atWrap: (anIndex - 1))]! !!Lexicon methodsFor: 'menu commands' stamp: 'cmm 5/2/2011 09:56'!offerMenu	"Offer a menu to the user, in response to the hitting of the menu button on the tool pane"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Lexicon'.	aMenu addStayUpItem.	aMenu addList: #(		('vocabulary...' 			chooseVocabulary)		('what to show...'			offerWhatToShowMenu)		-		('inst var refs (here)'		setLocalInstVarRefs)		('inst var assignments (here)'		setLocalInstVarDefs)		('class var refs (here)'		setLocalClassVarRefs)		-		('navigate to a sender...' 	navigateToASender)		('recent...' 					navigateToRecentMethod)		('show methods in current change set'									showMethodsInCurrentChangeSet)		('show methods with initials...'									showMethodsWithInitials)		-		"('toggle search pane' 		toggleSearch)"		-		('browse full (b)' 			browseMethodFull)		('browse hierarchy (h)'		classHierarchy)		('browse method (O)'		openSingleMessageBrowser)		('browse protocol (p)'		browseFullProtocol)		-		('fileOut'					fileOutMessage)		('printOut'					printOutMessage)		-		('senders of... (n)'			browseSendersOfMessages)		('implementors of... (m)'		browseMessages)		('versions (v)' 				browseVersions)		('inheritance (i)'			methodHierarchy)		-		('references... (r)' 				browseVariableReferences)		('assignments... (a)' 				browseVariableAssignments)		-		('more...'					shiftedYellowButtonActivity)).	aMenu popUpInWorld: ActiveWorld! !!Lexicon methodsFor: 'model glue' stamp: 'nice 3/31/2011 21:51'!doItReceiver	"This class's classPool has been jimmied to be the classPool of the class being browsed. A doIt in the code pane will let the user see the value of the class variables.  Here, if the receiver is affiliated with a specific instance, we give give that primacy"	^ self targetObject ifNil: [self selectedClass]! !!Lexicon methodsFor: 'model glue' stamp: 'ul 11/15/2010 11:52'!okayToAccept	"Answer whether it is okay to accept the receiver's input"	| ok aClass reply |	(ok := super okayToAccept) ifTrue:		[((aClass := self selectedClassOrMetaClass) ~~ targetClass) ifTrue:			[reply := UIManager default chooseFrom: 	{'okay, no problem'. 	'cancel - let me reconsider'. 	'compile into ', targetClass name, ' instead'.	'compile into a new uniclass'} title:'Caution!!  This would beaccepted into class ', aClass name, '.Is that okay?' .			reply = 1 ifTrue: [^ true].			reply ~= 2 ifTrue:				[self notYetImplemented].			^ false]].	^ ok! !!Lexicon methodsFor: 'new-window queries' stamp: 'cmm 5/2/2011 09:55'!browseVariableAssignments	"Let the search pertain to the target class regardless of selection."	self systemNavigation browseVariableAssignments: targetClass! !!Lexicon methodsFor: 'new-window queries' stamp: 'cmm 5/2/2011 09:45'!browseVariableReferences	"Let the search pertain to the target class regardless of selection"	self systemNavigation  browseVariableReferences: targetClass! !!Lexicon methodsFor: 'search' stamp: 'ul 11/15/2010 11:52'!obtainNewSearchString	"Put up a box allowing the user to enter a fresh search string"	| fragment |		fragment := UIManager default request: 'type method name or fragment: ' initialAnswer: self currentQueryParameter.	fragment ifNil: [^ self].	(fragment := fragment copyWithout: $ ) size = 0  ifTrue: [^ self].	currentQueryParameter := fragment.	fragment := fragment asLowercase.	currentQuery := #selectorName.	self showQueryResultsCategory.	self messageListIndex: 0! !!Lexicon methodsFor: 'search' stamp: 'ul 11/15/2010 11:53'!setMethodListFromSearchString	"Set the method list of the receiver based on matches from the search string"	| fragment aList |	self okToChange ifFalse: [^ self].	fragment := currentQueryParameter.	fragment := fragment asString asLowercase withBlanksTrimmed.	aList := targetClass allSelectors select:		[:aSelector | currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass].	fragment size > 0 ifTrue:		[aList := aList select:			[:aSelector | aSelector includesSubstring: fragment caseSensitive: false]].	aList size = 0 ifTrue:		[^ Beeper beep].	self initListFrom: aList asSortedArray highlighting: targetClass.	messageListIndex :=  messageListIndex min: messageList size.	self changed: #messageList! !!Lexicon methodsFor: 'selection' stamp: 'ul 8/2/2011 20:02'!selectImplementedMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any.  In this variant, only selectors "	| selector method messages |	(selector := self selectedMessageName) ifNil: [^ self].	method := (self selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages := method messages) size = 0])		 ifTrue: [^ aBlock value: selector].	(messages size = 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	messages := messages select: [:aSelector | currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass].	self systemNavigation 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: aBlock! !!Lexicon methodsFor: 'selection' stamp: 'ul 11/15/2010 11:53'!selectedMessage	"Answer the source method for the currently selected message."	(categoryList notNil and: [(categoryListIndex isNil or: [categoryListIndex = 0])])		ifTrue:			[^ '---'].	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'here would go the documentation for the protocol category, if any.'].		self showingDecompile ifTrue: [^ self decompiledSourceIntoContents].		self showingDocumentation ifTrue: [^ self commentContents].		currentCompiledMethod := class compiledMethodAt: selector ifAbsent: [nil].		^ self sourceStringPrettifiedAndDiffed asText makeSelectorBoldIn: class]! !!Lexicon methodsFor: 'senders' stamp: 'nice 3/24/2010 23:21'!navigateToASender	"Present the user with a list of senders of the currently-selected 	message, and navigate to the chosen one"	| selectorSet chosen aSelector |	aSelector := self selectedMessageName.	selectorSet := Set new.	(self systemNavigation allCallsOn: aSelector)		do: [:anItem | selectorSet add: anItem methodSymbol].	selectorSet := selectorSet				select: [:sel | currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass].	selectorSet size = 0		ifTrue: [^ Beeper beep].	self okToChange		ifFalse: [^ self].	chosen := UIManager default chooseFrom: selectorSet asSortedArray values: selectorSet asSortedArray.	chosen isEmptyOrNil		ifFalse: [self displaySelector: chosen]! !!Lexicon methodsFor: 'within-tool queries' stamp: 'cmm 5/2/2011 19:51'!selectorsDefiningInstVar	"Return a list of methods that define a given inst var that are in the protocol of this object"	| aList  |	aList := OrderedCollection new.	targetClass withAllSuperclassesDo:		[:aClass | 			(aClass whichMethodsStoreInto: currentQueryParameter asString) do: 				[ : cm | cm selector isDoIt ifFalse: [aList add: cm selector]			]		].	^ aList! !!Lexicon methodsFor: 'within-tool queries' stamp: 'cmm 5/2/2011 09:49'!setLocalInstVarDefs	"Put up a list of the instance variables in the viewed object, and when the user seletcts one, let the query results category show all the references to that instance variable."	| instVarToProbe |	targetClass chooseVarThenDo:		[:aName | instVarToProbe := aName].	instVarToProbe isEmptyOrNil ifTrue: [^ self].	currentQuery := #instVarDefs.	currentQueryParameter := instVarToProbe.	self showQueryResultsCategory! !!Lexicon methodsFor: 'within-tool queries' stamp: 'cmm 5/2/2011 09:49'!setLocalInstVarRefs	"Put up a list of the instance variables in the viewed object, and when the user seletcts one, let the query results category show all the references to that instance variable."	| instVarToProbe |	targetClass chooseVarThenDo:		[:aName | instVarToProbe := aName].	instVarToProbe isEmptyOrNil ifTrue: [^ self].	currentQuery := #instVarRefs.	currentQueryParameter := instVarToProbe.	self showQueryResultsCategory! !!LinkedList methodsFor: 'accessing' stamp: 'eem 10/2/2011 19:07'!size	"Answer how many elements the receiver contains."	| tally |	tally := 0.	self do: [:each | tally := tally + 1].	^ tally! !!ListChooser methodsFor: 'event handling' stamp: 'ul 3/5/2011 10:52'!updateFilter	selectedItems := 		searchText isEmptyOrNil 			ifTrue: [ fullList ]			ifFalse: [ 				| prefixMatches otherMatches |				prefixMatches := OrderedCollection new.				otherMatches := OrderedCollection new.				fullList do: [ :each | 					| index |					index := each findString: searchText startingAt: 1 caseSensitive: false.					index = 1 ifTrue: [ prefixMatches add: each ].					index > 1 ifTrue: [ otherMatches add: each ] ].				prefixMatches					addAllLast: otherMatches;					yourself ].	self changed: #list.	self selectedIndex: 1.	self changed: #selectedIndex.! !!ListController methodsFor: 'marker adjustment' stamp: 'ul 11/15/2010 11:53'!markerDelta	| viewList |	viewList := view list.	viewList compositionRectangle height = 0 ifTrue: [		^ (marker top - scrollBar inside top) - scrollBar inside height	].	^ (marker top - scrollBar inside top) -		((viewList clippingRectangle top -				viewList compositionRectangle top) asFloat /			viewList compositionRectangle height asFloat *			scrollBar inside height asFloat) rounded! !!ListController methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:53'!processKeyboard	"Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	sensor keyboardPressed ifFalse: [^ self].     keyEvent := sensor keyboard asciiValue.     oldSelection := view selection.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view clippingBox height // view list lineGrid.     keyEvent = 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent = 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent = 1  ifTrue: [nextSelection := 1].  "home"     keyEvent = 4  ifTrue: [nextSelection := max].   "end"     keyEvent = 11 ifTrue: [nextSelection := min max: (oldSelection -howMany)].  "page up"     keyEvent = 12  ifTrue: [nextSelection := (oldSelection + howMany)min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				self moveMarker]]			! !!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'nice 5/8/2011 10:36'!hasEquivalentIn: aCollection	^aCollection anySatisfy: [ :each | 		each withoutListWrapper = item withoutListWrapper]! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:19'!emitCodeForValue: stack encoder: encoder	stack push: 1.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 encoder genPushSpecialLiteral: specialLiteral])		ifFalse:			[encoder genPushLiteral: index]! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:03'!sizeCodeForValue: encoder	self reserve: encoder.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizePushSpecialLiteral: specialLiteral])		ifFalse:			[^encoder sizePushLiteral: index]! !!LiteralNode methodsFor: 'testing' stamp: 'ul 11/23/2010 13:06'!isLiteralNode	^ true! !!LiteralNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitLiteralNode: self! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:44'!emitCodeForLoad: stack encoder: encoder	writeNode ifNotNil:		[encoder genPushLiteral: index.		 stack push: 1]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:43'!emitCodeForStore: stack encoder: encoder	writeNode ifNil: [^encoder genStoreLiteralVar: index].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop	or use e.g. valueForStore:"	self flag: #bogus.	writeNode		emitCode: stack		args: 1		encoder: encoder		super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:09'!emitCodeForStorePop: stack encoder: encoder	writeNode ifNil:		[stack pop: 1.		 ^encoder genStorePopLiteralVar: index].	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:17'!emitCodeForValue: stack encoder: encoder	^readNode		ifNil: [stack push: 1.			encoder genPushLiteralVar: index]		ifNotNil: [readNode emitCodeForValue: stack encoder: encoder]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 8/17/2010 22:26'!sizeCodeForLoad: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [encoder sizePushLiteral: index]		ifFalse: [0]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 8/17/2010 22:27'!sizeCodeForStore: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:		[^encoder sizeStoreLiteralVar: index].	code < 0 ifTrue:		[self flag: #dubious.		 self code: (self code: self index type: LdLitType)].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop"	self flag: #bogus.	writeNode := encoder encodeSelector: #value:.	^writeNode sizeCode: encoder args: 1 super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2010 08:55'!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStore: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:58'!sizeCodeForValue: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialReadBinding]) 		ifFalse:			[^encoder sizePushLiteralVar: index].	readNode := MessageNode new 		receiver: (encoder encodeLiteral: key)		selector: (encoder encodeSelector: #value)		arguments: #()		precedence: #value precedence.	^readNode sizeCodeForValue: encoder! !!LiteralVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitLiteralVariableNode: self! !!LiteralVariableNode methodsFor: 'testing' stamp: 'eem 5/20/2010 09:12'!assignmentCheck: encoder at: location	^(key isVariableBinding and: [key canAssign not])		ifTrue: [location]		ifFalse: [-1]! !!Locale methodsFor: 'private' stamp: 'ul 11/15/2010 11:53'!fetchISO2Language	"Locale current fetchISO2Language"	| lang isoLang |	lang := self primLanguage.	lang ifNil: [^nil].	lang := lang copyUpTo: 0 asCharacter.	lang size = 2		ifTrue: [^lang].	isoLang := ISOLanguageDefinition iso3LanguageDefinition: lang.	^isoLang		ifNil: [nil]		ifNotNil: [isoLang iso2]! !!LocaleTest methodsFor: 'testing' stamp: 'ul 1/31/2011 03:56'!testIsFontAvailable	"self debug: #testIsFontAvailable"		<timeout: 60> "takes quite a while"	Preferences restoreFontsAfter: [		| currentDefaultTextStyle |		currentDefaultTextStyle := TextStyle default.		[ 			TextStyle setDefault: (TextStyle actualTextStyles at: #Accuny).			(Locale isoLanguage: 'ja') languageEnvironment removeFonts.			self assert: (Locale isoLanguage: 'en') languageEnvironment isFontAvailable.			"Next test should fail after installing Japanese font"			self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable not.			(Locale isoLanguage: 'ja') languageEnvironment installFont.			self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable ]				ensure: [ TextStyle setDefault: currentDefaultTextStyle ] ].! !!LocaleTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:24'!testLocaleChanged	"self debug: #testLocaleChanged"	"LanguageEnvironment >> startUp is called from Prject >> localeChanged"	<timeout: 60> "takes quite a while"	Project current updateLocaleDependents.	self assert: (ActiveHand instVarNamed: 'keyboardInterpreter') isNil.	self assert: (Clipboard default instVarNamed: 'interpreter') isNil.	Locale switchToID: (LocaleID isoLanguage: 'ja').	self assert: Preferences useFormsInPaintBox.	Locale switchToID: (LocaleID isoLanguage: 'en').	self assert: Preferences useFormsInPaintBox not.! !!LongTestCase methodsFor: 'as yet unclassified' stamp: 'ul 3/27/2011 19:28'!defaultTimeout	"Answer the default timeout to use for tests in this test case. The timeout is a value in seconds."	^super defaultTimeout * 10! !!LongTestCase class methodsFor: 'instance creation' stamp: 'ul 3/27/2011 19:24'!buildSuite	self shouldRun ifTrue: [ ^super buildSuite ].	^self suiteClass new! !!LongTestCase class methodsFor: 'testing' stamp: 'ul 3/27/2011 19:27'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name == #LongTestCase			! !!LongTestCaseTest methodsFor: 'as yet unclassified' stamp: 'ul 10/11/2010 02:50'!setUp	preferenceValue := LongTestCase shouldRun! !!LongTestCaseTest methodsFor: 'as yet unclassified' stamp: 'ul 10/11/2010 02:50'!tearDown	LongTestCase shouldRun: preferenceValue! !!LookupKey methodsFor: 'bindings' stamp: 'ul 9/28/2011 14:06'!beBindingOfType: aClass announcing: aBool	"Make the receiver a global binding of the given type"	(Smalltalk globals associationAt: self key) == self		ifFalse:[^self error:'Not a global variable binding'].	self class == aClass ifTrue:[^self].	self becomeForward: (aClass key: self key value: self value).	"NOTE: Now self == read-only (e.g., the new binding)"	^self recompileBindingsAnnouncing: aBool! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'ul 11/2/2010 03:08'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive:'primitiveMixLoopedSampledSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #leftSamples declareC: 'short int *leftSamples'>	<var: #rightSamples declareC: 'short int *rightSamples'>	isInStereo := leftSamples ~~ rightSamples.	compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.	compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor.	i := (2 * startIndex) - 1.	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex := (scaledIndex := scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex := (scaledIndex := scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex := sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count := 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex := sampleIndex]				ifFalse: [nextSampleIndex := ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m := scaledIndex bitAnd: LoopIndexFractionMask.		rightVal := leftVal :=			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal :=				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		rightVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0].			compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.			compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor]].	count := count - n.! !!MCAncestry methodsFor: 'ancestry' stamp: 'ul 5/8/2011 19:45'!allAncestors		| allAncestors |	allAncestors := Set new.	self allAncestorsDo: [ :each | ] visitedAncestors: allAncestors.	^allAncestors ! !!MCAncestry methodsFor: 'ancestry' stamp: 'ul 5/8/2011 19:08'!allAncestorsDo: aBlock		self allAncestorsDo: aBlock visitedAncestors: Set new! !!MCAncestry methodsFor: 'ancestry' stamp: 'ul 5/8/2011 19:06'!allAncestorsDo: aBlock visitedAncestors: visitedAncestors	self ancestors do: [ :each |		(visitedAncestors includes: each) ifFalse: [			visitedAncestors add: each.			aBlock value: each.			each allAncestorsDo: aBlock visitedAncestors: visitedAncestors ] ]! !!MCAncestry methodsFor: 'ancestry' stamp: 'bp 11/21/2010 18:33'!ancestorStringWithout: packageName	^ String streamContents:		[:s | self ancestors do: [:ea | s nextPutAll: (ea nameWithout: packageName)] separatedBy: [s nextPutAll: ', ']]! !!MCAncestry methodsFor: 'ancestry' stamp: 'cmm 3/10/2011 20:04'!ancestors	^ ancestors ifNil: [ Array empty ]! !!MCAncestry methodsFor: 'ancestry' stamp: 'cmm 3/12/2011 17:11'!hasAncestor: aVersionInfo	"Answer whether the receiver has ancestor, aVersionInfo.""Would it be more performant to use a Set for alreadySeen:?"	^ self		hasAncestor: aVersionInfo		alreadySeen: OrderedCollection new! !!MCAncestry methodsFor: 'ancestry' stamp: 'cmm 3/4/2011 14:41'!names	"The names of the ancestors."	^ self ancestors collect: [ : each | each name asMCVersionName ]! !!MCCacheRepository methodsFor: 'as yet unclassified' stamp: 'bf 3/28/2011 16:07'!basicStoreVersion: aVersion	(aVersion isCacheable not or: [self allFileNames includes: aVersion fileName])		ifFalse: [super basicStoreVersion: aVersion]! !!MCChangeNotificationTest methodsFor: 'running' stamp: 'cmm 1/19/2011 16:01'!setUp	super setUp.	workingCopy := MCWorkingCopy forPackage: self mockPackage! !!MCChangeNotificationTest methodsFor: 'running' stamp: 'ul 4/26/2011 05:27'!tearDown	super tearDown.	workingCopy unregister! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 00:43'!innerButtonRow	^ self buttonRow: self innerButtonSpecs! !!MCChangeSelector methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 00:42'!innerButtonSpecs	^		#(('Select All' selectAll 'select all changes')		  ('Select None' selectNone 'select no changes'))! !!MCClassDefinition methodsFor: 'accessing' stamp: 'cmm 3/8/2011 21:00'!workingCopy	^ self actualClass workingCopy! !!MCClassDefinition methodsFor: 'printing' stamp: 'ul 11/6/2010 05:50'!definitionAndCommentString	^ String streamContents: [:stream |		self printDefinitionOn: stream.		stream cr; cr.		self printClassSideDefinitionOn: stream.    		stream cr; cr.		self printCommentOn: stream]! !!MCClassDefinition methodsFor: 'printing' stamp: 'ul 11/6/2010 05:49'!printClassSideDefinitionOn: stream		stream		nextPutAll: self className;		nextPutAll: ' class ';		cr; tab;		nextPutAll: 'instanceVariableNames: ';		store: self classInstanceVariablesString! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 21:36'!printCommentOn: stream	stream		nextPut: $";		nextPutAll: self comment asString;		nextPut: $"! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:33'!source	^ self definitionAndCommentString! !!MCClassDefinition methodsFor: 'renaming' stamp: 'cmm 6/8/2011 13:36'!handlePackageRename: oldPackageName to: newPackageName 	(self actualClass category beginsWith: newPackageName) ifFalse:		[ self actualClass category:			(self				newCategoryNameFor: self actualClass category				givenRenameFrom: oldPackageName				to: newPackageName) ]! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'ul 4/26/2011 05:27'!tearDown	super tearDown.	Smalltalk at: 'MCMockClassC' ifPresent: [:c | c removeFromSystem]! !!MCCodeTool methodsFor: 'menus' stamp: 'cmm 9/20/2010 13:59'!copyReference	"Copy the selected selector to the clipboard"	self selectedMessageName ifNotNilDo:		[ : selector | Clipboard clipboardText:			(self selectedClassOrMetaClass				ifNil: [ selector asString ]				ifNotNilDo: [ : cls | (cls >> selector) reference ]) ]! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 6/24/2010 10:32'!fileOutMessage	"Put a description of the selected message on a file"	| fileName |	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].		 ^self].	items isEmpty ifTrue:		[^self].	fileName := UIManager default request: 'File out on which file?' initialAnswer: 'methods'.	Cursor write showWhile:		[| internalStream |		internalStream := WriteStream on: (String new: 1000).		internalStream header; timeStamp.		items do:			[:patchOp|			patchOp definition isMethodDefinition ifTrue:				[(patchOp definition actualClass notNil				  and: [patchOp definition actualClass includesSelector: patchOp definition selector])					ifTrue:						[patchOp definition actualClass							printMethodChunk: patchOp definition selector							withPreamble: true							on: internalStream							moveSource: false							toFile: nil]					ifFalse:						[internalStream nextChunkPut: patchOp definition className, ' removeSelector: ', patchOp definition selector printString]].			patchOp definition isClassDefinition ifTrue:				[patchOp definition actualClass					ifNotNil:						[internalStream nextChunkPut: patchOp definition actualClass definition.						 patchOp definition comment ifNotNil:							[patchOp definition actualClass organization								putCommentOnFile: internalStream								numbered: 1								moveSource: false								forClass: patchOp definition actualClass]]					ifNil:						[internalStream nextChunkPut: patchOp definition className, ' removeFromSystem']]].		FileStream writeSourceCodeFrom: internalStream baseName: fileName isSt: true useHtml: false]! !!MCCodeTool methodsFor: 'menus' stamp: 'cmm 9/20/2010 17:29'!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName	ifNil: [items notEmpty ifTrue:		[aMenu addList:#(('fileOut (o)'					fileOutMessage))]]	ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)			('copy reference'					copyReference)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCConfiguration methodsFor: 'updating' stamp: 'ul 5/8/2011 19:59'!updateFromRepositories	(repositories		inject: [ self updateFromRepositoriesWithoutCaching ]		into: [ :innerBlock :repository |			[ repository cacheAllFileNamesDuring: innerBlock ] ]) value	! !!MCConfiguration methodsFor: 'updating' stamp: 'ul 5/8/2011 19:57'!updateFromRepositoriesWithoutCaching	| oldNames newNames sortedNames newDeps |	oldNames := self dependencies collect: [:dep | dep versionInfo versionName].	newNames := Dictionary new.	self repositories		do: [:repo | 			ProgressNotification signal: '' extra: 'Checking ', repo description.			(repo possiblyNewerVersionsOfAnyOf: oldNames)				do: [:newName | newNames at: newName put: repo]]		displayingProgress: 'Searching new versions'.	sortedNames := newNames keys asArray sort:		[:a :b | a versionNumber > b versionNumber].	newDeps := OrderedCollection new: self dependencies size.	self dependencies		do: [:dep |			newDeps add: (sortedNames				detect: [:each | each packageName = dep package name]				ifFound: [ :newName |					| repo |					repo := newNames at: newName.					(self versionInfoNamed: newName for: dep from: repo)						ifNil: [ dep ]						ifNotNil: [ :info |							MCVersionDependency package: dep package info: info ] ]				ifNone: [ dep ]) ]		displayingProgress: 'downloading new versions'.	self dependencies: newDeps.! !!MCConfiguration methodsFor: 'private' stamp: 'bf 11/16/2011 19:31'!depsSatisfying: selectBlock versionDo: verBlock displayingProgress: progressString 	| count action |	count := 0.	self repositories do: [ : eachRepository | MCRepositoryGroup default addRepository: eachRepository ].	action := [ : dep | | ver repo |	ver := dep versionInfo name.	repo := self repositories		detect:			[ : eachRepository | eachRepository includesVersionNamed: ver ]		ifNone:			[ self logError: 'Version ' , ver , ' not found in any repository'.			self logError: 'Aborting'.			^ count ].	(selectBlock value: dep) ifTrue:		[ | new |		new := self			versionNamed: ver			for: dep			from: repo.		new			ifNil:				[ self logError: 'Could not download version ' , ver , ' from ' , repo description.				self logError: 'Aborting'.				^ count ]			ifNotNil:				[ self					logUpdate: dep package					with: new.				self class extraProgressInfo ifTrue:					[ ProgressNotification						signal: ''						extra: 'Installing ' , ver ].				verBlock value: new.				count := count + 1 ] ].	dep package workingCopy newRepositoryGroupIfDefault. "fix old working copies"	dep package workingCopy repositoryGroup addRepository: repo ].	self class extraProgressInfo		ifTrue:			[ self dependencies				do: action				displayingProgress: progressString ]		ifFalse: [ self dependencies do: action ].	^ count! !!MCConfiguration methodsFor: 'private' stamp: 'cmm 3/5/2011 14:54'!diffBaseFor: aDependency	| wc |	aDependency package hasWorkingCopy ifFalse: [^nil].	wc := aDependency package workingCopy.	wc ancestors ifEmpty: [^nil].	^wc ancestors first versionName! !!MCConfiguration methodsFor: 'private' stamp: 'cmm 3/15/2011 14:03'!suggestedNameOfNextVersion	"Suggest a name for the next version of this configuration. The format is assumed to be name-authorInitials.version. Automatically increments the version, takes author initials from Utilities."	^'{1}-{2}.{3}' format: {		name			ifNil: [ 'newConfiguration' ]			ifNotNil: [ name asMCVersionName packageName ].		Utilities authorInitials.		name			ifNil: [ 1 ]			ifNotNil: [ name asMCVersionName versionNumber + 1 ] }! !!MCConfiguration methodsFor: 'private' stamp: 'cmm 3/6/2011 16:25'!versionNamed: aMCVersionName for: aDependency from: repo	| baseName fileName ver |	(repo filterFileNames: repo cachedFileNames forVersionNamed: aMCVersionName) ifNotEmptyDo: [:cachedNames |		fileName := cachedNames anyOne.		self class extraProgressInfo			ifTrue:[ProgressNotification signal: '' extra: 'Using cached ', fileName].		ver := repo versionNamed: fileName].	ver ifNil: [		baseName := self diffBaseFor: aDependency.		(baseName notNil and: [baseName ~= aMCVersionName and: [repo includesVersionNamed: baseName]]) ifTrue: [			fileName := (MCDiffyVersion nameForVer: aMCVersionName base: baseName), '.mcd'.			self class extraProgressInfo				ifTrue:[ProgressNotification signal: '' extra: 'Downloading ', fileName].			ver := repo versionNamed: fileName]].	ver ifNil: [		fileName := aMCVersionName versionName, '.mcz'.		self class extraProgressInfo			ifTrue:[ProgressNotification signal: '' extra: 'Downloading ', fileName].		ver := repo versionNamed: fileName].	^ver! !!MCConfiguration commentStamp: 'dtl 5/10/2010 23:03' prior: 0!An MCConfiguration specifies the configuration of a set of related Monticello packages. It maintains an ordered list of package versions and a list of repositories in which the packages may be found.An MCConfiguration may be filed out for storage as an array specification, and new instances can be created from a stored array specification.!!MCConfigurationBrowser methodsFor: 'actions' stamp: 'ul 3/14/2011 17:21'!post	"Take the current configuration and post an update"	| name update managers names choice |	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	name := UIManager default		request: 'Update name (.cs) will be appended):'		initialAnswer: self configuration suggestedNameOfNextVersion.	name isEmpty ifTrue:[^self].	self configuration name: name.	update := MCPseudoFileStream on: (String new: 100).	update localName: name, '.cs'.	update nextPutAll: '"Change Set:		', name.	update cr; nextPutAll: 'Date:			', Date today printString.	update cr; nextPutAll: 'Author:			Posted by Monticello'.	update cr; cr; nextPutAll: 'This is a configuration map created by Monticello."'.	update cr; cr; nextPutAll: '(MCConfiguration fromArray: #'.	self configuration fileOutOn: update.	update nextPutAll: ') upgrade.'.	update position: 0.	managers := Smalltalk at: #UpdateManager ifPresent:[:mgr| mgr allRegisteredManagers].	managers ifNil:[managers := #()].	managers size > 0 ifTrue:[		| servers index |		servers := ServerDirectory groupNames asSortedArray.		names := (managers collect:[:each| each packageVersion]), servers.		index := UIManager default chooseFrom: names lines: {managers size}.		index = 0 ifTrue:[^self].		index <= managers size ifTrue:[			| mgr |			mgr := managers at: index.			^mgr publishUpdate: update.		].		choice := names at: index.	] ifFalse:[		names := ServerDirectory groupNames asSortedArray.		choice := UIManager default chooseFrom: names values: names.		choice == nil ifTrue: [^ self].	].	(ServerDirectory serverInGroupNamed: choice) putUpdate: update.! !!MCConfigurationBrowser methodsFor: 'dependencies' stamp: 'cmm 2/27/2011 16:39'!checkMissing	| missing |	missing := (self dependencies collect:		[ : ea | ea versionInfo name ]) asSet.	self repositories do:		[ : eachRepository | eachRepository cacheAllFileNamesDuring:			[ missing copy do:				[ : eachVersionName | (eachRepository includesVersionNamed: eachVersionName) ifTrue: [ missing remove: eachVersionName ] ] ] ].	^ missing isEmpty or:		[ self selectDependency: missing anyOne.		self confirm:			(String streamContents:				[ : strm | strm					 nextPutAll: 'No repository found for' ;					 cr.				missing do:					[ : r | strm						 nextPutAll: r ;						 cr ].				strm nextPutAll: 'Do you still want to store?' ]) ]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 21:11'!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'ul 3/14/2011 17:21'!pickName	| name |	name := UIManager default		request: 'Name (.', self configuration writerClass extension, ' will be appended):'		initialAnswer: self configuration suggestedNameOfNextVersion.	^ name isEmpty ifFalse: [name]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 20:56'!repositoryMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add repository...' addRepository)).	self selectedRepository ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove repository' removeRepository))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'cmm 4/22/2011 17:11'!addRepository	(self pickRepositorySatisfying:		[ : ea | (self repositories includes: ea) not ]) ifNotNil:		[ : repo | repo class supportsConfigurations ifFalse: [ ^ self inform: 'Not all of these repositories support MCConfigurations.' ].		self repositories add: repo.		self changed: #repositoryList ]! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'cmm 4/22/2011 17:12'!checkRepositories	| bad |	bad := self repositories reject: [:repo | repo class supportsConfigurations ].	^bad isEmpty or: [		self selectRepository: bad first.		self inform: (String streamContents: [:strm |			strm nextPutAll: 'Please remove these repositories:'; cr.			bad do: [:r | strm nextPutAll: r description; cr].			strm nextPutAll: '(only HTTP repositories are supported)']).		false].! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'dtl 5/10/2010 21:01'!removeRepository	repositoryIndex > 0		ifTrue: [self repositories removeAt: repositoryIndex.			repositoryIndex := 0.			self changed: #repositoryList]! !!MCConfigurationBrowser commentStamp: 'dtl 5/10/2010 21:48' prior: 0!A MCConfigurationBrowser displays an MCConfiguration, and edits the configuration to add or remove package dependencies and repository specifications. It allows a configuration to be stored in a repository or posted to an update stream.!!MCDefinition methodsFor: 'accessing' stamp: 'ul 11/7/2010 22:45'!actualClass	^nil! !!MCDefinition methodsFor: 'printing' stamp: 'bf 11/1/2011 11:42'!summarySuffixOver: previousDefinition	^self source = previousDefinition source		ifTrue: [ ' (source same but rev changed)' ]		ifFalse: [ ' (changed)' ]! !!MCDefinition methodsFor: 'repositories' stamp: 'cmm 3/8/2011 20:59'!repositoryGroup	"Answer the MCRepositoryGroup from which this this object was loaded."	^ self workingCopy repositoryGroup! !!MCDefinition methodsFor: 'repositories' stamp: 'cmm 3/8/2011 21:13'!workingCopy	self subclassResponsibility! !!MCDefinition methodsFor: 'renaming' stamp: 'cmm 6/8/2011 13:22'!handlePackageRename: oldPackageName to: newPackageName	"Overridden as necessary in subclasses."! !!MCDefinition methodsFor: 'renaming' stamp: 'cmm 6/6/2011 15:22'!newCategoryNameFor: categoryName givenRenameFrom: oldPackageName to: newPackageName 	^ oldPackageName size < categoryName size		ifTrue:			[ newPackageName ,				(categoryName					copyFrom: oldPackageName size + 1					to: categoryName size) ]		ifFalse: [ newPackageName ]! !!MCDictionaryRepository methodsFor: 'as yet unclassified' stamp: 'cmm 3/5/2011 18:32'!includesVersionNamed: aString 	| mcVersionName |	mcVersionName := aString asMCVersionName.	^ dict anySatisfy:		[ : ea | ea info versionName = mcVersionName ]! !!MCDictionaryRepository methodsFor: 'versions' stamp: 'ar 12/15/2010 21:59'!allVersionNames	"Answers all the version names in this repository"	^ dict values collect: [:ea | ea info name]	! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'fbs 6/9/2011 20:05'!baseSnapshot	| baseVersion |	baseVersion := self workingCopy repositoryGroup versionWithInfo: base.	baseVersion ifNil: [Error signal: 'Missing snapshot: ', self baseInfo name].	^ baseVersion snapshot! !!MCDiffyVersion methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2011 15:00'!fileName	^ ((self class		nameForVer: info name		base: base name) , '.' , self writerClass extension) asMCVersionName! !!MCDiffyVersion class methodsFor: 'name utilities' stamp: 'cmm 3/5/2011 16:39'!nameForVer: versionName base: baseName	| baseId |	baseId := versionName = baseName		ifTrue: [ baseName versionNumber asString ]		ifFalse:			[ versionName packageName = baseName packageName				ifTrue: [ baseName author, '.', baseName versionNumber asString ]				ifFalse: [ '@' , baseName ] ].	^ versionName versionName , '(' , baseId , ')'! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'ul 4/26/2011 04:11'!allFileNames	^directory entries 		sort: [ :a :b | a modificationTime >= b modificationTime ];		replace: [ :ea | ea name asMCVersionName ]! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'cmm 4/22/2011 16:59'!creationTemplate	^ super creationTemplate		ifNil:			[ self creationTemplate: (self class creationTemplateLocation: self directory pathName).			creationTemplate ]! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'avi 10/9/2003 12:57'!description	^ directory pathName! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'ab 7/6/2003 17:49'!directory	^ directory! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!directory: aDirectory	directory := aDirectory! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	directory := FileDirectory default! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'nk 11/2/2003 10:55'!isValid	^directory exists! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!readStreamForFileNamed: aString do: aBlock	| file val |	file := FileStream readOnlyFileNamed: (directory fullNameFor: aString).	val := aBlock value: file.	file close.	^ val! !!MCDirectoryRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!writeStreamForFileNamed: aString replace: aBoolean do: aBlock	| file sel |	sel := aBoolean ifTrue: [#forceNewFileNamed:] ifFalse: [#newFileNamed:].	file := FileStream perform: sel with: (directory fullNameFor: aString).	aBlock value: file.	file close.! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'cmm 4/22/2011 16:54'!directory: aFileDirectory 	^ self new		 directory: aFileDirectory ;		 yourself! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'cmm 4/22/2011 16:58'!path: fullyQualifiedName 	^ self directory: (FileDirectory on: fullyQualifiedName)! !!MCDirectoryRepository class methodsFor: 'configuring' stamp: 'cmm 4/22/2011 16:13'!creationTemplateLocation: location 	^ self name , ' path: {1}' format: {location printString}! !!MCDirectoryRepository class methodsFor: 'configuring' stamp: 'ab 7/24/2003 21:20'!description	^ 'directory'! !!MCDirectoryRepository class methodsFor: 'configuring' stamp: 'cmm 4/22/2011 16:00'!fillInTheBlankRequest	^ 'Directory Location:'! !!MCDirectoryRepository class methodsFor: 'configuring' stamp: 'ul 12/12/2009 14:10'!morphicConfigure	^ FileList2 modalFolderSelector ifNotNil:		[:directory |		self new directory: directory]! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'cmm 4/22/2011 16:54'!setUp	repository := MCDirectoryRepository directory: self directory! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'ul 4/26/2011 05:28'!tearDown	super tearDown.	self directory recursiveDelete! !!MCDirtyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!packageName	^ 'MCDirtyPackage'! !!MCEmptyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!packageName	^ 'MCEmptyPackage'! !!MCFileBasedRepository methodsFor: 'versions' stamp: 'cmm 3/5/2011 18:30'!includesVersionNamed: aString	^ self allVersionNames includes: aString asMCVersionName! !!MCFileBasedRepository methodsFor: 'versions' stamp: 'cmm 3/6/2011 16:18'!versionNamed: aMCVersionName	"For FileBased repositories, aMCVersionName must have the appropriate extension!!  :-("	| v |	v := self cache at: aMCVersionName ifAbsent: [self loadVersionFromFileNamed: aMCVersionName].	self resizeCache: cache.	(v notNil and: [v isCacheable]) ifTrue: [cache at: aMCVersionName asMCVersionName put: v].	^ v! !!MCFileBasedRepository methodsFor: 'versions' stamp: 'cmm 3/5/2011 18:31'!versionNamesForPackageNamed: packageName 	^ Array streamContents:		[ : stream | self allFileNamesOrCache do:			[ : each | | mcVersionName |			mcVersionName := each asMCVersionName.			mcVersionName packageName = packageName ifTrue: [ stream nextPut: mcVersionName ] ] ]! !!MCFileBasedRepository methodsFor: 'versions' stamp: 'cmm 3/6/2011 16:27'!versionWithInfo: aVersionInfo ifAbsent: errorBlock	(self allFileNamesForVersionNamed: aVersionInfo versionName) do:		[:fileName | | version |		version := self versionNamed: fileName.		version info = aVersionInfo ifTrue: [^ version]].	^ errorBlock value! !!MCFileBasedRepository methodsFor: 'overriding' stamp: 'cmm 3/7/2011 21:36'!allPackageNames	| answer |	answer := Set new.	self allFileNamesOrCache do:		[ : each | | versionName |		versionName := each asMCVersionName.		versionName isValid ifTrue: [ answer add: versionName packageName ] ].	^ answer! !!MCFileBasedRepository methodsFor: 'overriding' stamp: 'cmm 4/24/2011 18:41'!basicStoreVersion: aMCVersionOrConfiguration 	self		writeStreamForFileNamed: aMCVersionOrConfiguration fileName		do: [ : s | aMCVersionOrConfiguration fileOutOn: s ].	aMCVersionOrConfiguration isCacheable ifTrue:		[ cache ifNil: [ cache := Dictionary new ].		self resizeCache: cache.		cache			at: aMCVersionOrConfiguration fileName			put: aMCVersionOrConfiguration ]! !!MCFileBasedRepository methodsFor: 'overriding' stamp: 'avi 9/17/2005 16:40'!closestAncestorVersionFor: anAncestry ifNone: errorBlock	^ self cacheAllFileNamesDuring:		[super closestAncestorVersionFor: anAncestry ifNone: errorBlock]! !!MCFileBasedRepository methodsFor: 'overriding' stamp: 'avi 2/28/2004 18:32'!morphicOpen: aWorkingCopy	(MCFileRepositoryInspector repository: self workingCopy: aWorkingCopy)		show! !!MCFileBasedRepository methodsFor: 'overriding' stamp: 'nice 6/11/2010 21:51'!notifyList	(self allFileNames includes: 'notify') ifFalse: [^ #()].	^ self readStreamForFileNamed: 'notify' do:		[:s |		s upToEnd lines]! !!MCFileBasedRepository methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!cache	^ cache ifNil: [cache := Dictionary new]! !!MCFileBasedRepository methodsFor: 'private' stamp: 'ar 1/4/2010 17:21'!cacheAllFileNamesDuring: aBlock	allFileNames ifNotNil:[^aBlock value].	allFileNames := self allFileNames.	^ aBlock ensure: [allFileNames := nil]! !!MCFileBasedRepository methodsFor: 'private' stamp: 'bf 6/9/2005 15:47'!cachedFileNames	^cache == nil		ifTrue: [#()]		ifFalse: [cache keys]! !!MCFileBasedRepository methodsFor: 'private' stamp: 'cmm 4/7/2011 12:37'!flushCache	cache := allFileNames := nil! !!MCFileBasedRepository methodsFor: 'private' stamp: 'avi 9/17/2005 16:52'!maxCacheSize	^ 8! !!MCFileBasedRepository methodsFor: 'private' stamp: 'avi 9/18/2005 22:43'!resizeCache: aDictionary	[aDictionary size <= self maxCacheSize] whileFalse:		[aDictionary removeKey: aDictionary keys atRandom]! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'ab 8/21/2003 00:35'!allFileNames	self subclassResponsibility! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'cmm 3/6/2011 16:24'!allFileNamesForVersionNamed: aMCVersionName 	^ self		filterFileNames: self readableFileNames		forVersionNamed: aMCVersionName! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'avi 9/17/2005 16:40'!allFileNamesOrCache	^ allFileNames ifNil: [self allFileNames]! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'ul 3/22/2011 22:02'!allVersionNames	^self readableFileNames collect: [ :each | each versionName ]! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'stephaneducasse 2/4/2006 20:47'!canReadFileNamed: aString	| reader |	reader := MCVersionReader readerClassForFileNamed: aString.	^ reader notNil! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'cmm 3/6/2011 16:24'!filterFileNames: aCollection forVersionNamed: aMCVersionName 	^ aCollection select:		[ : ea | aMCVersionName = ea ]! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'avi 1/22/2004 13:34'!loadVersionFromFileNamed: aString	^ self versionReaderForFileNamed: aString do: [:r | r version]! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'avi 9/17/2005 18:37'!loadVersionInfoFromFileNamed: aString	^ self versionReaderForFileNamed: aString do: [:r | r info]	! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'ul 5/8/2011 03:26'!readableFileNames	"Answer an Array of MCVersionNames representing every file in this repository; first the ones from the cache (whether or not they still exist in the repository) followed by every other file in this repository that Monticello can read."	| all cached new |	all := self allFileNamesOrCache.	"from repository"	cached := self cachedFileNames.	"in memory"	"Create a sparse Set, so we can avoid #= for MCVersionNames during the difference calculation."	new := all difference: (		(Set new: (cached size * 8 min: all size))			addAll: cached;			yourself).	^ (cached asArray, new)		select: [:ea | self canReadFileNamed: ea]! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'avi 9/17/2005 18:37'!versionInfoFromFileNamed: aString	self cache at: aString ifPresent: [:v | ^ v info].	^ self loadVersionInfoFromFileNamed: aString! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'ul 12/12/2009 14:10'!versionReaderForFileNamed: aString do: aBlock	^ self		readStreamForFileNamed: aString		do: [:s |			(MCVersionReader readerClassForFileNamed: aString) ifNotNil:				[:class | aBlock value: (class on: s fileName: aString)]]! !!MCFileBasedRepository methodsFor: 'private-files' stamp: 'avi 10/31/2003 14:32'!writeStreamForFileNamed: aString do: aBlock	^ self writeStreamForFileNamed: aString replace: false do: aBlock! !!MCFileBasedRepository class methodsFor: 'release' stamp: 'ar 2/26/2010 23:03'!cleanUp	"Flush caches"	self flushAllCaches.! !!MCFileBasedRepository class methodsFor: 'release' stamp: 'avi 2/3/2005 00:43'!flushAllCaches	self allSubInstancesDo: [:ea | ea flushCache]! !!MCFileBasedRepository class methodsFor: '*monticelloconfigurations' stamp: 'cmm 4/22/2011 16:51'!supportsConfigurations	^ true! !!MCFileInTest methodsFor: 'running' stamp: 'ul 4/26/2011 05:27'!tearDown	super tearDown.	(diff isNil or: [diff isEmpty not])		 ifTrue: [expected updatePackage: self mockPackage]! !!MCFileInTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:53'!testStWriter	<timeout: 30> "takes a little longer"	self		assertFileOutFrom: MCStWriter		canBeFiledInWith: [stream fileIn].! !!MCFileRepositoryInspector methodsFor: 'private' stamp: 'cmm 3/4/2011 16:27'!allVersionNames	^ allVersionNames ifNil:		[ self initializeVersionNames.		allVersionNames ]! !!MCFileRepositoryInspector methodsFor: 'private' stamp: 'cmm 3/4/2011 16:26'!initializeVersionNames	repository cacheAllFileNamesDuring:		[ super initializeVersionNames.		allVersionNames := repository readableFileNames ]! !!MCFileRepositoryInspector methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!versionInfo	^ versionInfo ifNil: [versionInfo := repository versionInfoFromFileNamed: selectedVersion]! !!MCFileRepositoryInspector methodsFor: 'private' stamp: 'cmm 3/4/2011 16:21'!versionNamesForNoPackageSelection	^ self allVersionNames! !!MCFileRepositoryInspector methodsFor: 'private' stamp: 'cmm 3/4/2011 16:23'!versionNamesForSelectedPackage	^ self allVersionNames select:		[ : each | each packageName = selectedPackage ]! !!MCFileRepositoryInspector methodsFor: 'private' stamp: 'cmm 3/6/2011 15:21'!versionSelection: aNumber 	versionInfo := nil.	super versionSelection: aNumber! !!MCFrontier methodsFor: 'accessing' stamp: 'bf 12/8/2011 19:35'!frontier	^frontier asArray	"not safe to hand out the frontier itself"! !!MCFtpRepository methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2011 14:54'!parseDirectoryListing: aString	| stream files line tokens |	stream := aString readStream.	files := OrderedCollection new.	[stream atEnd] whileFalse:		[line := stream nextLine.		tokens := line findTokens: ' '.		tokens size > 2 ifTrue: [files add: tokens last asMCVersionName]].	^ files! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'cmm 3/6/2011 16:56'!allPackageNames	^ self root collect:		[ : ea | ea package name ]! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'cmm 3/6/2011 17:00'!includesVersionNamed: aString 	^ (self versionNamed: aString) notNil! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'cmm 3/6/2011 17:00'!versionNamed: aString 	| versionName |	versionName := aString asMCVersionName.	self root keysDo:		[ : each | each versionName = versionName ifTrue: [ ^ each ] ].	^ nil! !!MCGOODSRepository methodsFor: 'as yet unclassified' stamp: 'cmm 3/6/2011 17:03'!versionNamesForPackageNamed: aString 	^ Array streamContents:		[ : stream | self root keysDo:			[ : each | each versionName packageName = aString ifTrue: [ stream nextPut: each ] ] ]! !!MCGOODSRepository commentStamp: 'cmm 3/6/2011 16:56' prior: 0!A MCGOODSRepository simply stores a Dictionary of aVersionInfo-> aMCVersion.!!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2011 14:53'!parseFileNamesFromStream: aStream	| names fullName |	names := OrderedCollection new.	[aStream atEnd] whileFalse:		[[aStream upTo: $<. {$a. $A. nil} includes: aStream next] whileFalse.		aStream upTo: $".		aStream atEnd ifFalse: [			fullName := aStream upTo: $".			names add: fullName unescapePercents asMCVersionName ]].	^ names! !!MCHttpRepository methodsFor: 'required' stamp: 'fbs 6/9/2011 07:42'!allFileNames	| index |	[self displayProgress: 'Updating ', self description during:[		index := HTTPSocket httpGet: self locationWithTrailingSlash, '?C=M;O=D' args: nil user: self user passwd: self password.	]] on: NetworkError do: [ :e | self error: 'Could not access ', location, '(', e className, ')'].	index isString ifTrue: [self error: 'Could not access ', location].	^ self parseFileNamesFromStream: index	! !!MCHttpRepository methodsFor: 'required' stamp: 'ul 8/2/2011 20:03'!displayProgress: label during: workBlock	| nextUpdateTime |	nextUpdateTime := 0.	^label displayProgressFrom: 0.0 to: 1.0 during:[:bar|			workBlock on: HTTPProgress do:[:ex|				(ex total == nil or:[ex amount == nil]) ifFalse:[					(nextUpdateTime < Time millisecondClockValue 						or:[ex total = ex amount]) ifTrue:[							bar value: ex amount asFloat / ex total asFloat.							nextUpdateTime := Time millisecondClockValue + 100.					].				].				ex resume.			]		].! !!MCHttpRepository methodsFor: 'required' stamp: 'ar 7/21/2010 19:53'!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream response statusLine code |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	self displayProgress: 'Uploading ', aString during:[		response := HTTPSocket					httpPut: stream contents					to: (self urlForFileNamed: aString)					user: self user					passwd: self password.	].	"More robust handling of HTTP responses. Instead of enumerating	all possible return codes and http versions, do a quick parse"	(response beginsWith: 'HTTP/') ifTrue:[		"Looks like an HTTP header, not some error message"		statusLine := response copyUpTo: Character cr.		code := [(statusLine findTokens: ' ') second asInteger] on: Error do:[].	].	(code isInteger and:[code between: 200 and: 299]) 		ifFalse:[self error: response].! !!MCHttpRepository class methodsFor: 'ui-support' stamp: 'cmm 1/25/2011 13:00'!creationTemplate	^self creationTemplateLocation: 'http://www.squeaksource.com/ProjectName'		user: 'squeak'		password: 'squeak'! !!MCHttpRepository class methodsFor: 'ui-support' stamp: 'bf 4/14/2005 15:27'!creationTemplateLocation: location user: user password: password	^'MCHttpRepository	location: {1}	user: {2}	password: {3}' format: {location printString. user printString. password printString}! !!MCHttpRepository class methodsFor: 'ui-support' stamp: 'ab 7/24/2003 21:20'!description	^ 'HTTP'! !!MCHttpRepository class methodsFor: 'ui-support' stamp: 'bkv 2/18/2004 21:00'!fillInTheBlankRequest	^ 'HTTP Repository:'			! !!MCHttpRepository class methodsFor: 'ui-support' stamp: 'ab 7/24/2003 21:32'!location: location user: user password: password	^ self new		location: location;		user: user;		password: password! !!MCHttpRepository class methodsFor: 'ui-support' stamp: 'bkv 2/18/2004 21:01'!morphicConfigure	^ self fillInTheBlankConfigure! !!MCInitializationTest methodsFor: 'as yet unclassified' stamp: 'ul 4/26/2011 05:28'!tearDown	super tearDown.	(MCWorkingCopy forPackage: self mockPackage) unregister! !!MCMcmReader methodsFor: 'accessing' stamp: 'ar 6/30/2009 17:05'!configuration	configuration ifNil: [self loadConfiguration].	"browser modifies configuration, but the reader might get cached"	^configuration copy! !!MCMcmReader methodsFor: 'accessing' stamp: 'ar 6/30/2009 17:05'!loadConfiguration	stream reset.	configuration := MCConfiguration fromArray: (MCScanner scan: stream).	configuration name: self configurationName.! !!MCMcmReader methodsFor: 'accessing' stamp: 'ar 6/30/2009 17:06'!loadVersionInfo	info := self configuration! !!MCMcmReader methodsFor: 'accessing' stamp: 'ar 6/30/2009 17:06'!version	^self configuration! !!MCMcmReader commentStamp: 'dtl 5/10/2010 22:22' prior: 0!A MCMcmReader creates an MCConfiguration by reading an array specification from a stream.!!MCMcmUpdater commentStamp: 'cbc 8/26/2010 16:42' prior: 0!MCMcmUpdater provides utility methods for updating Monticello packages from Monticello configurations.When Monticello configurations are stored in a repository (or repositories), MCMcmUpdater acts as an update stream. It first ensures that each configuration map has been loaded in sequence, then updates the last configuration map to the most recent version for each specified package, and finally loads these versions to produce a fully updated configuration.Currently if a set of packages are unloaded from the image, using this class to reload them may cause problems, depending on what dependencies those classes have.  Success is not assured.  Removing packages via SmalltalkImage>>unloadAllKnownPackages will be successful, it flags the packages removed so that they are not loaded by this utility.If you wish to not have MCMcmUpdater update packages, there are two ways to handle this:1) To have MCMcmUpdater not update any packages not currently in the image set the UpdateMissingPackages preference to false:		MCMcmUpdater updateMissingPackages: false	Note that any new packages added to the repositories will not be picked up when this is turned off.2) To have MCMcmUpdater not update a specific package, evaluate		MCMcmUpdater disableUpdatesOfPackage: <packageName>Class Variables definitions:DefaultUpdateURL - String: the URL that will be checked by default for updates.  This would be set for a common standard location to check.LastUpdateMap - Dictionary of Integer: version number of the last loaded update map per repository.  Keeps track of the last configuration map, so that the utility will not have to run through the full history in the repositories each time you ask to update.SkipPackages - Set of Strings: names of packages to not update in MCMcmUpdater (empty by default).UpdateMissingPackages - Boolean: if true (default), new packages in the update config map will be loaded unless they are in SkipPackages.  If false, packages not currently loaded in the image will not be loaded by MCMcmUpdater.  (This can be dangerous if packages are split - use at your own risk).!!MCMcmUpdater class methodsFor: 'updating' stamp: 'bf 11/17/2011 16:50'!updateFromRepositories: repositoryUrls	"MCMcmUpdater updateFromRepositories: #(		'http://squeaksource.com/MCUpdateTest'	)"	| repos config |	Preferences enable: #upgradeIsMerge.	LastUpdateMap ifNil:[LastUpdateMap := Dictionary new].	"The list of repositories to consult in order"	repos := repositoryUrls collect:[:url| 		MCRepositoryGroup default repositories 			detect:[:r| r description = url]			ifNone:[ | r |				r := MCHttpRepository location: url user: '' password: ''.				MCRepositoryGroup default addRepository: r.				r]].	"The list of updates-author.version.mcm sorted by version"	repos do:[:r| r cacheAllFileNamesDuring:[		| updateList |		updateList := self updateListFor: r.		"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			(LastUpdateMap at: r description ifAbsent: [0]) = 0 ifTrue: [				"No update has ever been loaded from this repo. If no package is				present in the image either, we can skip right to the latest config"				config := r versionNamed: updateList last value.				(config dependencies anySatisfy: [:dep| dep package hasWorkingCopy])					ifFalse: [ (self useLatestPackagesFrom: r)						ifTrue: [LastUpdateMap at: r description put: updateList last key.							updateList := #()]						ifFalse: [updateList := updateList last: 1]]].			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				ProgressNotification signal: '' extra: 'Processing ', assoc value.				config := r versionNamed: assoc value.				"Skip packages that were specifically unloaded"				config dependencies: (config dependencies 					reject: [:dep| self skipPackages includes: dep package name]).				self updateMissingPackages ifFalse:[					"Skip packages that are not in the image"					config dependencies: (config dependencies 						select: [:dep| dep package hasWorkingCopy])].				(config dependencies allSatisfy:[:dep| dep isFulfilled]) 					ifFalse:[config upgrade].				LastUpdateMap at: r description put: assoc key.			] displayingProgress: 'Processing configurations'.			"We've loaded all the provided update configurations.			Use the latest configuration to update all the remaining packages."			(self useLatestPackagesFrom: r) ifTrue: [				config updateFromRepositories.				config upgrade].		]].	].	^config! !!MCMcmUpdater class methodsFor: 'preferences' stamp: 'ar 4/9/2010 20:41'!defaultUpdateURL	"The default update repository URL"	<preference: 'Update URL'		category: 'Monticello'		description: 'The repository URL for loading updates'		type: #String>	^DefaultUpdateURL ifNil:['']! !!MCMcmUpdater class methodsFor: 'preferences' stamp: 'ar 4/9/2010 20:40'!defaultUpdateURL: aString	"The default update repository URL"	DefaultUpdateURL := aString! !!MCMcmUpdater class methodsFor: 'preferences' stamp: 'cbc 8/25/2010 10:27'!disableUpdatesOfPackage: packageName	self skipPackages add: packageName! !!MCMcmUpdater class methodsFor: 'preferences' stamp: 'cbc 8/25/2010 10:29'!enableUpdatesForAllPackages	SkipPackages := Set new! !!MCMcmUpdater class methodsFor: 'preferences' stamp: 'cbc 8/25/2010 10:27'!enableUpdatesOfPackage: packageName	self skipPackages remove: packageName ifAbsent: [].! !!MCMcmUpdater class methodsFor: 'preferences' stamp: 'ar 8/24/2010 20:03'!updateMissingPackages	"Whether to update missing (unloaded) packages"	<preference: 'Update missing package'		category: 'Monticello'		description: 'If true, missing (unloaded) packages will be loaded during the update process.'		type: #Boolean>	^UpdateMissingPackages ifNil:[true]! !!MCMcmUpdater class methodsFor: 'preferences' stamp: 'ar 8/24/2010 20:04'!updateMissingPackages: aBool	"Whether to update missing (unloaded) packages"	UpdateMissingPackages := aBool.! !!MCMcmUpdater class methodsFor: 'private' stamp: 'cbc 8/25/2010 08:14'!skipPackages	^SkipPackages ifNil: [SkipPackages := Set new]! !!MCMcmUpdater class methodsFor: 'private' stamp: 'bf 7/12/2011 19:09'!updateListFor: repo	| updateList allNames minVersion |	updateList := SortedCollection new.	minVersion := LastUpdateMap at: repo description ifAbsent: [0].	"Find all the updates-author.version.mcm files"	'Checking ', repo description		displayProgressFrom: 0 to: 1 during: [:bar| 			bar value: 0.			allNames := repo allFileNames].	allNames do: [:versionedName | | version base parts author type |		parts := versionedName findTokens: '.-'.		parts size = 4 ifTrue: [			base := parts at: 1.			author := parts at: 2.			version := [(parts at: 3) asNumber] on: Error do: [:ex | ex return: 0].			type := parts at: 4.		].		(base = 'update' and: [version >= minVersion and: [type = 'mcm']]) 			ifTrue: [updateList add: version -> versionedName]].	^updateList! !!MCMcmUpdater class methodsFor: 'private' stamp: 'bf 7/12/2011 19:25'!useLatestPackagesFrom: repo	"for overriding on a per repository basis"	^true! !!MCMcmWriter commentStamp: 'dtl 5/10/2010 22:20' prior: 0!An MCMcmWriter stores an MCConfiguration on a stream in the form of an array specification.!!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2011 14:59'!fileName	^ 'InstallerTest.mcz' asMCVersionName! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'ul 4/26/2011 05:28'!tearDown	super tearDown.	expected snapshot updatePackage: self mockPackage.	self deleteFile.! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'bf 4/18/2010 18:38'!extractInfoFrom: dict	^MCWorkingCopy infoFromDictionary: dict cache: self infoCache! !!MCMenuSpec methodsFor: 'comparing' stamp: 'tfel 6/12/2010 11:43'!= aMCMenuSpec	^ self class == aMCMenuSpec class and: [self entry = aMCMenuSpec entry].! !!MCMenuSpec methodsFor: 'comparing' stamp: 'tfel 6/12/2010 11:42'!hash	^ self entry hash! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!entry	^entry! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!entry: anObject	entry := anObject! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!selector	^selector! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!selector: anObject	selector := anObject! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!target	^target! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!target: anObject	target := anObject! !!MCMenuSpec commentStamp: 'tfel 6/12/2010 14:57' prior: 0!A MCMenuSpec holds information to add menu entries to the monticello browser menus from external classes.Required is the entry string (#entry), the call target and the selector be called.An external class may use the MCWorkingCopyBrowser class>>addMenuSpec: method to add it's own menu entry to the monticello browser context menu.Note that MCMenuSpecs are compared via their menu entry string and if multiple MCMenuSpecs are added to the MCWorkingCopyBrowser, the last one takes precedence.!!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 22:53'!chooseLocal	self conflictSelectionDo:		[selection chooseLocal.		self changed: #text; changed: #list].	self selectNextUnresolvedConflict! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 22:38'!chooseRemote	self conflictSelectionDo:		[selection chooseRemote.		self changed: #text; changed: #list].	self selectNextUnresolvedConflict! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 22:59'!conflictSelectionDo: aBlock	self selectionIsConflicted		ifTrue: aBlock! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 00:43'!innerButtonRow	^ self buttonRow: self innerButtonSpecs! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 00:43'!innerButtonSpecs	^		#((Keep chooseRemote 'keep the selected change' )		  (Reject chooseLocal 'reject the selected change' ))! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 01:02'!methodListKey: aKeystroke from: aListMorph 	aKeystroke caseOf: {		[$k] -> [self chooseRemote].		[$r] -> [self chooseLocal]}		 otherwise: [super methodListKey: aKeystroke from: aListMorph ]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 23:09'!selectNextUnresolvedConflict	"Try and select the next unresolved conflict starting at current selection in the list, wrapping at beginning.	If there is no more unresolved conflict, then simply move to next non conflict item in the list.	This method makes assumption that conflicts are always sorted before non conflicts items."	(self findListMorph: #list)		ifNotNil:			[:aMorph |			| currentIndex nextUnresolvedIndex |			currentIndex := aMorph getCurrentSelectionIndex min: conflicts size.			nextUnresolvedIndex := (currentIndex + 1 to: currentIndex + conflicts size - 1)				detect:					[:i |					| nextItem |					((nextItem := conflicts atWrap: i) isKindOf: MCConflict)						and: [nextItem isResolved not]]				ifNone: [0].			nextUnresolvedIndex = 0				ifTrue: [items size > 1 ifTrue: [self selection: (aMorph getCurrentSelectionIndex max: conflicts size)  - conflicts size \\ items size + conflicts size + 1]]				ifFalse: [self selection: nextUnresolvedIndex - 1 \\ conflicts size + 1].].! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 01:55'!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)].	^ {		#((buttonRow) (0 0 1 0) (0 0 0 30)).		#((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from:) (0 0 1 0.4) (0 30 0 0)).		#((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30)).		{ #(textMorph: annotations). #(0 0.4 1 0.4). { 0. 30. 0. 30+self defaultAnnotationPaneHeight. }}.		{ #(textMorph: text). #(0 0.4 1 1). { 0. 30+self defaultAnnotationPaneHeight. 0. 0.}}	}! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'nice 9/22/2010 00:48'!timeStamp	^ timeStamp ifNil: ['']! !!MCMethodDefinition methodsFor: 'accessing' stamp: 'cmm 3/8/2011 20:28'!workingCopy	"Answer the working copy of which this object is defined."	^ self asMethodReference workingCopy! !!MCMethodDefinition methodsFor: 'installing' stamp: 'cmm 3/8/2011 20:25'!addMethodAdditionTo: aCollection 	aCollection		 add: self asMethodAddition createCompiledMethod ;		 yourself! !!MCMethodDefinition methodsFor: 'installing' stamp: 'ul 11/15/2010 11:53'!scanForPreviousVersion	| sourceFilesCopy method position |	method := self actualClass compiledMethodAt: selector ifAbsent: [^ nil].	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos tokens preamble methodCategory stamp prevFileIndex |	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		methodCategory = category ifFalse:			[methodCategory = (Smalltalk 									at: #Categorizer 									ifAbsent: [Smalltalk at: #ClassOrganizer]) 										default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: className category: methodCategory meta: classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!MCMethodDefinition methodsFor: 'printing' stamp: 'bf 3/28/2011 18:41'!fullClassName	"Using #class selector for classes for backwards compatibility"	^ self classIsMeta		ifFalse: [self className]		ifTrue: [			(self actualClass notNil and: [ self actualClass isTrait ])				ifFalse: [self className, ' class']				ifTrue: [self className, ' classSide']]! !!MCMethodDefinition methodsFor: 'printing' stamp: 'bf 11/1/2011 11:49'!summarySuffixOver: previousDefinition	| sourceChanged categoryChanged timeStampChanged |	sourceChanged := self source ~= previousDefinition source.	timeStampChanged := self timeStamp ~= previousDefinition timeStamp.	categoryChanged := self category ~= previousDefinition category.	sourceChanged | timeStampChanged | categoryChanged		ifFalse: [ ^super summarySuffixOver: previousDefinition ].	sourceChanged ifTrue: [		^categoryChanged			ifTrue: [ ' (changed and recategorized)' ]			ifFalse: [ ' (changed)' ] ].	timeStampChanged & categoryChanged		ifTrue: [^ ' (recategorized and different time stamp)' ].	^categoryChanged		ifTrue: [ ' (only recategorized)' ]		ifFalse: [ ' (only different time stamp)' ]! !!MCMethodDefinition methodsFor: 'converting' stamp: 'ar 3/4/2010 23:39'!asMethodAddition	^MethodAddition new		compile: source		classified: category		withStamp: timeStamp		notifying: nil		logSource: true		inClass: self actualClass.! !!MCMethodDefinition methodsFor: 'converting' stamp: 'cmm 3/8/2011 19:44'!asMethodReference	^ MethodReference		class: self actualClass		selector: self selector! !!MCMethodDefinition methodsFor: 'renaming' stamp: 'cmm 6/8/2011 13:49'!handlePackageRename: oldPackageName to: newPackageName 	"If I'm an extension or override method, rename the category to be prefixed with newPackageName."	((self isExtensionMethod or: [ self isOverrideMethod ]) and: [ (self category allButFirst beginsWith: newPackageName asLowercase) not ]) ifTrue:		[ self actualClass organization			renameCategory: self category			toBe:				'*' ,					(self						newCategoryNameFor: self category allButFirst						givenRenameFrom: oldPackageName						to: newPackageName) ]! !!MCMethodDefinition class methodsFor: 'class initialization' stamp: 'ab 8/22/2003 18:14'!initialize	Smalltalk addToShutDownList: self! !!MCMethodDefinition class methodsFor: 'class initialization' stamp: 'ul 2/26/2010 17:42'!shutDown		definitions := nil.! !!MCMethodDefinition class methodsFor: 'accessing' stamp: 'ul 2/26/2010 17:42'!cachedDefinitions		^definitions ifNil: [ definitions := WeakIdentityKeyDictionary new ]! !!MCMethodDefinition class methodsFor: 'create' stamp: 'ab 7/26/2003 02:05'!className: classStringclassIsMeta: metaBooleanselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	^ self instanceLike:		(self new initializeWithClassName: classString					classIsMeta: metaBoolean					selector: selectorString					category: catString					timeStamp: timeString					source: sourceString)! !!MCMethodDefinition class methodsFor: 'create' stamp: 'ab 4/1/2003 01:40'!className: classStringselector: selectorStringcategory: catStringtimeStamp: timeStringsource: sourceString	^ self	className: classString			classIsMeta: false			selector: selectorString			category: catString			timeStamp: timeString			source: sourceString! !!MCMethodDefinition class methodsFor: 'create' stamp: 'nice 1/1/2010 22:10'!forMethodReference: aMethodReference	| definition |	definition := self cachedDefinitions at: aMethodReference compiledMethod ifAbsent: [].	(definition isNil		or: [definition selector ~= aMethodReference methodSymbol		or: [definition className ~= aMethodReference classSymbol		or: [definition classIsMeta ~= aMethodReference classIsMeta		or: [definition category ~= aMethodReference category]]]])			ifTrue: [definition := self 						className: aMethodReference classSymbol						classIsMeta: aMethodReference classIsMeta						selector: aMethodReference methodSymbol						category: aMethodReference category						timeStamp: aMethodReference timeStamp						source: aMethodReference source.					self cachedDefinitions at: aMethodReference compiledMethod put: definition].	^ definition	! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'eem 10/9/2010 17:15'!override ^ 1! !!MCMethodDefinitionTest methodsFor: 'running' stamp: 'ul 4/26/2011 05:28'!tearDown	super tearDown.	self restoreMocks.	(MCWorkingCopy forPackage: (MCPackage named: 'FooBarBaz')) unregister.	self class compile: 'override ^ 1' classified: 'mocks'.	self ownPackage modified: isModified.! !!MCMockPackageInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 20:31'!packageName	^ 'MonticelloMocks'! !!MCModification methodsFor: 'accessing' stamp: 'bf 11/1/2011 11:42'!summarySuffix	^ modification summarySuffixOver: obsoletion! !!MCModification methodsFor: 'as yet unclassified' stamp: 'bf 6/13/2011 16:27'!isUnchangedMethod	"true if this is a modification of a method where only the timestamp changed"	^ obsoletion isMethodDefinition		and: [obsoletion source = modification source			and: [obsoletion category = modification category] ]! !!MCOrganizationDefinition methodsFor: 'testing' stamp: 'ab 7/19/2003 18:25'!= aDefinition	^ (super = aDefinition)		and: [categories = aDefinition categories]! !!MCOrganizationDefinition methodsFor: 'testing' stamp: 'cwp 7/11/2003 01:33'!isOrganizationDefinition	^ true! !!MCOrganizationDefinition methodsFor: 'actions' stamp: 'ab 7/18/2003 21:47'!accept: aVisitor	^ aVisitor visitOrganizationDefinition: self! !!MCOrganizationDefinition methodsFor: 'actions' stamp: 'cmm 6/8/2011 13:59'!handlePackageRename: oldPackageName to: newPackageName 	categories do:		[ : each | (each beginsWith: newPackageName) ifFalse:			[ | newCategoryName |			newCategoryName := self				newCategoryNameFor: each				givenRenameFrom: oldPackageName				to: newPackageName.			(SystemOrganizer default categories includes: newCategoryName) ifTrue: [ SystemOrganizer default removeCategory: newCategoryName ].			SystemOrganizer default				renameCategory: each				toBe: newCategoryName ] ]! !!MCOrganizationDefinition methodsFor: 'actions' stamp: 'avi 2/22/2004 13:46'!postloadOver: oldDefinition	SystemOrganization categories:		(self			reorderCategories: SystemOrganization categories			original: (oldDefinition ifNil: [#()] ifNotNil: [oldDefinition categories]))! !!MCOrganizationDefinition methodsFor: 'actions' stamp: 'bf 10/17/2011 16:22'!reorderCategories: allCategories original: oldCategories	| first |	first := allCategories detect: [:ea | categories includes: ea]		ifNone: [^ allCategories, categories].	^ 	((allCategories copyUpTo: first) copyWithoutAll: oldCategories, categories),		categories,		((allCategories copyAfter: first) copyWithoutAll: oldCategories, categories)! !!MCOrganizationDefinition methodsFor: 'actions' stamp: 'bf 10/17/2011 16:28'!unload	SystemOrganization categories:		(SystemOrganization categories copyWithoutAll: categories)! !!MCOrganizationDefinition methodsFor: 'accessing' stamp: 'ab 5/24/2003 13:51'!categories	^ categories! !!MCOrganizationDefinition methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!categories: anArray	categories := anArray! !!MCOrganizationDefinition methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!commonPrefix	| stream |	categories isEmpty ifTrue: [^ ''].		stream := String new writeStream.	categories first withIndexDo:		[:c :i|		categories do:			[:ea |			(ea at: i ifAbsent: []) = c ifFalse: [^ stream contents]].		stream nextPut: c].	^ stream contents! !!MCOrganizationDefinition methodsFor: 'accessing' stamp: 'bf 6/21/2011 13:52'!description	^ Array with: #organization! !!MCOrganizationDefinition methodsFor: 'accessing' stamp: 'ab 7/19/2003 18:01'!sortKey	^ '<organization>'! !!MCOrganizationDefinition methodsFor: 'accessing' stamp: 'ab 7/22/2003 01:14'!source	^ String streamContents:		[:s |		categories do: [:ea | s nextPutAll: ea] separatedBy: [s cr]]! !!MCOrganizationDefinition methodsFor: 'accessing' stamp: 'ab 5/24/2003 13:55'!summary	^ categories asArray printString! !!MCPackage methodsFor: 'accessing' stamp: 'ab 7/7/2003 00:57'!name	^ name! !!MCPackage methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!name: aString	name := aString! !!MCPackage methodsFor: 'accessing' stamp: 'ab 7/7/2003 13:33'!packageInfo	^ PackageInfo named: name! !!MCPackage methodsFor: 'accessing' stamp: 'cwp 11/13/2003 13:33'!workingCopy	^ MCWorkingCopy forPackage: self.! !!MCPackage methodsFor: 'testing' stamp: 'ar 4/26/2005 21:57'!= other	^ other species = self species and: [other name sameAs: name]! !!MCPackage methodsFor: 'testing' stamp: 'bf 4/19/2005 16:26'!hasWorkingCopy	^ MCWorkingCopy registry includesKey: self! !!MCPackage methodsFor: 'testing' stamp: 'ar 4/26/2005 21:57'!hash	^ name asLowercase hash! !!MCPackage methodsFor: 'printing' stamp: 'nk 7/28/2003 13:30'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: name;		nextPut: $)! !!MCPackage methodsFor: 'input/output' stamp: 'ul 3/17/2011 01:29'!snapshot	| packageInfo definitions categories |	packageInfo := self packageInfo.	definitions := OrderedCollection new.	categories := packageInfo systemCategories.	categories isEmpty ifFalse: [ definitions add: (MCOrganizationDefinition categories: categories) ].	CurrentReadOnlySourceFiles cacheDuring: [		packageInfo methods do: [:ea | definitions add: ea asMethodDefinition] displayingProgress: 'Snapshotting methods...'.		(packageInfo respondsTo: #overriddenMethods) ifTrue:			[packageInfo overriddenMethods				do: [:ea | definitions add:						(packageInfo changeRecordForOverriddenMethod: ea) asMethodDefinition]				displayingProgress: 'Searching for overrides...'].		packageInfo classes do: [:ea | definitions addAll: ea classDefinitions] displayingProgress: 'Snapshotting classes...' ].	(packageInfo respondsTo: #hasPreamble) ifTrue: [		packageInfo hasPreamble ifTrue: [definitions add: (MCPreambleDefinition from: packageInfo)].		packageInfo hasPostscript ifTrue: [definitions add: (MCPostscriptDefinition from: packageInfo)].		packageInfo hasPreambleOfRemoval ifTrue: [definitions add: (MCRemovalPreambleDefinition from: packageInfo)].		packageInfo hasPostscriptOfRemoval ifTrue: [definitions add: (MCRemovalPostscriptDefinition from: packageInfo)]]. 	^ MCSnapshot fromDefinitions: definitions! !!MCPackage methodsFor: 'input/output' stamp: 'ab 7/10/2003 01:13'!storeOn: aStream	aStream		nextPutAll: 'MCPackage';		space; nextPutAll: 'named: '; store: name.! !!MCPackage methodsFor: 'input/output' stamp: 'cwp 11/13/2003 13:32'!unload	^ self workingCopy unload! !!MCPackageLoader methodsFor: 'private' stamp: 'ul 6/17/2011 12:27'!basicLoad	"Load the contents of some package. This is the core loading method	in Monticello. Be wary about modifying it unless you understand the details	and dependencies of the various entities being modified."	| pkgName |	errorDefinitions := OrderedCollection new.	"Obviously this isn't the package name but we don't have anything else	to use here. ChangeSet current name will generally work since a CS is 	usually installed prior to installation."	pkgName := ChangeSet current name.	[["Pass 1: Load everything but the methods,  which are collected in methodAdditions."	additions do: [:ea | 		ea isMethodDefinition 			ifTrue:[methodAdditions add: ea asMethodAddition]			ifFalse:[[ea load]on: Error do: [errorDefinitions add: ea]].	] displayingProgress: 'Reshaping ', pkgName.	"Try again any delayed definitions"	self shouldWarnAboutErrors ifTrue: [self warnAboutErrors].	errorDefinitions do: [:ea | ea load] 		displayingProgress: 'Reloading ', pkgName.	"Pass 2: We compile new / changed methods"	methodAdditions do:[:ea| ea createCompiledMethod] 		displayingProgress: 'Compiling ', pkgName.	'Installing ', pkgName displayProgressFrom: 0 to: 2 during:[:bar|		"There is no progress *during* installation since a progress bar update		will redraw the world and potentially call methods that we're just trying to install."		bar value: 1.		"Pass 3: Install the new / changed methods		(this is a separate pass to allow compiler changes to be loaded)"		methodAdditions do:[:ea| ea installMethod].		"Pass 4: Remove the obsolete methods"		removals do:[:ea| ea unload].	].	"Finally, notify observers for the method additions"	methodAdditions do: [:each | each notifyObservers] 		"the message is fake but actually telling people how much time we spend		in the notifications is embarrassing so lie instead"		displayingProgress: 'Installing ', pkgName.	additions do: [:ea | ea postloadOver: (self obsoletionFor: ea)] 		displayingProgress: 'Initializing ', pkgName.	] on: InMidstOfFileinNotification do: [:n | n resume: true]	] ensure: [self flushChangesFile]! !!MCPackageLoader methodsFor: 'private' stamp: 'ul 8/2/2011 20:03'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangesOrganizer changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	aBlock ensure: [changeHolder newChanges: oldChanges].! !!MCPackageManager methodsFor: 'operations' stamp: 'cmm 6/8/2011 13:39'!unregister	self class registry		removeKey: package		ifAbsent: [ "Should not complain when trying to clean up." ].	self class changed: #allManagers! !!MCPackageManager methodsFor: 'operations' stamp: 'dtl 1/11/2011 23:30'!unregisterSubpackages	(self class registry keys		select: [:p | self packageName , '-*' match: p name])		do: [:k | self class registry removeKey: k]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:15'!registerForNotifications	Smalltalk		at: #SystemChangeNotifier		ifPresent:			[:cls|			cls uniqueInstance noMoreNotificationsFor: self.			self reregisterForNotificationsWith: cls uniqueInstance]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:14'!reregisterForNotificationsWith: aSystemChangeNotifier	aSystemChangeNotifier		notify: self ofSystemChangesOfItem: #class change: #Added using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Modified using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Commented using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #classMoved:;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #classRemoved:;		notify: self ofSystemChangesOfItem: #method change: #Added using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Recategorized using: #methodMoved:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #methodRemoved:! !!MCPackageTest methodsFor: 'running' stamp: 'ul 4/26/2011 05:28'!tearDown	super tearDown.	self mockSnapshot install! !!MCPackageTest methodsFor: 'tests' stamp: 'nice 8/27/2010 20:39'!testUnload	| mock |	self mockPackage unload.	self deny: (Smalltalk hasClassNamed: #MCMockClassA).	self deny: (MCSnapshotTest includesSelector: #mockClassExtension).	mock := (Smalltalk at: #MCMock).	self assert: (mock subclasses noneSatisfy: [:c | c name = #MCMockClassA])! !!MCPatchBrowser methodsFor: 'as yet unclassified' stamp: 'bf 6/13/2011 16:33'!unchangedMethods	^ items select: [:op | op isUnchangedMethod]! !!MCPatchBrowser methodsFor: 'menus' stamp: 'bf 6/21/2011 13:48'!methodListMenu: aMenu	selection ifNotNil:		[aMenu addList:#(			('install'	 installSelection)			('revert'	 revertSelection)			-)].	self unchangedMethods ifNotEmpty:		[aMenu addList:#(			('revert unchanged methods...'	revertUnchangedMethods)			-)].	super methodListMenu: aMenu.	^ aMenu! !!MCPatchBrowser methodsFor: 'actions' stamp: 'bf 6/21/2011 13:47'!revertUnchangedMethods	"revert methods that only have changed timestamps"	| loader unchangedMethods |	unchangedMethods := items select: [:op | op isUnchangedMethod].	(self confirm: ('Revert {1} methods that only differ in timestamp?' translated format: {unchangedMethods size}))		ifTrue: [			loader := MCPackageLoader new.			unchangedMethods do: [:op | op inverse applyTo: loader].			loader loadWithName: self changeSetNameForInstall].! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:48'!addDefinition: aDefinition	stream nextPutAll: 'A'; tab; nextPutAll: aDefinition summary; cr! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:57'!modifyDefinition: oldDefinition to: newDefinition	stream nextPutAll: 'M'; tab; nextPutAll: newDefinition summary; cr! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:57'!removeDefinition: aDefinition	stream nextPutAll: 'D'; tab; nextPutAll: aDefinition summary; cr! !!MCPatchMessage methodsFor: 'accessing' stamp: 'bf 9/4/2010 16:29'!message	^stream contents! !!MCPatchMessage methodsFor: 'accessing' stamp: 'bf 9/4/2010 17:44'!patch: aPatch	stream ifNil: [stream := WriteStream on: (String new: 100)].	aPatch operations asSortedCollection		do: [:op | op applyTo: self]! !!MCPatchOperation methodsFor: 'accessing' stamp: 'ul 11/6/2010 05:55'!sourceText	^(self isClassPatch		ifFalse: [ TextDiffBuilder ]		ifTrue: [ ClassDiffBuilder ])			buildDisplayPatchFrom: self fromSource			to: self toSource			inClass: self targetClass			prettyDiffs: (				Preferences diffsWithPrettyPrint and: [					self targetClass notNil and: [					self isClassPatch not ] ])! !!MCPatchOperation methodsFor: 'as yet unclassified' stamp: 'bf 6/13/2011 16:24'!isUnchangedMethod	"true if this is a modification of a method where only the timestamp changed"	^false! !!MCPatchTest methodsFor: 'as yet unclassified' stamp: 'ul 4/26/2011 05:28'!tearDown	super tearDown.	self restoreMocks! !!MCReader class methodsFor: 'testing' stamp: 'ul 3/22/2011 22:34'!concreteSubclassesDo: aBlock	self allSubclassesDo: [ :each |		each isAbstract ifFalse: [ aBlock value: each ] ]! !!MCReader class methodsFor: 'testing' stamp: 'ul 3/22/2011 21:23'!readerClassForFileNamed: fileName		self concreteSubclassesDo: [ :each |		(each canReadFileNamed: fileName) ifTrue: [ ^each ] ].	^nil! !!MCRepository methodsFor: 'testing' stamp: 'ab 8/21/2003 12:36'!= other	^ other species = self species and: [other description = self description]! !!MCRepository methodsFor: 'testing' stamp: 'ab 8/21/2003 12:36'!hash	^ self description hash! !!MCRepository methodsFor: 'versions' stamp: 'cmm 3/12/2011 11:41'!allVersionsDo: aBlock	self allPackageNames asArray sort		do:			[ : eachPackageName | | sortedVersions |			sortedVersions := (self versionNamesForPackageNamed: eachPackageName) sort:				[ : a : b | a versionNumber < b versionNumber ].			sortedVersions				do:					[ : eachVersionName | (self versionNamed: eachVersionName) ifNotNil:						[ : ver | aBlock value: ver ] ]				displayingProgress:					[ : eachVersionName | 'Importing ' , eachVersionName ] ]		displayingProgress:			[ : eachPackageName | 'Importing versions of ' , eachPackageName ]! !!MCRepository methodsFor: 'versions' stamp: 'cmm 8/15/2011 17:26'!copyAllFrom: aMCRepository 	"Copy all MCVersions from aMCRepository to the receiver."	self cacheAllFileNamesDuring:		[ aMCRepository cacheAllFileNamesDuring:			[ | pkgCount |			pkgCount := 0.			'Copy all package versions from ' , aMCRepository description				displayProgressFrom: 0				to: aMCRepository allPackageNames size				during:					[ : pkgBar | aMCRepository allPackageNames asArray sort do:						[ : eachPackageName | | versions verCount |						verCount := 0.						versions := (aMCRepository versionNamesForPackageNamed: eachPackageName) difference: (self versionNamesForPackageNamed: eachPackageName).						'Progress for ' , eachPackageName							displayProgressFrom: 0							to: versions size							during:								[ : verBar | versions do:									[ : eachVersionName | (aMCRepository versionNamed: eachVersionName) ifNotNil:										[ : ver | self storeVersion: ver ].									verBar value: (verCount := verCount + 1) ].								pkgBar value: (pkgCount := pkgCount + 1) ] ] ] ] ]! !!MCRepository methodsFor: 'versions' stamp: 'cmm 8/13/2011 19:18'!copyImageVersions	"For each package contained in the receiver, copy the version of that package which is currently loaded in this image.  If no version of a package is loaded in the image, nothing is copied for that package."	self cacheAllFileNamesDuring:		[ self allPackageNames do:			[ : eachPkgName | MCWorkingCopy allManagers				detect: [ : each | each packageName = eachPkgName ]				ifFound:					[ : loaded | loaded ancestors do:						[ : infoToCopy | (self includesVersionNamed: infoToCopy versionName) ifFalse:							[ (MCRepositoryGroup default versionWithInfo: infoToCopy)								ifNil: [ Warning signal: infoToCopy name , ' not found in RepositoryGroup default.' ]								ifNotNilDo:									[ : ver | self storeVersion: ver ] ] ] ]				ifNone: [ "Image specifies no version to copy." ] ] ]! !!MCRepository methodsFor: 'versions' stamp: 'cmm 3/3/2011 14:46'!highestNumberedVersionNameForPackageNamed: aString 	^ (self versionNamesForPackageNamed: aString)		ifNil: [ self error: aString , ' not found in ' , self asString ]		ifNotNilDo:			[ : pkg | pkg detectMax:				[ : each | each versionNumber ] ]! !!MCRepository methodsFor: 'versions' stamp: 'ab 8/21/2003 12:40'!includesVersionNamed: aString	self subclassResponsibility! !!MCRepository methodsFor: 'versions' stamp: 'cmm 4/19/2011 21:11'!missingAncestryDo: oneArgBlock 	"Value oneArgBlock with each of the MCVersionInfo ancestry that is missing from this repository."	self cacheAllFileNamesDuring:		[ self allPackageNames do:			[ : each | self				missingAncestryForPackageNamed: each				do: oneArgBlock ] ]! !!MCRepository methodsFor: 'versions' stamp: 'cmm 4/19/2011 21:23'!missingAncestryForPackageNamed: packageName do: oneArgBlock 	| start |	self cacheAllFileNamesDuring:		[ start := self versionNamed: (self highestNumberedVersionNameForPackageNamed: packageName).		self cacheAllFileNamesDuring:			[ start info allAncestorsDo:				[ : each | (self includesVersionNamed: each versionName) ifFalse: [ oneArgBlock value: each ] ] ] ]! !!MCRepository methodsFor: 'versions' stamp: 'cmm 4/19/2011 21:42'!obtainMissingAncestryFrom: sourceRepository 	self cacheAllFileNamesDuring:		[ self missingAncestryDo:			[ : each | (sourceRepository includesVersionNamed: each versionName)				ifTrue: [ self storeVersion: (sourceRepository versionNamed: each versionName) ]				ifFalse: [ Notification signal: each versionName , ' not present in ' , sourceRepository asString ] ] ]! !!MCRepository methodsFor: 'versions' stamp: 'ul 5/8/2011 15:13'!possiblyNewerVersionsOfAnyOf: versionNames 	"Answer a collection of MCVersionNames which might be newer versions of the versions identified by versionNames."	^self cacheAllFileNamesDuring: [		versionNames		inject: OrderedCollection new		into:			[ : coll : eachVersionName | | eachPackageName |			eachPackageName := eachVersionName packageName.			(self versionNamesForPackageNamed: eachPackageName) do:				[ : eachInSelf | (eachInSelf versionNumber > eachVersionName versionNumber or:					[ eachInSelf versionNumber = eachVersionName versionNumber and: [ eachInSelf author ~= eachVersionName author ] ]) ifTrue: [ coll add: eachInSelf ] ].			coll ] ]! !!MCRepository methodsFor: 'versions' stamp: 'cmm 3/6/2011 16:29'!versionNamed: aMCVersionName	"Answer the MCVersion with name, aMCVersionName, or nil if it doesn't exist in this repository."	self subclassResponsibility! !!MCRepository methodsFor: 'versions' stamp: 'cmm 3/3/2011 14:45'!versionNamesForPackageNamed: aString	"Answer a collection of MCVersionNames whose Package is named aString."	self subclassResponsibility! !!MCRepository methodsFor: 'versions' stamp: 'avi 10/9/2003 12:42'!versionWithInfo: aVersionInfo	^ self versionWithInfo: aVersionInfo ifAbsent: [nil]! !!MCRepository methodsFor: 'versions' stamp: 'ab 8/16/2003 18:22'!versionWithInfo: aVersionInfo ifAbsent: aBlock	self subclassResponsibility ! !!MCRepository methodsFor: 'packages' stamp: 'cmm 3/2/2011 22:32'!allPackageNames	self subclassResponsibility! !!MCRepository methodsFor: 'accessing' stamp: 'avi 8/31/2004 01:08'!alwaysStoreDiffs	^ storeDiffs ifNil: [false]! !!MCRepository methodsFor: 'accessing' stamp: 'bkv 2/18/2004 20:48'!asCreationTemplate	^ self creationTemplate! !!MCRepository methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:10'!closestAncestorVersionFor: anAncestry ifNone: errorBlock	anAncestry breadthFirstAncestorsDo:		[:ancestorInfo |		(self versionWithInfo: ancestorInfo) ifNotNil: [:v | ^ v]].	^ errorBlock value! !!MCRepository methodsFor: 'accessing' stamp: 'bkv 2/18/2004 20:46'!creationTemplate	^ creationTemplate! !!MCRepository methodsFor: 'accessing' stamp: 'cmm 4/22/2011 15:52'!creationTemplate: aString 	creationTemplate := aString! !!MCRepository methodsFor: 'accessing' stamp: 'avi 10/9/2003 12:53'!description	^ self class name! !!MCRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!doAlwaysStoreDiffs	storeDiffs := true! !!MCRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!doNotAlwaysStoreDiffs	storeDiffs := false! !!MCRepository methodsFor: 'accessing' stamp: 'avi 8/26/2004 14:27'!notificationForVersion: aVersion	^ MCVersionNotification version: aVersion repository: self! !!MCRepository methodsFor: 'accessing' stamp: 'avi 8/26/2004 14:23'!notifyList	^ #()! !!MCRepository methodsFor: 'accessing' stamp: 'avi 8/31/2004 01:06'!prepareVersionForStorage: aVersion	^ self alwaysStoreDiffs		ifTrue: [aVersion asDiffAgainst:				 (self closestAncestorVersionFor: aVersion info ifNone: [^ aVersion])]		ifFalse: [aVersion]! !!MCRepository methodsFor: 'accessing' stamp: 'cmm 3/4/2011 14:47'!refresh	"Subclasses override if necessary."! !!MCRepository methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!sendNotificationsForVersion: aVersion	| notification notifyList |	notifyList := self notifyList.	notifyList isEmpty ifFalse:		[notification := self notificationForVersion: aVersion.		notifyList do: [:ea | notification notify: ea]]! !!MCRepository methodsFor: 'accessing' stamp: 'cmm 4/22/2011 16:34'!storeVersion: aMCVersionOrConfiguration	self basicStoreVersion: (self prepareVersionForStorage: aMCVersionOrConfiguration).	self sendNotificationsForVersion: aMCVersionOrConfiguration! !!MCRepository methodsFor: 'private' stamp: 'avi 8/26/2004 14:20'!basicStoreVersion: aVersion	self subclassResponsibility! !!MCRepository methodsFor: 'private' stamp: 'cmm 3/6/2011 20:15'!cacheAllFileNamesDuring: aBlock	"FileBasedRepository's can only access all version-names, therefore this is provided to allow client-code to direct caching of getting all filenames.  Other types of repositories offer more sophisticated kinds of access, so they don't need to cache, so simply run the block."	^ aBlock value! !!MCRepository methodsFor: 'ui' stamp: 'lr 9/26/2003 20:03'!morphicOpen	self morphicOpen: nil! !!MCRepository methodsFor: 'ui' stamp: 'avi 2/28/2004 20:10'!morphicOpen: aWorkingCopy	(MCRepositoryInspector repository: self workingCopy: aWorkingCopy) show! !!MCRepository methodsFor: 'ui' stamp: 'bf 4/14/2005 17:30'!openAndEditTemplateCopy	^ self class fillInTheBlankConfigure: (self asCreationTemplate ifNil: [^nil])! !!MCRepository methodsFor: 'ui' stamp: 'cmm 4/25/2011 08:07'!wasRemoved	"Subclasses may override to, for example, disconnect a db session."! !!MCRepository methodsFor: 'printing' stamp: 'mas 9/24/2003 04:21'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self description;		nextPut: $).! !!MCRepository class methodsFor: 'instance creation' stamp: 'ar 12/16/2010 09:41'!location: urlOrPath	"Answer an MCRepository for the given url or path. Accepted locations are:		- http, and ftp urls (i.e., http://source.squeak.org/trunk)		- directory paths (i.e., C:\Squeak\packages)		- directory matches (i.e., C:\Squeak\packages\*)	"	^self location: urlOrPath username: '' password: ''! !!MCRepository class methodsFor: 'instance creation' stamp: 'cmm 4/22/2011 16:54'!location: urlOrPath username: user password: pass	"Answer an MCRepository for the given url or path. Accepted locations are:		- http, and ftp urls (i.e., http://source.squeak.org/trunk)		- directory paths (i.e., C:\Squeak\packages)		- directory matches (i.e., C:\Squeak\packages\*)	If provided, the supplied user name and password will be used."	| url |	(urlOrPath findString: '://') > 0 ifTrue:[		url := urlOrPath asUrl.		url scheme caseOf: {			['ftp'] -> [^MCFtpRepository 							host: url authority							 directory: url pathString allButFirst							user: user 							password: user].			['http'] -> [^MCHttpRepository 							location: urlOrPath 							user: user 							password: pass].		} otherwise:[^self error: 'Unsupported scheme: ', url scheme].	].	(urlOrPath endsWith: '*') ifTrue:[		^MCSubDirectoryRepository new 				directory: (FileDirectory on: urlOrPath allButLast)].	^MCDirectoryRepository			directory: (FileDirectory on: urlOrPath)! !!MCRepository class methodsFor: 'configuring' stamp: 'ab 8/21/2003 00:30'!allConcreteSubclasses	^ self withAllSubclasses reject: [:ea | ea isAbstract]! !!MCRepository class methodsFor: 'configuring' stamp: 'bkv 2/18/2004 20:59'!creationTemplate	self subclassResponsibility.! !!MCRepository class methodsFor: 'configuring' stamp: 'ab 8/21/2003 00:29'!description	^ nil! !!MCRepository class methodsFor: 'configuring' stamp: 'bkv 2/18/2004 21:05'!fillInTheBlankConfigure	^ self fillInTheBlankConfigure: self creationTemplate			! !!MCRepository class methodsFor: 'configuring' stamp: 'stephaneducasse 2/4/2006 20:47'!fillInTheBlankConfigure: aTemplateString	| chunk repo |		aTemplateString ifNil: [ ^ false ].	chunk := FillInTheBlankMorph 			request: self fillInTheBlankRequest			initialAnswer: aTemplateString			centerAt: Sensor cursorPoint			inWorld: World			onCancelReturn: nil			acceptOnCR: false			answerExtent: 400@120.				chunk 		ifNotNil: [ 			repo := self readFrom: chunk readStream.			repo creationTemplate: chunk. 	].	^ repo! !!MCRepository class methodsFor: 'configuring' stamp: 'bkv 2/18/2004 20:58'!fillInTheBlankRequest	self subclassResponsibility.! !!MCRepository class methodsFor: 'configuring' stamp: 'ab 8/21/2003 12:59'!isAbstract	^ self description isNil! !!MCRepository class methodsFor: 'configuring' stamp: 'ab 7/24/2003 21:01'!morphicConfigure	^ self new! !!MCRepository class methodsFor: '*monticelloconfigurations' stamp: 'cmm 4/22/2011 16:52'!supportsConfigurations	^ false! !!MCRepositoryGroup methodsFor: 'add / remove' stamp: 'avi 1/27/2004 00:29'!addRepository: aRepository	((repositories includes: aRepository) or: [aRepository == MCCacheRepository default])		ifFalse: [repositories add: aRepository.				self class default addRepository: aRepository].	self changed: #repositories! !!MCRepositoryGroup methodsFor: 'add / remove' stamp: 'cmm 4/25/2011 08:13'!removeRepository: aRepository	| removed |	removed := repositories remove: aRepository ifAbsent: [].	removed ifNotNil: [ removed wasRemoved ].	self changed: #repositories! !!MCRepositoryGroup methodsFor: 'testing' stamp: 'avi 11/7/2003 00:20'!includes: aRepository	^ self repositories includes: aRepository! !!MCRepositoryGroup methodsFor: 'testing' stamp: 'cmm 3/5/2011 18:33'!includesVersionNamed: aString 	| versionName |	versionName := aString asMCVersionName.	self repositoriesDo:		[ : ea | (ea includesVersionNamed: versionName) ifTrue: [ ^ true ] ].	^ false! !!MCRepositoryGroup methodsFor: 'initialize-release' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	repositories := OrderedCollection new! !!MCRepositoryGroup methodsFor: 'accessing' stamp: 'nk 11/2/2003 10:57'!repositories	^ ((Array with: MCCacheRepository default), repositories) select: [ :ea | ea isValid ]! !!MCRepositoryGroup methodsFor: 'accessing' stamp: 'avi 11/7/2003 00:51'!repositoriesDo: aBlock	self repositories do: [:ea | [aBlock value: ea] on: Error do: []]! !!MCRepositoryGroup methodsFor: 'accessing' stamp: 'klc 5/25/2008 20:20'!versionWithInfo: aVersionInfo	^self versionWithInfo: aVersionInfo ifNone: [ nil ]! !!MCRepositoryGroup methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:10'!versionWithInfo: aVersionInfo ifNone: aBlock	self repositoriesDo: [:ea | (ea versionWithInfo: aVersionInfo) ifNotNil: [:v | ^ v]].	^aBlock value! !!MCRepositoryGroup class methodsFor: 'as yet unclassified' stamp: 'cmm 3/15/2011 13:27'!flushAllCaches	self default repositoriesDo:		[ : each | each flushCache ]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 11/10/2003 22:37'!defaultExtent	^450@300! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 20:06'!defaultLabel	^'Repository: ' , repository description! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'avi 9/17/2005 17:21'!hasVersion	^ selectedVersion notNil! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'bf 4/20/2011 14:47'!identifyLoadedAndInherited: aMCWorkingCopy 	| seen |	seen := Set new.	aMCWorkingCopy ancestors do:		[ : ancestor | loaded add: ancestor versionName.		seen add: ancestor.		ancestor ancestorsDoWhileTrue:			[ : heir | (seen includes: heir)				ifTrue: [ false ]				ifFalse:					[ inherited add: heir versionName.					seen add: heir.					true ] ] ]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'stephaneducasse 2/4/2006 20:47'!order: anInteger	self class order: (order := anInteger).	self changed: #versionList.! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 2/28/2011 16:10'!orderSpecs	^{		'unchanged' -> nil.		'order by package' -> [ :x :y | x packageName < y packageName ].		'order by author' -> [ :x :y | x author < y author ].		'order by version-string' -> [ :x :y | x versionNumber asString < y versionNumber asString ].		'order by version-number' -> [ :x :y | x versionNumber > y versionNumber ].		'order by filename' -> [ :x :y | x fileName < y fileName ].	}! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 21:07'!orderString: anIndex	^String streamContents: [ :stream |		order = anIndex			ifTrue: [ stream nextPutAll: '<yes>' ]			ifFalse: [ stream nextPutAll: '<no>' ].		stream nextPutAll: (self orderSpecs at: anIndex) key ]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 3/15/2011 13:47'!packageHighlight: aString 	^ (loaded anySatisfy:		[ : each | each packageName = aString ])		ifTrue:			[ Text				string: aString				attribute:					(TextEmphasis new emphasisCode:						((newer includes: aString)							ifTrue: [ 5 ]							ifFalse: [ 4 ])) ]		ifFalse: [ aString ]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 3/23/2011 16:32'!packageList	| result loadedPackages |	packageNames ifNotNil: [ ^ packageNames ].	repository cacheAllFileNamesDuring: 		[ "Enjoy emphasis side-effects of populating my versionNames." 		self versionNames.		result := repository allPackageNames ].	"sort loaded packages first, then alphabetically"	loadedPackages := Set new: loaded size.	loaded do:		[ : each | loadedPackages add: each packageName ].	result := result asArray sort:		[ : a : b | | loadedA loadedB |		loadedA := loadedPackages includes: a.		loadedB := loadedPackages includes: b.		loadedA = loadedB			ifTrue: [ a < b ]			ifFalse: [ loadedA ] ].	^ packageNames := result collect:		[ : each | self packageHighlight: each ]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 17:25'!packageListMenu: aMenu	^aMenu! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 20:17'!packageSelection	^self packageList indexOf: selectedPackage! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 11/27/2011 17:30'!packageSelection: aNumber	selectedPackage := (aNumber between: 1 and: self packageList size)		ifTrue: [ (self packageList at: aNumber) asString ].	self versionSelection: 0.	versionNames := nil.	self changed: #packageSelection; changed: #versionList! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 3/15/2011 13:55'!refreshEmphasis	| identifyNewer |	identifyNewer := newer isNil.	identifyNewer ifTrue: [ newer := Set new ].	self initializeEmphasis.	MCWorkingCopy allManagers do:		[ : each | self identifyLoadedAndInherited: each.		identifyNewer ifTrue: [ self identifyNewerVersionsOf: each ] ]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 2/14/2010 10:10'!representsSameBrowseeAs: anotherModel 	^ self class = anotherModel class	and: [ self repository = anotherModel repository ]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 3/6/2011 16:17'!version	^ version ifNil:		[Cursor wait showWhile:			[version := repository versionNamed: selectedVersion].		version]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 3/4/2011 15:39'!versionHighlight: aMCVersionName	inherited ifNil: [inherited := #()].	^Text		string: aMCVersionName		attribute: (TextEmphasis new emphasisCode: (			((loaded includes: aMCVersionName) ifTrue: [ 4 "underlined" ]				ifFalse: [ (inherited includes: aMCVersionName)					ifTrue: [ 0 ]					ifFalse: [ 1 "bold" ] ])))! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 3/4/2011 16:19'!versionList	| result |	result := selectedPackage		ifNil: [ self versionNamesForNoPackageSelection ]		ifNotNil: [ self versionNamesForSelectedPackage ].	"Not sure why we need this ugly Error trapping here.."	(self orderSpecs at: order) value ifNotNil:		[ : sortBlock | result sort:			[ : a : b | [ sortBlock				value: a				value: b ]				on: Error				do: [ true ] ] ].	^ result collect:		[ : each | self versionHighlight: each ]! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 21:07'!versionListMenu: aMenu	1 to: self orderSpecs size do: [ :index |		aMenu addUpdating: #orderString: target: self selector: #order: argumentList: { index } ].	^aMenu! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 3/4/2011 16:06'!versionNamesForSelectedPackage	^ self versionNames! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 20:18'!versionSelection	^self versionList indexOf: selectedVersion! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'cmm 3/6/2011 15:21'!versionSelection: aNumber 	selectedVersion := version := nil.	aNumber isZero ifFalse: [ selectedVersion := (self versionList at: aNumber) asString ].	self		 changed: #versionSelection ;		 changed: #summary ;		 changed: #hasVersion! !!MCRepositoryInspector methodsFor: 'morphic ui' stamp: 'lr 9/26/2003 20:26'!widgetSpecs	^#(	((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph: package) (0 0 0.5 0.6) (0 30 0 0))		((listMorph: version) (0.5 0 1 0.6) (0 30 0 0))		((textMorph: summary) (0 0.6 1 1) (0 0 0 0)) )! !!MCRepositoryInspector methodsFor: 'initialize-release' stamp: 'cmm 3/4/2011 14:44'!identifyNewerVersionsOf: aMCWorkingCopy 	(repository possiblyNewerVersionsOfAnyOf: aMCWorkingCopy ancestry names) do:		[ : eachNewerVersionName | newer add: eachNewerVersionName packageName ]! !!MCRepositoryInspector methodsFor: 'initialize-release' stamp: 'cmm 3/2/2011 23:05'!initialize	super initialize.	self initializeEmphasis! !!MCRepositoryInspector methodsFor: 'initialize-release' stamp: 'cmm 3/15/2011 13:25'!initializeEmphasis	inherited := Set new.	loaded := Set new! !!MCRepositoryInspector methodsFor: 'initialize-release' stamp: 'cmm 3/4/2011 16:26'!initializeVersionNames	repository cacheAllFileNamesDuring:		[ versionNames := repository versionNamesForPackageNamed: selectedPackage.		self refreshEmphasis ]! !!MCRepositoryInspector methodsFor: 'initialize-release' stamp: 'cmm 2/14/2010 20:26'!postAcceptBrowseFor: aModel	"Make the same selections as in aModel."	self 		packageSelection: aModel packageSelection ;		versionSelection: aModel versionSelection! !!MCRepositoryInspector methodsFor: 'initialize-release' stamp: 'cmm 3/7/2011 21:43'!setRepository: aFileBasedRepository workingCopy: aWorkingCopy 	order := self class order.	repository := aFileBasedRepository.	self refresh.	aWorkingCopy		ifNil: [ self packageSelection: 1 ]		ifNotNil:			[ selectedPackage := aWorkingCopy ancestry ancestors ifNotEmpty:				[ : ancestors | ancestors anyOne name asMCVersionName packageName ] ].	MCWorkingCopy addDependent: self! !!MCRepositoryInspector methodsFor: 'actions' stamp: 'avi 9/18/2005 10:54'!load	self hasVersion ifTrue:		[self version isCacheable			ifTrue: [version workingCopy repositoryGroup addRepository: repository].		super load.		self refresh].! !!MCRepositoryInspector methodsFor: 'actions' stamp: 'bf 11/16/2004 11:56'!merge	super merge.	self refresh.! !!MCRepositoryInspector methodsFor: 'actions' stamp: 'cmm 3/15/2011 13:47'!refresh	packageNames := versionNames := newer := nil.	repository refresh.	self		 changed: #packageList ;		 changed: #versionList.! !!MCRepositoryInspector methodsFor: 'access' stamp: 'cmm 2/14/2010 09:54'!repository	^ repository! !!MCRepositoryInspector methodsFor: 'access' stamp: 'cmm 3/4/2011 16:27'!versionNames	^ versionNames ifNil:		[ self initializeVersionNames.		versionNames ]! !!MCRepositoryInspector methodsFor: 'access' stamp: 'cmm 3/4/2011 16:04'!versionNamesForNoPackageSelection	^ Array empty! !!MCRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!order	Order isNil		ifTrue: [ Order := 5 ].	^Order! !!MCRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!order: anInteger	Order := anInteger! !!MCRepositoryInspector class methodsFor: 'as yet unclassified' stamp: 'lr 9/26/2003 20:09'!repository: aFileBasedRepository workingCopy: aWorkingCopy	^self new		setRepository: aFileBasedRepository workingCopy: aWorkingCopy;		yourself! !!MCRepositoryInspector class methodsFor: 'class initialization' stamp: 'bf 3/16/2005 14:41'!initialize	"self initialize"	self migrateInstances! !!MCRepositoryInspector class methodsFor: 'class initialization' stamp: 'bf 3/16/2005 14:53'!migrateInstances	self allSubInstancesDo: [:inst |		#(packageList versionList) do: [:each |			[(inst findListMorph: each) highlightSelector: nil]				on: Error do: [:ignore | ]]].! !!MCRepositoryTest methodsFor: 'tests' stamp: 'ul 3/24/2011 08:51'!testCreationMethods	"Tests creation via MCRepository>>location:"	| repo |	repo := MCRepository location: FileDirectory default pathName.	self assert: (repo isKindOf: MCDirectoryRepository).	self assert: (repo description = FileDirectory default pathName).	repo := MCRepository location: (FileDirectory default pathName, FileDirectory slash, '*').	self assert: (repo isKindOf: MCSubDirectoryRepository).	"XXXX: MCSubDirectoryRepo prints wrongly on Windows"	self assert: (repo description = (FileDirectory default pathName, FileDirectory slash, '*')).	repo := MCRepository location: 'http://source.squeak.org/trunk'.	self assert: (repo isKindOf: MCHttpRepository).	self assert: (repo description = 'http://source.squeak.org/trunk').	repo := MCRepository 		location: 'ftp://source.squeak.org/trunk' 		username: 'foo' 		password: 'bar'.	self assert: (repo isKindOf: MCFtpRepository).	self assert: (repo description = 'ftp://foo@source.squeak.org/trunk').! !!MCSMReleaseRepository methodsFor: 'as yet unclassified' stamp: 'cmm 3/5/2011 15:19'!releaseVersion: aVersion url: urlString	| result |	result := HTTPSocket		httpPost: self squeakMapUrl, '/packagebyname/', packageName, '/newrelease'		args: {'version' -> {(aVersion info versionNumber)}.			   'note' -> {aVersion info message}.			   'downloadURL' -> {urlString}}		user: user		passwd: password.	result contents size > 4 ifTrue: [self error: result contents]! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'hmm 4/16/2010 22:07'!allClassNames	^ (items 		select: [:ea | (ea isOrganizationDefinition | ea isScriptDefinition) not] 		thenCollect: [:ea | ea className]) asSet.! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'bf 7/11/2011 12:27'!packageOrganizations	^ items select: [:ea | ea isOrganizationDefinition]! !!MCSnapshotBrowser methodsFor: 'listing' stamp: 'bf 7/11/2011 12:35'!visibleCategories	^ ((self packageOrganizations gather: [:ea | ea categories]),		(self packageClasses collect: [:ea | ea category]))			asSet asSortedCollection add: self extensionsCategory; yourself.! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'nice 5/8/2011 10:41'!assertAListIncludes: anArrayOfStrings	self assert: (self listMorphs 			anySatisfy: [:m | m getList includesAllOf: anArrayOfStrings]).! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'nice 5/8/2011 10:42'!assertAListMatches: strings	| listMorphs |	listMorphs := self listMorphs.	self assert: (listMorphs 		anySatisfy: [:m | | list |			list := m getList. (list size = strings size) and: [list includesAllOf: strings]])! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'nice 5/8/2011 10:42'!assertButtonExists: aString	self assert: (self buttonMorphs anySatisfy: [:m | m label = aString])! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'nice 5/8/2011 10:40'!denyAListHasSelection: aString	self deny: (self listMorphs 			anySatisfy: [:m | m selection = aString])! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'nice 5/8/2011 10:41'!denyAListIncludesAnyOf: anArrayOfStrings	self deny: (self listMorphs 			anySatisfy: [:m | m getList includesAnyOf: anArrayOfStrings])! !!MCSnapshotTest methodsFor: '*Tests-Monticello-Mocks' stamp: 'ab 7/7/2003 23:21'!mockClassExtension! !!MCStWriterTest methodsFor: 'asserting' stamp: 'nice 2/23/2011 21:51'!assertChunkIsWellFormed: chunk	self class newParser		parse: chunk readStream 		class: UndefinedObject 		noPattern: true		context: nil		notifying: nil		ifFail: [self assert: false]! !!MCStWriterTest methodsFor: 'asserting' stamp: 'nice 2/23/2011 21:51'!assertMethodChunkIsWellFormed: chunk	self class newParser		parse: chunk readStream 		class: UndefinedObject 		noPattern: false		context: nil		notifying: nil		ifFail: [self assert: false]! !!MCSubDirectoryRepository methodsFor: 'enumeration' stamp: 'nsh 11/20/2011 00:52'!allFileNames	"sorting {entry. dirName. name}"	| sorted |	sorted := SortedCollection sortBlock: [:a :b |		a first modificationTime >= b first modificationTime ].	self allDirectories		do: [:dir | dir entries				do: [:ent | ent isDirectory						ifFalse: [sorted add: {ent. dir fullName. ent name}]]].	^ sorted		collect: [:ea | ea third asMCVersionName]! !!MCSubDirectoryRepository methodsFor: 'user interface' stamp: 'ul 3/23/2011 07:21'!description	^ directory pathName, FileDirectory slash, '*'! !!MCTestCase methodsFor: 'running' stamp: 'ul 4/26/2011 05:26'!clearPackageCache	"Remove all mock packages created during the tests from the package cache."	| directory |	directory := MCCacheRepository default directory.	(directory fileNamesMatching: self mockVersionName, '*') do: [ :each |		directory deleteFileNamed: each ]! !!MCTestCase methodsFor: 'running' stamp: 'ul 4/26/2011 05:25'!tearDown	self clearPackageCache! !!MCTool methodsFor: 'morphic ui' stamp: 'nice 9/22/2010 00:34'!buildWindow	| window |	Smalltalk at: #ToolBuilder ifPresent: [:tb | ^tb build: self].	window := SystemWindow labelled: self label.	window model: self.	self widgetSpecs do: [:spec |		| send fractions offsets |		send := spec first.		fractions := spec at: 2 ifAbsent: [#(0 0 1 1)].		offsets := spec at: 3 ifAbsent: [#(0 0 0 0)].		window			addMorph: (self perform: send first withArguments: send allButFirst)			fullFrame:				(LayoutFrame					fractions: 						((fractions first)@(fractions second) corner: 							(fractions third)@(fractions fourth))					offsets:						((offsets first)@(offsets second)  corner:							(offsets third)@(offsets fourth)))].	^ window! !!MCTool methodsFor: 'morphic ui' stamp: 'nice 9/22/2010 02:03'!defaultAnnotationPaneHeight 	"Answer the receiver's preferred default height for new annotation panes.	Since MC compares two annotations, reserve a bit less than a double the traditional height."	^ (Preferences parameterAt: #defaultAnnotationPaneHeight ifAbsentPut: [25]) * 5 // 3! !!MCTool methodsFor: 'morphic ui' stamp: 'bf 9/27/2011 14:54'!fillMenu: aMenu fromSpecs: anArray	anArray do:		[:spec |		aMenu add: spec first target: self selector: spec second argumentList: (spec allButFirst: 2)].	^ aMenu! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 00:42'!innerButtonRow	^ self buttonRow: tool innerButtonSpecs! !!MCVersion methodsFor: 'accessing' stamp: 'cmm 3/3/2011 14:57'!fileName	^ (info name, '.', self writerClass extension) asMCVersionName! !!MCVersion methodsFor: 'initialize-release' stamp: 'cmm 2/25/2011 16:26'!initializeWithPackage: aPackage info: aVersionInfo snapshot: aSnapshot dependencies: aCollection 	self		setPackage: aPackage		info: aVersionInfo		snapshot: aSnapshot		dependencies: aCollection.	self addToCache! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'bf 9/27/2011 15:05'!getMenu: aMenu	index < 1 ifTrue: [^ aMenu].	self fillMenu: aMenu fromSpecs: 		{{'view changes to ', ancestry name . #viewChanges}},		(self selectedInfo ancestors collect: [:parent |			{'view changes from ', parent name . #viewChanges: . parent}]),		#(('spawn history' spawnHistory)).	^ aMenu! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'bf 9/27/2011 15:00'!viewChanges	self viewChanges: ancestry snapshot: self baseSnapshot		relativeTo: self selectedInfo snapshot: self selectedSnapshot! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'bf 9/27/2011 15:00'!viewChanges: otherInfo	self viewChanges: self selectedInfo snapshot: self selectedSnapshot		relativeTo:  otherInfo snapshot: (self snapshotForInfo: otherInfo)! !!MCVersionHistoryBrowser methodsFor: 'morphic ui' stamp: 'bf 9/27/2011 14:59'!viewChanges: ancestorInfo snapshot: ancestorSnapshot relativeTo: baseInfo snapshot: baseSnapshot	"Note that the patchLabel will be parsed in MCPatchBrowser>>installSelection, so don't translate it!!"	| patch patchLabel |	patchLabel := 'changes between {1} and {2}' format: { baseInfo name. ancestorInfo name }.	patch := ancestorSnapshot patchRelativeToBase: baseSnapshot.	(MCPatchBrowser forPatch: patch) label: patchLabel; show! !!MCVersionInfo methodsFor: 'accessing' stamp: 'cmm 3/12/2011 17:10'!dateAndTime	^ DateAndTime		date: date		time: (time ifNil: [ Time midnight ])! !!MCVersionInfo methodsFor: 'accessing' stamp: 'bp 11/21/2010 19:27'!nameWithout: packageName	| result |	result := self name.	(result beginsWith: packageName , '-') ifTrue: [		result := result copyFrom: packageName size + 2 to: result size].	^result! !!MCVersionInfo methodsFor: 'accessing' stamp: 'cmm 3/3/2011 14:34'!versionName	^ name		ifNil: [ self name ]		ifNotNil: [ name asMCVersionName ]! !!MCVersionInfo methodsFor: 'accessing' stamp: 'cmm 3/5/2011 15:18'!versionNumber	^ self versionName versionNumber! !!MCVersionInfo methodsFor: 'converting' stamp: 'bf 4/18/2010 23:25'!asDictionary	^ Dictionary new		at: #name put: name;		at: #id put: id asString;		at: #message put: message;		at: #date put: date;		at: #time put: time;		at: #author put: author;		at: #ancestors put: (self ancestors collect: [:a | a asDictionary]);		yourself! !!MCVersionInfo methodsFor: 'initialize-release' stamp: 'cmm 3/7/2011 14:22'!initializeWithName: vName id: aUUID message: aString date: aDate time: aTime author: initials ancestors: aCollection stepChildren: stepCollection	name := vName asString asMCVersionName.	id := aUUID.	message := aString.	date := aDate.	time := aTime.	author := initials.	ancestors :=  aCollection.	stepChildren := stepCollection! !!MCVersionInspector methodsFor: 'morphic ui' stamp: 'cmm 2/28/2011 17:58'!buttonSpecs       ^ #(('Refresh' refresh 'refresh the version-list')		(Browse browse 'Browse this version' hasVersion)               (History history 'Browse the history of this version' hasVersion)               (Changes changes 'Browse the changes this version would make to theimage' hasVersion)               (Load load 'Load this version into the image' hasVersion)               (Merge merge 'Merge this version into the image' hasVersion)               (Adopt adopt 'Adopt this version as an ancestor of your working copy'hasVersion)               (Copy save 'Copy this version to another repository' hasVersion)               (Diff diff 'Create an equivalent version based on an earlier release'hasVersion))! !!MCVersionInspector methodsFor: 'accessing' stamp: 'avi 2/28/2004 20:19'!adopt	(self confirm:'Modifying ancestry can be dangerous unless you knowwhat you are doing.  Are you sure you want to adopt',self version info name, ' as an ancestor of your working copy?')		ifTrue: [self version adopt]! !!MCVersionInspector methodsFor: 'accessing' stamp: 'bf 3/22/2005 22:12'!browse	self version browse! !!MCVersionInspector methodsFor: 'accessing' stamp: 'nk 4/17/2004 10:05'!changes	(MCPatchBrowser forPatch: self version changes)		showLabelled: 'Changes from ', self version info name! !!MCVersionInspector methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:09'!diff	| ancestorVersion |	self pickAncestor ifNotNil:		[:ancestor |		ancestorVersion := self version workingCopy repositoryGroup versionWithInfo: ancestor.		(self version asDiffAgainst: ancestorVersion) open]! !!MCVersionInspector methodsFor: 'accessing' stamp: 'lr 9/26/2003 20:15'!hasVersion	^version notNil! !!MCVersionInspector methodsFor: 'accessing' stamp: 'avi 9/17/2005 17:14'!history	(MCVersionHistoryBrowser new ancestry: self versionInfo) show! !!MCVersionInspector methodsFor: 'accessing' stamp: 'bf 3/14/2005 15:32'!load	Cursor wait showWhile: [self version load]! !!MCVersionInspector methodsFor: 'accessing' stamp: 'avi 2/28/2004 20:19'!merge	self version merge! !!MCVersionInspector methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:09'!save	self pickRepository ifNotNil:		[:ea |		ea storeVersion: self version]! !!MCVersionInspector methodsFor: 'accessing' stamp: 'avi 9/17/2005 17:16'!summary	^self hasVersion		ifTrue: [ self versionSummary ]		ifFalse: [ String new ]! !!MCVersionInspector methodsFor: 'accessing' stamp: 'avi 2/28/2004 20:19'!version	^ version! !!MCVersionInspector methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!version: aVersion	version := aVersion! !!MCVersionInspector methodsFor: 'accessing' stamp: 'avi 9/17/2005 17:16'!versionInfo	^ self version info! !!MCVersionInspector methodsFor: 'accessing' stamp: 'avi 9/17/2005 17:16'!versionSummary	^ self version summary! !!MCVersionName methodsFor: 'testing' stamp: 'cmm 4/24/2011 20:04'!isValid	^ [ (self endsWith: '.mcm') or:		[ self packageName notEmpty and:			[ self author notEmpty and: [ self versionNumber > 0 ] ] ] ]		on: Error		do:			[ : err | false ]! !!MCVersionName methodsFor: 'private' stamp: 'cmm 3/3/2011 14:22'!ancestry	"If I am a in the diffy-format which includes the ancestor attributes, answer them as a single String, separated by a dot."	^ (self copyAfterLast: $() copyUpTo: $)! !!MCVersionName methodsFor: 'private' stamp: 'cmm 3/4/2011 10:12'!species	^ ByteString! !!MCVersionName methodsFor: 'converting' stamp: 'cmm 3/3/2011 14:33'!asMCVersionName	^ self! !!MCVersionName methodsFor: 'comparing' stamp: 'cmm 3/12/2011 11:48'!= aByteString 	"Ignore any file-extension for comparison of MCVersionNames."	| myVersionName |	aByteString isString ifFalse: [ ^ false ].	myVersionName := self versionName.	^ (myVersionName		compare: myVersionName		with: aByteString asMCVersionName versionName		collated: AsciiOrder) = 2! !!MCVersionName methodsFor: 'comparing' stamp: 'cmm 3/4/2011 10:36'!hash	^ self versionName hash! !!MCVersionName methodsFor: 'accessing' stamp: 'ul 3/23/2011 04:55'!ancestorAuthor	"The author of the ancestor, if this is a Diffy filename."	^self ancestry copyUpTo: $.! !!MCVersionName methodsFor: 'accessing' stamp: 'ul 3/23/2011 04:55'!ancestorVersionNumber	"The author of the ancestor, if this is a Diffy filename."	^(self ancestry copyAfter: $.) asInteger ifNil: [ 0 ]! !!MCVersionName methodsFor: 'accessing' stamp: 'ul 3/23/2011 04:55'!author	"The author initials embedded in the filename."		^(self versionName copyAfterLast: $-) copyUpTo: $.! !!MCVersionName methodsFor: 'accessing' stamp: 'ul 3/23/2011 04:56'!packageName	"The MC Package name embedded into this filename."		^self versionName copyUpToLast: $-! !!MCVersionName methodsFor: 'accessing' stamp: 'cmm 4/24/2011 22:12'!versionName	"Answer my version name as a ByteString, without the file suffix or any ancestor-attributes."	| end |	self isEmpty ifTrue: [^ String empty].  	(self last between: $0 and: $9)		ifTrue: [ end := self size ]		ifFalse: [			end := (self lastIndexOf: $. ifAbsent: [ self size + 1 ]) - 1.			end := end min: (self indexOf: $( ifAbsent: [ self size + 1 ]) - 1 ].	^self first: end! !!MCVersionName methodsFor: 'accessing' stamp: 'cmm 3/4/2011 13:40'!versionNumber	"The Integer version number identified by this filename."	^ ((self versionName copyAfterLast: $-) copyAfter: $.) asInteger ifNil: [ 0 ]! !!MCVersionName commentStamp: 'cmm 3/4/2011 13:32' prior: 0!A MCVersionName models the Monticello file / version name, in the format [Package]-[Author].[version-number]([ancestorAuthor.ancestorVersionNumber]).[mc?].Any file-extension, if present, is ignored.!!MCVersionName class methodsFor: 'instance creation' stamp: 'cmm 3/3/2011 14:19'!on: aString 	"aString may be with or without a mc? extension."	^ (self new: aString size)		replaceFrom: 1			to: aString size			with: aString			startingAt: 1 ;		yourself! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:38'!defaultAction	^ MCSaveVersionDialog new		versionName: suggestion;		logMessage: initialMessage;		showModally! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:28'!initialMessage	^ initialMessage! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:28'!initialMessage: aString	initialMessage := aString! !!MCVersionNameTest methodsFor: 'as yet unclassified' stamp: 'cmm 3/4/2011 13:12'!allValidFixtures	^ self standardFixtures , self diffyFixtures! !!MCVersionNameTest methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2011 14:33'!diffyFixtures	^ #('Package-author.123(origAuthor.122)' 'Package-author.123(origAuthor.122).mcd' ) collect:		[ : each | each asMCVersionName ]! !!MCVersionNameTest methodsFor: 'as yet unclassified' stamp: 'cmm 3/4/2011 13:13'!invalidFixtures	^ {String empty. 'abc'. '123' } collect: [ : each | each asMCVersionName ]! !!MCVersionNameTest methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2011 14:33'!standardFixtures	^ #('Package-author.123' 'Package-author.123.mcz' ) collect:		[ : each | each asMCVersionName ]! !!MCVersionNameTest methodsFor: 'as yet unclassified' stamp: 'cmm 3/2/2011 15:03'!verifyAncestryAttributes: aMCFileName 	self		 assert: aMCFileName ancestorVersionNumber = 122 ;		 assert: aMCFileName ancestorAuthor = 'origAuthor'! !!MCVersionNameTest methodsFor: 'as yet unclassified' stamp: 'cmm 3/2/2011 15:11'!verifyPackageAuthorVersion: aMCFileName 	self		 assert: aMCFileName packageName = 'Package' ;		 assert: aMCFileName versionNumber = 123 ;		 assert: aMCFileName author = 'author' ;		 assert: aMCFileName isValid! !!MCVersionNameTest methodsFor: 'tests' stamp: 'cmm 3/4/2011 13:12'!testAttributeAccess	self allValidFixtures do: [ : each | self verifyPackageAuthorVersion: each ]! !!MCVersionNameTest methodsFor: 'tests' stamp: 'cmm 3/4/2011 13:07'!testDiffyNames	self diffyFixtures do: [ : each | self verifyAncestryAttributes: each ]! !!MCVersionNameTest methodsFor: 'tests' stamp: 'cmm 3/4/2011 13:12'!testEquality	| standard mc |	standard := 'Package-author.123.mcz'.	mc := standard asMCVersionName.	self		 assert: standard = mc ;		 assert: mc = standard.	self assert: self allValidFixtures asSet size = 1! !!MCVersionNameTest methodsFor: 'tests' stamp: 'cmm 3/4/2011 13:13'!testInvalid	self assert: (self invalidFixtures noneSatisfy: [ : each | each isValid ])! !!MCVersionNameTest methodsFor: 'tests' stamp: 'ul 3/28/2011 20:16'!testSpecies	self		assert: ByteString equals: 'Package-author.123.mcz' asMCVersionName versionName class;		assert: ByteString equals: 'Package-author.123' asMCVersionName versionName class! !!MCVersionNameTest methodsFor: 'tests' stamp: 'ul 3/28/2011 20:26'!testVersionNameReturnsAByteString	#(		'Package-author.123.mcz'		'Package-author.123'		'Package-author.123(122).mcd'		'Package-author.123(author2.122).mcd') do: [ :each |			self assert: ByteString equals: each asMCVersionName versionName class ]! !!MCVersionReader class methodsFor: 'file services' stamp: 'ul 3/22/2011 21:23'!initialize	"MCVersionReader initialize"	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | FileList unregisterFileReader: installer].	self concreteSubclassesDo: [:aClass | FileList registerFileReader: aClass].	"get rid of AnObsoleteMCMcReader and AnObsoleteMCMcvReader"	(FileList registeredFileReaderClasses  select: [ :ea | ea isObsolete ]) do: 		[ :ea | FileList unregisterFileReader: ea ]! !!MCVersionReader class methodsFor: 'file services' stamp: 'cmm 4/22/2011 16:54'!loadVersionFile: fileName 	| version |	version := self versionFromFile: fileName.	version workingCopy repositoryGroup addRepository: (MCDirectoryRepository path: (FileDirectory dirPathFor: fileName)).	version load! !!MCVersionReader class methodsFor: 'reading' stamp: 'ul 8/2/2011 20:03'!file: fileName streamDo: aBlock	^FileStream readOnlyFileNamed: fileName do: aBlock! !!MCVersionReader class methodsFor: '*monticello-file services' stamp: 'cmm 4/22/2011 16:55'!loadVersionStream: stream fromDirectory: directory	| version |	version := self versionFromStream: stream.	directory isRemoteDirectory ifFalse: [	version workingCopy repositoryGroup addRepository:		(MCDirectoryRepository directory: directory). ].	version load.! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'bp 11/21/2010 18:33'!description	^ self packageNameWithStar, ' (', (ancestry ancestorStringWithout: self packageName), ')'! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'bp 11/21/2010 17:12'!printOn: stream	super printOn: stream.	stream		nextPut: $(;		nextPutAll: self packageName;		nextPut: $)! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:54'!newVersion	^ (self requestVersionNameAndMessageWithSuggestion: self uniqueVersionName		initialMessage: self patchMessageSuggestion) ifNotNil:			[:pair |			self newVersionWithName: pair first				message: (self patchMessageStripped: pair last)].! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:31'!patchMessageChanges	| changes parentInfo parentSnapshot |	parentInfo := self ancestors		ifEmpty: [nil]		ifNotEmpty: [self ancestors first].	parentSnapshot := 	self findSnapshotWithVersionInfo: parentInfo.	changes := package snapshot patchRelativeToBase: parentSnapshot.	^ (MCPatchMessage new patch: changes) message! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 19:00'!patchMessageChangesDelimiter	^'=== text below is ignored ==='! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 19:04'!patchMessageChangesHeader	^ancestry summary, String cr,	'Added, Modified, Deleted',	(self ancestors ifEmpty: [''] ifNotEmpty: [' vs. ', self ancestors first name]), ':'! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:15'!patchMessageDefault	^ 'empty log message'! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:31'!patchMessageStripped: aString	| pos |	pos := aString findString: self patchMessageChangesDelimiter.	^ (pos > 0		ifTrue: [aString first: pos - 1]		ifFalse: [aString]) withBlanksTrimmed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:35'!patchMessageSuggestion	^	self patchMessageDefault, String cr, String cr,		self patchMessageChangesDelimiter, String cr,		self patchMessageChangesHeader, String cr,		self patchMessageChanges! !!MCWorkingCopy methodsFor: 'operations' stamp: 'cmm 6/8/2011 14:25'!renameToBe: newPackageName 	| newWorkingCopy definitions |	self modified ifTrue: [ self error: 'Should only rename an unmodified package.' ].	(MCWorkingCopy allManagers anySatisfy:		[ : each | each packageName = newPackageName ]) ifTrue: [ self error: newPackageName , ' is already taken.' ].	definitions := self package snapshot definitions.	PackageInfo registerPackageName: newPackageName.	newWorkingCopy := (MCWorkingCopy forPackage: (MCPackage new name: newPackageName))		 repositoryGroup: self repositoryGroup ;		 requiredPackages: self requiredPackages copy ;		 modified: true ;		 yourself.	definitions do:		[ : each | each			handlePackageRename: self package name			to: newPackageName ].	self ancestors do:		[ : each | newWorkingCopy ancestry addAncestor: each ].	newWorkingCopy package snapshot definitions size = definitions size ifTrue:		[ PackageOrganizer default unregisterPackage: (PackageInfo named: self packageName).		self unregister ].	^ newWorkingCopy! !!MCWorkingCopy methodsFor: 'operations' stamp: 'dtl 1/11/2011 23:30'!unload	MCPackageLoader unloadPackage: self package.	self unregisterSubpackages.	self unregister.! !!MCWorkingCopy methodsFor: 'repositories' stamp: 'bf 11/16/2011 19:20'!newRepositoryGroupIfDefault	repositoryGroup == MCRepositoryGroup default		ifTrue: [repositoryGroup := MCRepositoryGroup new]! !!MCWorkingCopy methodsFor: 'private' stamp: 'cmm 3/5/2011 15:19'!nextVersionName	| branch oldName |	ancestry ancestors isEmpty		ifTrue:			[ counter ifNil: [ counter := 0 ].			branch := package name ]		ifFalse:			[ oldName := ancestry ancestors first versionName.			branch := oldName packageName.			counter ifNil:				[ counter := (ancestry ancestors detectMax:					[ : eachVersionInfo | eachVersionInfo versionNumber ])					ifNil: [ 0 ]					ifNotNil:						[ : highestNumbered | highestNumbered versionNumber ] ] ].	counter := counter + 1.	^ branch , '-' , Utilities authorInitials , '.' , counter asString! !!MCWorkingCopy methodsFor: 'private' stamp: 'cmm 3/3/2011 15:24'!possiblyNewerVersionsIn: aRepository 	^ aRepository possiblyNewerVersionsOfAnyOf:		(self ancestors collect:			[ : each | each versionName ])! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/4/2010 15:29'!requestVersionNameAndMessageWithSuggestion: nameString initialMessage: msgString	^ (MCVersionNameAndMessageRequest new		suggestedName: nameString;		initialMessage: msgString		) signal! !!MCWorkingCopy methodsFor: 'private' stamp: 'cmm 6/6/2011 19:26'!requiredPackages: aCollection	requiredPackages := aCollection! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'bf 4/19/2010 00:39'!infoFromDictionary: aDictionary cache: cache	| id |	id := (aDictionary at: #id) asString.	^ cache at: id ifAbsentPut:		[MCVersionInfo			name: (aDictionary at: #name ifAbsent: [''])			id: (UUID fromString: id)			message: (aDictionary at: #message ifAbsent: [''])			date: ([Date fromString: (aDictionary at: #date)] ifError: [nil])			time: ([Time fromString: (aDictionary at: #time)] ifError: [nil])			author: (aDictionary at: #author ifAbsent: [''])			ancestors: (self ancestorsFromArray: (aDictionary at: #ancestors ifAbsent: []) cache: cache)			stepChildren: (self ancestorsFromArray: (aDictionary at: #stepChildren ifAbsent: []) cache: cache)]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'eem 7/3/2009 11:21'!initialize	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | self adoptVersionInfoFrom: installer].	self updateInstVars.	"Temporary conversion code -- remove later"	registry ifNotNil:[registry rehash]. "changed #="	self allInstancesDo:[:each| "moved notifications"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			cls uniqueInstance noMoreNotificationsFor: each.		].	].	self registerForNotifications.	Smalltalk addToStartUpList: self! !!MCWorkingCopy class methodsFor: 'system startup' stamp: 'eem 7/3/2009 11:34'!startUp: resuming	"Ensure Monticello is receiving system change notifications."	resuming ifTrue:		[Smalltalk			at: #SystemChangeNotifier			ifPresent: [:scn| self reregisterForNotificationsWith: scn uniqueInstance]]! !!MCWorkingCopy class methodsFor: 'class initialization' stamp: 'bp 1/7/2011 22:44'!cleanUp: aggressive	"Remove all PackageInfos that are not associated with an MCWorkingCopy when aggressively cleaning up"	aggressive ifTrue: [self flushObsoletePackageInfos]! !!MCWorkingCopy class methodsFor: 'cleanup' stamp: 'bp 1/7/2011 22:48'!flushObsoletePackageInfos	"Flush any and all PackageInfos that are not associated with an MCWorkingCopy."	| pkgNames |	pkgNames := self allManagers collect:[:wcs| wcs packageName] as: Set.	PackageOrganizer default flushObsoletePackages:[:p|		p class isObsolete or:[(pkgNames includes: p packageName) not].	].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 5/8/2011 19:44'!checkForNewerVersions	| newer |	newer := workingCopy possiblyNewerVersionsIn: self repository.	^ newer isEmpty or: [		self confirm: 'CAUTION!! These versions in the repository may be newer:', 			String cr, ((newer asCommaString withNoLineLongerThan:  150) truncateWithElipsisTo: 5 * 149), String cr,			'Do you really want to save this version?'].! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'cmm 8/14/2011 14:44'!copyImageVersions	self repository ifNotNil: [ : repos | repos copyImageVersions ]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'cmm 6/6/2011 16:56'!renamePackage	| newName |	workingCopy ifNil:		[ UIManager inform: 'Please select a package to be renamed.'.		^ self ].	workingCopy modified ifTrue:		[ UIManager inform: 'Only unmodified packages should be renamed.'.		^ self ].	newName := FillInTheBlankMorph		request: 'New name of package:'		initialAnswer: workingCopy packageName.	newName isEmptyOrNil ifFalse:		[ | newWorkingCopy |		newWorkingCopy := workingCopy renameToBe: newName.		workingCopy package snapshot definitions			ifEmpty:				[ "It worked."				workingCopy unregister.				workingCopy := newWorkingCopy.				self repositorySelection: 0.				self					 workingCopyListChanged ;					 changed: #workingCopySelection ;					 changed: #repositoryList.				self changedButtons ]			ifNotEmpty: 				[ "It didn't work, browse the remaining definitions."				self browseWorkingCopy ] ]! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'tfel 6/12/2010 13:47'!insertExternalMenuEntries: aMenu		self class externalMenuEntries ifNotEmpty: [		aMenu addLine.		self class externalMenuEntries do: [:each |			aMenu 				add: each entry 				target: each target				selector: each selector				argument: self]].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'cmm 8/14/2011 14:39'!repositoryListMenu: aMenu	self repository ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('open repository' #openRepository)		    ('edit repository info' #editRepository)		   ('add to package...' #addRepositoryToPackage)		   ('remove repository' #removeRepository)			   ('load repositories' #loadRepositories)			   ('save repositories' #saveRepositories)		   ('flush cached versions' #flushAllCaches)			   ('copy image versions here' #copyImageVersions)		).		aMenu		add: (self repository alwaysStoreDiffs					ifTrue: ['store full versions']					ifFalse: ['store diffs'])		target: self		selector: #toggleDiffs.	^ aMenu				! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'cmm 6/6/2011 16:59'!workingCopyListMenu: aMenu	workingCopy ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('add required package' #addRequiredPackage)			('clear required packages' #clearRequiredPackages)			('browse package' #browseWorkingCopy)			('view changes' #viewChanges)			('view history' #viewHistory)			('recompile package' #recompilePackage)			('revert package...' #revertPackage)			('unload package' #unloadPackage)			('delete working copy' #deleteWorkingCopy)			('rename package...' #renamePackage)).	(Smalltalk includesKey: #SARMCPackageDumper) ifTrue: [		aMenu add: 'make SAR' target: self selector: #fileOutAsSAR	].	self insertExternalMenuEntries: aMenu.	^aMenu! !!MCWorkingCopyBrowser class methodsFor: 'hooks' stamp: 'tfel 6/12/2010 14:55'!addMenuSpec: aMCMenuSpec	"Register a context menu entry in the monticello browser from an external package.	 The MCWorkingCopyBrowser model is passed as argument."	self externalMenuEntries 		remove: aMCMenuSpec 		ifAbsent: ["Remove any previous entry with description string"];		add: aMCMenuSpec.! !!MCWorkingCopyBrowser class methodsFor: 'hooks' stamp: 'tfel 6/12/2010 11:44'!externalMenuEntries		ExternalMenuEntries ifNil: [ExternalMenuEntries := Set new].	^ ExternalMenuEntries! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'ul 4/26/2011 05:27'!clearPackageCache	"Remove all mock packages created during the tests from the package cache."	| directory |	super clearPackageCache.	directory := MCCacheRepository default directory.	(directory fileNamesMatching: self packageName, '*') do: [ :each |		directory deleteFileNamed: each ]! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'cmm 6/8/2011 13:12'!setUp	| repos1 repos2 |	self clearPackageCache.	repositoryGroup := MCRepositoryGroup new.	workingCopy := MCWorkingCopy forPackage: self mockPackage.	versions := Dictionary new.	versions2 := Dictionary new.	repos1 := MCDictionaryRepository new dictionary: versions.	repos2 := MCDictionaryRepository new dictionary: versions2.	repositoryGroup addRepository: repos1.	repositoryGroup addRepository: repos2.	MCRepositoryGroup default removeRepository: repos1; removeRepository: repos2.	workingCopy repositoryGroup: repositoryGroup.	savedInitials := Utilities authorInitialsPerSe.	Utilities setAuthorInitials: 'abc'.! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'cmm 6/8/2011 14:33'!tearDown	super tearDown.	workingCopy unregister.	self restoreMocks.	SystemOrganizer default removeEmptyCategories.	MCSnapshotTest organization removeEmptyCategories.	Utilities setAuthorInitials: savedInitials! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'ar 5/10/2010 20:54'!testDoubleRepeatedMerge	| base motherA1 motherA2 motherB1 motherB2 inst |	<timeout: 30> "takes a little longer"	base := self snapshot.	self change: #a toReturn: 'a1'.	motherA1 :=  self snapshot.	self change: #c toReturn: 'c1'.	motherA2 :=  self snapshot.			self load: base.	self change: #b toReturn: 'b1'.	motherB1 :=  self snapshot.	self change: #d toReturn: 'd1'.	motherB2 :=  self snapshot.		self load: base.	self merge: motherA1.	self merge: motherB1.	self change: #a toReturn: 'a2'.	self change: #b toReturn: 'b2'.	self snapshot.	self shouldnt: [self merge: motherA2] raise: Error.	self shouldnt: [self merge: motherB2] raise: Error.		inst := self mockInstanceA.	self assert: inst a = 'a2'.	self assert: inst b = 'b2'.	self assert: inst c = 'c1'.	self assert: inst d = 'd1'.	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'cmm 6/8/2011 14:42'!testRenamePrefix	self verifyRenameTo: 'Renamed-' , workingCopy packageName.	SystemOrganizer default		renameCategory: 'Renamed-Tests-Monticello-Mocks'		toBe: 'Tests-Monticello-Mocks'! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'cmm 6/8/2011 13:27'!testRenameSuffix	self verifyRenameTo: workingCopy packageName, '-Renamed'! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'ar 5/10/2010 20:53'!testRepeatedMerge	| base mother1 mother2 inst |	<timeout: 30> "takes a little longer"	base :=  self snapshot.	self change: #one toReturn: 2.	mother1 :=  self snapshot.	self change: #two toReturn: 3.	mother2 :=  self snapshot.			self load: base.	self change: #truth toReturn: false.	self snapshot.	inst := self mockInstanceA.	self assert: inst one = 1.	self assert: inst two = 2.		self merge: mother1.	self assert: inst one = 2.	self assert: inst two = 2.			self change: #one toReturn: 7.	self assert: inst one = 7.	self assert: inst two = 2.		self shouldnt: [self merge: mother2] raise: Error.	self assert: inst one = 7.	self assert: inst two = 3.! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'cmm 6/8/2011 14:15'!verifyRenameTo: newName 	| oldWorkingCopy oldDefinitions newWorkingCopy |	oldWorkingCopy := workingCopy.	oldDefinitions := workingCopy package snapshot definitions.	newWorkingCopy := workingCopy renameToBe: newName.	self		 assert: oldWorkingCopy ancestors = newWorkingCopy ancestors ;		 assert: newWorkingCopy needsSaving ;		 assert: newWorkingCopy requiredPackages = oldWorkingCopy requiredPackages ;		 assert: newWorkingCopy repositoryGroup repositories = oldWorkingCopy repositoryGroup repositories ;		 assert: newWorkingCopy package snapshot definitions size = oldDefinitions size ;		 assert: (MCWorkingCopy registry includesKey: newWorkingCopy package) ;		 assert: (MCWorkingCopy registry includes: newWorkingCopy) ;		 deny: (MCWorkingCopy registry includes: oldWorkingCopy).	workingCopy := newWorkingCopy! !!MIDIScore methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 10:05'!initialize	super initialize.	tracks := #().	ambientTrack := Array new.	tempoMap := #().	ticksPerQuarterNote := 100.! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'alain.plantec 5/28/2009 10:05'!initialize	super initialize.	midiParser := MIDIInputParser on: nil.	channels := (1 to: 16) collect: [:ch | MIDISynthChannel new initialize].! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'nice 3/31/2011 01:42'!midiTrackingLoop	midiParser clearBuffers.		[self processMIDI ifFalse: [(Delay forMilliseconds: 5) wait]] repeat! !!MIDISynthChannel methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 10:05'!initialize	super initialize.	instrument := FMSound default.	muted := false.	masterVolume := 0.5.	channelVolume := 1.0.	pan := 0.5.	pitchBend := 0.0.	activeSounds := OrderedCollection new.! !!MIMEDocument methodsFor: 'testing' stamp: 'ls 4/30/2000 18:45'!isMultipartAlternative	"whether the document is in a multipart format where the parts are alternates"	^ self contentType = 'multipart/alternative'! !!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'nice 6/11/2010 21:52'!from: aPopupMenu title: titleStringOrNil	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."	| menu items lines selections labelString j |	menu := self new.	titleStringOrNil ifNotNil: [		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].	labelString := aPopupMenu labelString.	items := labelString asString lines.	labelString isText ifTrue:		["Pass along text emphasis if present"		j := 1.		items := items collect:			[:item | | emphasis |			j := labelString asString findString: item startingAt: j.			emphasis := TextEmphasis new emphasisCode: (labelString emphasisAt: j).			item asText addAttribute: emphasis]].	lines := aPopupMenu lineArray.	lines ifNil: [lines := #()].	menu cancelValue: 0.	menu defaultTarget: menu.	selections := (1 to: items size) asArray.	1 to: items size do: [:i |		menu add: (items at: i) selector: #selectMVCItem: argument: (selections at: i).		(lines includes: i) ifTrue: [menu addLine]].	^ menu! !!MVCProject methodsFor: 'utilities' stamp: 'ul 6/17/2011 12:28'!do: aBlock withProgressInfoOn: aMorphOrNil label: aString	"Evaluate aBlock with a labeled progress bar. Use a simple progress	bar set to 50% progress. In Morphic, progress is displayed with a	ComplexProgressIndicator."	aString		displayProgressFrom: 0 to: 2		during: [:bar |  bar value: 1.				aBlock value]! !!MVCProject methodsFor: 'utilities' stamp: 'fm 9/11/2010 00:55'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	^ ScheduledControllers interruptName: labelString! !!MVCProject methodsFor: 'utilities' stamp: 'fm 9/11/2010 00:22'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label."	^ ScheduledControllers interruptName: labelString preemptedProcess: theInterruptedProcess! !!MVCToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 21:40'!openDebugger: anObject	"Build and open the object. Answer the widget opened."	| window |	window := self build: anObject.	window controller openNoTerminate.	^window! !!MVCToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 21:40'!openDebugger: anObject label: aString	"Build an open the object, labeling it appropriately.  Answer the widget opened."	| window |	window := self build: anObject.	window label: aString.	window controller openNoTerminate.	^window! !!MVCToolBuilder methodsFor: 'pluggable widgets' stamp: 'laza 2/9/2011 10:11'!buildPluggableWindow: aSpec	| widget children label |	topSize := 0@0 corner: 640@480.	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := StandardSystemView new.	self register: widget id: aSpec name.	widget model: aSpec model.	label := aSpec label.	label isSymbol ifTrue: [label := aSpec model perform: label].	label isNil ifFalse: [widget setLabel: label].	children := aSpec children.	children isSymbol ifTrue:[		"This isn't implemented by StandardSystemView, so we fake it"		children := widget model perform: children.	].	aSpec extent ifNotNil:[topSize :=  0@0 extent: aSpec extent].	widget window: topSize.	panes := OrderedCollection new.	self buildAll: children in: widget.	widget setUpdatablePanesFrom: panes.	^widget! !!MVCToolBuilder class methodsFor: 'accessing' stamp: 'fm 9/8/2010 11:52'!isActiveBuilder	"Answer whether I am the currently active builder"	"This is really a way of answering whether 'Smalltalk isMVC'"	ScheduledControllers ifNil:[^false].	^(ScheduledControllers activeControllerProcess ifNil:[^false]) isTerminated not! !!MVCUIManager methodsFor: 'ui requests' stamp: 'kb 4/14/2011 23:31'!displayProgress: titleString at: aPoint from: minVal to: maxVal during: workBlock	"Display titleString as a caption over a progress bar while workBlock is evaluated."	| delta savedArea captionText textFrame barFrame outerFrame result range lastW |	barFrame := aPoint - (75@10) corner: aPoint + (75@10).	captionText := DisplayText text: titleString asText allBold.	captionText		foregroundColor: Color black		backgroundColor: Color white.	textFrame := captionText boundingBox insetBy: -4.	textFrame := textFrame align: textFrame bottomCenter					with: barFrame topCenter + (0@2).	outerFrame := barFrame merge: textFrame.	delta := outerFrame amountToTranslateWithin: Display boundingBox.	barFrame := barFrame translateBy: delta.	textFrame := textFrame translateBy: delta.	outerFrame := outerFrame translateBy: delta.	savedArea := Form fromDisplay: outerFrame.	Display fillBlack: barFrame; fillWhite: (barFrame insetBy: 2).	Display fillBlack: textFrame; fillWhite: (textFrame insetBy: 2).	captionText displayOn: Display at: textFrame topLeft + (4@4).	range := maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"	lastW := 0.	[result := workBlock value:  "Supply the bar-update block for evaluation in the work block"		[:barVal |		| w |		w := ((barFrame width-4) asFloat * ((barVal-minVal) asFloat / range min: 1.0)) asInteger.		w ~= lastW ifTrue: [			Display fillGray: (barFrame topLeft + (2@2) extent: w@16).			lastW := w]]]		ensure: [savedArea displayOn: Display at: outerFrame topLeft].	^result! !!MVCUIManager methodsFor: 'ui requests' stamp: 'ul 8/2/2011 20:03'!informUser: aString during: aBlock	"Display a message above (or below if insufficient room) the cursor 	during execution of the given block.		UIManager default informUser: 'Just a sec!!' during: [(Delay forSeconds: 1) wait].	"	(SelectionMenu labels: '')		displayAt: Sensor cursorPoint		withCaption: aString		during: aBlock! !!MVCUIManager methodsFor: 'initialize-release' stamp: 'dtl 2/12/2011 15:55'!initialize	toolBuilder := MVCToolBuilder new! !!MVCUIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 0!MVCUIManager is a UIManager that implements user interface requests for an MVC user interface.!!MacUnicodeInputInterpreter methodsFor: 'keyboard' stamp: 'bf 1/31/2011 16:59'!nextCharFrom: sensor firstEvt: evtBuf 	| keyValue mark |	keyValue := evtBuf at: 6.	mark := self japaneseSpecialMark: keyValue.	mark notNil		ifTrue: [^ mark].	keyValue < 256		ifTrue: [^ (Character value: keyValue) squeakToIso].	"Smalltalk systemLanguage charsetClass charFromUnicode: keyValue."	^ Unicode value: keyValue! !!Magnitude methodsFor: 'testing' stamp: 'mtf 3/7/2011 21:35'!clampHigh: highMagnitude"Answer my value, but keep it less than highMagnitude"	^ self min: highMagnitude! !!Magnitude methodsFor: 'testing' stamp: 'mtf 3/7/2011 21:34'!clampLow: lowMagnitude"Answer my value, but keep it greater than lowMagnitude"	^ self max: lowMagnitude! !!Magnitude methodsFor: 'testing' stamp: 'mtf 3/7/2011 21:35'!clampLow: lowMagnitude high: highMagnitude"Answer my value, but keep it between lowMagnitude and highMagnitude"	^ self min: highMagnitude max: lowMagnitude! !!MailMessage methodsFor: 'parsing' stamp: 'nice 2/16/2011 01:36'!fieldsFrom: aStream do: aBlock	"Invoke the given block with each of the header fields from the given stream. The block arguments are the field name and value. The streams position is left right after the empty line separating header and body."	| savedLine line s |	savedLine := aStream nextLine.	[aStream atEnd] whileFalse: [		line := savedLine.		(line isEmpty) ifTrue: [^self].  "quit when we hit a blank line"		[savedLine := aStream nextLine.		 (savedLine size > 0) and: [savedLine first isSeparator]] whileTrue: [			"lines starting with white space are continuation lines"			s := ReadStream on: savedLine.			s skipSeparators.			line := line, ' ', s upToEnd].		self reportField: line withBlanksTrimmed to: aBlock].	"process final header line of a body-less message"	(savedLine isEmpty) ifFalse: [self reportField: savedLine withBlanksTrimmed to: aBlock].! !!MailMessage class methodsFor: 'utilities' stamp: 'tonyg 9/12/2011 09:25'!dateStamp: aDateAndTime	"Return the given date and time formatted as a email Date: line"	"The result conforms to RFC822 with a long year, e.g.  'Thu, 18 Feb 1999 20:38:51'"	| d t |	d := aDateAndTime asDate.	t := aDateAndTime asTime.	^	(d weekday copyFrom: 1 to: 3), ', ',		(d printFormat: #(1 2 3 $  2 1 1)), ' ',		"We are careful to avoid fractional seconds appearing in the result:"		(Time fromSeconds: t asSeconds) print24! !!MailMessage class methodsFor: 'utilities' stamp: 'tonyg 9/12/2011 09:20'!dateStampNow	"Return the current date and time formatted as a email Date: line"	^ self dateStamp: DateAndTime now! !!MailMessageTest methodsFor: 'as yet unclassified' stamp: 'tonyg 9/12/2011 13:49'!testDateStampFractionalSecondFormatting	self assert: (MailMessage dateStamp: (DateAndTime fromSeconds: 1.234))					= 'Tue, 1 Jan 1901 00:00:01'		description: 'RFC822 (and RFC2822) forbids non-integer seconds in dates'! !!MailMessageTest commentStamp: 'tonyg 9/12/2011 09:17' prior: 0!This is the unit test for the class MailMessage.!!MailSender class methodsFor: 'settings' stamp: 'nice 8/27/2010 20:43'!setUserName	"Change the user's email name for use in composing messages."	(UIManager default			request: 'What is your email address?\(This is the address other people will reply to you)' withCRs			initialAnswer: (UserName ifNil: [UserName := '']))		ifNotNil: [:answer | UserName := answer]! !!MatrixTransform2x3 methodsFor: 'explorer' stamp: 'bf 7/13/2011 18:51'!explorerContents	^(FloatArray newFrom: self) explorerContents! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 6/19/2008 09:36'!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVarLong: index.	stack pop: 1! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57'!sizeCodeForStore: encoder	^encoder sizeStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53'!sizeCodeForValue: encoder	^encoder sizePushInstVarLong: index! !!MczInstaller methodsFor: 'utilities' stamp: 'ul 8/2/2011 20:03'!useNewChangeSetDuring: aBlock	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := ChangeSet new name: (ChangeSet uniqueNameLike: self extractPackageName).	changeHolder newChanges: newChanges.	aBlock ensure: [changeHolder newChanges: oldChanges].! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:58'!smallAuthoringToolsIcon	^ Icons		at: #smallAuthoringToolsIcon		ifAbsentPut: [ self smallAuthoringToolsIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'dgd 9/25/2004 22:59'!smallCancelIcon	"Private - Generated method"	^ Icons			at: #'smallCancel'			ifAbsentPut:[ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self smallCancelIconContents readStream) ].! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:40'!smallCenteredIcon	^ Icons		at: #smallCenteredIcon		ifAbsentPut: [ self smallCenteredIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:19'!smallChangesIcon	^ Icons		at: #smallChangesIcon		ifAbsentPut: [ self smallChangesIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:06'!smallConfigurationIcon	^ Icons		at: #smallConfigurationIcon		ifAbsentPut: [ self smallConfigurationIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:19'!smallCopyIcon	^ Icons		at: #smallCopyIcon		ifAbsentPut: [ self smallCopyIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 15:35'!smallCutIcon	^ Icons		at: #smallCutIcon		ifAbsentPut: [ self smallCutIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/21/2010 22:48'!smallDebugIcon	^ Icons		at: #smallDebugIcon		ifAbsentPut: [ self smallDebugIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:49'!smallDeleteIcon	^ Icons		at: #smallDeleteIcon		ifAbsentPut: [ self smallDeleteIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:27'!smallFindIcon	^ Icons		at: #smallFindIcon		ifAbsentPut: [ self smallFindIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'dgd 10/12/2004 20:58'!smallFontsIcon	"Private - Generated method"	^ Icons			at: #'smallFonts'			ifAbsentPut:[ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self smallFontsIconContents readStream) ].! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:13'!smallFullscreenOffIcon	^ Icons		at: #smallFullscreenOffIcon		ifAbsentPut: [ self smallFullscreenOffIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:13'!smallFullscreenOnIcon	^ Icons		at: #smallFullscreenOnIcon		ifAbsentPut: [ self smallFullscreenOnIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:19'!smallHelpIcon	^ Icons		at: #smallHelpIcon		ifAbsentPut: [ self smallHelpIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:52'!smallHomeIcon	^ Icons		at: #smallHomeIcon		ifAbsentPut: [ self smallHomeIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:41'!smallJustifiedIcon	^ Icons		at: #smallJustifiedIcon		ifAbsentPut: [ self smallJustifiedIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:38'!smallLeftFlushIcon	^ Icons		at: #smallLeftFlushIcon		ifAbsentPut: [ self smallLeftFlushIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:35'!smallOkIcon	^ Icons		at: #smallOkIcon		ifAbsentPut: [ self smallOkIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:19'!smallOpenIcon	^ Icons		at: #smallOpenIcon		ifAbsentPut: [ self smallOpenIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 15:26'!smallPasteIcon	^ Icons		at: #smallPasteIcon		ifAbsentPut: [ self smallPasteIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 1/5/2011 20:43'!smallPinIcon	^ Icons		at: #smallPinIcon		ifAbsentPut: [ self smallPinIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:45'!smallPrintIcon	^ Icons		at: #smallPrintIcon		ifAbsentPut: [ self smallPrintIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 16:58'!smallProjectBackIcon	^ Icons		at: #smallProjectBackIcon		ifAbsentPut: [ self smallProjectBackIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 16:56'!smallProjectIcon	^ Icons		at: #smallProjectIcon		ifAbsentPut: [ self smallProjectIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 16:54'!smallProjectJumpIcon	^ Icons		at: #smallProjectJumpIcon		ifAbsentPut: [ self smallProjectJumpIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 15:23'!smallProjectLoadIcon	^ Icons		at: #smallProjectLoadIcon		ifAbsentPut: [ self smallProjectLoadIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 14:29'!smallProjectNextIcon	^ Icons		at: #smallProjectNextIcon		ifAbsentPut: [ self smallProjectNextIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 15:18'!smallProjectSaveIcon	^ Icons		at: #smallProjectSaveIcon		ifAbsentPut: [ self smallProjectSaveIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/22/2010 00:16'!smallQuitIcon	^ Icons		at: #smallQuitIcon		ifAbsentPut: [ self smallQuitIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:23'!smallQuitNoSaveIcon	^ Icons		at: #smallQuitNoSaveIcon		ifAbsentPut: [ self smallQuitNoSaveIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:20'!smallRedoIcon	^ Icons		at: #smallRedoIcon		ifAbsentPut: [ self smallRedoIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:39'!smallRightFlushIcon	^ Icons		at: #smallRightFlushIcon		ifAbsentPut: [ self smallRightFlushIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/20/2010 18:48'!smallSaveAsIcon	^ Icons		at: #smallSaveAsIcon		ifAbsentPut: [ self smallSaveAsIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/21/2010 20:30'!smallSaveIcon	^ Icons		at: #smallSaveIcon		ifAbsentPut: [ self smallSaveIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/20/2010 18:48'!smallSaveNewIcon	^ Icons		at: #smallSaveNewIcon		ifAbsentPut: [ self smallSaveNewIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/21/2010 22:00'!smallScreenshotIcon	^ Icons		at: #smallScreenshotIcon		ifAbsentPut: [ self smallScreenshotIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:28'!smallSearchIcon	^ Icons		at: #smallSearchIcon		ifAbsentPut: [ self smallSearchIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 17:09'!smallTimerIcon	^ Icons		at: #smallTimerIcon		ifAbsentPut: [ self smallTimerIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/21/2010 23:21'!smallTrafficIcon	^ Icons		at: #smallTrafficIcon		ifAbsentPut: [ self smallTrafficIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:20'!smallUndoIcon	^ Icons		at: #smallUndoIcon		ifAbsentPut: [ self smallUndoIconContents ]! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:20'!smallWindowIcon	^ Icons		at: #smallWindowIcon		ifAbsentPut: [ self smallWindowIconContents ]! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 20:42'!importIconNamed: aString	"self importIconNamed: 'appearanceIcon'"	"will create a method appearanceIconContents holding the string representation of the	icon, and a method appearanceIcon to access a form built using that string"		| writer image stream |	writer := GIFReadWriter on: (FileStream fileNamed: './icons/', aString, '.gif').	image := [ writer nextImage]			ensure: [writer close].	"store string representation"	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString, 'Contents' ; cr.	stream nextPutAll: (self methodStart: aString).	image storeOn: stream.	stream nextPutAll: self methodEnd.	stream close.	MenuIcons class compile: stream contents classified: 'private - icons' notifying: nil.	"create accessor method"	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString ; cr.	stream nextPutAll: (self methodAccessorFor: aString).	MenuIcons class compile: stream contents classified: 'accessing - icons' notifying: nil.	^ stream contents! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 21:15'!importPngIconNamed: aString	"self importIconNamed: 'appearanceIcon'"	"will create a method appearanceIconContents holding the string representation of the	icon, and a method appearanceIcon to access a form built using that string"		| writer image stream |	writer := PNGReadWriter on: (FileStream fileNamed: './icons/', aString, '.png').	image := [ writer nextImage]			ensure: [writer close].	"store string representation"	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString, 'Contents' ; cr.	stream nextPutAll: (self methodStart: aString).	image storeOn: stream.	stream nextPutAll: self methodEnd.	stream close.	MenuIcons class compile: stream contents classified: 'private - icons' notifying: nil.	"create accessor method"	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString ; cr.	stream nextPutAll: (self methodAccessorFor: aString).	MenuIcons class compile: stream contents classified: 'accessing - icons' notifying: nil.	^ stream contents! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 20:51'!methodAccessorFor: iconName	"Template method for an icon accessor method"	^ '	^ Icons		at: #{1}		ifAbsentPut: [ self {1}Contents ]' format: {iconName}! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 20:36'!methodEnd	^ ''! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 20:36'!methodStart: aString	^'^ '! !!MenuIcons class methodsFor: 'menu decoration' stamp: 'MAD 12/30/2010 23:19'!itemsIcons	"answer a collection of associations wordings -> icon to  	decorate  	the menus all over the image"	| icons |	icons := OrderedCollection new.	"icons add: #('Test Runner' ) -> self smallTrafficIcon."	" 	world menu"	icons add: #('previous project' 'go to previous project') -> self smallProjectBackIcon.	icons add: #('go to next project') -> self smallProjectNextIcon.	icons add: #('select' ) -> self smallSelectIcon.	icons add: #('jump to project...' ) -> self smallProjectJumpIcon.	icons add: #('open...' ) -> self smallOpenIcon.	icons add: #('appearance...' ) -> self smallConfigurationIcon.	icons add: #('help...' ) -> self smallHelpIcon.	icons add: #('windows...' ) -> self smallWindowIcon.	icons add: #('changes...' ) -> self smallChangesIcon.	icons add: #('print PS to file...' ) -> self smallPrintIcon.	icons add: #('debug...' ) -> self smallDebugIcon.	icons add: #('export...' ) -> self smallExportIcon.	icons add: #('save' ) -> self smallSaveIcon.	icons add: #('save project on file...' ) -> self smallProjectSaveIcon.	icons add: #('save as...') -> self smallSaveAsIcon.	icons add: #('save as new version') -> self smallSaveNewIcon.	icons add: #('save and quit' ) -> self smallQuitIcon.	icons add: #('quit') -> self smallQuitNoSaveIcon.	icons add: #('load project from file...' ) -> self smallProjectLoadIcon.	""	icons add: #('do it (d)' ) -> self smallDoItIcon.	icons add: #('inspect it (i)' 'explore it (I)' 'inspect world' 'explore world' 'inspect model' 'inspect morph' 'explore morph' 'inspect owner chain' 'explore' 'inspect' 'explore (I)' 'inspect (i)' 'basic inspect' ) -> self smallInspectItIcon.	icons add: #('print it (p)' ) -> self smallPrintIcon.	icons add: #('debug it' ) -> self smallDebugIcon.	icons add: #('tally it' ) -> self smallTimerIcon.	""	icons add: #('copy (c)' 'copy to paste buffer' 'copy text' ) -> self smallCopyIcon.	icons add: #('paste (v)' 'paste...' ) -> self smallPasteIcon.	icons add: #('cut (x)' ) -> self smallCutIcon.	""	icons add: #('accept (s)' 'yes' 'Yes' ) -> self smallOkIcon.	icons add: #('cancel (l)' 'no' 'No' ) -> self smallCancelIcon.	""	icons add: #('do again (j)' ) -> self smallRedoIcon.	icons add: #('undo (z)' ) -> self smallUndoIcon.	""	icons add: #( 'find class... (f)' 'find method...' ) -> self smallSearchIcon.	icons add: #('find...(f)' 'find again (g)') -> self smallFindIcon.	""	icons add: #('remove' 'remove class (x)' 'delete method from changeset (d)' 'remove method from system (x)' 'delete class from change set (d)' 'remove class from system (x)' 'destroy change set (X)' ) -> self smallDeleteIcon.	icons add: #('add item...' 'new category...' 'new change set... (n)' ) -> self smallNewIcon.	""	icons add: #('new morph...' 'objects (o)' ) -> self smallObjectCatalogIcon.	icons add: #('authoring tools...')  -> self smallAuthoringToolsIcon.	icons add: #('projects...')  -> self smallProjectIcon.	""	icons add: #('make screenshot')  -> self smallScreenshotIcon.		""	icons add: #('leftFlush' ) -> self smallLeftFlushIcon.	icons add: #('rightFlush' ) -> self smallRightFlushIcon.	icons add: #('centered' 'set alignment... (u)' ) -> self smallCenteredIcon.	icons add: #('justified' ) -> self smallJustifiedIcon.	""	icons add: #('set font... (k)' 'list font...' 'set subtitles font' 'change font' 'system fonts...' 'change font...' ) -> self smallFontsIcon.	icons add: #('full screen on') -> self smallFullscreenOnIcon.	icons add: #('full screen off' ) -> self smallFullscreenOffIcon.	""	^ icons! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:58'!smallAuthoringToolsIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2808846277 4285241285 4285241285 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4104749094 16777215 16777215 16777215 4285241285 4288461528 3765147589 4285241285 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4156465773 4038761825 16777215 16777215 16777215 4285241285 4269385423 4287147474 4272275675 3898314177 16777215 16777215 16777215 16777215 797072384 4273576540 4294437589 4256074563 275795968 16777215 16777215 2892732357 4183986884 4286491090 4288461528 4255103704 3881930943 3064638120 3131747241 3920013734 4104492405 4293443700 4291597568 2693556224 16777215 16777215 16777215 2540345030 3580466371 4268792519 4286622160 4289118684 4270501585 4285635011 4294967295 4291342725 4292591497 4292980025 3953030672 4288257175 16777215 16777215 16777215 16777215 4083520451 3731461315 4285701320 4286227917 4289250269 4219249868 4286878622 4272851774 4292917094 4291794688 4124363449 4288257175 16777215 16777215 16777215 16777215 16777215 3951402422 4268004291 4286228432 4285636298 4272472796 4272064850 4291274851 4292526223 4071986259 4226279912 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4259637483 4268725432 4286293452 4286030796 4273182039 4290882421 4289438090 4256807607 4260689397 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4294901502 4259177190 4288849830 4289112743 4288981159 4288849829 4289375657 4275953373 4277795321 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4294901502 4060020478 4294967295 4294967295 4294967295 4294967295 4294967295 3824020973 4277795321 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4278124286 3003055870 3317805978 3874482915 4274568359 4291740331 4289906910 3102337511 3992582649 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4278124286 3671774150 3233788567 4258252210 4292135090 4291940812 4290889933 3269254362 3791321850 4288257175 16777215 16777215 16777215 16777215 16777215 3868826775 4227726845 3923234754 2916008878 4241934256 4293847268 4290693332 4272668629 4190688481 3690790396 3868826775 16777215 16777215 16777215 16777215 16777215 3029965976 3471502058 4191934156 4192131794 4276808165 4294111470 4294177521 4292074211 4258191588 3506174971 3130694807 16777215 16777215 16777215 16777215 16777215 865835926 4070153367 3924421097 4244504061 4277926649 4294704122 4294506744 4294440951 3638484958 4019821720 1620219282 16777215 16777215 16777215 16777215 16777215 33554432 1553505174 3550059671 3952712855 4288257175 4288257175 4288257175 4288257175 3365510294 1653576333 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:40'!smallCenteredIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2862522779 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2862522779 16777215 16777215 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4289309097 4289309097 4289309097 4289309097 4294572537 4294572536 4294506743 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294375157 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4289440683 4289309097 4289309097 4289309097 4289309097 4289309097 4294309365 4294309364 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572536 4294375157 4294309365 4294309364 4294243571 4294177778 4294111985 4294243571 4294177779 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572536 4294506743 4294440950 4294375157 4294309365 4294309365 4294243572 4294177779 4294177778 4294111985 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294440950 4294375158 4294309365 4289309097 4289309097 4289309097 4289309097 4294111985 4294046193 4294046193 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294375157 4294309365 4294309364 4294046193 4294046193 4293980400 4293914607 4294046193 4293980400 4293980399 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294967295 4288454554 16777215 16777215 2862522779 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 2862522780 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:19'!smallChangesIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 490044345 2671475640 3728440505 4130765241 3845814969 3157949368 1395947704 87254732 16777215 16777215 16777215 2033415863 271610031 16777215 16777215 1345746614 4130962105 4201816526 4288331486 4289908199 4289907942 4288593630 4100561352 4030167480 1479833527 16777215 1714780343 4281563063 255031227 16777215 691173044 4114250680 4288134110 4289186277 4289448678 4290631148 4291288047 4292076787 4292602100 4291288045 4115827136 3224795577 4148724669 4231297207 238518454 16777215 2604301240 4252279246 4286425299 4282351034 4281628855 4231756985 4083652551 4272736226 4292798965 4292930549 4293062134 4254381786 4291879151 4181425337 222000817 16777215 4080630456 4282745533 4265508539 4114316473 1966241975 422804152 1161066169 3443096760 4117469896 4292141808 4293324792 4293587448 4293587448 4198202553 187593913 16777215 4264916919 4214979769 2641535701 3862395320 590575030 16777215 16777215 16777215 1613920439 4281628855 4291813359 4291682544 4293390584 4198202808 171147443 16777215 4231231415 2119404740 729984219 324965577 33587328 16777215 16777215 71336127 3292101303 4204509915 4293652984 4292930549 4293587448 4214980024 154759594 16777215 222000817 16777215 16777215 16777215 16777215 16777215 16777215 2687727799 4281563063 4165830334 4149447104 4149447104 4149447360 4281563063 138444991 16777215 4180899767 4264785847 4264785847 4248008631 4231231415 4214454199 3107157943 490044345 406156725 406156725 406156725 406156725 406156725 473396918 16777215 16777215 4231231415 4293521912 4293521912 4293456120 4255630561 3761732280 271610031 16777215 16777215 16777215 16777215 445231586 964537051 4231231415 204177599 16777215 4231297207 4293587448 4291616752 4291879151 4264785847 1781757623 16777215 16777215 16777215 187593913 3912595640 2373363157 3260780998 4281563063 87254732 16777215 4248271288 4293587448 4293390584 4293456376 4291419116 4115958721 3392765112 909407928 16777215 1781757623 3980361147 4283862726 4265311417 4197940152 16777215 16777215 4248402616 4292798965 4271947742 4293258743 4293062134 4292076530 4271619037 4115892929 4214519992 4282022840 4265245624 4282417339 4283665089 2822470841 16777215 16777215 4265048504 4150630087 3560339896 4099247298 4290630890 4291879409 4291091181 4290368490 4289383143 4287871453 4287476954 4288265438 4114184888 707885494 16777215 16777215 4281563063 2469820856 16777215 1412724406 3996678584 4082995909 4287608282 4288857058 4288923108 4288002782 4235765200 4130962105 1530230966 16777215 16777215 16777215 2721216695 16777471 16777215 16777215 87254732 1395947704 3191569337 3912858808 4197742775 3829103801 2856222137 607287480 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:06'!smallConfigurationIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282944717 4282944717 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1480812686 4282944717 4282944717 1480812686 4282944717 4291155690 4282944717 1480812686 4282944717 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 4282944717 4291155690 4287805149 4282944717 4285374933 4289250531 4285374933 4282944717 4287805149 4291155690 4282944717 16777215 16777215 16777215 16777215 16777215 4282944717 4287805149 4289250531 4289250531 4289250531 4289250531 4289250531 4289250531 4289250531 4287805149 4282944717 16777215 16777215 16777215 16777215 16777215 1480812686 4282944717 4289250531 4287082715 4098460874 4284323793 4098460874 4287476956 4289250531 4282944717 1480812686 16777215 16777215 16777215 16777215 4282944717 4282944717 4285374933 4289250531 4098460874 2923986606 1497524108 2537911972 3998060491 4289250531 4285374933 4282944717 4282944717 16777215 16777215 16777215 4282944717 4291155690 4289250531 4289250531 4284323793 1497524108 16777215 1497524108 4284323793 4289250531 4289250531 4291155690 4282944717 16777215 16777215 16777215 4282944717 4282944717 4285374933 4289250531 4166095308 3445593287 1497524108 3225977527 4098460874 4289250531 4285374933 4282944717 4282944717 16777215 16777215 16777215 16777215 1480812686 4282944717 4291155690 4287082715 4166095308 4284323793 4098460874 4288330975 4289250531 4282944717 1480812686 16777215 16777215 16777215 16777215 16777215 4282944717 4287805149 4289250531 4289250531 4289250531 4289250531 4289250531 4289250531 4289250531 4287805149 4282944717 16777215 16777215 16777215 16777215 16777215 4282944717 4291155690 4287805149 4282944717 4285374933 4289250531 4285374933 4282944717 4287805149 4291155690 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 4282944717 4282944717 1480812686 4282944717 4291155690 4282944717 1480812686 4282944717 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282944717 4282944717 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:19'!smallCopyIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 1335796123 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 1403036570 16777215 16777215 16777215 16777215 2107219353 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2140773783 16777215 16777215 16777215 16777215 2107219353 2147483647 2146694131 2146694129 2146694129 2146694129 2146694129 2146694129 2146694131 2146694131 2147483647 2140773783 16777215 16777215 16777215 16777215 2107219353 2147483647 2146694131 2144588753 3500845735 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2879299995 2107219353 2147483647 2146694131 2146694131 4254834329 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288257175 2107219353 2147483647 2146694131 2144588753 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294967295 4288257175 2107219353 2147483647 2146694131 2146694129 4254834329 4294967295 4294177778 4291940816 4291940816 4291940816 4291940816 4291940816 4291940816 4294177778 4294967295 4288257175 2107219353 2147483647 2146694129 2144457169 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294967295 4288257175 2107219353 2147483647 2146562545 2146562545 4254834329 4294967295 4294177778 4291940816 4291940816 4291940816 4291940816 4291940816 4294177778 4294177778 4294967295 4288257175 2107219353 2147483647 2146562545 2144325583 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294704123 4294309365 4288257175 2107219353 2147220475 2146430959 2146430959 4254834329 4294967295 4294177778 4291940816 4291940816 4291940816 4291940816 4291940816 4294046193 4294572536 4291743694 4288257175 2107219353 2146825717 2146957301 2146825717 4254834329 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4288520347 4288520347 4288520347 4288520347 4288257175 1352639388 2140904857 2140904857 2140904857 4254768536 4294901501 4294177778 4294177778 4294177778 4294177778 4294704123 4289243814 4294704123 4294572537 4293454312 4288257175 16777215 16777215 16777215 16777215 4221214104 4294704122 4294177778 4294177778 4294177778 4294704123 4294704123 4289243814 4294704123 4293519848 4288257175 3432619159 16777215 16777215 16777215 16777215 4221214104 4294375158 4294572536 4294506743 4294835708 4294769916 4292664540 4289243814 4293454312 4288257175 2140773783 16777215 16777215 16777215 16777215 16777215 2744950939 4288322968 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 3214580887 2140773783 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 15:35'!smallCutIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 2086296920 4270888083 4169895821 16777215 16777215 16777215 16777215 3580785006 4271151255 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4288060314 4294440951 3950673018 3178000237 16777215 16777215 16777215 4254110610 4292401881 4018045312 16777215 16777215 16777215 16777215 16777215 16777215 4288257693 4292467931 4293980656 3833232506 16777215 16777215 1851284056 4290165433 4291744465 4288060571 16777215 16777215 16777215 16777215 16777215 16777215 4271217305 4290626241 4294441207 4186343815 3178000237 16777215 4288257693 4292073430 4290297019 4169435271 16777215 16777215 16777215 16777215 16777215 16777215 1700288598 4288323486 4292928482 4294046449 4001268610 3597693552 4290823620 4292204502 4288257693 3177671015 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4220227726 4290757570 4294572537 4271151254 4289441710 4290823106 4290823363 3900144248 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1549162838 4288257693 4293257190 4294309621 4289178795 4290033847 4287994521 1549162838 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3698554484 4290954692 4293651948 4290165433 4288389279 3580785006 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2539610207 4288060314 4291744208 4290625727 4283997890 1549162838 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 4266566084 4283212999 4287417300 4292537599 4292537599 4266631363 2134145207 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 4288667371 4292537599 4292537599 4283213770 3744684890 4285454303 4292537599 4292537599 4292537599 4283212999 2134145207 16777215 16777215 16777215 2134145207 4288667371 4292537599 3945492591 4287941348 4279934652 16777215 458557696 4292537599 4283279307 4118390190 4292537599 4283212999 2134145207 16777215 16777215 4268539848 4292537599 3125100092 16777215 4287941605 4280000187 16777215 16777215 4283212743 4272087534 16777215 3057990715 4292537599 4281899979 16777215 16777215 4280130745 4288734706 16777215 3477099345 4292537599 4281899979 16777215 16777215 4281899979 4290041584 3544143702 16777215 4292537599 4281899979 16777215 16777215 4281899979 4292537599 4288734706 4292537599 4245856928 1549473302 16777215 16777215 1549473302 4269132498 4292537599 4292537599 4292537599 4245727654 16777215 16777215 16777215 4281899979 4280195254 4280130488 1549473302 16777215 16777215 16777215 16777215 2538548780 4281899979 4281899979 4281899979 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/21/2010 22:48'!smallDebugIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 16777215 16777215 4231297207 4231297207 16777215 2134145207 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 4231297207 4290304767 4290304767 4231297207 4231297207 4231297207 16777215 4231297207 4231297207 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 4290304767 4231297207 4290304767 4290304767 4290304767 4231297207 2134145207 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 4231297207 4290304767 4290304767 4290304767 4290304767 4290304767 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 2134145207 2134145207 4231297207 4290304767 4290304767 4281694904 4290304767 4290304767 4290304767 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 4231297207 4231297207 4290304767 4290304767 4290304767 4281694904 4290304767 4290304767 4231297207 4231297207 4231297207 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 4290304767 4290304767 4290304767 4281694904 4290304767 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 2134145207 4231297207 4290304767 4290304767 4290304767 4285966811 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 4231297207 4231297207 4231297207 4231297207 2134145207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:49'!smallDeleteIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1382511397 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 1986424869 16777215 1449488679 4287666543 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4288192890 1147498793 4284837928 4292994782 4287139466 4285493612 4285625199 4285822577 4285954164 4286151542 4286283129 4286480507 4286612094 4286809472 4286941059 4290691515 4292994782 4284837928 4284837928 4292994782 4284112991 4285888370 4286019958 4286283128 4286414715 4286612094 4286809473 4287006852 4287072902 4287270280 4287336074 4289243813 4292994782 4284837928 4284837928 4290955444 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4290231460 4284837928 2590339368 4284837928 4288851047 4287338045 4287206716 4287075131 4286877754 4286614585 4286416951 4286022196 4285693233 4285495344 4285363760 4285035308 4284837928 2590207782 16777215 4284837928 4291812235 4290760282 4290760282 4290694233 4289904210 4289970017 4290232690 4289115217 4288325447 4287733059 4287272512 4288324968 4284837928 16777215 16777215 4284837928 4291812235 4290760282 4290760282 4290628441 4291022450 4292731857 4292731857 4292074155 4289575523 4288983124 4288391252 4288324716 4284837928 16777215 16777215 4284837928 4291943566 4290760282 4290760282 4292140202 4291088506 4290627953 4292139948 4292205742 4289509987 4289246047 4288917339 4289574266 4284837928 16777215 16777215 4284837928 4292009105 4290957409 4291220332 4292600262 4292731857 4290365032 4290101861 4290101613 4290956176 4289114972 4288719960 4289903745 4284837928 16777215 16777215 4284837928 4292337822 4291286129 4291286127 4292534726 4291285891 4290430569 4291942578 4290232689 4292468932 4288983643 4288390740 4290100612 4284837928 16777215 16777215 4284837928 4292403360 4291220334 4291154541 4291154294 4292205742 4291614119 4292600263 4292534470 4290035573 4288786006 4288259408 4289772418 4284837928 16777215 16777215 4284837928 4292206493 4291154538 4291022952 4290693989 4290365026 4290036063 4291679916 4289378136 4288983381 4288654161 4288127821 4289705854 4284837928 16777215 117440512 4284837928 4206542989 4292140187 4291943322 4291876761 4291614359 4291416725 4291284884 4291021715 4290890129 4290692752 4290363789 4204569458 4284837928 100663296 16777216 2103470115 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 2120049952 33554432)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:27'!smallFindIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 3500845735 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2879299995 16777215 16777215 16777215 16777215 4254834329 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288257175 16777215 16777215 16777215 16777215 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294967295 4288257175 16777215 16777215 16777215 16777215 4254834329 4294967295 4294177778 4291940816 4291940816 4291940816 4291940816 4291940816 4291940816 4294177778 4294967295 4288257175 16777215 16777215 16777215 16777215 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4292796125 4287862162 4287862162 4287862162 4287862162 4287927954 16777215 16777215 16777215 16777215 4254834329 4294967295 4294177778 4291940816 4291940816 4290164917 4287862162 4290430675 4289841372 4289578718 4290037208 4287862162 1552255106 16777215 16777215 16777215 4254768536 4294967295 4294177778 4294177778 4292796381 4287862162 4290036947 4288002781 4291288045 4291682288 4289119970 4288461783 4287862162 830636669 16777215 16777215 4254834329 4294967295 4294177778 4291940816 4287862162 4289772744 4287674587 4292996085 4293718521 4293456120 4291944945 4288200674 4255366615 4287862162 16777215 16777215 4254834329 4294967295 4294177778 4294177778 4287862162 4289578459 4289711079 4292864501 4293193462 4293061877 4291419375 4289383143 4270634460 4287862162 16777215 16777215 4254768536 4294901501 4294177778 4294177778 4287862162 4290038751 4289711336 4292338931 4292864758 4292142066 4291813617 4291156462 4253726428 4287862162 16777215 16777215 4221214104 4294704122 4294177778 4294177778 4287862162 4289970895 4287936987 4290565356 4291551216 4291419376 4292273395 4289645027 4221615577 4287862162 16777215 16777215 4221214104 4294967295 4294967295 4294967295 4292401366 4287862162 4289381852 4288463072 4290367719 4290499818 4289447648 4288856541 4287862162 3800664454 16777215 16777215 2744950939 4288322968 4288257175 4288257175 4288257175 4287665037 4287862162 4290630372 4288068314 4287281116 4289052891 4287862162 4289901490 4289901490 3632300413 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2306834557 4287862162 4287862162 4287862162 4287862162 4288585629 4291151300 4289901490 4289901490 4288059028 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4288585629 4291151300 4289901490 4288059028 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 33554432 4288585629 4288585629 4288059028)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:13'!smallFullscreenOffIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 3597627500 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 3597627500 4288322713 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290033079 4290033079 4294045933 4294045933 4294111726 4294111726 4290033079 4290033079 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290098872 4294045933 4294045933 4294111470 4294177519 4294177519 4294177519 4290098872 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290098872 4290362044 4290822852 4294111726 4294111726 4294243312 4294243312 4290559423 4290296251 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4294111726 4290757059 4291612368 4292270298 4294177519 4294178289 4292072919 4291480782 4290691266 4294309105 4290098872 4294966267 4288322713 4288322713 4294966267 4294177519 4294177519 4294243312 4292270298 4292730849 4293125607 4293191400 4292928228 4292270298 4294374898 4294113010 4294374898 4294966267 4288322713 4288322713 4294966267 4294243312 4294243312 4294308849 4294178289 4293059814 4294309105 4294374130 4293191400 4294440435 4294440435 4294440691 4294178803 4294966267 4288322713 4288322713 4294966267 4294440691 4294440691 4294440691 4294506228 4293257193 4294505716 4294572277 4293651951 4294571509 4294376182 4294638070 4294637302 4294966267 4288322713 4288322713 4294966267 4294506484 4294506484 4294571509 4292007126 4292862435 4293454316 4293651951 4293322986 4292533470 4294638070 4294703863 4294637302 4294966267 4288322713 4288322713 4294966267 4290033079 4294572277 4290559423 4291086024 4291941333 4294571509 4294637302 4292401884 4291349196 4290559423 4294703863 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290164665 4290427837 4294376182 4294638070 4294703095 4294768888 4290362044 4290098872 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290033079 4294703863 4294637302 4294441975 4294768888 4294834681 4294834681 4290033079 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290033079 4290033079 4294769656 4294769656 4294900474 4294834681 4290033079 4290033079 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4288322713 3647762028 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 3698093161)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:13'!smallFullscreenOnIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 2576981400 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2576981400 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288257175 4288257175 4294967295 4281563063 4281563063 4281563063 4281563063 4294046192 4294046192 4294111985 4294111985 4281563063 4281563063 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281563063 4281760184 4294046192 4294046192 4294111728 4294177777 4294177777 4294177777 4281760184 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281760184 4282942140 4285175492 4294111985 4294111985 4294243571 4294243571 4283861695 4282679483 4281957047 4281563063 4294967295 4288257175 4288257175 4294967295 4281628855 4294111985 4284912835 4287672272 4289643482 4294177777 4294243827 4289052375 4287080654 4284584386 4294309364 4281825720 4294967295 4288257175 4288257175 4294967295 4294177778 4294177778 4294243570 4289511898 4291023329 4291943399 4292206568 4291286500 4289446362 4294375157 4294309621 4294375157 4294967295 4288257175 4288257175 4294967295 4294243570 4294243571 4294309107 4294243827 4291877862 4294309363 4294374901 4292272104 4294440693 4294440693 4294440949 4294375414 4294967295 4288257175 4288257175 4294967295 4294440949 4294440949 4294440950 4294506486 4292141033 4294506487 4294572536 4292863983 4294572537 4294572793 4294638329 4294638073 4294967295 4288257175 4288257175 4294967295 4294506743 4294506742 4294572280 4288461014 4290892259 4292535020 4292995311 4292009706 4289840862 4294638329 4294704122 4294638330 4294967295 4288257175 4288257175 4294967295 4281628855 4294572536 4283664831 4285701320 4288198101 4294572537 4294638330 4289381084 4286292684 4283599039 4294704122 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281759927 4282219705 4283204797 4294572793 4294638329 4294704123 4294769659 4282942140 4281825720 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281563063 4281563063 4294704122 4294638330 4294638586 4294769916 4294835452 4294835452 4281563063 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281563063 4281563063 4281563063 4294769915 4294769915 4294901245 4294835709 4281563063 4281563063 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288257175 2643827092 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2694091921)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:19'!smallHelpIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 672815513 2232900251 3306642333 4061617052 4061617052 3306642333 2232900251 672815513 16777215 16777215 16777215 16777215 16777215 16777215 33587328 2031573916 4113327778 4254773454 4291285987 4293849847 4293849847 4291285987 4254708174 4130104994 2014796699 33587328 16777215 16777215 16777215 33587328 3289865116 4133981369 4293455348 4290102746 4285699261 4282479274 4282479274 4285699261 4290168539 4293520883 4134047161 3289865116 33587328 16777215 16777215 2031573916 4134441147 4293652469 4284844728 4283530415 4291549157 4294178297 4293586676 4289971418 4283925171 4285633726 4293718518 4150890169 2031573916 16777215 672815513 4113459107 4293521140 4284779191 4279720860 4286159552 4294835710 4292732142 4294112760 4294967295 4291286244 4282151596 4286094019 4293586933 4130236322 672815513 2232900251 4271748304 4290102746 4279720860 4279720860 4283793842 4283925171 4281626024 4284845241 4294967295 4294770173 4283334836 4283071922 4290892002 4255234002 2232900251 3306642333 4291417573 4285699261 4279720860 4280574624 4281165988 4281822889 4282348973 4288065743 4294967295 4293718262 4283729335 4283860408 4287869136 4291812328 3307101598 4061617052 4293981175 4282085031 4280311967 4281165988 4281823145 4282414509 4286225605 4294638845 4294901502 4287606223 4284386493 4284518078 4286095046 4294112761 4061748381 4061617052 4293981175 4282216616 4280903075 4281757096 4282348973 4283006130 4293718518 4294967295 4289512155 4284846529 4285109698 4285241284 4286752203 4294178298 4061944989 3306642333 4291417573 4286027967 4281363109 4282151595 4282874544 4284188857 4291878122 4292009707 4285372612 4285438406 4285701320 4285898697 4289183708 4292141036 3307167391 2232900251 4254971088 4290365661 4281757352 4282480557 4283269044 4284254907 4288460756 4288723928 4285569735 4285964490 4286358733 4286555855 4291944429 4255957466 2233031837 672815513 4130236323 4293586933 4285962689 4282874544 4283597493 4285437634 4294967295 4294967295 4286292940 4286424783 4286884818 4289250528 4293981433 4130433443 672815513 16777215 2014796699 4134572988 4293784054 4286554310 4283794871 4285635011 4294967295 4294967295 4286621647 4286884818 4289447393 4294178811 4151876034 2015125149 16777215 16777215 33587328 3289865116 4151415997 4293784054 4291089381 4288197844 4286423754 4286949839 4289381599 4292141550 4294112762 4152270533 3290652832 33587328 16777215 16777215 16777215 33587328 2031573916 4130367396 4272471510 4292075243 4294178554 4294244347 4292403949 4256351709 4130630309 2015256221 33587328 16777215 16777215 16777215 16777215 16777215 16777215 672815513 2232900251 3306970782 4061879709 4061879709 3307233441 2233031837 672815513 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:52'!smallHomeIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4290904064 2180975120 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4294904335 4294904335 4290904064 1291782669 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4294904335 4287978586 4288768873 4294904335 4290904064 1291782669 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4294904335 4289883499 4288059284 4289440682 4292057497 4294904335 4290904064 1291782669 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4294904335 4289955460 4288717214 4291085765 4291677644 4291217093 4292128687 4294904335 4290904064 1291782669 16777215 16777215 16777215 1291782669 4290904064 4294904335 4290158236 4289704110 4291546058 4293190884 4293190884 4293190884 4292861919 4292264385 4294904335 4290904064 1291782669 16777215 1291782669 4290904064 4294904335 4290228141 4289901233 4292993505 4293848814 4293848814 4293848814 4293783021 4293783021 4293717228 4293253336 4294904335 4290904064 1291782669 4290904064 4294904335 4290822334 4289835696 4292927712 4293651435 4293717228 4293717228 4293717228 4293651435 4293519849 4293519849 4293519849 4293716457 4294904335 4290904064 1740701696 4294904335 4293388776 4284967526 4284967526 4284967526 4284967526 4293717228 4287269773 4287138960 4287137928 4287138960 4287138185 4294440951 4294904335 1455489024 16777215 4284967526 4294243572 4284967526 4287665037 4287730830 4287796367 4293717228 4287138959 4286949841 4287137928 4286818512 4287073167 4294375158 4284967526 16777215 16777215 4284967526 4294177779 4284967526 4288059539 4288059539 4288059539 4293717228 4287073166 4285110471 4287137928 4283533503 4286941325 4294309365 4284967526 16777215 16777215 4284967526 4294111986 4284967526 4288191125 4288191125 4288453494 4293717228 4286811028 4281563063 4287137928 4281563063 4286613908 4294309365 4284967526 16777215 16777215 4284967526 4294111986 4284967526 4288191382 4288191382 4288322448 4293717228 4290691267 4291086541 4291217352 4291152333 4289967027 4294309365 4284967526 16777215 16777215 4284967526 4294046193 4284967526 4288257175 4288257175 4288257175 4293717228 4289835441 4289901234 4289901234 4289901234 4289901234 4294309365 4284967526 16777215 16777215 4284967526 4294440951 4286085750 4289178277 4289243814 4289309350 4294309365 4294440951 4294440951 4294440951 4294440951 4294440951 4294769916 4284967526 16777215 16777215 2892392806 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 2540137061 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:41'!smallJustifiedIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2862522779 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2862522779 16777215 16777215 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294506743 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294375157 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294309364 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294375157 4294375157 4294309365 4294309364 4294243571 4294177778 4294111985 4294046193 4294177779 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572536 4294506743 4294440950 4294375157 4294309365 4294309365 4294243572 4294177779 4294177778 4294111985 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294440950 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294046193 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294375157 4294177778 4294111985 4294046193 4294046193 4293980400 4293914607 4293848814 4293783021 4293980399 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294967295 4288454554 16777215 16777215 2862522779 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 2862522780 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:38'!smallLeftFlushIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2862522779 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2862522779 16777215 16777215 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289309097 4289309097 4289309097 4289309097 4289309097 4294572537 4294572537 4294572536 4294506743 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294440950 4294440950 4294440950 4294440950 4294375157 4294309365 4294309364 4294375157 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289440683 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294309365 4294309364 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572536 4294572536 4294506743 4294440950 4294375157 4294309365 4294309364 4294243571 4294177779 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572536 4294309365 4294309364 4294243571 4294177778 4294309365 4294243572 4294177779 4294177778 4294111985 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294440950 4289309097 4289309097 4289309097 4289309097 4294243571 4294177778 4294111985 4294046193 4294046193 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294375157 4294309365 4294309364 4294243571 4294177779 4294111986 4294046193 4294046193 4293980400 4293980399 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294967295 4288454554 16777215 16777215 2862522779 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 2862522780 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:35'!smallOkIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 248039624 79675327 33554431 33554431 33554431 33554431 33554431 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 16777215 16777215 16777215 16777215 2438055777 2135606620 16777215 16777215 33554431 33554431 33554431 33554431 33554431 33554431 50331647 50331647 50331647 50331647 61516458 2471741027 4285252467 4284989551 2034219344 16777215 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 2437793121 4285186674 4287618449 4286961290 4284332135 2066328132 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 2437923681 4285055344 4287487120 4287356046 4284397928 4281637445 134225920 33554431 33554431 1147794552 1718086006 33554431 33554431 33554431 33554431 2437792609 4284989551 4287290254 4287159181 4284332135 4231042883 134225920 16777215 196721081 1047000951 3865102958 4286107261 1885067371 33554431 33554431 2437792091 4284923758 4287224460 4287027851 4284266341 4230977347 152844572 61516458 93952409 1198060663 3831679084 4287027080 4287552399 4233345377 1884605796 2336866654 4284857964 4286962059 4286896264 4284069475 4230911554 152844572 33554431 33554431 33554431 169502259 4284334440 4285910139 4287684243 4286961546 4284990064 4285252723 4286764935 4286634375 4284003682 4247426367 152844572 33554431 33554431 33554431 33554431 33554431 186080558 4283676768 4285252979 4287159181 4287027594 4286568581 4286568325 4283806817 4264203071 171134259 50331647 33554431 33554431 33554431 33554431 33554431 33554431 186080535 4283018583 4284595563 4286634118 4286371460 4283741024 4264071742 152844572 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 186074647 4282229325 4284003683 4283544158 4263940413 152844572 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 186074647 4281243715 4213674302 136331296 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 186074647 136331296 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:19'!smallOpenIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 4167658343 4218055784 4234767207 4234833000 4234833000 4251741802 4251807595 3597825392 359492973 16777215 16777215 16777215 2676854157 3968633996 3968633996 3968633996 4285098855 4294572537 4294638330 4294704123 4294769916 4294769916 4294835709 4289835697 3782111083 242052461 16777215 16777215 4035677067 4292072403 4291940817 4291809231 4284967526 4292993505 4292598747 4292598747 4292598747 4292401368 4292269782 4294901502 4272202915 3563942253 158429553 16777215 4018570886 4291875024 4290690750 4290427578 4284967526 4293125091 4289506732 4289506732 4289506732 4289506732 4292730332 4294901502 4294835709 4272335015 2590863724 16777215 4001464705 4291611851 4290427578 4290295992 4285098855 4293454056 4293256677 4293190884 4293190884 4293190884 4293322470 4293783021 4293585642 4292467161 4050678382 16777215 3967647101 4291414473 4290295992 4290032820 4285098855 4293651435 4289704110 4289506731 4289506731 4289506731 4293190884 4293519849 4293519849 4292467417 4084101228 16777215 3950540920 4291085508 4290098613 4289835441 4285164648 4293914607 4293848814 4293848814 4293783021 4293783021 4293783021 4293783021 4293717228 4292927712 4050546540 16777215 3916591730 4290822336 4282744759 4281957047 4281957047 4281826232 4281759928 4281759928 4281628856 4281628855 4281628855 4281628855 4281563063 4281563063 4281563063 3828906425 3916394351 4290559164 4281628856 4291354096 4291354096 4291354096 4291354096 4291354096 4291354096 4291419632 4291419888 4291419888 4291419888 4291419888 4291025902 4264785848 3882445161 4290295992 4281628855 4291550960 4288463588 4288463588 4288463588 4288463588 4288463588 4288463588 4288463588 4288463588 4288463588 4288660965 4290894317 4247943351 3848561764 4290032819 4281759927 4291682288 4288857574 4288857574 4288857574 4288857574 4288857574 4288857574 4288857574 4288857574 4288857574 4288660709 4290893805 4214519992 3831389790 4289835441 4281825720 4291288047 4289054438 4288988902 4288988902 4288988902 4288988902 4288988902 4288988902 4288726245 4288331748 4288003810 4290434027 4197742776 3797572186 4289440683 4281957047 4289711337 4288200675 4287938018 4287609569 4287477985 4287346912 4287149791 4286821086 4286689758 4286689758 4286952670 4288725988 4164188600 3764083547 4289309097 4282088119 4288660196 4287412448 4287083999 4287083999 4287083999 4287083999 4287083999 4287083999 4287083999 4287083999 4287215583 4287609312 4147542200 3764017754 4287601320 4282088119 4284193486 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4283404487 3644225976 2656459876 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 3996481463 1194293175)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 15:26'!smallPasteIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 33554432 3983042920 4286743170 4286743170 4286743170 4286743170 3983042920 33554432 16777215 16777215 16777215 16777215 16777215 1278376377 4281628855 4281628855 4281628855 4286677633 4289377716 4289378230 4289378230 4289377716 4286677633 4281628855 4281628855 4281628855 1278376377 16777215 138420224 4281628855 4289252074 4292537599 4287207318 4286874756 4288652194 4288717730 4288717730 4288586401 4286874756 4287206547 4292537599 4289252074 4281628855 71319552 524958216 4281628855 4292537599 4287207061 4294375158 4293651435 4291940817 4291940817 4291940817 4291940817 4293651435 4294440951 4287206290 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4294309365 4294309365 4294309365 4294309365 4294309365 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4291546572 4291546572 4291546572 4291546572 4294243828 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4294309365 4294309365 4294309365 4294243828 4294112499 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4291546572 4291546572 4291480779 4291480522 4293980656 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4294243828 4294178035 4294046449 4293980656 4293322983 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294243572 4294112242 4294046449 4293980656 4293257190 4292665053 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294046706 4293980656 4293915120 4292730846 4291744208 4291678672 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4293980656 4293849327 4293191397 4291743951 4294967295 4294967295 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4293783791 4293125861 4292138709 4291612622 4294967295 4294967295 4287270798 4292537599 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287076246 4294178035 4294901502 4294901502 4294901502 4294243828 4294835965 4287270798 4292537599 4292537599 4292537599 4281628855 273694720 138420224 4281628855 4289252074 4292537599 4287142553 4287468177 4287468177 4287468177 4287468177 4287468177 4292537599 4292537599 4292537599 4289252074 4281628855 71319552 16777215 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 1/5/2011 20:43'!smallPinIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1560237654 2550092884 872371541 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1560237654 4294923605 4294923605 4294923605 1560237654 16777215 16777215 16777215 16777215 4294923605 16777215 16777215 16777215 16777215 16777215 1560237654 4294923605 4294923605 4294936712 4294936712 4294923605 1560237654 16777215 16777215 16777215 4294923605 4294923605 16777215 16777215 16777215 1560237654 4294923605 4294923605 4294936712 4294936712 4294923605 4294923605 4294923605 872371541 16777215 16777215 1560237654 4294923605 4294923605 1560226346 2113885782 4294923605 4294923605 4294936712 4294936712 4294923605 4294923605 4294923605 4293283149 2550092884 16777215 16777215 16777215 2113885782 4294923605 4294923605 4294923605 4294923605 4294936712 4294936712 4294923605 4294923605 4294923605 4293283149 4291576900 2107979575 16777215 16777215 16777215 16777215 2902410822 4294923605 4294923605 4294936712 4294936712 4294923605 4294923605 4294923605 4293283149 4291576900 2107979575 16777215 16777215 16777215 16777215 16777215 872371541 3187614499 4294923605 4294923605 4294923605 4294923605 4294923605 4293283149 4291576900 2107979575 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1560237654 3405717793 4294923605 4294923605 4294923605 4293283149 4291576900 2107979575 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3212409209 4286151033 3405717793 4294923605 4294923605 4291773765 2545302845 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3212409209 4286151033 3212409209 1560237654 3187614499 4294923605 4294923605 1560226346 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3212409209 4286151033 3212409209 16777215 16777215 872371541 2902410822 4294923605 4294923605 16777215 16777215 16777215 16777215 16777215 16777215 2675472504 4286151033 3212409209 16777215 16777215 16777215 16777215 16777215 2113885782 4294923605 4294923605 16777215 16777215 16777215 16777215 2138601592 4286151033 2675472504 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1560237654 4294923605 4294923605 16777215 16777215 16777215 4286151033 2138601592 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:45'!smallPrintIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2176367288 4290296247 4290296247 4290296247 4290296247 4290296247 4290296247 4290296247 4290296247 4290296247 2176367288 16777215 16777215 16777215 16777215 16777215 4290296247 4294638330 4294638330 4294638330 4294638330 4294638330 4294638330 4294638330 4294638330 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294638330 4291809231 4291809231 4291809231 4291809231 4291809231 4291809231 4291809231 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294638330 4294243572 4294243572 4294243572 4294309365 4294309365 4294309365 4294309365 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294572537 4291809231 4291809231 4291875024 4291875024 4291875024 4291940817 4291940817 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294572537 4293322470 4293454056 4293519849 4293519849 4293585642 4293651435 4293717228 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294506744 4289835441 4289835441 4289835441 4289967027 4293388263 4293388263 4293388263 4294572537 4290296247 16777215 16777215 16777215 2173603982 4287598991 4288125078 4290361785 4290295992 4290361785 4290361785 4290361785 4290361785 4290361785 4290295992 4290295992 4288125078 4287598991 2173603982 16777215 4287598991 4294835709 4294638330 4294375158 4294375158 4294375158 4294375158 4294375158 4294375158 4294375158 4294375158 4294375158 4293651435 4293783021 4287598991 16777215 4287598991 4294835709 4292664540 4294046193 4290559164 4294309365 4293256677 4293519849 4293388263 4293454056 4293322470 4293125091 4289703855 4292335317 4287598991 16777215 4287598991 4294177779 4292269525 4293190884 4293190884 4293190884 4293190884 4293190884 4293125091 4293190884 4293190884 4292927712 4288585116 4291875024 4287598991 16777215 4287598991 4294309365 4291480266 4288190358 4287466635 4287466635 4287203463 4287334792 4287203205 4286940290 4287071877 4287334792 4290756543 4291875024 4287598991 16777215 4287598991 4294309365 4291282887 4291151301 4291151301 4291151301 4291151301 4291151300 4291019715 4290822336 4290953922 4291085508 4291151301 4291940817 4287598991 16777215 4287598991 4293980400 4292861919 4292927712 4292927712 4292861919 4292861919 4292861919 4292861919 4292861919 4292730333 4292861919 4292796126 4292664540 4287598991 16777215 2811269520 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 2811269520)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 16:58'!smallProjectBackIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4293176763 4293176763 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292985039 4293751676 4293751676 4292985039 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292793830 4293496216 4294901760 4294901760 4293496216 4292793830 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292985039 4294901760 4294901760 4294901760 4294901760 4292985039 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290694609 4287727293 4287727293 4290694609 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287595701 4281014002 4281014002 4287661239 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287463852 4280948465 4280948465 4287464110 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290628297 4287595700 4287595700 4290628298 4292537599 4281628855 16777215 16777215 2083747767 4291090666 4284271650 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 3169845236 4278231040 4278231040 3053453311 3053453311 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4284271650 4289589680 4278231040 4278231040 4278231040 4278231040 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281118976 4283491340 4278248192 4278247936 4278246144 4278244352 4278231040 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4281118976 4285526614 4278231040 4278231040 4278231040 4278231040 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3169910772 4278231040 4278231040 3053453311 3053453311 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 16:56'!smallProjectIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4293176763 4293176763 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292985039 4293751676 4293751676 4292985039 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292793830 4293496216 4294901760 4294901760 4293496216 4292793830 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292985039 4294901760 4294901760 4294901760 4294901760 4292985039 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290694609 4287727293 4287727293 4290694609 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287595701 4281014002 4281014002 4287661239 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287463852 4280948465 4280948465 4287464110 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290628297 4287595700 4287595700 4290628298 4292537599 4281628855 16777215 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 16:54'!smallProjectJumpIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4293176763 4293176763 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292985039 4293751676 4293751676 4292985039 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292793830 4293496216 4294901760 4294901760 4293496216 4292793830 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292985039 4294901760 4294901760 4294901760 4294901760 4292985039 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290694609 4287727293 4287727293 4290694609 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287595701 4281014002 4281014002 4287661239 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287463852 4280948465 4280948465 4287464110 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290628297 4287595700 4287595700 4290628298 4292537599 4281628855 16777215 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4284271650 4291090666 2083747767 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 3053453311 3053453311 4278231040 4278231040 3500729258 16777215 16777215 1275109632 4278231040 1275109632 4278231040 1275109632 4278231040 1275109632 3053453311 4278231040 4278231040 4278231040 4278231040 4278241792 4278231040 3417498546 16777215 4278231040 4278246144 4278231040 4278246144 4278231040 4278246144 4278231040 3053453311 4278231040 4278246144 4278246144 4278246144 4278246144 4278241792 4278231040 16777215 1275109632 4278231040 1275109632 4278231040 1275109632 4278231040 1275109632 3053453311 4278231040 4278231040 4278231040 4278231040 4278241792 4278231040 3417498546 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 3053453311 3053453311 4278231040 4278231040 3500729258 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 15:23'!smallProjectLoadIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4294928966 4294928966 4292537599 4292537599 4292537599 4281628855 16777215 16777215 16777215 16777215 4281628855 4281628855 4281628855 4292537599 4292537599 4294949256 4294901760 4294901760 4294949256 4292537599 4292537599 4281628855 16777215 16777215 1412725174 4281628855 4281628855 4287412967 4281628855 4288923367 4292537599 4294933841 4294901760 4294901760 4294933841 4292537599 4292537599 4281628855 16777215 1412725174 4281628855 4290304767 4290304767 4290304767 4287412967 4281628855 4278247936 4278247936 4292537599 4292537599 4290947299 4290947299 4292537599 4281628855 16777215 4281628855 4290304767 4287412967 4281628855 4287412967 4281628855 4279353404 4278247936 4278247936 4292537599 4290947299 4282515711 4282515711 4290947299 4281628855 16777215 4281628855 4290304767 4281628855 4281628855 4281628855 4281628855 4278247936 4278247936 4278247936 4292537599 4290947299 4282515711 4282515711 4290947299 4281628855 16777215 4281628855 4281628855 4281628855 16777215 16777215 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 14:29'!smallProjectNextIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 3178078063 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 3178078063 16777215 16777215 4282619024 4292666586 4292666586 4292666586 4292666586 4292666586 4294159759 4294159503 4292666586 4292666586 4292666586 4292666586 4292600791 4282619024 16777215 16777215 4282619024 4292666587 4292337348 4292337348 4292337348 4293637757 4294139970 4294139970 4293571966 4292271812 4292271812 4292337350 4292600791 4282619024 16777215 16777215 4282619025 4292666589 4292337349 4292337349 4292337349 4294079056 4294901760 4294901760 4294079056 4292337349 4292337349 4292271812 4292600790 4282619024 16777215 16777215 4282619025 4292732381 4292337608 4292337608 4292337608 4294901760 4294901760 4294901760 4294901760 4292337350 4292271810 4292271553 4292600791 4282619024 16777215 16777215 4282619025 4292666586 4292337609 4285977428 4285977170 4285911632 4285911631 4292271554 4291084195 4287727293 4287727293 4291084196 4292534996 4282619024 16777215 16777215 4282619025 4292469200 4292140219 4278239744 4278239744 4278239744 4285713988 4292074168 4287595701 4281014002 4281014002 4287661239 4292337610 4282619024 16777215 16777215 4282619025 4292140221 4291942577 4278239744 4278239744 4278239744 4285582397 4291942577 4287463852 4280948465 4280948465 4287464110 4292140221 4282619024 16777215 16777215 4282619026 4292074170 4292074167 4278239744 4278239744 4278239744 4285713987 4292074167 4290886292 4287595700 4287595700 4290886293 4292073912 4282619024 16777215 16777215 4282619026 4291415968 4291415968 4291415968 4291415968 4291415968 4291415968 4291415968 4291415968 4291415968 4284271650 4293915107 4291153049 4282619024 16777215 16777215 3178078063 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4291354847 4291354847 4291354847 4278231040 4278231040 4290962394 3178078063 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4278231040 4278231040 4278231040 4278231040 4289589680 4284271650 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4278231040 4278244352 4278246144 4278247936 4278248192 4283491340 4281118976 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4278231040 4278231040 4278231040 4278231040 4285526614 4281118976 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 3053453311 3053453311 4278231040 4278231040 3169910772 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281118976 3053453311 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 15:18'!smallProjectSaveIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4294928966 4294928966 4292537599 4292537599 4292537599 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4292537599 4292537599 4294949256 4294901760 4294901760 4294949256 4292537599 4292537599 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4292537599 4292537599 4294933841 4294901760 4294901760 4294933841 4292537599 4292537599 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4278247936 4278247936 4278247936 4292537599 4292537599 4290947299 4290947299 4292537599 4281628855 16777215 4281628855 4281628855 1412725174 16777215 16777215 4281628855 4278247936 4278247936 4278247936 4292537599 4290947299 4282515711 4282515711 4290947299 4281628855 16777215 4281628855 4290304767 4281628855 1412725174 16777215 4281628855 4278247936 4278247936 4278247936 4292537599 4290947299 4282515711 4282515711 4290947299 4281628855 16777215 4281628855 4287412967 4290304767 4281628855 16777215 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215 16777215 4281628855 4290304767 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4281628855 4290304767 4281628855 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4281628855 4287412967 4290304767 4287412967 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4290434020 4281628855 4287412967 4281628855 4284643980 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4290434020 4281628855 4290434020 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/22/2010 00:16'!smallQuitIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 4284901482 4290098613 4288124823 4287401100 4286677377 4286085240 4285558896 4285295724 4294046194 4294112244 4294309366 4294440952 4294440952 4293980658 4287598995 679904902 4284901482 4290493371 4288585374 4287730065 4287137928 4286545791 4286019447 4285756275 4294046194 4294309365 4294572537 4294704124 4294769916 4294638330 4289243563 1066044042 4284901482 4291217094 4289111718 4288387995 4287664272 4287137928 4286677377 4286282619 4294046194 4294309366 4294638330 4288727272 4282685399 4294704123 4289769906 1183484554 4284901482 4291282887 4289572269 4289045925 4288387995 4287730065 4287203721 4286808963 4294046451 4294112502 4285771742 4284261853 4278219466 4292536564 4288260277 1736008038 4284901482 4291414473 4289769648 4289243304 4288716960 4288190616 4287664272 4287203721 4293324017 4282553556 4285444580 4289977081 4281306583 4280321491 4279467214 4278544569 4284901482 4291480266 4289835441 4289374890 4288848546 4288322202 4287795858 4286351764 4279335885 4285707496 4288007672 4288401400 4288861177 4288926713 4289189626 4278348735 4284901482 4291480266 4289967027 4289506476 4288980132 4288519581 4285894306 4278218436 4285182955 4285906421 4283345650 4283542770 4283674098 4283805170 4288335864 4278348992 4284901482 4291480266 4290164406 4289638062 4289177511 4288585374 4278217663 4281832927 4284527603 4280522222 4278946541 4278224107 4278224106 4278224364 4286300406 4278348992 4284901482 4291480266 4290295992 4289835441 4289243304 4288716960 4286944417 4278217920 4280782815 4281638640 4278223849 4278223849 4278223849 4278224106 4284133619 4278348735 4284901482 4291480266 4290295992 4289901234 4289374890 4288914339 4288387995 4287337370 4280057289 4279600088 4281835503 4282689009 4282097645 4282294251 4282425579 4278348735 4284901482 4291480266 4290295992 4290032820 4289572269 4289111718 4288716960 4287927444 4285625720 4283604181 4278220498 4281572332 4278218436 4278482381 4278218435 4079241345 4284901482 4291480266 4290295992 4290295992 4289835441 4289309097 4286743170 4288322460 4292467419 4293454314 4286230746 4278219466 4278218951 4293520107 4288190874 814056837 4284901482 4291480266 4290361785 4290624957 4288124824 4288454561 4291875283 4292533470 4292730592 4292796385 4292862178 4288002776 4283209424 4292665056 4286875272 495223940 4284901482 4291743438 4289177769 4288783012 4291283661 4291612369 4291743954 4291743955 4291809747 4291809747 4291809747 4291809747 4291809747 4291612626 4285690998 176193664 3309849418 4286282878 4284967275 4285033068 4285098861 4285098861 4285098861 4285098861 4285164654 4285164654 4285164654 4285164654 4285164654 4285098861 3326889805 41975936 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:23'!smallQuitNoSaveIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 4284967526 4290098613 4288124823 4287401100 4286677377 4286085240 4285558896 4285295724 4294111985 4294243570 4294375157 4294506743 4294506743 4293980912 4287730575 369098751 4284967526 4290493371 4288585374 4287730065 4287137928 4286545791 4286019447 4285756275 4294111985 4294309365 4294572537 4294769915 4294769916 4294638330 4289375144 587202559 4284967526 4291217094 4289111718 4288387995 4287664272 4287137928 4286677377 4286282619 4294111985 4294375157 4294638330 4293435552 4292297797 4294704123 4289835696 654311423 4284967526 4291282887 4289572269 4289045925 4288387995 4287730065 4287203721 4286808963 4294177777 4294374642 4292768627 4292697180 4291428352 4294237146 4290091673 988390307 4284967526 4291414473 4289769648 4289243304 4288716960 4288190616 4287664272 4287203721 4294043878 4292100674 4293160558 4294554547 4292292400 4292026402 4291695379 4173529088 4284967526 4291480266 4289835441 4289374890 4288848546 4288322202 4287795858 4287921276 4291629331 4293423730 4294481302 4294482843 4294550178 4294550435 4294616999 4240637952 4284967526 4291480266 4289967027 4289506476 4288980132 4288519581 4288836982 4291035136 4293618282 4294276470 4294069839 4294070609 4294071124 4294071637 4294482586 4240703488 4284967526 4291480266 4290164406 4289638062 4289177511 4288585374 4290707456 4292818744 4294140000 4293796644 4293724943 4293591040 4293525504 4293656576 4294343547 4240703488 4284967526 4291480266 4290295992 4289835441 4289243304 4288716960 4288775557 4290772992 4292814633 4293932085 4293459968 4293459968 4293459968 4293525504 4294138458 4240637952 4284967526 4291480266 4290295992 4289901234 4289374890 4288914339 4288387995 4288318347 4291370268 4292351255 4293867320 4294001733 4293737276 4293606975 4293607489 4257415168 4284967526 4291480266 4290295992 4290032820 4289572269 4289111718 4288716960 4287927444 4286083697 4292170578 4291952640 4293669684 4291035136 4291625991 4290969600 3368550400 4284967526 4291480266 4290295992 4290295992 4289835441 4289309097 4286743170 4288388250 4292467673 4293520104 4292508538 4291428352 4291231744 4293585897 4288256664 436207615 4284967526 4291480266 4290361785 4290624957 4288125079 4288586140 4291941328 4292665050 4292796637 4292862430 4292928223 4292384661 4291841612 4292731100 4287006852 268435455 4284967526 4291743438 4289243559 4288914593 4291415495 4291678668 4291875534 4291875790 4291875791 4291875791 4291875791 4291875791 4291875791 4291809996 4285822578 100663295 2238541675 4286348923 4285098855 4285164648 4285230441 4285230441 4285230441 4285230441 4285296234 4285296234 4285296234 4285296234 4285296234 4285230441 2255647856 33554431 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:20'!smallRedoIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282691328 860270336 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282691328 4282691328 1128640256 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282691328 4289526392 4282691328 1094955264 16777215 16777215 16777215 16777215 16777215 16777215 16777215 122271232 1178971904 2655301120 3477384960 4282691328 4282691328 4289526392 4289526392 4282691328 1094955264 16777215 16777215 16777215 16777215 16777215 910339840 2974068224 3298668032 3719096654 4289591414 4289591671 4289919871 4289001324 4285128704 4289526392 4282691328 1094955264 16777215 16777215 16777215 1246081024 3359944448 4256228425 4289722227 4288737880 4288866048 4288866048 4288866048 4288866048 4285128704 4285128704 4289526392 4282691328 998676224 16777215 725725696 3125128960 4289586251 4289853296 4289128704 4288080156 4288866048 4288866048 4290044672 4285128704 4285128704 4285128704 4285260032 4289526392 4282691328 16777215 2655301120 3936735531 4289852778 4289194502 4290044672 4290044672 4291877888 4285586944 4285128704 4285128704 4285128704 4285128704 4286901554 4282691328 1094955264 16777215 3662721792 4289917550 4290701860 4292009728 4288537088 4288931328 4288931328 4288931328 4288931328 4292864000 4285128704 4286901554 4282691328 1094955264 16777215 16777215 4048204032 4289983599 4292141312 4272009984 4282691328 4282691328 4282691328 4282691328 4282691328 4292075264 4286901554 4282691328 1094955264 16777215 16777215 16777215 4282691328 4290964552 4289116160 4047810304 1933946624 809873152 16777215 16777215 4282691328 4286901554 4282691328 1094955264 16777215 16777215 16777215 16777215 4282691328 4256752690 4282691328 1212395008 16777215 16777215 16777215 16777215 4282691328 4282691328 860270336 16777215 16777215 16777215 16777215 16777215 4282691328 4122863670 4265914112 16777215 16777215 16777215 16777215 16777215 4282691328 860270336 16777215 16777215 16777215 16777215 16777215 16777215 3242438144 3333936384 3466506240 1212395008 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1581559808 2253699584 2529681430 2359929600 205564416 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 541634304 1782820864 1531162112 491171840 79675136 61516288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:39'!smallRightFlushIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2862522779 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2862522779 16777215 16777215 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4289638062 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4289638062 4289440683 4289440683 4289440683 4289440683 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294440950 4294440950 4294440950 4294375157 4294309365 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294375157 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4289440683 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294309364 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572536 4294375157 4294309365 4294309364 4294243571 4294177778 4294111985 4294046193 4294177779 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572536 4294506743 4294440950 4294375157 4294309365 4294309365 4294243572 4294177779 4294177778 4294111985 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294440950 4294375158 4294309365 4294309365 4294309364 4289440683 4289309097 4289309097 4289309097 4293848814 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294375157 4294309365 4294309364 4294243571 4294177779 4293980400 4293914607 4293848814 4293783021 4293980399 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294967295 4288454554 16777215 16777215 2862522779 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 2862522780 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/20/2010 18:48'!smallSaveAsIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 2088343690 2119535780 1866038431 2352512158 3560536991 4281957279 4165041566 3847390612 2237959310 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1581744805 2120722634 1569307355 3451508718 4292273651 4291617521 4288990696 4252212658 4249387676 461084520 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4287143846 4285694857 4283662745 4282615725 4282813362 4289252322 4291355120 4283799744 4284120721 4286677886 4286677886 4286677886 4286677886 4287796623 16777215 16777215 4287534739 4294967295 4293126109 4291944164 4286032581 4281957279 4289975786 4288464094 4284256430 4292601323 4294967295 4294967295 4294967295 4287862160 16777215 16777215 4287994512 4294046193 4294046193 4293257444 4286818752 4281957279 4286756567 4288266713 4282416802 4290234575 4294046193 4293980657 4293980657 4287862160 16777215 16777215 4287862160 4293914864 4281957279 4281957279 4281957279 4281957279 4286756567 4284195788 4281957279 4281957279 4281957279 4281957279 4293980400 4287862160 16777215 16777215 4287862160 4293783022 4292073678 4281957279 4288793573 4286230477 4286230477 4286230477 4286361550 4288661474 4281957279 4288854206 4293848558 4287862160 16777215 16777215 4287862160 4294704123 4293519849 4291810762 4281957279 4288793573 4286361550 4286361550 4290040551 4281957279 4288656827 4293519849 4294375158 4287862160 16777215 16777215 4287862160 4294046193 4294704123 4293519849 4291810762 4281957279 4290106858 4288793573 4282154659 4288656827 4293519849 4294704123 4294046193 4287862160 16777215 16777215 4287862160 4293519849 4294046193 4294704123 4294704123 4292271570 4282613922 4281957279 4289182914 4294704123 4294835709 4294046193 4293519849 4287862160 16777215 2158208927 4289901488 4289835952 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 2158208927 4286677886 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4278190080 4294967295 4294967295 4286677886 4286677886 4294967295 4290625211 4294967295 4290625212 4294967295 4290625211 4294967295 4290625211 4294967295 4291085763 4294967295 4278190080 4294967295 4294967295 4286677886 4286677886 4294967295 4291085763 4294967295 4291085763 4294967295 4291085763 4294967295 4291085763 4294967295 4291085763 4294967295 4278190080 4294967295 4294967295 4286677886 4286677886 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4278190080 4294967295 4294967295 4286677886 2155971454 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 2155971454)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/21/2010 20:30'!smallSaveIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 2089200540 2119802550 1865322161 2351730865 3559886514 4281306802 4164849841 3847723431 2238554017 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1581749686 2120857815 1569835238 3451969523 4292602614 4292012277 4289452015 4252872386 4249392559 461679227 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4287999926 4286748316 4284126380 4282227390 4282424771 4289779178 4291749876 4283738575 4284780964 4287862160 4287862160 4287862160 4287862160 4288849568 16777215 16777215 4288587684 4294967295 4293455075 4292404714 4286495186 4281306802 4290436848 4288991207 4284654271 4292930288 4294967295 4294967295 4294967295 4288980641 16777215 16777215 4289047457 4294243572 4294243572 4293586409 4287477965 4281306802 4287218657 4288859618 4282159540 4290892761 4294243572 4294178036 4294178036 4288980641 16777215 16777215 4288980641 4294112243 4281306802 4281306802 4281306802 4281306802 4287218657 4284068825 4281306802 4281306802 4281306802 4281306802 4294177779 4288980641 16777215 16777215 4288980641 4294046193 4292534487 4281306802 4289254892 4286693081 4286693081 4286693081 4286823898 4289188586 4281306802 4289578443 4294111729 4288980641 16777215 16777215 4288980641 4294769916 4293783021 4292337107 4281306802 4289254892 4286823898 4286823898 4290567150 4281306802 4289446856 4293783021 4294506744 4288980641 16777215 16777215 4288980641 4294243572 4294769916 4293783021 4292337107 4281306802 4290567664 4289254892 4281635253 4289446856 4293783021 4294769916 4294243572 4288980641 16777215 16777215 4288980641 4293783021 4294243572 4294769916 4294769916 4292732122 4282422196 4281306802 4289907150 4294769916 4294835709 4294243572 4293783021 4288980641 16777215 16777215 4288980641 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294506744 4294506744 4294111986 4294111986 4293783021 4288980641 16777215 16777215 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 16777215 16777215 4288980641 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4288980641 16777215 16777215 4288980641 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4288980641 16777215 16777215 4288980641 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4288980641 16777215 16777215 4288849568 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4288849568 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/20/2010 18:48'!smallSaveNewIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 2089200540 2119802550 1865322161 2351730865 3559886514 4281306802 4164849841 3847723431 2238554017 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1581749686 2120857815 1569835238 3451969523 4292602614 4292012277 4289452015 4252872386 4249392559 461679227 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4287999926 4286748316 4284126380 4282227390 4282424771 4289779178 4291749876 4283738575 4284780964 4287862160 4287862160 4287862160 4287862160 4288849568 16777215 16777215 4288587684 4294967295 4293455075 4292404714 4286495186 4281306802 4290436848 4288991207 4284654271 4292930288 4294967295 4294967295 4294967295 4288980641 16777215 16777215 4289047457 4294243572 4294243572 4293586409 4287477965 4281306802 4287218657 4288859618 4282159540 4290892761 4294243572 4294178036 4294178036 4288980641 16777215 16777215 4288980641 4294112243 4281306802 4281306802 4281306802 4281306802 4287218657 4284068825 4281306802 4281306802 4281306802 4281306802 4294177779 4288980641 16777215 16777215 4288980641 4294046193 4292534487 4281306802 4289254892 4286693081 4286693081 4286693081 4286823898 4289188586 4281306802 4289578443 4294111729 4288980641 16777215 16777215 4288980641 4294769916 4293783021 4292337107 4281306802 4289254892 4286823898 4286823898 4290567150 4281306802 4289446856 4293783021 4294506744 4288980641 16777215 16777215 4288980641 4294243572 4294769916 4293783021 4292337107 4281306802 4290567664 4289254892 4281635253 4289446856 4293717228 4294704123 4294177779 4288980641 16777215 16777215 4288980641 4293783021 4294243572 4294769916 4294769916 4292732122 4282422196 4281306802 4289907150 4294769916 4294901502 4285890304 4294638330 4288980641 16777215 16777215 4288980641 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294440951 4294835709 4285890304 4294508288 4285890304 4293190883 16777216 16777215 4288980641 4292598747 4292598747 4292598747 4292598747 4292467161 4292598747 4292598747 4294243572 4285890304 4289311744 4294508288 4289311744 4285890304 3003121663 16777215 4288980641 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4285890304 4294508288 4294508288 4294508288 4294508288 4294508288 4285890304 16777215 4288980641 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4293783021 4285890304 4289311744 4294508288 4289311744 4285890304 3003121663 16777215 4288980641 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4293783021 4285890304 4294508288 4285890304 4293190883 16777215 16777215 4288849568 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4292796381 4285890304 4292796381 4288849568 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/21/2010 22:00'!smallScreenshotIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 1982540587 4283392626 4284446346 4284446346 4284446346 4265561434 1462117926 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282009685 4294967295 4294967295 4294967295 4294967295 4278190079 4282075478 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282010199 4292209663 4294967295 4294967295 4294967295 4289649663 4282075478 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281483596 4285105307 4288332514 4288859118 4289649151 4285237151 4282207836 16777215 16777215 16777215 16777215 2738567995 4283524727 4283129455 4282339422 4282471266 4282997611 4287410126 16777215 16777215 16777215 4288595688 4281088066 4282207836 4282339422 4283393141 2738567995 4284315017 4291028223 4290371327 4294967295 4294967295 4289649663 4287871704 4288793068 4289123060 4289583358 4289649151 4291553535 4289649151 4291028223 4291815679 4262992929 4284907927 4289649663 4284578703 4289386490 4289649663 4288595688 4291422207 4292472319 4291815679 4289649663 4288464102 4288464102 4287673812 4285500581 4290633983 4262992929 4284512397 4289452028 4284578703 4285830059 4288661482 4291028223 4290043391 4288661482 4288201184 4288201184 4287805142 4289386490 4285895853 4283524727 4289649663 4262992929 4284248967 4289188854 4284578703 4286093489 4289452028 4288135134 4288595688 4284512397 4281351496 4283656571 4287673812 4286159027 4288398052 4284117381 4289649663 4262992929 4284248967 4289188854 4284578703 4286093489 4288595688 4285500581 4281614926 4280429620 4279440147 4279440147 4281483596 4285105307 4285500581 4285171101 4289452028 4262992929 4284248967 4289188854 4284578703 4286685886 4285632423 4282997611 4282405472 4294967295 4289649663 4283393141 4281219910 4284973977 4285171101 4286356407 4289452028 4262795547 4284248967 4289188854 4284578703 4287476176 4285171101 4281746770 4283393141 4289649663 4294047999 4291422207 4284248967 4286159027 4285237151 4285830059 4289386490 4262795547 4284248967 4289188854 4284644497 4286685372 4285171101 4283063661 4279440147 4285961903 4292997631 4292866559 4286817728 4287673812 4285237151 4285961903 4288661482 4262269971 4283854207 4287937498 4288332771 4288003291 4288332514 4284842133 4280693050 4283524727 4284248967 4287410126 4290239999 4288201184 4288464102 4287015107 4286357176 4198056779 2738567995 4283854207 4283392626 4283392626 4262335254 4285171101 4285434531 4283393141 4284315017 4286093489 4284512397 4284051331 4283524727 4283392626 4283392369 2738567995 16777215 16777215 16777215 16777215 1261844022 2218408506 3578481483 4250166386 4283985793 4250166386 3595324751 1849178168 858927666 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:28'!smallSearchIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 2844298120 4118971263 4270032000 4286677886 4102062717 2542571658 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1049398408 4169171584 4275361492 4292993763 4275887841 4292468193 4292796385 4275360979 4152328574 982356365 16777215 16777215 16777215 16777215 16777215 898667920 4269966464 4292993762 4188256462 4051150803 4202607067 4286296026 4050822352 4188584911 4293190884 4253123454 832018322 16777215 16777215 16777215 16777215 4118774141 4292993505 4204180946 4269518811 3989823728 3957780472 4242861558 3736589034 4252741594 4187666386 4293059298 4085153916 16777215 16777215 16777215 1989120396 4206278581 4188782032 4269518810 3890014453 3958108664 4042257914 4243058680 3705071349 3265316323 4269453018 4189701845 4155683760 1871811470 16777215 16777215 4286348921 4292993504 4285571534 4189508073 4225821173 4226149879 4209504247 4293258742 4040549618 3616191967 3850022619 4287476438 4292927711 4286348921 16777215 16777215 4269900670 4292862434 4286230234 3418150637 3453149937 3336103923 3235703028 3856394484 1854058716 2054926555 2340269274 4286230234 4293454056 4269900670 16777215 16777215 4202725756 4293256677 4269846745 3013262819 3049314029 2999902193 2580077294 2762853096 1517990106 1820176348 2189209564 4235700950 4293059298 4185883004 16777215 16777215 3348469650 4224700367 4237407702 3312690387 2340269274 1970974426 1585098972 1920839387 1333702363 1702801116 3211500488 4254447831 4174631890 3231094675 16777215 16777215 1654103191 3801388691 4292403431 4286296026 2558111192 2004528861 1652207325 2172366553 1434169051 2071374035 4286296026 4292468967 3933895800 2122877572 16777215 16777215 16777215 3883761531 3971463351 4291024100 4286296026 3496384451 1987685334 2742594518 3445920446 4286361562 4291811035 4272203427 4120418711 4068179065 426141286 16777215 16777215 781949846 4152328572 3819086754 4292995310 4288790749 4269977817 4286296026 4288856541 4292666346 4252860027 4291151300 4288125334 4253518213 3917052791 813727872 16777215 16777215 781949846 3833430139 3700527759 3802177952 4073573837 4293256677 3634076827 3782703477 1668247407 4286611838 4291085506 4288322970 4258386385 4286546045 16777215 16777215 16777215 16777215 1637391254 3063520407 4118774140 4286546300 3063520407 1637391254 16777215 2256436862 4286546045 4292203988 4292796126 4286546045 16777215 16777215 16777215 16777215 33554432 67108864 83886080 100663296 100663296 117440512 100663296 100663296 1685419381 4269834365 4286546045 1451262077 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 17:09'!smallTimerIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 4288526525 4116212343 4116212343 4288526525 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4284515726 4284515726 4284515726 4284515726 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4284515726 4284515726 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2639020888 4116212343 4284449675 4284515726 4284909712 3377418592 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1414084431 4149767289 4288526525 4291550689 4292208362 4292274155 4291419360 4288525497 4284515981 1414084431 16777215 16777215 16777215 16777215 16777215 1414084431 4267474568 4291090909 4291286488 4291875796 4284534498 4284534498 4293322728 4291877082 4291090909 4284450703 1414084431 16777215 16777215 16777215 16777215 4099434870 4291090909 4290693837 4292798956 4284534498 4284534498 4284534498 4294046451 4293849072 4290693837 4291090909 4099434870 16777215 16777215 16777215 2639020888 4288526525 4291089366 4292730334 4278190080 4284534498 4284534498 4284534498 4294178037 4293914865 4292730334 4291089366 4288526525 2639020888 16777215 16777215 3931463791 4291550689 4290561222 4294046451 4293522164 4278190080 4285054413 4284534498 4294178037 4293980401 4294046451 4290561222 4291550689 4285369491 75530240 16777215 4284450446 4292208362 4291415245 4293980401 4294243573 4294310137 4278190080 4280778896 4293190885 4293914865 4293914608 4294440951 4292076519 4284582032 16777215 16777215 3931463791 4291550689 4290363586 4294243573 4293717229 4293783279 4284966759 4278190080 4293651693 4293454314 4294506745 4294046194 4291550689 4284842635 16777215 16777215 2639020888 4288526525 4290497486 4293651436 4294046193 4293717229 4294506745 4293585900 4293454057 4294111987 4294506744 4292272611 4288526525 4066077045 16777215 16777215 16777215 4116146551 4291090909 4289838785 4293980401 4294309365 4293717229 4293191142 4293783279 4294309366 4293323499 4291090909 4284712333 890442520 16777215 16777215 16777215 1731932739 4284251783 4291090909 4290562765 4291678674 4294309366 4294177780 4294375159 4292600805 4291090909 4284581518 3493280325 1325400064 67108864 16777215 16777215 385875968 2385323570 4216680057 4288526525 4291550689 4292208362 4292274155 4291550689 4288526525 4284514697 3593219383 2147483648 1090519040 16777215 16777215 16777215 16777215 520093696 1509949440 3493476934 4233325429 4284383883 4284450703 4284185988 4064366169 2650800128 2097152000 939524096 33554432 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/21/2010 23:21'!smallTrafficIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 422804152 4281694648 4281694648 4281694648 4281694648 4281694648 4281694648 422804152 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4289448421 4292255918 4293546071 4293546071 4292255918 4289448421 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4293546071 4294836738 4294836738 4293546071 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4293546071 4294836738 4294836738 4293546071 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4292255918 4293546071 4293546071 4292255918 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4292265390 4293569111 4293569111 4292265390 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4293569111 4294872578 4294872578 4293569111 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4293569111 4294872578 4294872578 4293569111 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4292265390 4293569111 4293569111 4292265390 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4287747246 4282960727 4282960727 4287747246 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4282960727 4278370818 4278370818 4282960727 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4282960727 4278370818 4278370818 4282960727 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4289448421 4287747246 4282960727 4282960727 4287747246 4289448421 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 808811194 4281694648 4281694648 4281694648 4281694648 4281694648 4281694648 808811194 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:20'!smallUndoIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 4292129024 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 348959488 4292129024 4292129024 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 295077632 4292129024 4294834103 4292129024 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 295077632 4292129024 4294834103 4294962176 4292129024 4292129024 3889082880 3486232576 2764878080 193694464 16777215 16777215 16777215 16777215 16777215 295077632 4292129024 4294834103 4294633738 4294896384 4294832763 4294832503 4294635126 4177194867 3570184704 3587224576 479367680 16777215 16777215 16777215 177838336 4292129024 4294834103 4294633472 4294699535 4294370304 4294633472 4294370304 4293646336 4294107683 4294635120 4276869437 3838882816 848269056 16777215 16777215 4292129024 4294834103 4294633472 4294765071 4294699535 4294699535 4294633472 4294370304 4293909760 4293909760 4293909760 4294107683 4293515323 3402478080 177838336 16777215 295077632 4292129024 4294832770 4294765071 4294567680 4292988160 4292988160 4292988160 4293909760 4293909760 4293909760 4293448704 4294438002 4174625536 3419123968 16777215 16777215 295077632 4292129024 4294832766 4293185536 4294832766 4294766704 4294766704 4294766704 4294766704 4294764032 4293448704 4293054208 4294042744 4107187200 16777215 16777215 16777215 295077632 4292129024 4294832766 4294832766 4292129024 4292129024 4292129024 4292129024 4292000000 4294175095 4293448960 4294372208 4174361600 16777215 16777215 16777215 16777215 295077632 4292129024 4294832766 4292129024 16777215 16777215 819310336 1355393280 3386159616 4294569333 4294240640 4291867648 16777215 16777215 16777215 16777215 16777215 16777215 4292129024 4292129024 16777215 16777215 16777215 16777215 449753344 4292262912 4277595539 4291932928 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4292129024 16777215 16777215 16777215 16777215 16777215 4275681792 4277134179 4023367168 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 584233984 4242919490 4276277570 2144319232 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1574154752 3002197102 2933044736 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1775351296 1775482368 416658688 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:20'!smallWindowIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 1556466370 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 1556466370 16777215 16777215 16777215 16777215 4291217859 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4291217859 16777215 16777215 16777215 16777215 4291217859 4294901502 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4294835709 4291217859 16777215 16777215 16777215 16777215 4291217859 4294835708 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4294769916 4291217859 16777215 16777215 16777215 16777215 4291217859 4294704379 4294638330 4294638330 4293388774 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 1556466370 4291217859 4294572537 4294506744 4294441208 4291217859 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4291217859 4291217859 4294572537 4294374901 4294309365 4291217859 4294901502 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4294835709 4291217859 4291217859 4294309365 4294046193 4294111986 4291217859 4294835708 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4294769916 4291217859 4291217859 4294111987 4293914350 4293848814 4291217859 4294704379 4294638330 4294638330 4294638330 4294572793 4294572537 4294572537 4294572537 4294572537 4294572793 4291217859 4291217859 4294046449 4293585643 4293585642 4291217859 4294572537 4294506744 4294441208 4294506488 4294506744 4294506487 4294440951 4294506487 4294506487 4294572537 4291217859 4291217859 4294374901 4294112242 4294177522 4291217859 4294572537 4294374901 4294309365 4294309365 4294309365 4294243829 4294309365 4294309365 4294374901 4294506744 4291217859 1589888702 4291217859 4291217859 4291217859 4291217859 4294309365 4294046193 4294111986 4294111986 4294111986 4294111986 4294111986 4294111986 4294046193 4294243828 4291217859 16777215 16777215 16777215 16777215 4291217859 4294111987 4293914350 4293848814 4293848814 4293848814 4293783021 4293848814 4293848557 4293848558 4294111986 4291217859 16777215 16777215 16777215 16777215 4291217859 4294046449 4293585643 4293585642 4293585898 4293585642 4293585642 4293585642 4293585642 4293585642 4294046193 4291217859 16777215 16777215 16777215 16777215 4291217859 4294374901 4294112242 4294177522 4294111986 4294112243 4294111986 4294111986 4294177522 4294111986 4294111986 4291217859 16777215 16777215 16777215 16777215 1589888702 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 1556466370)	offset: 0@0)! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/2/2010 16:11'!contentString: aString 	aString 		ifNil: [self removeProperty: #contentString]		ifNotNil: [self setProperty: #contentString toValue: aString]! !!MenuMorph methodsFor: 'accessing' stamp: 'nice 8/27/2010 22:00'!lastSelection	"Return the label of the last selected item or nil."	^selectedItem ifNotNil: [selectedItem selector]! !!MenuMorph methodsFor: 'construction' stamp: 'MAD 1/2/2011 00:38'!addStayUpIcons	| title closeBox pinBox titleBarArea titleString |	title := submorphs				detect: [:ea | ea hasProperty: #titleString]				ifNone: [self setProperty: #needsTitlebarWidgets toValue: true.					^ self].	closeBox := SystemWindowButton new target: self;				 actionSelector: #delete;				 labelGraphic: self class closeBoxImage;				 color: Color transparent;				 extent: 14 @ 16;				 borderWidth: 0.	pinBox := SystemWindowButton new target: self;				 actionSelector: #stayUp:;				 arguments: {true};				 labelGraphic: self class pushPinImage;				 color: Color transparent;				 extent: 16 @ 16;				 borderWidth: 0.	Preferences noviceMode		ifTrue: [closeBox setBalloonText: 'close this menu'.			pinBox setBalloonText: 'keep this menu up'].	titleBarArea :=  AlignmentMorph newRow vResizing: #shrinkWrap;			 layoutInset: 3;			 color: Preferences menuTitleColor;			 addMorphBack: closeBox;			 addMorphBack: title;			 addMorphBack: pinBox.		title color: Color transparent.	titleString := title 		findDeepSubmorphThat: [:each | each respondsTo: #font: ]		ifAbsent: [StringMorph contents: String empty].	titleString font: Preferences windowTitleFont.	Preferences roundedMenuCorners		ifTrue: [titleBarArea useRoundedCorners].		self addMorphFront: titleBarArea.	titleBarArea setProperty: #titleString toValue: (title valueOfProperty: #titleString).	title removeProperty: #titleString.	self setProperty: #hasTitlebarWidgets toValue: true.	self removeProperty: #needsTitlebarWidgets.	self removeStayUpItems! !!MenuMorph methodsFor: 'construction' stamp: 'nice 6/11/2010 21:52'!labels: labelList lines: linesArray selections: selectionsArray 	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelArray := (labelList isString) 				ifTrue: [labelList lines]				ifFalse: [labelList]. 	1 to: labelArray size		do: 			[:i | 			self add: (labelArray at: i) action: (selectionsArray at: i).			(linesArray includes: i) ifTrue: [self addLine]]! !!MenuMorph methodsFor: 'control' stamp: 'cmm 1/11/2011 21:04'!popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 	"Present this menu at the given point under control of the given 	hand."	| evt |	aWorld submorphs		select: [:each | (each isKindOf: MenuMorph)				and: [each stayUp not]]		thenCollect: [:menu | menu delete].	self items isEmpty		ifTrue: [^ self].	MenuIcons decorateMenu: self.	(self submorphs		select: [:m | m isKindOf: UpdatingMenuItemMorph])		do: [:m | m updateContents].	"precompute width"	self		positionAt: aPoint		relativeTo: (selectedItem				ifNil: [self items first])		inWorld: aWorld.	aWorld addMorphFront: self.	"Acquire focus for valid pop up behavior"	hand newMouseFocus: self.	aBoolean		ifTrue: [hand newKeyboardFocus: self.			self showKeyboardHelp].	evt := hand lastEvent.	(evt isKeyboard			or: [evt isMouse					and: [evt anyButtonPressed not]])		ifTrue: ["Select first item if button not down"			self moveSelectionDown: 1 event: evt			"Select first item if button not down"].	self updateColor.	self changed! !!MenuMorph methodsFor: 'control' stamp: 'ul 11/15/2010 11:53'!wantsToBeDroppedInto: aMorph	"Return true if it's okay to drop the receiver into aMorph.  A single-item MenuMorph is in effect a button rather than a menu, and as such should not be reluctant to be dropped into another object."	^ (aMorph isWorldMorph or: [submorphs size = 1]) or:		[Preferences systemWindowEmbedOK]! !!MenuMorph methodsFor: 'keyboard control' stamp: 'cmm 1/11/2011 21:07'!keyStroke: evt 	self hideKeyboardHelp; noteRootMenuHasUsedKeyboard.	self keyStrokeHandlers		detect: [:each | self perform: each with: evt]		ifNone: [self handleFiltering: evt]! !!MenuMorph methodsFor: 'keystroke helpers' stamp: 'cmm 1/11/2011 21:08'!handleFiltering: evt	| matchString |	matchString := self valueOfProperty: #matchString ifAbsentPut: [ String new ].	matchString := evt keyValue = 8 " Character backspace asciiValue "		ifTrue: [			matchString isEmpty 				ifTrue: [ matchString ] 				ifFalse: [ matchString allButLast ] ]		ifFalse: [			matchString copyWith: evt keyCharacter ].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt! !!MenuMorph methodsFor: 'keystroke helpers' stamp: 'cmm 1/11/2011 21:06'!hideKeyboardHelp	self deleteBalloon! !!MenuMorph class methodsFor: 'images' stamp: 'MAD 1/2/2011 00:27'!pushPinImage	"Answer the push-pin image, creating and caching it at this time if it is absent"	^ MenuIcons smallPinIcon! !!MenuMorph class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 11:53'!fromArray: anArray 	"Construct a menu from anArray. The elements of anArray  	must be either:  	* A pair of the form: <label> <selector>  	or	* The 'dash' (or 'minus sign') symbol  	 	Refer to the example at the bottom of the method"	| menu |	menu := self new.	anArray		do: [:anElement |			anElement size = 1				ifTrue: [					anElement == #- ifFalse: [^ self error: 'badly-formed menu constructor'].					menu addLine.				]				ifFalse: [					anElement size = 2 ifFalse: [^ self error: 'badly-formed menu constructor'].					menu add: anElement first action: anElement second.				]		].	^ menu! !!MenuStub methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2006 10:43'!click: aString	| item |	item := self items detect: [:ea | ea label = aString] ifNone: [^ self].	item action isSymbol		ifTrue: [self model perform: item action]		ifFalse: [item action value]! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForStorePop: stack encoder: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self emitCodeForEffect: stack encoder: encoder! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self sizeCodeForEffect: encoder! !!MessageNames methodsFor: 'search' stamp: 'ul 7/9/2011 16:08'!computeSelectorListFromSearchString	"Compute selector list from search string. The searchString is a list of expressions separated by ;. Each expression is matched individually. An expression can be a simple string (same as *expression*), a string with double quotes (exact match) or a match expression (see String >> #match:)."		searchString := searchString asString copyWithout: $ . "?dubious?"	^selectorList := Cursor wait showWhile: [		(Array streamContents: [ :stream |			(searchString findBetweenSubStrs: ';') do: [ :selPat |				(selPat first = $" and: [ selPat last = $" and: [ selPat size > 2 ] ])					ifTrue: [						Symbol 							hasInterned: (selPat copyFrom: 2 to: selPat size - 1)							ifTrue: [ :sym | stream nextPut: sym ] ]					ifFalse: [						| raw n m |						n := selPat occurrencesOf: $*.						m := selPat occurrencesOf:  $#.						raw := ((n > 0 or: [ m > 0 ]) 	and: [ selPat size > (n + m) ])							ifTrue: [ Symbol selectorsMatching: selPat ]							ifFalse: [ Symbol selectorsContaining: selPat ].						stream nextPutAll: raw ] ] ]) 			sort: [ :x :y | x caseInsensitiveLessOrEqual: y ] ]! !!MessageNames methodsFor: 'selection' stamp: 'fbs 3/24/2011 17:53'!selectedMessageName	selectorList ifNil: [^ nil].	^selectorListIndex = 0 ifFalse: [selectorList at: selectorListIndex ifAbsent: [nil]]! !!MessageNames methodsFor: 'selector list' stamp: 'ul 11/15/2010 11:53'!messageList	"Answer the receiver's message list, computing it if necessary. The way 	to force a recomputation is to set the messageList to nil"	messageList		ifNil: [messageList := selectorListIndex = 0						ifTrue: [#()]						ifFalse: [self systemNavigation								allImplementorsOf: (selectorList at: selectorListIndex)].			self				messageListIndex: (messageList size > 0						ifTrue: [1]						ifFalse: [0])].	^ messageList! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:47'!buildSearchPaneWith: builder	| buttonFrame buttonSpec textFrame textSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttonFrame := LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.3 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	textFrame := LayoutFrame new		leftFraction: 0.3 offset: 1;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	buttonSpec := builder pluggableActionButtonSpec new.	buttonSpec 		model: self;		label: 'Search';		action: [self doSearchFrom: searchPane];		frame: buttonFrame.	top children add: buttonSpec.		textSpec := builder pluggableInputFieldSpec new.	textSpec 		model: self;		name: #search;		getText: #searchString; 		setText: #searchString:notifying:;		frame: textFrame.	top children add: textSpec.	^top! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/23/2010 10:29'!buildWith: builder	"ToolBuilder open: MessageNames new"	| searchPaneHeight windowSpec max result |	searchPaneHeight := self buttonHeight.	max := self wantsOptionalButtons ifTrue:[0.42] ifFalse:[0.5].	windowSpec := self buildWindowWith: builder specs: {		(self topConstantHeightFrame: searchPaneHeight fromLeft: 0 width: 0.5) -> [self buildSearchPaneWith: builder].		(self selectorListFrame: max fromTop: searchPaneHeight) -> [self buildSelectorListWith: builder].		(0.5@0.0 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	result := builder build: windowSpec.	searchPane := builder widgetAt: #search.	^result! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:44'!selectorListFrame: max fromTop: topOffset	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: topOffset;		rightFraction: 0.5 offset: 0;		bottomFraction: max offset: 0.! !!MessageNames methodsFor: 'class list' stamp: 'fbs 3/24/2011 17:54'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	self hasMessageSelected ifTrue:		[ ^ self setClassAndSelectorIn: [:c :s | ^c] ].		(selectorListIndex isNil not and: [selectorListIndex > 0]) ifTrue: [^Smalltalk classNamed: (self selectorList at: selectorListIndex)].		^ nil.	! !!MessageNames methodsFor: 'as yet unclassified' stamp: 'fbs 6/7/2011 17:40'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !!MessageNames class methodsFor: 'instance creation' stamp: 'fbs 3/23/2011 21:40'!openMessageNames	"Open a new instance of the receiver in the active world"	^(ToolBuilder open: self new label: 'Message Names') model	"MessageNames openMessageNames"! !!MessageNamesTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/23/2011 21:40'!setUp	browser := MessageNames openMessageNames.! !!MessageNamesTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/23/2011 21:40'!tearDown	ToolBuilder default close: browser topView.! !!MessageNamesTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/24/2011 07:36'!testCannotUnselectCategory	| selectorList |	browser searchString: 'cull'.	browser selectorListIndex: 1.	selectorList := browser selectorList copy.		browser selectorListIndex: 0.	self assert: selectorList = browser selectorList.! !!MessageNamesTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/23/2011 21:40'!testOpenMessageNames	| b |	b := MessageNames openMessageNames.	[self assert: (b isKindOf: MessageNames)]		ensure: [ToolBuilder default close: b topView].! !!MessageNamesTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/23/2011 21:48'!testSearchString	| cCount cullCount cullCullCount |	browser searchString: 'c'.	cCount := browser selectorList size.		browser searchString: 'cull:'.	cullCount := browser selectorList size.		self assert: cullCount < cCount.		browser searchString: 'cull:cull:'.	cullCullCount := browser selectorList size.		self assert: cullCullCount < cullCount.! !!MessageNamesTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/29/2011 16:55'!testSelectedClassOrMetaClass	| firstClass |	browser searchString: 'cull'.	firstClass := browser messageList first actualClass.		browser messageListIndex: 1.	self assert: browser selectedClassOrMetaClass = firstClass.		browser messageListIndex: 0.	self assert: browser selectedClassOrMetaClass isNil.		"And just to be sure:"	browser messageListIndex: 1.	self assert: browser selectedClassOrMetaClass = firstClass.! !!MessageNamesTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/24/2011 07:54'!testSelectedMessageCategoryName	browser searchString: 'cull'.	browser selectorListIndex: 1.	browser messageListIndex: 1.	self deny: browser selectedMessageCategoryName isNil.	browser messageListIndex: 0.	self assert: browser selectedMessageCategoryName isNil.! !!MessageNamesTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/24/2011 17:37'!testSelection	browser searchString: 'cull'.	browser selectorListIndex: 1.	browser messageListIndex: 1.	self assert: (browser selection isKindOf: MethodReference).	browser messageListIndex: 0.	self assert: browser selection isNil.! !!MessageNode methodsFor: 'code generation' stamp: 'eem 9/29/2008 14:45'!emitCodeForCase: stack encoder: encoder value: forValue	| braceNode sizeStream allReturn |	forValue ifFalse:		[^super emitCodeForEffect: stack encoder: encoder].	braceNode := arguments first.	sizeStream := ReadStream on: sizes.	receiver emitCodeForValue: stack encoder: encoder.	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last | | thenSize elseSize |		thenSize := sizeStream next.		elseSize := sizeStream next.		last ifFalse: [encoder genDup. stack push: 1].		keyNode emitCodeForEvaluatedValue: stack encoder: encoder.		equalNode emitCode: stack args: 1 encoder: encoder.		self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.		last ifFalse: [encoder genPop. stack pop: 1].		valueNode emitCodeForEvaluatedValue: stack encoder: encoder.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse:			[self emitCodeForJump: elseSize encoder: encoder.			 allReturn := false].		(last and: [allReturn]) ifTrue:			[self emitCodeForJump: elseSize encoder: encoder]].	arguments size = 2		ifTrue:			[arguments last emitCodeForEvaluatedValue: stack encoder: encoder] "otherwise: [...]"		ifFalse:			[NodeSelf emitCodeForValue: stack encoder: encoder.			caseErrorNode emitCode: stack args: 0 encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23'!emitCodeForEffect: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: false]		ifFalse: 			[super emitCodeForEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:12'!emitCodeForIf: stack encoder: encoder value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize := sizes at: 1.	elseSize := sizes at: 2.	(forValue not and: [elseSize * thenSize > 0]) ifTrue:		"Two-armed IFs forEffect share a single pop"		[^super emitCodeForEffect: stack encoder: encoder].	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	receiver emitCodeForValue: stack encoder: encoder.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.			pc := encoder methodStreamPosition.			thenExpr emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not ifTrue:				"...not ifTrue: avoids using ifFalse: alone during this compile)"				"Elide jump over else after a return"				[self emitCodeForJump: elseSize encoder: encoder].			elseExpr emitCodeForEvaluatedValue: stack encoder: encoder]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					thenExpr emitCodeForEvaluatedEffect: stack encoder: encoder]				ifFalse:					[self emitCodeForBranchOn: true dist: elseSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					elseExpr emitCodeForEvaluatedEffect: stack encoder: encoder]]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:28'!emitCodeForIfNil: stack encoder: encoder value: forValue	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitCodeForValue: stack encoder: encoder.	forValue ifTrue: [encoder genDup. stack push: 1].	encoder genPushSpecialLiteral: nil. stack push: 1.	equalNode emitCode: stack args: 1 encoder: encoder.	self 		emitCodeForBranchOn: (selector key == ifNotNilSelector)		dist: theSize 		pop: stack 		encoder: encoder.	pc := encoder methodStreamPosition.	forValue 		ifTrue: 			[encoder genPop. stack pop: 1.			theNode emitCodeForEvaluatedValue: stack encoder: encoder]			ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'nice 2/3/2011 21:12'!emitCodeForRepeat: stack encoder: encoder value: forValue 	" L1: ... Jmp(L1)"	| loopSize |	loopSize := sizes at: 1.	receiver emitCodeForEvaluatedEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:31'!emitCodeForToDo: stack encoder: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt := arguments at: 4.	limitInit := arguments at: 7.	test := arguments at: 5.	block := arguments at: 3.	incStmt := arguments at: 6.	blockSize := sizes at: 1.	loopSize := sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitCodeForEffect: stack encoder: encoder].	initStmt emitCodeForEffect: stack encoder: encoder.	test emitCodeForValue: stack encoder: encoder.	self emitCodeForBranchOn: false dist: blockSize pop: stack encoder: encoder.	pc := encoder methodStreamPosition.	block emitCodeForEvaluatedEffect: stack encoder: encoder.	incStmt emitCodeForEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23'!emitCodeForValue: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitCodeForValue: stack encoder: encoder].			arguments do: [:argument | argument emitCodeForValue: stack encoder: encoder].			pc := encoder methodStreamPosition + 1. "debug pc is first byte of the send, i.e. the next byte".			selector				emitCode: stack				args: arguments size				encoder: encoder				super: receiver == NodeSuper]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:36'!emitCodeForWhile: stack encoder: encoder value: forValue 	"L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := sizes at: 1.	loopSize := sizes at: 2.	cond emitCodeForEvaluatedValue: stack encoder: encoder.	self emitCodeForBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"	pc := encoder methodStreamPosition.	stmt emitCodeForEvaluatedEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'nice 12/27/2009 03:11'!sizeCodeForCase: encoder value: forValue	| braceNode sizeIndex elseSize allReturn |	forValue not ifTrue:		[^super sizeCodeForEffect: encoder].	equalNode := encoder encodeSelector: #=.	braceNode := arguments first.	sizes := Array new: 2 * braceNode numElements.	sizeIndex := sizes size.	elseSize := arguments size = 2		ifTrue:			[arguments last sizeCodeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode := encoder encodeSelector: #caseError.			 (NodeSelf sizeCodeForValue: encoder)			 + (caseErrorNode sizeCode: encoder args: 0 super: false)]. "self caseError"	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last |		valueNode returns ifFalse: [allReturn := false]].	braceNode casesReverseDo:		[:keyNode :valueNode :last | | thenSize |		sizes at: sizeIndex put: elseSize.		thenSize := valueNode sizeCodeForEvaluatedValue: encoder.		last ifFalse: [thenSize := thenSize + encoder sizePop].		valueNode returns ifFalse: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		(last and: [allReturn]) ifTrue: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize := elseSize + encoder sizeDup].		elseSize := elseSize					+ (keyNode sizeCodeForEvaluatedValue: encoder)					+ (equalNode sizeCode: encoder args: 1 super: false)					+ (self sizeCode: encoder forBranchOn: false dist: thenSize)					+ thenSize.		sizeIndex := sizeIndex - 2].	^(receiver sizeCodeForValue: encoder) + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'nice 3/31/2011 00:24'!sizeCodeForEffect: encoder	special > 0 		ifTrue:			[encoder noteOptimizedSelector: originalSelector.			^self perform: (MacroSizers at: special) with: encoder with: false].	^super sizeCodeForEffect: encoder! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:15'!sizeCodeForIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	(forValue	 or: [(thenExpr isJust: NodeNil)	 or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^super sizeCodeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize := elseExpr sizeCodeForEvaluatedValue: encoder.			thenSize := (thenExpr sizeCodeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeCode: encoder forJump: elseSize]).			branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize := 0.					thenSize := thenExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]				ifFalse:					[thenSize := 0.					elseSize := elseExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: true dist: elseSize]].	sizes := Array with: thenSize with: elseSize.	^(receiver sizeCodeForValue: encoder)	+ branchSize + thenSize + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:57'!sizeCodeForIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).			 ^(receiver sizeCodeForValue: encoder)			 + encoder sizeDup			 + (encoder sizePushSpecialLiteral: nil)			 + (equalNode sizeCode: encoder args: 1 super: false)			 + (self 					sizeCode: encoder forBranchOn: selector key == theSelector 					dist: theSize)			 + theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).			 ^(receiver sizeCodeForValue: encoder)				+ (encoder sizePushSpecialLiteral: nil)				+ (equalNode sizeCode: encoder args: 1 super: false)				+ (self 					sizeCode: encoder					forBranchOn: selector key == theSelector 					dist: theSize)				+ theSize]! !!MessageNode methodsFor: 'code generation' stamp: 'nice 2/3/2011 21:10'!sizeCodeForRepeat: encoder value: forValue 	"L1: ... Jmp(L1) nil (nil for value only);"	| loopSize |	loopSize := (receiver sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).	sizes := Array with: loopSize.	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:09'!sizeCodeForToDo: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize initSize limitInit |	block := arguments at: 3.	initStmt := arguments at: 4.	test := arguments at: 5.	incStmt := arguments at: 6.	limitInit := arguments at: 7.	initSize := initStmt sizeCodeForEffect: encoder.	limitInit == nil ifFalse:		[initSize := initSize + (limitInit sizeCodeForEffect: encoder)].	blockSize := (block sizeCodeForEvaluatedEffect: encoder)			+ (incStmt sizeCodeForEffect: encoder)			+ (encoder sizeJumpLong: -1).	loopSize := (test sizeCodeForValue: encoder)			+ (self sizeCode: encoder forBranchOn: false dist: blockSize)			+ blockSize.	sizes := Array with: blockSize with: loopSize.	^initSize	+ loopSize	+ (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'code generation' stamp: 'nice 3/31/2011 00:25'!sizeCodeForValue: encoder	| total |	special > 0 		ifTrue: 			[encoder noteOptimizedSelector: originalSelector.			^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector := selector copy "only necess for splOops"].	total := selector sizeCode: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total := total + (receiver sizeCodeForValue: encoder)].	sizes := arguments collect: 					[:arg | | argSize | 					argSize := arg sizeCodeForValue: encoder.					total := total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:00'!sizeCodeForWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).	branchSize := self					sizeCode: encoder					forBranchOn: selector key == #whileFalse:  "Btp for whileFalse"					dist: stmtSize.	loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.	sizes := Array with: stmtSize with: loopSize.	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'initialize-release' stamp: 'nice 3/2/2011 23:57'!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	originalSelector := selNode key.	selNode code == #macro		ifTrue: [self noteSpecialSelector: selNode key]		ifFalse: [special := 0].	selector := selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!MessageNode methodsFor: 'initialize-release' stamp: 'nice 3/2/2011 23:55'!receiver: rcvr selector: aSelector arguments: args precedence: p from: encoder 	"Compile."	self receiver: rcvr		arguments: args		precedence: p.	originalSelector := aSelector.	self noteSpecialSelector: aSelector.	(self transform: encoder)		ifTrue: 			[selector isNil ifTrue:				[selector := SelectorNode new 								key: (MacroSelectors at: special)								code: #macro]]		ifFalse: 			[selector := encoder encodeSelector: aSelector.			rcvr == NodeSuper ifTrue: [encoder noteSuper]].	self pvtCheckForPvtSelector: encoder! !!MessageNode methodsFor: 'macro transformations' stamp: 'nice 1/12/2011 22:07'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:	 and: [initStmt isAssignmentNode	 and: [initStmt variable isTemp]]) ifFalse:		[^nil].	body := arguments last statements.	variable := initStmt variable.	increment := body last toDoIncrement: variable.	(increment == nil	 or: [receiver statements size ~= 1]) ifTrue:		[^nil].	test := receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	(test isMessageNode	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:		[^nil].	"The block must not overwrite the limit"	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])		ifTrue: [^nil]. 	toDoBlock := BlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	variable scope: -1.	variable beBlockArg.	^MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:33'!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeFalse) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'ul 2/26/2011 21:58'!transformCase: encoder	| caseNode |	caseNode := arguments first.	(caseNode isMemberOf: BraceNode) ifFalse: [ ^false ].	(caseNode blockAssociationCheck: encoder) ifFalse: [ ^false ].	(arguments size = 1 or: [		self checkBlock: arguments last as: 'otherwise arg' from: encoder ]) ifFalse: [			^false ].	 caseNode elements do: [ :messageNode |		messageNode receiver noteOptimizedIn: self.		messageNode arguments first noteOptimizedIn: self ].	 arguments size = 2 ifTrue: [ arguments last noteOptimizedIn: self ].	 ^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfFalseIfTrue: encoder	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder)	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.			arguments swap: 1 with: 2.			arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)						with: (arguments first noteOptimizedIn: self).		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder)	   and: [arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeTrue) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'nice 2/3/2011 20:58'!transformRepeat: encoder	"answer true if this #repeat message can be optimized"		^(self checkBlock: receiver as: 'receiver' from: encoder)	   and: [receiver noteOptimizedIn: self.			true]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/7/2010 14:56'!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange limitIsAssignedTo |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^false]]		ifFalse: [increment := encoder encodeLiteral: 1].	(limit := arguments at: 1) isVariableReference ifTrue:		[limitIsAssignedTo := false.		 arguments last nodesDo:			[:node|			(node isAssignmentNode and: [node variable = limit]) ifTrue:				[limitIsAssignedTo := true]].		 limitIsAssignedTo ifTrue:			[^false]].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:17'!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder) ifFalse:		[^false].	arguments size = 0 ifTrue:  "transform bodyless form to body form"		[selector := SelectorNode new						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])						code: #macro.		 arguments := Array with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).		 receiver noteOptimizedIn: self.		 ^true].	^(self transformBoolean: encoder)	   and: [receiver noteOptimizedIn: self.			arguments first noteOptimizedIn: self.			true]! !!MessageNode methodsFor: 'printing' stamp: 'nice 2/3/2011 20:57'!printRepeatOn: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	^self printKeywords: selector key		arguments: (Array new)		on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'ul 11/15/2010 11:53'!printToDoOn: aStream indent: level	| limitNode |	self printReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode := arguments first]		ifFalse: [limitNode := arguments last value].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'printing' stamp: 'ul 11/15/2010 11:54'!printWithClosureAnalysisToDoOn: aStream indent: level	| limitNode |	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.	limitNode := (arguments last == nil				or: [arguments last isAssignmentNode not])					ifTrue: [arguments first]					ifFalse: [arguments last value].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key = 1]])		ifTrue: [self printWithClosureAnalysisKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printWithClosureAnalysisKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'testing' stamp: 'eem 2/3/2011 09:08'!canCascade	^receiver ~~ NodeSuper! !!MessageNode methodsFor: 'testing' stamp: 'nice 4/2/2011 19:00'!ensureCanCascade: encoder	special > 0 ifTrue:		[special := 0.		selector := encoder encodeSelector: originalSelector.		arguments := originalArguments.		receiver isBlockNode ifTrue: [receiver deoptimize].		arguments do:			[:each|			each isBlockNode ifTrue:				[each deoptimize]]]! !!MessageNode methodsFor: 'private' stamp: 'ul 2/20/2011 17:17'!checkBlock: node as: nodeName from: encoder maxArgs: maxArgs	"Answer true if node is a BlockNode with at most maxArgs arguments.	This check is required in order to inline some special messages.	Notify some undue usage of these special messages."	node isBlockNode ifFalse: [ ^false ].	node numberOfArguments <= maxArgs ifTrue: [ ^true ].	^encoder notify: '<- ', nodeName , ' of ' , (MacroSelectors at: special) , ' has too many arguments'! !!MessageNode methodsFor: 'private' stamp: 'jmv 3/3/2011 08:53'!receiver: rcvr arguments: args precedence: p	receiver := rcvr.	arguments := args.	originalArguments := arguments copy.	sizes := Array new: arguments size.	precedence := p! !!MessageNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitMessageNode: self! !!MessageNode commentStamp: '<historical>' prior: 0!I represent a receiver and its message.	Precedence codes:	1 unary	2 binary	3 keyword	4 other	If special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.!!MessageNode class methodsFor: 'class initialization' stamp: 'nice 2/3/2011 21:27'!initialize	"MessageNode initialize"	MacroSelectors := 		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:			repeat ).	MacroTransformers := 		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:			transformRepeat: ).	MacroEmitters := 		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForRepeat:encoder:value:).	MacroSizers := 		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:			sizeCodeForToDo:value: sizeCodeForToDo:value:			sizeCodeForCase:value: sizeCodeForCase:value:			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForRepeat:value:).	MacroPrinters := 		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:			printRepeatOn:indent:)! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 01:01'!cull: firstArg	"Send the message with these optional arguments and answer the return value"	selector numArgs >= 1 ifTrue: [ ^self value: firstArg ].	^self value! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 01:01'!cull: firstArg cull: secondArg	"Send the message with these optional arguments and answer the return value"	| numArgs |	(numArgs := selector numArgs) >= 2 ifTrue: [ ^self value: firstArg value: secondArg ].		numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 01:03'!cull: firstArg cull: secondArg cull: thirdArg	"Send the message with these optional arguments and answer the return value"	| numArgs |	(numArgs := selector numArgs) >= 2 ifTrue: [ 		numArgs >= 3 ifTrue: [ ^self value: firstArg value: secondArg value: thirdArg ].		^self value: firstArg value: secondArg ].	numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 01:04'!cull: firstArg cull: secondArg cull: thirdArg cull: fourthArg	"Send the message with these optional arguments and answer the return value"	| numArgs |	(numArgs := selector numArgs) >= 3 ifTrue: [		numArgs >= 4 ifTrue: [			^self value: firstArg value: secondArg value: thirdArg value: fourthArg ].		^self value: firstArg value: secondArg value: thirdArg ].	numArgs = 2 ifTrue: [ ^self value: firstArg value: secondArg ].		numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 00:53'!value: firstArg	"Send the message with these arguments and answer the return value"	^receiver perform: selector with: firstArg! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 00:52'!value: firstArg value: secondArg	"Send the message with these arguments and answer the return value"	^receiver perform: selector with: firstArg with: secondArg! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 00:52'!value: firstArg value: secondArg value: thirdArg	"Send the message with these arguments and answer the return value"	^receiver perform: selector with: firstArg with: secondArg with: thirdArg! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 00:54'!value: firstArg value: secondArg value: thirdArg value: fourthArg	"Send the message with these arguments and answer the return value"	^receiver perform: selector withArguments: { firstArg. secondArg. thirdArg. fourthArg }! !!MessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:11'!valueOtherwise: aBlock	"Send the message and answer the return value"	^self value! !!MessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:22'!valueWithArguments: anArray otherwise: aBlock	^ self valueWithArguments: anArray! !!MessageSend methodsFor: 'evaluating' stamp: 'ul 3/15/2011 01:54'!valueWithPossibleArgs: anArray	"Send selector to the receiver with arguments in anArray. Only use enough arguments for the arity of the selector; supply nils for missing ones."		^receiver perform: selector withEnoughArguments: anArray! !!MessageSend methodsFor: 'private' stamp: 'jmv 5/14/2009 09:54'!isReceiverOrAnyArgumentGarbage	^false! !!MessageSet methodsFor: 'class list' stamp: 'fbs 3/22/2011 22:19'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	self hasMessageSelected ifFalse: [^nil].	self setClassAndSelectorIn: [:c :s | ^c]! !!MessageSet methodsFor: 'class list' stamp: 'fbs 3/24/2011 07:43'!selectedMessageCategoryName 	"Answer the name of the selected message category or nil."	| cls |	self hasMessageSelected ifFalse: [^ nil].	cls := self selectedClassOrMetaClass.		cls ifNil: [^ nil].		^ cls organization categoryOfElement: self selectedMessageName! !!MessageSet methodsFor: 'contents' stamp: 'fbs 3/28/2011 22:40'!contents	"Answer the contents of the receiver"	^ contents == nil		ifTrue: [currentCompiledMethod := nil. '']		ifFalse: [self hasMessageSelected			ifTrue: [self editContents]			ifFalse: [currentCompiledMethod := nil. contents]]! !!MessageSet methodsFor: 'drag and drop' stamp: 'fbs 6/8/2011 12:03'!dragFromMessageList: index	"Drag a method from the browser"	^self selectedClassOrMetaClass compiledMethodAt: (self messageList at: index) ifAbsent:[nil]! !!MessageSet methodsFor: 'filtering' stamp: 'fbs 6/8/2011 12:18'!filterToImplementorsOf	"Filter the receiver's list down to only those items with a given selector"	| aFragment inputWithBlanksTrimmed |	aFragment := self request: 'type selector:' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed := aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector |					aSelector == aSymbol]]! !!MessageSet methodsFor: 'filtering' stamp: 'ul 11/15/2010 11:54'!filterToMessagesInChangesFile	"Filter down only to messages whose source code risides in the Changes file.  This allows one to ignore long-standing methods that live in the .sources file."		self filterFrom:		[:aClass :aSelector | | cm |			aClass notNil and: [aSelector notNil and:				[(self class isPseudoSelector: aSelector) not and:					[(cm := aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex ~= 1]]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'ul 11/15/2010 11:54'!filterToMessagesInSourcesFile	"Filter down only to messages whose source code resides in the .sources file."		self filterFrom: [:aClass :aSelector | | cm |		(aClass notNil and: [aSelector notNil]) and:			[(self class isPseudoSelector: aSelector) not and:				[(cm := aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex = 1]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'fbs 6/8/2011 12:18'!filterToNotImplementorsOf	"Filter the receiver's list down to only those items whose selector is NOT one solicited from the user."	| aFragment inputWithBlanksTrimmed |	aFragment := self request: 'type selector: ' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed := aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector |					aSelector ~~ aSymbol]]! !!MessageSet methodsFor: 'filtering' stamp: 'fbs 6/8/2011 12:18'!filterToNotSendersOf	"Filter the receiver's list down to only those items which do not send a given selector"	| aFragment inputWithBlanksTrimmed |	aFragment := self request: 'type selector:' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed := aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector | | aMethod |					(aMethod := aClass compiledMethodAt: aSelector) isNil or:						[(aMethod hasLiteralThorough: aSymbol) not]]]! !!MessageSet methodsFor: 'filtering' stamp: 'fbs 6/8/2011 12:18'!filterToSendersOf	"Filter the receiver's list down to only those items which send a given selector"	| aFragment inputWithBlanksTrimmed |	aFragment := self request: 'type selector:' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed := aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector | | aMethod |					(aMethod := aClass compiledMethodAt: aSelector) notNil and:						[aMethod hasLiteralThorough: aSymbol]]]! !!MessageSet methodsFor: 'message functions' stamp: 'fbs 6/8/2011 12:18'!fileOutMessage	"Put a description of the selected method on a file, or all methods if none selected."	| fileName |	self selectedMessageName ifNotNil:		[^super fileOutMessage].	fileName := self request: 'File out on which file?' initialAnswer: 'methods'.	Cursor write showWhile:		[| internalStream |		internalStream := WriteStream on: (String new: 1000).		internalStream header; timeStamp.		messageList do:			[:methodRef|			methodRef actualClass				printMethodChunk: methodRef methodSymbol				withPreamble: true				on: internalStream				moveSource: false				toFile: nil].		FileStream writeSourceCodeFrom: internalStream baseName: fileName isSt: true useHtml: false]! !!MessageSet methodsFor: 'message functions' stamp: 'fbs 6/8/2011 07:57'!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	self 		menuHook: aMenu 		named: #messageListMenu 		shifted: shifted.	Preferences useOnlyServicesInMenu ifTrue:[^aMenu].	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('what to show...'			offerWhatToShowMenu)			('toggle break on entry'		toggleBreakOnEntry)			-			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)			('copy selector (c)'						copySelector)			('copy reference'						copyReference)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('versions (v)'				browseVersions)			-			('references... (r)'			browseVariableReferences)			('assignments... (a)'			browseVariableAssignments)			('class refs (N)'			browseClassRefs)			-			('remove method (x)'			removeMessage)			('explore method'			exploreMethod)			('inspect method'			inspectMethod)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!MessageSet methodsFor: 'message functions' stamp: 'cmm 6/6/2011 09:55'!reformulateList	"The receiver's messageList has been changed; rebuild it"	super reformulateList.	self		 changed: #messageList ;		 changed: #messageListIndex.	self contentsChanged.	autoSelectString ifNotNil: [ self changed: #autoSelect ]! !!MessageSet methodsFor: 'message functions' stamp: 'fbs 3/17/2011 17:36'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	self hasMessageSelected		ifFalse: [^ self].	self okToChange		ifFalse: [^ self].	messageName := self selectedMessageName.	confirmation := self systemNavigation  confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation = 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self deleteFromMessageList: self selection.	self reformulateList.	confirmation = 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'message functions' stamp: 'fbs 3/22/2011 22:11'!removeMessageFromBrowser	"Remove the selected message from the browser."	self hasMessageSelected ifFalse: [^ self].	self deleteFromMessageList: self selection.	self reformulateList.	self adjustWindowTitleAfterFiltering! !!MessageSet methodsFor: 'message functions' stamp: 'fbs 6/7/2011 17:58'!shiftedMessageListMenu: aMenu	"Fill aMenu with the items appropriate when the shift key is held down"	aMenu addStayUpItem.	aMenu addList: #(		('toggle diffing (D)'						toggleDiffing)		('implementors of sent messages'			browseAllMessages)		-		('local senders of...'						browseLocalSendersOfMessages)		('local implementors of...'				browseLocalImplementors)		-		('spawn sub-protocol'					spawnProtocol)		('spawn full protocol'					spawnFullProtocol)		-		('sample instance'						makeSampleInstance)		('inspect instances'						inspectInstances)		('inspect subinstances'					inspectSubInstances)).	self addExtraShiftedItemsTo: aMenu.	aMenu addList: #(		-		('change category...'					changeCategory)).	self canShowMultipleMessageCategories ifTrue: [aMenu addList:		 #(('show category (C)'						showHomeCategory))].	aMenu addList: #(		-		('change sets with this method'			findMethodInChangeSets)		('revert to previous version'				revertToPreviousVersion)		('remove from current change set'		removeFromCurrentChanges)		('revert & remove from changes'		revertAndForget)		('add to current change set'				adoptMessageInCurrentChangeset)		('copy up or copy down...'				copyUpOrCopyDown)		-		('more...' 								unshiftedYellowButtonActivity)).	^ aMenu! !!MessageSet methodsFor: 'message list' stamp: 'fbs 3/28/2011 22:31'!hasMessageSelected	^ messageListIndex ~= 0.! !!MessageSet methodsFor: 'message list' stamp: 'fbs 3/22/2011 21:29'!lastMessageName	^ self messageList last selector.! !!MessageSet methodsFor: 'message list' stamp: 'fbs 4/11/2011 11:47'!messageListIndex	^messageListIndex ifNil: [0]! !!MessageSet methodsFor: 'message list' stamp: 'cmm 2/18/2010 22:48'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	messageListIndex := anInteger.	contents := 		messageListIndex ~= 0			ifTrue: [self selectedMessage]			ifFalse: [''].	self changed: #messageListIndex.	 "update my selection"	self editSelection: #editMessage.	self contentsChanged.	(messageListIndex ~= 0 and: [ autoSelectString notNil and: [ self contents notEmpty ] ]) ifTrue: [ self changed: #autoSelect ].	self decorateButtons! !!MessageSet methodsFor: 'message list' stamp: 'fbs 3/22/2011 22:17'!messageListIndexOf: aString	^ (self messageList collect: [:each | each selector]) indexOf: aString.! !!MessageSet methodsFor: 'message list' stamp: 'ar 1/2/2010 03:41'!selectedMessage	"Answer the source method for the currently selected message."		self setClassAndSelectorIn: [:class :selector | | source | 		class ifNil: [^ 'Class vanished'].		selector first isUppercase ifTrue:			[selector == #Comment ifTrue:				[currentCompiledMethod := class organization commentRemoteStr.				^ class comment].			selector == #Definition ifTrue:				[^ class definition].			selector == #Hierarchy ifTrue: [^ class printHierarchy]].		source := class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod := nil.			^ 'Missing'].		self showingDecompile ifTrue: [^ self decompiledSourceIntoContents].		currentCompiledMethod := class compiledMethodAt: selector ifAbsent: [nil].		self showingDocumentation ifTrue: [^ self commentContents].	source := self sourceStringPrettifiedAndDiffed.	^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'message list' stamp: 'fbs 3/28/2011 22:35'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	messageListIndex = 0 ifTrue: [^ nil].	^ self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'message list' stamp: 'nice 8/19/2010 16:33'!sortByDate	"Sort the message-list by date of time-stamp"	| assocs inOrder |	assocs := messageList collect:		[:aRef | | aDate aCompiledMethod |			aDate := aRef methodSymbol == #Comment				ifTrue:					[aRef actualClass organization dateCommentLastSubmitted]				ifFalse:					[aCompiledMethod := aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: [nil].					aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].			aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"	inOrder := assocs asArray sort: [:a :b | a value < b value].	messageList := inOrder collect: [:assoc | assoc key].	self changed: #messageList! !!MessageSet methodsFor: 'toolbuilder' stamp: 'fbs 6/7/2011 17:33'!buildMessageListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #messageList; 		getIndex: #messageListIndex; 		setIndex: #messageListIndex:; 		menu: #messageListMenu:shifted:; 		keyPress: #messageListKey:from:.	Preferences browseWithDragNDrop 		ifTrue:[listSpec dragItem: #dragFromMessageList:].	^listSpec! !!MessageSet methodsFor: 'private' stamp: 'fbs 6/7/2011 17:27'!initializeMessageList: anArray	"Initialize my messageList from the given list of MethodReference or string objects.  NB: special handling for uniclasses."		messageList := OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel | | s |				class ifNotNil:					[class isUniClass						ifTrue:							[s := class typicalInstanceName, ' ', sel]						ifFalse:							[s := class name , ' ' , sel , ' {' , 								((class organization categoryOfElement: sel) ifNil: ['']) , '}'].					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s)]]].	messageListIndex := messageList isEmpty ifTrue: [0] ifFalse: [1].	contents := ''! !!MessageSet methodsFor: 'private' stamp: 'fbs 3/24/2011 17:40'!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ self messageList at: (self messageListIndex) ifAbsent: [nil]! !!MessageSet methodsFor: 'private' stamp: 'ul 11/15/2010 11:54'!setFilteredList: newList 	"Establish newList as the new list if appropriate, and adjust the window title accordingly; if the new list is of the same size as the old, warn and do nothing"	newList size = 0 ifTrue:		[ self inform: 'Nothing would be left in the list if you did that'.		^false ].	newList size = messageList size ifTrue:		[ self inform: 'That leaves the list unchanged'.		^false ].	self		 initializeMessageList: newList ;		 adjustWindowTitleAfterFiltering.	^true! !!MessageSet methodsFor: 'as yet unclassified' stamp: 'fbs 6/8/2011 12:17'!request: prompt initialAnswer: initialAnswer	^ UIManager default		request: prompt		initialAnswer: initialAnswer! !!MessageSet methodsFor: 'accessing' stamp: 'bf 7/11/2011 11:40'!doItReceiver	^ self selectedClass! !!MessageSet methodsFor: 'accessing' stamp: 'fbs 6/7/2011 17:45'!editSelection: aSelection	"Set the editSelection as requested."	editSelection := aSelection.	self changed: #editSelection.! !!MessageSet methodsFor: 'initialize-release' stamp: 'fbs 6/19/2011 16:03'!initialize	super initialize.	messageList := OrderedCollection new.! !!MessageSet methodsFor: 'initialize-release' stamp: 'fbs 3/29/2011 17:10'!systemOrganizer: aSystemOrganizer	messageListIndex := 0.	^ super systemOrganizer: aSystemOrganizer.! !!MessageSet methodsFor: 'copying' stamp: 'fbs 6/8/2011 12:22'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	messageListIndex := messageListIndex veryDeepCopyWith: deepCopier.	editSelection := editSelection veryDeepCopyWith: deepCopier.! !!MessageSet methodsFor: 'breakpoints' stamp: 'bf 7/13/2011 17:59'!toggleBreakOnEntry	"Install or uninstall a halt-on-entry breakpoint"	| selectedMethod |	self selectedClassOrMetaClass ifNil: [ ^self].	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.	selectedMethod hasBreakpoint		ifTrue:			[BreakpointManager unInstall: selectedMethod]		ifFalse:			[BreakpointManager 				installInClass: self selectedClassOrMetaClass				selector: self selectedMessageName].	self changed: #messageList! !!MessageSet methodsFor: 'user interface' stamp: 'ael 12/19/2011 15:11'!modelWakeUp	"A window with me as model has been activated."	| tm |	super modelWakeUp.	(self canDiscardEdits and: [autoSelectString notNil]) ifTrue:		[tm := self codeTextMorph.		(tm hasProperty: #launched) ifFalse:			[tm scrollSelectionIntoView.			tm setProperty: #launched toValue: true]		]! !!MessageSet commentStamp: '<historical>' prior: 0!I represent a query path of the retrieval result of making a query about methods in the system. The result is a set of methods, denoted by a message selector and the class in which the method was found. As a StringHolder, the string I represent is the source code of the currently selected method. I am typically viewed in a Message Set Browser consisting of a MessageListView and a BrowserCodeView.!!MessageSetTest methodsFor: 'initialize-release' stamp: 'fbs 4/17/2011 22:23'!initialize	super initialize.		"Contains the triggers sent by the model during its updates."	updates := OrderedCollection new.! !!MessageSetTest methodsFor: 'running' stamp: 'fbs 4/17/2011 22:23'!setUp	browser := (MessageSet		openMessageList: (SystemNavigation default allImplementorsOf: #browseAllImplementorsOf:)		name: 'Test MessageSet'		autoSelect: nil) model.	browser addDependent: self.! !!MessageSetTest methodsFor: 'running' stamp: 'fbs 3/22/2011 17:34'!tearDown	ToolBuilder default close: browser topView.! !!MessageSetTest methodsFor: 'testing' stamp: 'fbs 4/17/2011 22:22'!testAutoSelectString	browser autoSelectString: 'browseAllImplementorsOf:'.	self assert: browser autoSelectString = 'browseAllImplementorsOf:'.	browser messageListIndex: 2.	self assert: (updates includes: #autoSelect).! !!MessageSetTest methodsFor: 'testing' stamp: 'fbs 3/29/2011 16:56'!testContents	browser messageListIndex: 0.	self assert: browser contents = ''.		browser messageListIndex: 1.	self deny: browser contents = ''.	! !!MessageSetTest methodsFor: 'testing' stamp: 'fbs 3/29/2011 16:56'!testHasMessageSelected	browser messageListIndex: 1.	self assert: browser hasMessageSelected.		browser messageListIndex: 0.	self deny: browser hasMessageSelected.		"And just to be sure:"	browser messageListIndex: 1.	self assert: browser hasMessageSelected.! !!MessageSetTest methodsFor: 'testing' stamp: 'fbs 3/29/2011 16:56'!testRemoveMessageFromBrowser	| count sel |	browser messageListIndex: 1.	sel := browser selection.		browser removeMessageFromBrowser.	self deny: (browser messageList includes: sel) description: 'Method not removed'.	browser messageListIndex: 0.	count := browser messageList size.	browser removeMessageFromBrowser.	self assert: count = browser messageList size description: 'Some method was removed'.! !!MessageSetTest methodsFor: 'testing' stamp: 'fbs 3/29/2011 16:57'!testSelectedClassOrMetaClass	| firstClass |	firstClass := browser messageList first actualClass.		browser messageListIndex: 1.	self assert: browser selectedClassOrMetaClass = firstClass.		browser messageListIndex: 0.	self assert: browser selectedClassOrMetaClass isNil.		"And just to be sure:"	browser messageListIndex: 1.	self assert: browser selectedClassOrMetaClass = firstClass.! !!MessageSetTest methodsFor: 'testing' stamp: 'fbs 3/29/2011 16:57'!testSelectedMessageCategoryName	| firstCat methodRef |	methodRef := browser messageList first.	firstCat := methodRef actualClass organization categoryOfElement: methodRef selector.		browser messageListIndex: 1.	self assert: browser selectedMessageCategoryName = firstCat.		browser messageListIndex: 0.	self assert: browser selectedMessageCategoryName isNil.		"And just to be sure:"	browser messageListIndex: 1.	self assert: browser selectedMessageCategoryName = firstCat.! !!MessageSetTest methodsFor: 'testing' stamp: 'fbs 3/29/2011 16:58'!testSelectedMessageName	| firstSel |	firstSel := browser messageList first selector.		browser messageListIndex: 1.	self assert: browser selectedMessageName = firstSel.		browser messageListIndex: 0.	self assert: browser selectedMessageName isNil.		"And just to be sure:"	browser messageListIndex: 1.	self assert: browser selectedMessageName = firstSel.! !!MessageSetTest methodsFor: 'testing' stamp: 'fbs 3/29/2011 16:57'!testSelection	| firstRef |	firstRef := browser messageList first.		browser messageListIndex: 1.	self assert: browser selection = firstRef.		browser messageListIndex: 0.	self assert: browser selection isNil.		"And just to be sure:"	browser messageListIndex: 1.	self assert: browser selection = firstRef.! !!MessageSetTest methodsFor: 'private' stamp: 'fbs 4/17/2011 22:28'!update: aSelector	updates addLast: aSelector.! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/17/2011 12:37'!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay time0 |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[			| observedProcess startTime |			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self				tally: observedProcess suspendedContext				in: observedProcess				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs] repeat.		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"			SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |				gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/17/2011 12:37'!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay time0 observedProcess |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess := Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[			| startTime |			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs] repeat.		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |			gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].		time := Time millisecondClockValue - time0 ]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess := aProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	endTime := time0 + msecDuration.	sem := Semaphore new.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [			[				| startTime |				startTime := Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess 						ifTrue: [ observedProcess ]						ifFalse: [ nil ])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |		gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].	time := Time millisecondClockValue - time0! !!MessageTally class methodsFor: 'defaults' stamp: 'jmv 4/30/2010 14:10'!defaultMaxClassNameSize	"Return the default maximum width of the class name alone"	^50! !!MessageTally class methodsFor: 'defaults' stamp: 'jmv 4/30/2010 14:10'!defaultMaxClassPlusSelectorSize	"Return the default maximum width of the class plus selector together (not counting the '>>')"	^100! !!MessageTrace methodsFor: 'building' stamp: 'fbs 3/29/2011 09:26'!removeMessageFromBrowser	| indexToSelect |	self hasMessageSelected ifFalse: [^ self].	"Try to keep the same selection index."	indexToSelect := (messageSelections indexOf: true) max: 1.	self selectedMessages do: [ :eachMethodReference | self deleteFromMessageList: eachMethodReference ].	self deselectAll.	messageSelections ifNotEmpty:		[ messageSelections 			at: (indexToSelect min: messageSelections size)  "safety"			put: true ].	anchorIndex := indexToSelect min: messageSelections size.	self 		messageListIndex: anchorIndex ; 		reformulateList! !!MessageTrace methodsFor: 'copying' stamp: 'cmm 8/13/2011 19:30'!veryDeepInner: aDeepCopier 	super veryDeepInner: aDeepCopier.	autoSelectStrings := autoSelectStrings veryDeepCopyWith: aDeepCopier.	messageSelections := messageSelections veryDeepCopyWith: aDeepCopier! !!MessageTraceTest methodsFor: 'as yet unclassified' stamp: 'fbs 4/17/2011 22:28'!setUp	browser := (MessageTrace		openMessageList: (SystemNavigation default allImplementorsOf: #browseAllImplementorsOf:)		name: 'Test MessageSet'		autoSelect: nil) model.			browser addDependent: self.! !!Metaclass methodsFor: 'testing' stamp: 'nice 5/7/2011 14:27'!whichMethodsStoreInto: varName 	"Answer a collection of CompiledMethod which store into the argument, varName, as a named class variable. Or let super try with a named instance variable."	| ref |	ref := self classPool		associationAt: varName		ifAbsent: [ ^ super whichMethodsStoreInto: varName ].	^self methodDict values select: [:eachMethod | eachMethod writesRef: ref ]! !!Metaclass methodsFor: 'testing' stamp: 'nice 5/7/2011 14:10'!whichSelectorsStoreInto: varName 	"Answer a collection of selectors whose methods access the argument, varName, as a named class variable. Or let super try with a named instance variable."	| ref |	ref := self classPool		associationAt: varName		ifAbsent: [ ^ super whichSelectorsStoreInto: varName ].	^self methodDict keys select: [:aSelector | (self methodDict at: aSelector) writesRef: ref ]! !!Metaclass methodsFor: 'copying' stamp: 'nice 12/29/2010 10:21'!postCopy	"Don't share the reference to the sole instance."	super postCopy.	thisClass := nil.! !!Metaclass methodsFor: 'organization' stamp: 'fbs 2/15/2011 08:27'!category	^ thisClass category! !!MethodContext methodsFor: 'initialize-release' stamp: 'eem 9/10/2009 15:49'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	closureOrNil		ifNotNil:			[pc := closureOrNil startpc.			self stackp: closureOrNil numArgs + closureOrNil numCopiedValues.			1 to: closureOrNil numCopiedValues do:				[:i | self tempAt: closureOrNil numArgs + i put: (closureOrNil at: i)]]		ifNil:			[pc := method initialPC.			self stackp: method numTemps.			method numArgs+1 to: method numTemps do:				[:i | self tempAt: i put: nil]]! !!MethodContext methodsFor: 'system simulation' stamp: 'eem 7/2/2010 10:26'!pushArgs: args "<Array>" from: sendr "<ContextPart>" 	"Helps simulate action of the value primitive for closures.	 This is used by ContextPart>>runSimulated:contextAtEachStep:"	closureOrNil		ifNil: [self error: 'context needs a closure!!']		ifNotNil:			["See BlockClosure>>asContextWithSender:"			 stackp ~= (closureOrNil numArgs + closureOrNil numCopiedValues) ifTrue:				[self error: 'stack pointer is incorrect!!'].].	1 to: closureOrNil numArgs do:		[:i| self at: i put: (args at: i)].	sender := sendr! !!MethodContext methodsFor: 'testing' stamp: 'mha 9/22/2010 11:42'!atEnd	^ self isExecutingBlock		ifTrue: [ self closure startpc + self closure size - 1 = self pc ]		ifFalse: [ self pc >= self method endPC ]! !!MethodContext methodsFor: '*Tools-Inspector' stamp: 'ar 8/19/2010 12:16'!inspectorClass	"Answer the class of the inspector to be used on the receiver.  Called by inspect; 	use basicInspect to get a normal (less useful) type of inspector."	^ ContextInspector! !!MethodContextTest methodsFor: 'tests' stamp: 'HenrikSperreJohansen 6/11/2010 21:19'!testRestart	self should: [self privRestartTest] notTakeMoreThan: 0.1 second! !!MethodContextTest methodsFor: 'private' stamp: 'ul 11/15/2010 11:54'!privRestartTest	"This tests may loop endlessly if incorrect, so call it from another method testing it does not time out"	|a firstTimeThrough |	firstTimeThrough := true.	a := 10.		self assert: 30 equals: [|b| 		self assert: 10 = a .		self assert: nil == b.		b := a + 20. 		firstTimeThrough ifTrue: [			firstTimeThrough := false.			thisContext restart.].		b] value! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 6/18/2010 21:38'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	^(array at: (self scanFor: key)) 		ifNil: [ aBlock value ]		ifNotNil: [ :value | key -> value ]! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 9/18/2011 15:13'!at: key put: value	"Set the value at key to be value."		| index |	index := self scanFor: key.	(self basicAt: index)		ifNil: [			self				basicAt: index put: key;				atNewIndex: index put: value ]		ifNotNil: [ 			(array at: index) flushCache.			array at: index put: value ].	^value! !!MethodDictionary methodsFor: 'accessing' stamp: 'nice 2/1/2011 02:23'!includesKey: aSymbol	"This override assumes that instVarsInclude: uses a fast primitive"	aSymbol ifNil: [^ false].	^ self instVarsInclude: aSymbol! !!MethodDictionary methodsFor: 'removing' stamp: 'ul 9/27/2011 17:41'!removeAll	"Remove all elements from this collection. Preserve the capacity"		| newSelf |	tally = 0 ifTrue: [^self].	newSelf := self species newForCapacity: self basicSize.	self copyFrom: newSelf! !!MethodDictionary methodsFor: 'removing' stamp: 'ul 9/18/2011 11:39'!removeKey: key ifAbsent: errorBlock 	"The interpreter might be using this MethodDict while	this method is running!!  Therefore we perform the removal	in a copy, and then atomically copy that copy"	| copy |	copy := self copy.	copy removeDangerouslyKey: key ifAbsent: [^ errorBlock value].	self copyFrom: copy! !!MethodDictionary methodsFor: 'private' stamp: 'ul 9/18/2011 15:11'!compact	"Make sure that I have the highest possible load factor (between 37.5% and 75%)."		| newInstance |	newInstance := self compactWithoutBecome.	newInstance capacity = self capacity		ifTrue: [ self copyFrom: newInstance ]		ifFalse: [ self becomeForward: newInstance ]! !!MethodDictionary methodsFor: 'private' stamp: 'ul 9/18/2011 13:41'!compactWithoutBecome	"Return a copy of self which has the highest possible load factor (between 37.5% and 75%)."		| newInstance |	newInstance := self species new: self size.	1 to: self basicSize do: [ :index | 		(self basicAt: index) ifNotNil: [ :key |			newInstance at: key put: (array at: index) ] ].	^newInstance! !!MethodDictionary methodsFor: 'private' stamp: 'ul 9/27/2011 17:37'!grow	| newSelf |	newSelf := self species newForCapacity: self basicSize * 2.	1 to: self basicSize do: [ :i | 		(self basicAt: i) ifNotNil: [ :key |			newSelf at: key put: (array at: i) ] ].	self become: newSelf! !!MethodDictionary methodsFor: 'private' stamp: 'ul 9/27/2011 17:40'!rehash 		| newInstance |	newInstance := self species newForCapacity: self basicSize.	1 to: self basicSize do: [ :index | 		(self basicAt: index) ifNotNil: [ :key |			newInstance at: key put: (array at: index) ] ].	self copyFrom: newInstance! !!MethodDictionary commentStamp: 'nice 2/1/2011 02:47' prior: 0!I am a special dictionary holding methods. I am just like a normal Dictionary, except that I am implemented differently.  Each Class has an instance of MethodDictionary to hold the correspondence between selectors (names of methods) and methods themselves.In a normal Dictionary, the instance variable 'array' holds an array of Associations.  Since there are thousands of methods in the system, these Associations waste space.  Each MethodDictionary is a variable object, with the list of keys (selector Symbols) in the variable part of the instance.  The variable 'array' holds the values, which are CompiledMethods.I also maintain the following invariant: (self basicAt: index) isNil = (array at: index) isNil.!!MethodDictionary class methodsFor: 'instance creation' stamp: 'ul 9/27/2011 18:02'!new	"Create a new instance with 32 slots, which can hold at most 24 methods before growing is necessary."		^self newForCapacity: 32! !!MethodDictionary class methodsFor: 'instance creation' stamp: 'ul 9/27/2011 17:51'!new: numberOfElements	"Create an instance large enough to hold numberOfElements methods without growing."		^self newForCapacity: (self sizeFor: numberOfElements)! !!MethodDictionary class methodsFor: 'initialize-release' stamp: 'ul 9/18/2011 15:08'!compactAllInstances	| instancesToExchange newInstances |	instancesToExchange := Array streamContents: [ :oldStream |		newInstances := Array streamContents: [ :newStream |			self allInstances do: [ :each |				| newInstance |				newInstance := each compactWithoutBecome.				newInstance capacity = each capacity 					ifTrue: [ each copyFrom: newInstance ]					ifFalse: [						oldStream nextPut: each.						newStream nextPut: newInstance ] ] ] ].	instancesToExchange elementsForwardIdentityTo: newInstances! !!MethodDictionary class methodsFor: 'sizing' stamp: 'ul 12/21/2011 04:25'!sizeFor: numberOfElements	"Return the minimum capacity of a dictionary that can hold numberOfElements elements. At least 25% of the array must be empty and the return value must be a power of 2."	^(numberOfElements * 4 // 3) asLargerPowerOfTwo max: 1! !!MethodDictionary class methodsFor: 'private' stamp: 'ul 9/27/2011 17:34'!newForCapacity: capacity	"Create an instance with the given capacity which must be a power of two."		^(self basicNew: capacity) initialize: capacity! !!MethodFinder methodsFor: 'initialize' stamp: 'cmm 5/2/2011 19:51'!initialize	"The methods we are allowed to use.  (MethodFinder new initialize) "	Approved := Set new.	AddAndRemove := Set new.	Blocks := Set new.	"These modify an argument and are not used by the MethodFinder: longPrintOn: printOn: storeOn: sentTo: storeOn:base: printOn:base: absPrintExactlyOn:base: absPrintOn:base: absPrintOn:base:digitCount: writeOn: writeScanOn: possibleVariablesFor:continuedFrom: printOn:format:""Object"  	#("in class, instance creation" categoryForUniclasses chooseUniqueClassName initialInstance isSystemDefined newFrom: officialClass readCarefullyFrom:"accessing" at: basicAt: basicSize bindWithTemp: in: size yourself "testing" basicType ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: isColor isFloat isFraction isInMemory isInteger isMorph isNil isNumber isPoint isPseudoContext isText isTransparent isWebBrowser knownName notNil pointsTo: wantsSteps "comparing" = == closeTo: hash identityHash identityHashPrintString ~= ~~ "copying" clone copy shallowCopy "dependents access" canDiscardEdits dependents hasUnacceptedEdits "updating" changed changed: okToChange update: windowIsClosing "printing" fullPrintString isLiteral longPrintString printString storeString stringForReadout stringRepresentation "class membership" class isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass "error handling" "user interface" addModelMenuItemsTo:forMorph:hand: defaultBackgroundColor defaultLabelForInspector fullScreenSize initialExtent modelWakeUp mouseUpBalk: newTileMorphRepresentative windowActiveOnFirstClick windowReqNewLabel: "system primitives" asOop instVarAt: instVarNamed: "private" "associating" -> "converting" as: asOrderedCollection asString "casing" caseOf: caseOf:otherwise: "binding" bindingOf: "macpal" contentsChanged currentEvent currentHand currentWorld flash instanceVariableValues scriptPerformer "flagging" flag: "translation support" "objects from disk" "finalization" ) do: [:sel | Approved add: sel].	#(at:add: at:modify: at:put: basicAt:put: "NOT instVar:at:""message handling" perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: ) do: [:sel | AddAndRemove add: sel]."Boolean, True, False, UndefinedObject"  	#("logical operations" & eqv: not xor: |"controlling" and: ifFalse: ifFalse:ifTrue: ifTrue: ifTrue:ifFalse: or:"copying" "testing" isEmptyOrNil) do: [:sel | Approved add: sel]."Behavior" 	#("initialize-release""accessing" compilerClass decompilerClass evaluatorClass format methodDict parserClass sourceCodeTemplate subclassDefinerClass"testing" instSize instSpec isBits isBytes isFixed isPointers isVariable isWeak isWords"copying""printing" defaultNameStemForInstances printHierarchy"creating class hierarchy""creating method dictionary""instance creation" basicNew basicNew: new new:"accessing class hierarchy" allSubclasses allSubclassesWithLevelDo:startingLevel: allSuperclasses subclasses superclass withAllSubclasses withAllSuperclasses"accessing method dictionary" allSelectors changeRecordsAt: compiledMethodAt: compiledMethodAt:ifAbsent: firstCommentAt: lookupSelector: selectors selectorsDo: selectorsWithArgs: "slow but useful ->" sourceCodeAt: sourceCodeAt:ifAbsent: sourceMethodAt: sourceMethodAt:ifAbsent:"accessing instances and variables" allClassVarNames allInstVarNames allSharedPools classVarNames instVarNames instanceCount sharedPools someInstance subclassInstVarNames"testing class hierarchy" inheritsFrom: kindOfSubclass"testing method dictionary" canUnderstand: classThatUnderstands: hasMethods includesSelector: whichClassIncludesSelector: whichSelectorsAccess: whichSelectorsReferTo: whichSelectorsReferTo:special:byte: whichMethodsStoreInto:"enumerating""user interface""private" indexIfCompact) do: [:sel | Approved add: sel]."ClassDescription"	#("initialize-release" "accessing" classVersion isMeta name theNonMetaClass"copying" "printing" classVariablesString instanceVariablesString sharedPoolsString"instance variables" checkForInstVarsOK: "method dictionary" "organization" category organization whichCategoryIncludesSelector:"compiling" acceptsLoggingOfCompilation wantsChangeSetLogging"fileIn/Out" definition"private" ) do: [:sel | Approved add: sel]."Class"	#("initialize-release" "accessing" classPool"testing""copying" "class name" "instance variables" "class variables" classVarAt: classVariableAssociationAt:"pool variables" "compiling" "subclass creation" "fileIn/Out" ) do: [:sel | Approved add: sel]. "Metaclass"	#("initialize-release" "accessing" isSystemDefined soleInstance"copying" "instance creation" "instance variables"  "pool variables" "class hierarchy"  "compiling""fileIn/Out"  nonTrivial ) do: [:sel | Approved add: sel]."Context, BlockContext"	#(receiver client method receiver tempAt: "debugger access" pc selector sender shortStack sourceCode tempNames tempsAndValues"controlling"  "printing" "system simulation" "initialize-release" "accessing" hasMethodReturn home numArgs"evaluating" value value:ifError: value:value: value:value:value: value:value:value:value: valueWithArguments:"controlling"  "scheduling"  "instruction decoding"  "printing" "private"  "system simulation" ) do: [:sel | Approved add: sel].	#(value: "<- Association has it as a store" ) do: [:sel | AddAndRemove add: sel]."Message"	#("inclass, instance creation" selector: selector:argument: selector:arguments:"accessing" argument argument: arguments sends:"printing" "sending" ) do: [:sel | Approved add: sel].	#("private" setSelector:arguments:) do: [:sel | AddAndRemove add: sel]."Magnitude"	#("comparing" < <= > >= between:and:"testing" max: min: min:max: ) do: [:sel | Approved add: sel]."Date, Time"	#("in class, instance creation" fromDays: fromSeconds: fromString: newDay:month:year: newDay:year: today	"in class, general inquiries" dateAndTimeNow dayOfWeek: daysInMonth:forYear: daysInYear: firstWeekdayOfMonth:year: indexOfMonth: leapYear: nameOfDay: nameOfMonth:"accessing" day leap monthIndex monthName weekday year"arithmetic" addDays: subtractDate: subtractDays:"comparing""inquiries" dayOfMonth daysInMonth daysInYear daysLeftInYear firstDayOfMonth previous:"converting" asSeconds"printing"  mmddyyyy printFormat: "private" weekdayIndex 	"in class, instance creation" fromSeconds: now 	"in class, general inquiries" dateAndTimeFromSeconds: dateAndTimeNow millisecondClockValue millisecondsToRun: totalSeconds"accessing" hours minutes seconds"arithmetic" addTime: subtractTime:"comparing""printing" intervalString print24 "converting") do: [:sel | Approved add: sel].	#("private" 		 ) do: [:sel | AddAndRemove add: sel]."Number"	#("in class" readFrom:base: "arithmetic" * + - / // \\ abs negated quo: reciprocal rem:"mathematical functions" arcCos arcSin arcTan arcTan: cos exp floorLog: ln log log: raisedTo: raisedToInteger: sin sqrt squared tan"truncation and round off" ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated"comparing""testing" even isDivisibleBy: isInfinite isNaN isZero negative odd positive sign strictlyPositive"converting" @ asInteger asNumber asPoint asSmallAngleDegrees degreesToRadians radiansToDegrees"intervals" to: to:by: "printing" printStringBase: storeStringBase: ) do: [:sel | Approved add: sel]."Integer"	#("in class" primesUpTo:"testing" isPowerOfTwo"arithmetic" alignedTo:"comparing""truncation and round off" atRandom normalize"enumerating" timesRepeat:"mathematical functions" degreeCos degreeSin factorial gcd: lcm: take:"bit manipulation" << >> allMask: anyMask: bitAnd: bitClear: bitInvert bitInvert32 bitOr: bitShift: bitXor: lowBit noMask:"converting" asCharacter asColorOfDepth: asFloat asFraction asHexDigit"printing" asStringWithCommas hex hex8 radix:"system primitives" lastDigit replaceFrom:to:with:startingAt:"private" "benchmarks" ) do: [:sel | Approved add: sel]."SmallInteger, LargeNegativeInteger, LargePositiveInteger"	#("arithmetic" "bit manipulation" highBit "testing" "comparing" "copying" "converting" "printing" "system primitives" digitAt: digitLength "private" fromString:radix: ) do: [:sel | Approved add: sel].	#(digitAt:put: ) do: [:sel | AddAndRemove add: sel]."Float"	#("arithmetic""mathematical functions" reciprocalFloorLog: reciprocalLogBase2 timesTwoPower:"comparing" "testing""truncation and round off" exponent fractionPart integerPart significand significandAsInteger"converting" asApproximateFraction asIEEE32BitWord asTrueFraction"copying") do: [:sel | Approved add: sel]."Fraction, Random"	#(denominator numerator reduced next nextValue) do: [:sel | Approved add: sel].	#(setNumerator:denominator:) do: [:sel | AddAndRemove add: sel]."Collection"	#("accessing" anyOne"testing" includes: includesAllOf: includesAnyOf: includesSubstringAnywhere: isEmpty isSequenceable occurrencesOf:"enumerating" collect: collect:thenSelect: count: detect: detect:ifNone: detectMax: detectMin: detectSum: inject:into: reject: select: select:thenCollect: intersection:"converting" asBag asCharacterSet asSet asSortedArray asSortedCollection asSortedCollection:"printing""private" maxSize"arithmetic""math functions" average max median min range sum) do: [:sel | Approved add: sel].	#("adding" add: addAll: addIfNotPresent:"removing" remove: remove:ifAbsent: removeAll: removeAllFoundIn: removeAllSuchThat: remove:ifAbsent:) do: [:sel | AddAndRemove add: sel]."SequenceableCollection"	#("comparing" hasEqualElements:"accessing" allButFirst allButLast at:ifAbsent: atAll: atPin: atRandom: atWrap: fifth first fourth identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: last second sixth third"removing""copying" , copyAfterLast: copyAt:put: copyFrom:to: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpTo: copyUpToLast: copyWith: copyWithout: copyWithoutAll: forceTo:paddingWith: shuffled sortBy:"enumerating" collectWithIndex: findFirst: findLast: pairsCollect: with:collect: withIndexCollect: polynomialEval:"converting" asArray asDictionary asFloatArray asIntegerArray asStringWithCr asWordArray reversed"private" copyReplaceAll:with:asTokens: ) do: [:sel | Approved add: sel].	#( swap:with:) do: [:sel | AddAndRemove add: sel]."ArrayedCollection, Bag"	#("private" defaultElement "sorting" isSorted"accessing" cumulativeCounts sortedCounts sortedElements "testing" "adding" add:withOccurrences: "removing" "enumerating" 	) do: [:sel | Approved add: sel].	#( mergeSortFrom:to:by: sort sort: add: add:withOccurrences:"private" setDictionary ) do: [:sel | AddAndRemove add: sel]."Other messages that modify the receiver"	#(atAll:put: atAll:putAll: atAllPut: atWrap:put: replaceAll:with: replaceFrom:to:with:  removeFirst removeLast) do: [:sel | AddAndRemove add: sel].	self initialize2."MethodFinder new initialize.MethodFinder new organizationFiltered: Set"! !!MethodFinder methodsFor: 'initialize' stamp: 'nice 12/29/2010 14:49'!testFromTuple: nth	"verify that the methods allowed don't crash the system.  Try N of each of the fundamental types.  up to 4 of each kind." | objects nonRepeating even other aa cnt |objects := #((1 4 17 42) ($a $b $c $d) ('one' 'two' 'three' 'four')	(x + rect: new) ((a b 1 4) (c 1 5) ($a 3 d) ()) (4.5 0.0 3.2 100.3)	).objects := objects, {{true. false. true. false}. {Point. SmallInteger. Association. Array}.	{Point class. SmallInteger class. Association class. Array class}.	"{ 4 blocks }."	{Date today. '1 Jan 1950' asDate. '25 Aug 1987' asDate. '1 Jan 2000' asDate}.	{'15:16' asTime. '1:56' asTime. '4:01' asTime. '6:23' asTime}.	{Dictionary new. Dictionary new. Dictionary new. Dictionary new}.	{#(a b 1 4) asOrderedCollection. #(c 1 5) asOrderedCollection. 		#($a 3 d) asOrderedCollection. #() asOrderedCollection}.	{3 -> true. 5.6 -> $a. #x -> 2. 'abcd' -> false}.	{9 @ 3 extent: 5 @ 4. 0 @ 0 extent: 45 @ 9. -3 @ -7 extent: 2 @ 2. 4 @ 4 extent: 16 @ 16}.	{Color red.  Color blue. Color black. Color gray}}.self test2: objects."rec+0, rec+1, rec+2, rec+3 need to be tested.  " cnt := 0.nth to: 4 do: [:take |	nonRepeating := OrderedCollection new.	objects do: [:each |		nonRepeating addAll: (each copyFrom: 1 to: take)].	"all combinations of take, from nonRepeating"	even := true.	nonRepeating combinations: take atATimeDo: [:tuple |		even ifTrue: [other := tuple clone]			ifFalse: [self load: (aa := Array with: tuple with: 1 with: other with: 7).				(cnt := cnt + 1) \\ 50 = 0 ifTrue: [					Transcript cr; show: aa first printString].				self search: true.				self test2: aa.				self test2: nonRepeating.				"self test2: objects"].		even := even not].	].! !!MethodFinder methodsFor: 'initialize' stamp: 'nice 3/31/2011 01:15'!testRandom	"verify that the methods allowed don't crash the system.  Pick 3 or 4 from a mixed list of the fundamental types." 	| objects other aa cnt take tuple fName sss |	objects := #(		(1 4 17 42) ($a $b $c $d) ('one' 'two' 'three' 'four')		(x + rect: new) ((a b 1 4) (c 1 5) ($a 3 d) ()) (4.5 0.0 3.2 100.3)	).	objects := objects, {{true. false. true. false}. {Point. SmallInteger. Association. Array}.		{Point class. SmallInteger class. Association class. Array class}.		"{ 4 blocks }."		{Date today. '1 Jan 1950' asDate. '25 Aug 1987' asDate. '1 Jan 2000' asDate}.		{'15:16' asTime. '1:56' asTime. '4:01' asTime. '6:23' asTime}.		{Dictionary new. Dictionary new. Dictionary new. Dictionary new}.		{#(a b 1 4) asOrderedCollection. #(c 1 5) asOrderedCollection. 			#($a 3 d) asOrderedCollection. #() asOrderedCollection}.		{3 -> true. 5.6 -> $a. #x -> 2. 'abcd' -> false}.		{9 @ 3 extent: 5 @ 4. 0 @ 0 extent: 45 @ 9. -3 @ -7 extent: 2 @ 2. 4 @ 4 extent: 16 @ 16}.		{Color red.  Color blue. Color black. Color gray}}.	self test2: objects.	"rec+0, rec+1, rec+2, rec+3 need to be tested.  " 	fName := (FileDirectory default fileNamesMatching: '*.ran') first.	sss := fName splitInteger first.	(Collection classPool at: #RandomForPicking) seed: sss.	cnt := 0.		[take := #(3 4) atRandom.	tuple := (1 to: take) collect: [:ind | (objects atRandom) atRandom].	other := (1 to: take) collect: [:ind | (objects atRandom) atRandom].	self load: (aa := Array with: tuple with: 1 with: other with: 7).	((cnt := cnt + 1) \\ 10 = 0) " | (cnt > Skip)" ifTrue:		[Transcript cr; show: cnt printString; tab; tab; show: aa first printString].	cnt > (Smalltalk at: #StopHere) ifTrue: [self halt].		"stop just before crash"	cnt > (Smalltalk at: #Skip)		ifTrue:			["skip this many at start"			self search: true.			self test2: aa first.  self test2: (aa at: 3).			"self test2: objects"]] repeat.	! !!MethodHolder methodsFor: 'contents' stamp: 'nice 2/23/2011 21:51'!contents: input notifying: aController 	| selector |	(selector := methodClass newParser parseSelector: input asText) ifNil:		[self inform: 'Sorry - invalid format for the method name and arguments -- cannot accept.'.		^ false].	selector == methodSelector ifFalse:		[self inform:'You cannot change the name ofthe method here -- it must continueto be ', methodSelector.		^ false].	selector := methodClass				compile: input asText				classified: self selectedMessageCategoryName				notifying: aController.	selector == nil ifTrue: [^ false].	contents := input asString copy.	currentCompiledMethod := methodClass compiledMethodAt: methodSelector.	^ true! !!MethodHolder methodsFor: 'menu' stamp: 'nice 3/31/2011 21:51'!doItReceiver	"If there is an instance associated with me, answer it, for true mapping of self.  If not, then do what other code-bearing tools do, viz. give access to the class vars."	^ self selectedClass! !!MethodHolder class methodsFor: '*Etoys' stamp: 'ar 5/20/2010 19:56'!isolatedCodePaneForClass: aClass selector: aSelector	"Answer a MethodMorph on the given class and selector"	| aCodePane aMethodHolder |	aMethodHolder := self new.	aMethodHolder methodClass: aClass methodSelector: aSelector.	aCodePane := MethodMorph on: aMethodHolder text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aMethodHolder addDependent: aCodePane.	aCodePane borderWidth: 2; color: Color white.	aCodePane scrollBarOnLeft: false.	aCodePane width: 300.	^ aCodePane! !!MethodHolder class methodsFor: '*Etoys' stamp: 'ar 5/20/2010 19:56'!makeIsolatedCodePaneForClass: aClass selector: aSelector	"Create, and place in the morphic Hand, an isolated code pane bearing source code for the given class and selector"	(self isolatedCodePaneForClass: aClass selector: aSelector) openInHand! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:01'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^self generate: CompiledMethodTrailer empty using: CompiledMethod! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:00'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is arbitrary but is typically either the reference	 to the source code that is stored with every CompiledMethod, or an	 encoding of the method's temporary names."	^self generate: trailer using: CompiledMethod! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:01'!generate: trailer ifQuick: methodBlock	^self generate: trailer using: CompiledMethod ifQuick: methodBlock! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:02'!generate: trailer using: aCompiledMethodClass	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.	 The argument, trailer, is arbitrary but is typically either the reference to the source code	 that is stored with every CompiledMethod, or an encoding of the method's temporary names."	| primErrNode blkSize nLits literals stack method |	self generate: trailer		using: aCompiledMethodClass		ifQuick:			[:m |			  m	literalAt: 2 put: encoder associationForClass;				properties: properties.			^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	encoder supportsClosureOpcodes ifTrue:		[self ensureClosureAnalysisDone.		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].	blkSize := (block sizeCodeForEvaluatedValue: encoder)				+ (primErrNode					ifNil: [0]					ifNotNil: [primErrNode sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).	method := aCompiledMethodClass				newBytes: blkSize				trailerBytes: trailer 				nArgs: arguments size				nTemps: (encoder supportsClosureOpcodes							ifTrue: [| locals |									locals := arguments,											  temporaries,											  (primErrNode												ifNil: [#()]												ifNotNil: [{primErrNode}]).									encoder										noteBlockExtent: block blockExtent										hasLocals: locals.									locals size]							ifFalse: [encoder maxTemp])				nStack: 0				nLits: (nLits := (literals := encoder allLiterals) size)				primitive: primitive.	nLits > 255 ifTrue:		[^self error: 'Too many literals referenced'].	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].	stack position: method numTemps.	block emitCodeForEvaluatedValue: stack encoder: encoder.	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 14:59'!generate: trailer using: aCompiledMethodClass ifQuick: methodBlock	| v |	(primitive = 0 and: [arguments size = 0 and: [block isQuick]]) ifFalse:		[^self].	v := block code.	v < 0 ifTrue:		[^self].	v = LdSelf ifTrue:		[^methodBlock value: (aCompiledMethodClass toReturnSelfTrailerBytes: trailer)].	(v between: LdTrue and: LdMinus1 + 3) ifTrue:		[^methodBlock value: (aCompiledMethodClass toReturnConstant: v - LdSelf trailerBytes: trailer)].	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType)) ifTrue:		[^methodBlock value: (aCompiledMethodClass toReturnField: v trailerBytes: trailer)].	v // 256 = 1 ifTrue:		[^methodBlock value: (aCompiledMethodClass toReturnField: v \\ 256 trailerBytes: trailer)]! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:01'!generateWithTempNames	"Answer a CompiledMethod with temps names encoded in trailer"	^self		generate: (CompiledMethodTrailer new tempNames: self schematicTempNamesString)		using: CompiledMethod! !!MethodNode methodsFor: 'code generation' stamp: 'eem 11/29/2008 18:53'!properties	^properties! !!MethodNode methodsFor: 'printing' stamp: 'eem 8/15/2010 10:36'!printWithClosureAnalysisOn: aStream 	self ensureClosureAnalysisDone.	precedence = 1		ifTrue: 			[(self selector includesSubString: '()/')				ifTrue: [aStream nextPutAll: (self selector copyUpTo: $)).						arguments							do: [:arg| aStream nextPutAll: arg key]							separatedBy: [aStream nextPutAll: ', '].						aStream nextPut: $)]				ifFalse: [aStream nextPutAll: self selector]]  "no node for method selector"		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				arg printDefinitionForClosureAnalysisOn: aStream.				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			 self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1; nextPut: $|.			temporaries do: [:temp | 				aStream space.				temp printDefinitionForClosureAnalysisOn: aStream].			aStream space; nextPut: $|].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printWithClosureAnalysisStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitMethodNode: self! !!MethodNode methodsFor: 'converting' stamp: 'eem 9/27/2011 15:15'!ensureNotQuick	"If the receiver is quick (can be generated as a Quick method, ^self,^inst var or ^ special constant)	 make it not so.  This is used to create break-pointable versions of quick methods.   Answer if the	 receiver was quick."	^block ensureNotQuick: encoder! !!MethodNode methodsFor: 'converting' stamp: 'eem 8/31/2010 11:54'!preen	"Preen for pretty-printing and/or decompilation.	 i.e. post-process to cover up for inadequacies in both algorithms.	 Currently one case, hiding the assignment to the arg of an inlined block arg to ifNotNil:,		(var := expr) ifNil: [...] ifNotNil: [...]    =>    expr ifNil: [...] ifNotNil: [:var| ...]."	self preenLocalIfNotNilArg! !!MethodNode methodsFor: 'converting' stamp: 'eem 8/31/2010 12:36'!preenLocalIfNotNilArg	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where	 the block already declares the variable and the decompile case where it does not."	| varsToHide |	varsToHide := Set new.	self nodesDo:		[:node| | variable |		(node isMessageNode		and: [node macroPrinter == #printIfNilNotNil:indent:		and: [node receiver isMessageNode		and: [node receiver selector key == #==		and: [node receiver receiver isAssignmentNode		and: [(variable := node receiver receiver variable) isTemp		and: [variable isRemote not		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:			[node arguments last arguments isEmpty				ifTrue: [node arguments last arguments: { variable }.						varsToHide add: variable]				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].			 node receiver receiver: node receiver receiver value]].	varsToHide notEmpty ifTrue:		[self nodesDo:			[:node|			((node == self or: [node isBlockNode])			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !!MethodNode methodsFor: 'source mapping' stamp: 'nice 2/23/2011 21:50'!rawSourceRangesAndMethodDo: aBinaryBlock	"Evaluate aBinaryBlock with the rawSourceRanges and method generated from the receiver."	| methNode method |	methNode := encoder classEncoding newParser					encoderClass: encoder class;					parse: (sourceText "If no source, use decompile string as source to map from"							ifNil: [self decompileString]							ifNotNil: [sourceText])					class: self methodClass.	method := methNode generate.  "set bytecodes to map to"	^aBinaryBlock		value: methNode encoder rawSourceRanges		value: method! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 15:27'!addLocalsToPool: locals "<Set of: TempVariableNode>"	localsPool isNil ifTrue:		[localsPool := IdentitySet new].	localsPool addAll: locals! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2008 10:04'!ensureClosureAnalysisDone	block blockExtent ifNil:		[temporaries := block analyseArguments: arguments temporaries: temporaries rootNode: self]! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 13:43'!locationCounter	^locationCounter! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:27'!noteBlockEntry: aBlock	"Evaluate aBlock with the numbering for the block entry."	locationCounter isNil ifTrue:		[locationCounter := -1].	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 12:12'!noteBlockExit: aBlock	"Evaluate aBlock with the numbering for the block exit."	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:07'!referencedValuesWithinBlockExtent: anInterval 	^(localsPool select:		[:temp|		 temp isReferencedWithinBlockExtent: anInterval]) collect:			[:temp|			temp isRemote ifTrue: [temp remoteNode] ifFalse: [temp]]! !!MethodNode methodsFor: 'debugger support' stamp: 'nice 2/23/2011 21:51'!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	^encoder blockExtentsToTempsMap ifNil:		[| methNode |		methNode := encoder classEncoding newParser						encoderClass: encoder class;						parse: (sourceText ifNil: [self decompileString])						class: self methodClass.		"As a side effect generate: creates data needed for the map."		methNode generate.		methNode encoder blockExtentsToTempsMap]! !!MethodNode methodsFor: 'debugger support' stamp: 'eem 7/1/2009 13:45'!hasGeneratedMethod	^encoder hasGeneratedMethod! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:58'!schematicTempNamesString	"Answer the temp names for the current method node in a form that captures	 temp structure.  The temps at each method and block scope level occur	 space-separated, with any indirect temps enclosed in parentheses.  Each block	 level is enclosed in square brackets.  e.g.		'method level temps (indirect temp)[block args and temps (indirect)]'	 This representation can be reconstituted into a blockExtentsToTempsMap	 by a CompiledMethod that has been copied with the schematicTempNamesString."	encoder hasGeneratedMethod ifFalse:		["create the encoder's blockExtentsToLoals map, except if the method is quick		  in which case it has no temps."		(self generate) isQuick ifTrue:			[^'']].	^encoder schematicTempNamesString! !!MethodNode commentStamp: 'eem 8/15/2010 10:49' prior: 0!I am the root of the parse tree..Instance Variables	arguments:			<SequenceableCollection>	block:				<BlockNode>	encoder:			<BytecodeEncoder>	localsPool:			<IdentitySet>	locationCounter:	<Integer>	precedence:		<Integer>	primitive:			<Integer>	properties:			<AdditionalMethodState|nil>	selectorOrFalse:	<Object>	sourceText:		<String|Text>	temporaries:		<SequenceableCollection>arguments	- the collection of parsed or decompiled method argumentsblock	- the BlockNode holding the method's statementsencoder	- the object that comprises the copiler's scope table, literal pool and back-end bytecode generatorlocalsPool	- a set used to determine the set of copied values for each block in the methodlocationCounter	- an integer used to mark block scopes for the purposes of the closure transformation.  See BlockNode>>#analyseArguments:temporaries:rootNode:precedence	- the precedence of the method's selector (see Symbol>>precedence)primitive	- if non-zero this is the integer code of the method's primitiveproperties	- the object used to accumulate method properties (a.k.a. pragmas)selectorOrFalse	- the method's selector or false if this is a doitsourceText	- the source test from which the method was compiledtemporaries	- the collection of parsed or decompiled method temporaries!!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'fbs 12/22/2010 07:23'!testCompileCharacter	self assertPragma: 'foo: $a' givesKeyword: #foo: arguments: #( $a ).	self assertPragma: 'foo: $ ' givesKeyword: #foo: arguments: { Character space }.! !!MethodPropertiesTest methodsFor: 'testing' stamp: 'eem 5/23/2011 17:16'!testAllMethodsHaveMethodClass	Smalltalk garbageCollect.	self assert: (CompiledMethod allInstances			reject: [:cm | | lastLiteral |				lastLiteral := cm literalAt: cm numLiterals.				lastLiteral isVariableBinding					and: [lastLiteral value isBehavior							or: [lastLiteral value isTrait]]]) isEmpty			description: 'CompiledMethods must have methodClass literal'! !!MethodReference methodsFor: '*monticello' stamp: 'cmm 3/8/2011 20:16'!workingCopy	"Answer the MCWorkingCopy in which I am defined."	^ self packageInfo workingCopy! !!MethodReference methodsFor: 'comparing' stamp: 'RAA 5/28/2001 11:56'!<= anotherMethodReference	classSymbol < anotherMethodReference classSymbol ifTrue: [^true].	classSymbol > anotherMethodReference classSymbol ifTrue: [^false].	classIsMeta = anotherMethodReference classIsMeta ifFalse: [^classIsMeta not].	^methodSymbol <= anotherMethodReference methodSymbol! !!MethodReference methodsFor: 'comparing' stamp: 'nice 1/1/2010 21:57'!= anotherMethodReference 	"Answer whether the receiver and the argument represent the 	same object."	^ self species == anotherMethodReference species		and: [self classSymbol = anotherMethodReference classSymbol		and: [self classIsMeta = anotherMethodReference classIsMeta		and: [self methodSymbol = anotherMethodReference methodSymbol]]]! !!MethodReference methodsFor: 'comparing' stamp: 'dgd 3/8/2003 11:54'!hash	"Answer a SmallInteger whose value is related to the receiver's  	identity."	^ (self species hash bitXor: self classSymbol hash)		bitXor: self methodSymbol hash! !!MethodReference methodsFor: 'accessing' stamp: 'ul 3/13/2011 23:14'!actualClass 	^Smalltalk globals at: classSymbol ifPresent: [ :actualClass |		classIsMeta			ifTrue: [ actualClass classSide ]			ifFalse: [ actualClass ] ]! !!MethodReference methodsFor: 'accessing' stamp: 'ar 12/12/2009 17:43'!category	"Answers the class category (cached for reuse via MC and other tools)"	^ category ifNil: [category := self actualClass organization categoryOfElement: methodSymbol]! !!MethodReference methodsFor: 'accessing' stamp: 'RAA 5/28/2001 08:10'!classSymbol	^classSymbol! !!MethodReference methodsFor: 'accessing' stamp: 'RAA 5/28/2001 08:10'!methodSymbol	^methodSymbol! !!MethodReference methodsFor: 'accessing' stamp: 'eem 5/25/2010 17:56'!selector	^methodSymbol! !!MethodReference methodsFor: 'accessing' stamp: 'sr 6/4/2004 01:55'!sourceString	^ (self actualClass sourceCodeAt: self methodSymbol) asString! !!MethodReference methodsFor: 'accessing' stamp: 'RAA 5/29/2001 14:44'!stringVersion	^stringVersion! !!MethodReference methodsFor: 'accessing' stamp: 'RAA 5/29/2001 14:44'!stringVersion: aString	stringVersion := aString! !!MethodReference methodsFor: 'accessing' stamp: 'kph 12/16/2006 10:11'!stringVersionDefault	^classSymbol, (classIsMeta ifTrue: [ ' class ' ] ifFalse: [' ']), methodSymbol  ! !!MethodReference methodsFor: 'initialize-release' stamp: 'mtf 10/4/2008 00:52'!category: aSymbol	category := aSymbol! !!MethodReference methodsFor: 'initialize-release' stamp: 'RAA 5/28/2001 08:06'!setClass: aClass methodSymbol: methodSym stringVersion: aString 	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	methodSymbol := methodSym.	stringVersion := aString.! !!MethodReference methodsFor: 'initialize-release' stamp: 'RAA 5/28/2001 07:34'!setClassAndSelectorIn: csBlock	^csBlock value: self actualClass value: methodSymbol! !!MethodReference methodsFor: 'initialize-release' stamp: 'RAA 5/28/2001 06:04'!setClassSymbol: classSym classIsMeta: isMeta methodSymbol: methodSym stringVersion: aString 	classSymbol := classSym.	classIsMeta := isMeta.	methodSymbol := methodSym.	stringVersion := aString.! !!MethodReference methodsFor: 'initialize-release' stamp: 'kph 12/16/2006 10:06'!setStandardClass: aClass methodSymbol: methodSym	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	methodSymbol := methodSym.	stringVersion := nil.! !!MethodReference methodsFor: 'testing' stamp: 'RAA 5/28/2001 08:11'!classIsMeta	^classIsMeta! !!MethodReference methodsFor: 'testing' stamp: 'md 8/27/2005 17:17'!isValid	"Answer whether the receiver represents a current selector or Comment"	| aClass |	methodSymbol isDoIt ifTrue: [^ false].	(aClass := self actualClass) ifNil: [^ false].	^ (aClass includesSelector: methodSymbol) or:		[methodSymbol == #Comment]! !!MethodReference methodsFor: 'printing' stamp: 'sw 11/5/2001 00:53'!printOn: aStream	"Print the receiver on a stream"	super printOn: aStream.	aStream nextPutAll: ' ', self actualClass name, ' >> ', methodSymbol! !!MethodReference methodsFor: 'converting' stamp: 'ul 7/6/2011 02:29'!asString	^stringVersion ifNil: [ self stringVersionDefault ]! !!MethodWithInterface methodsFor: 'script editor' stamp: 'sw 3/10/2003 23:58'!allScriptActivationButtons	"Answer all the script-activation buttons that exist for this interface"	^ ScriptActivationButton allInstances select: 		[:aButton | aButton uniclassScript == self]! !!MirrorPrimitiveTests methodsFor: 'testing' stamp: 'eem 7/6/2010 20:44'!expectedFailures	^Smalltalk isRunningCog		ifTrue: [#()]		ifFalse: [#(testMirrorAt testMirrorEqEq testMirrorInstVarAt testMirrorPerform testMirrorSize)]! !!MixedSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:10'!postCopy	"Copy my component sounds."	super postCopy.	self copySounds! !!Monitor methodsFor: 'private' stamp: 'ul 9/10/2011 19:23'!exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil	[ 		| lock |		lock := queuesMutex critical: [ anOrderedCollection addLast: Semaphore new ].		self exit.		anIntegerOrNil 			ifNil: [ lock wait 	]			ifNotNil: [				| delay |				delay := MonitorDelay 					signalLock: lock					afterMSecs: anIntegerOrNil					inMonitor: self					queue: anOrderedCollection.				[ lock wait ] ensure: [ delay unschedule ] ] ]		ensure: [ self enter ]! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 02:13'!queueDict		^queueDict ifNil: [ queueDict := IdentityDictionary new ]! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 03:40'!signalAllInQueue: anOrderedCollection	queuesMutex critical: [		anOrderedCollection removeAllSuchThat: [ :each |			each signal.			true ] ]! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 03:41'!signalQueue: anOrderedCollection	queuesMutex critical: [		anOrderedCollection isEmpty ifFalse: [			anOrderedCollection removeFirst signal ] ]! !!MonitorTest methodsFor: 'examples' stamp: 'ul 9/10/2011 16:55'!testMonitorNotGainingUnwantedSignalsDuringUnwinding	| monitor process |	monitor := Monitor new.	process := [ monitor critical: [ monitor wait ] ] newProcess.	process resume.	50 milliSeconds asDelay wait.	process terminate.	self assert: 1 equals: ((monitor instVarNamed: #mutex) instVarNamed: #excessSignals)! !!Month commentStamp: 'cbr 7/28/2010 18:11' prior: 0!I represent a month.For example, to get the number of days this month, you can evaluate the following expression:Month current daysInMonth!!Month class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 09:29'!indexOfMonth: aMonthName	1 to: 12 do: [ :i |  (aMonthName, '*' match: (MonthNames at: i)) ifTrue: [^i] ].	self error: aMonthName , ' is not a recognized month name'.! !!Month class methodsFor: 'squeak protocol' stamp: 'cmm 4/28/2011 22:09'!readFrom: aStream	| m y c |	m := (ReadWriteStream with: '') reset.	[(c := aStream next) isSeparator] whileFalse: [m nextPut: c].	[(c := aStream next) isSeparator] whileTrue.	y := (ReadWriteStream with: '') reset.	y nextPut: c.	[aStream atEnd] whileFalse: [y nextPut: aStream next].	^ self 		month: m contents		year: y contents asInteger"Month readFrom: 'July 1998' readStream"! !!MonthTest methodsFor: 'Tests' stamp: 'ul 3/27/2011 17:27'!testIndexOfMonth	| m |	m := #(#January #February #March #April #May #June #July #August #September #October #November #December).		m withIndexDo: [:item :index | self assert: (Month indexOfMonth: item) = index].		self should: [Month indexOfMonth: 1] raise: TestResult error.	self should: [Month indexOfMonth: #'1'] raise: TestResult error.	self should: [Month indexOfMonth: #Marsh] raise: TestResult error. "notice the misspell!!"	self should: [Month indexOfMonth: #UnexistingMonth] raise: TestResult error.! !!Morph methodsFor: 'accessing' stamp: 'nice 8/28/2010 01:26'!sticky: aBoolean 	"change the receiver's sticky property"	(extension isNil and: [aBoolean not]) ifTrue: [^ self].	self assureExtension sticky: aBoolean! !!Morph methodsFor: 'drawing' stamp: 'bf 5/23/2011 11:51'!drawErrorOn: aCanvas	"The morph (or one of its submorphs) had an error in its drawing method."	| saneBounds |	saneBounds := bounds rounded.	aCanvas		frameAndFillRectangle: saneBounds		fillColor: Color red		borderWidth: 1		borderColor: Color yellow.	aCanvas line: saneBounds topLeft to: saneBounds bottomRight width: 1 color: Color yellow.	aCanvas line: saneBounds topRight to: saneBounds bottomLeft width: 1 color: Color yellow.! !!Morph methodsFor: 'drop shadows' stamp: 'cmm 12/4/2010 15:11'!changeShadowColor	"Change the shadow color of the receiver -- triggered, e.g. from a menu"	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: self shadowColor				setColorSelector: #shadowColor:) openNearMorph: self ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #shadowColor: ;				 originalColor: self shadowColor ;								putUpFor: self				near: self fullBoundsInWorld ]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 3/2/2010 16:16'!formerOwner: aMorphOrNil 	aMorphOrNil 		ifNil: [self removeProperty: #formerOwner]		ifNotNil: [self setProperty: #formerOwner toValue: aMorphOrNil]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 3/2/2010 16:16'!formerPosition: formerPosition 	formerPosition 		ifNil: [self removeProperty: #formerPosition]		ifNotNil: [self setProperty: #formerPosition toValue: formerPosition]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'cmm 12/4/2010 20:30'!slideToTrash: evt	"Perhaps slide the receiver across the screen to a trash can and make it disappear into it.  In any case, remove the receiver from the screen."	| aForm trash startPoint endPoint morphToSlide |	((self renderedMorph == Utilities scrapsBook) or: [self renderedMorph isKindOf: TrashCanMorph]) ifTrue:		[self dismissMorph.  ^ self].	Preferences slideDismissalsToTrash ifTrue:		[morphToSlide := self representativeNoTallerThan: 200 norWiderThan: 200 thumbnailHeight: 100.		aForm := morphToSlide imageForm offset: (0@0).		trash := ActiveWorld			findDeepSubmorphThat:				[:aMorph | (aMorph isKindOf: TrashCanMorph) and:					[aMorph topRendererOrSelf owner == ActiveWorld]]			ifAbsent:				[trash := TrashCanMorph new.				trash position: ActiveWorld bottomLeft - (0 @ (trash extent y + 26)).				trash openInWorld.				trash].		endPoint := trash fullBoundsInWorld center.		startPoint := self topRendererOrSelf fullBoundsInWorld center - (aForm extent // 2)].	self dismissMorph.	ActiveWorld displayWorld.	Preferences slideDismissalsToTrash ifTrue:		[aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15].	Utilities addToTrash: self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld startPoint endPoint |	aForm := self imageForm offset: 0@0.	aWorld := self world.	startPoint := evt hand fullBounds origin.	self delete.	aWorld displayWorld.	endPoint := aPosition.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	SoundService soundEnabled ifTrue: [TrashCanMorph playDeleteSound].! !!Morph methodsFor: 'events-processing' stamp: 'bf 6/24/2010 13:15'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent wasHandled: true.	(anEvent controlKeyPressed			and: [anEvent blueButtonChanged not				and: [Preferences cmdGesturesEnabled]])		ifTrue: [^ self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].		"this mouse down could be the start of a gesture, or the end of a gesture focus"	(self isGestureStart: anEvent)		ifTrue: [^ self gestureStart: anEvent].	self mouseDown: anEvent.	Preferences maintainHalos		ifFalse:[ anEvent hand removeHaloFromClick: anEvent on: self ].	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownThreshold			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepRate ].! !!Morph methodsFor: 'fileIn/out' stamp: 'cmm 2/24/2011 20:46'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName ok |	aFileName := ('my {1}' translated format: {self class name}) asFileName.	"do better?"	aFileName := UIManager default request: 'File name? (".morph" will be added to end)' translated 			initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^ Beeper beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok := aFileName endsWith: '.morph'.	"don't double them"	ok := ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName := aFileName,'.morph'].	self saveOnFileNamed: aFileName! !!Morph methodsFor: 'geometry' stamp: 'dtl 5/22/2011 16:10'!extent: aPoint	(bounds extent closeTo: aPoint) ifTrue: [^ self].	self changed.	bounds := (bounds topLeft extent: aPoint) rounded.	self layoutChanged.	self changed.! !!Morph methodsFor: 'initialization' stamp: 'cmm 12/4/2010 14:25'!openNear: aRectangle 	self		openNear: aRectangle		in: World! !!Morph methodsFor: 'initialization' stamp: 'cmm 12/4/2010 14:21'!openNear: aRectangle in: aWorld	| wb leftOverlap rightOverlap topOverlap bottomOverlap best |	wb := aWorld bounds.	self fullBounds.	leftOverlap := self width - (aRectangle left - wb left).	rightOverlap := self width - (wb right - aRectangle right).	topOverlap := self height - (aRectangle top - wb top).	bottomOverlap := self height - (wb bottom - aRectangle bottom).	best := nil.	{		{leftOverlap. #topRight:. #topLeft}.		{rightOverlap. #topLeft:. #topRight}.		{topOverlap. #bottomLeft:. #topLeft}.		{bottomOverlap. #topLeft:. #bottomLeft}.	} do: [ :tuple |		(best isNil or: [tuple first < best first]) ifTrue: [best := tuple].	].	self perform: best second with: (aRectangle perform: best third).	self bottom: (self bottom min: wb bottom) rounded.	self right: (self right min: wb right) rounded.	self top: (self top max: wb top) rounded.	self left: (self left max: wb left) rounded.	self openInWorld: aWorld.! !!Morph methodsFor: 'initialization' stamp: 'cmm 12/4/2010 14:24'!openNearMorph: aMorph 	self		openNear: aMorph boundsInWorld		in: (aMorph world ifNil: [ World ])! !!Morph methodsFor: 'menus' stamp: 'cmm 8/2/2010 18:20'!addPaintingItemsTo: aMenu hand: aHandMorph 	| subMenu movies |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'repaint' translated action: #editDrawing.	subMenu add: 'set rotation center' translated action: #setRotationCenter.	subMenu add: 'reset forward-direction' translated		action: #resetForwardDirection.	subMenu add: 'set rotation style' translated action: #setRotationStyle.	subMenu add: 'erase pixels of color' translated		action: #erasePixelsUsing:.	subMenu add: 'recolor pixels of color' translated		action: #recolorPixelsUsing:.	subMenu add: 'reduce color palette' translated action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' translated		action: #addBorderToShape:.	movies := (self world rootMorphsAt: aHandMorph targetPoint) 				select: [:m | (m isKindOf: MovieMorph) or: [m isSketchMorph]].	movies size > 1 		ifTrue: 			[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'ul 11/15/2010 11:54'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	self mustBeBackmost ifFalse:		[aMenu add: 'send to back' translated action: #goBehind.		aMenu add: 'bring to front' translated action: #comeToFront.		self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.		aMenu addLine].	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addBorderStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	owner isTextMorph ifTrue:[self addTextAnchorMenuItems: aMenu hand: aHandMorph].	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addPlayerItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addStackItemsTo: aMenu.	self addMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size = 1 ifTrue:		[aMenu			add: ('unlock "{1}"' translated format: unlockables first externalName)			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'cmm 12/4/2010 15:10'!changeColor	"Change the color of the receiver -- triggered, e.g. from a menu"	NewColorPickerMorph useIt		ifTrue: [ (NewColorPickerMorph on: self) openNear: self fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #fillStyle: ;				 originalColor: self color ;								putUpFor: self				near: self fullBoundsInWorld ]! !!Morph methodsFor: 'meta-actions' stamp: 'mtf 2/20/2011 20:40'!blueButtonDown: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h tfm doNotDrag |	h := anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag := false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag := true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag := true].		(self hasOwner: h target) ifTrue:[doNotDrag := true]].	tfm := (self transformedFrom: nil) inverseTransformation.	"cmd-drag on flexed morphs works better this way"	h := self addHalo: (anEvent transformedBy: tfm).	h ifNil: [^ self].	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: (anEvent transformedBy: tfm)		selectors: { nil. nil. nil. #dragTarget:. }		threshold: HandMorph dragThreshold.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!Morph methodsFor: 'meta-actions' stamp: 'cmm 12/4/2010 15:11'!changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand 	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"	| desiredLoc |	self flag: #arNote.	"Simplify this due to anObject == self for almost all cases"	desiredLoc := anObject isMorph		ifTrue:			[ Rectangle				center: self position				extent: 20 ]		ifFalse:			[ anObject == self world				ifTrue: [ anObject viewBox bottomLeft + (20 @ -20) extent: 200 ]				ifFalse: [ anObject fullBoundsInWorld ] ].	^ NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: anObject				originalColor: aColor				setColorSelector: aSymbol) openNear: desiredLoc ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: aHand ;				 target: anObject ;				 selector: aSymbol ;				 originalColor: aColor ;								putUpFor: anObject				near: desiredLoc ;				 yourself ]! !!Morph methodsFor: 'meta-actions' stamp: 'cmm 12/4/2010 19:27'!embedInto: evt	"Embed the receiver into some other morph"	|  target morphs |	morphs := self potentialEmbeddingTargets.	target := UIManager default 		chooseFrom: (morphs collect:[:m| m knownName ifNil:[m class name asString]])		values: self potentialEmbeddingTargets		title: ('Place ', self externalName, ' in...').	target ifNil:[^self].	target addMorphFrontFromWorldPosition: self! !!Morph methodsFor: 'meta-actions' stamp: 'ul 9/28/2011 14:07'!subclassMorph	"Create a new subclass of this morph's class and make this morph be an instance of it."	| oldClass newClassName newClass |	oldClass := self class.	newClassName := UIManager default		request: 'Please give this new class a name'		initialAnswer: oldClass name.	newClassName = '' ifTrue: [^ self].	(Smalltalk includesKey: newClassName)		ifTrue: [^ self inform: 'Sorry, there is already a class of that name'].	newClass := oldClass subclass: newClassName asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: oldClass category asString.	self becomeForward: (self as: newClass)! !!Morph methodsFor: 'printing' stamp: 'ul 12/9/2010 03:01'!colorString: aColor 	aColor ifNil: [ ^'nil' ].	^aColor name		ifNil: [ aColor storeString ]		ifNotNil: [ :colorName | 'Color ', colorName ]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'nice 5/8/2011 10:50'!hasSubmorphWithProperty: aSymbol	^submorphs anySatisfy: [:m | m hasProperty: aSymbol]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ul 8/2/2011 20:05'!submorphThat: block1 ifNone: block2	^submorphs detect: block1 ifNone: block2	! !!Morph methodsFor: 'testing' stamp: 'nk 9/4/2004 17:38'!isSelectionMorph	^false! !!Morph methodsFor: 'testing' stamp: 'cmm 12/4/2010 20:24'!renameTo: aName 	"Set Player name in costume. Update Viewers. Fix all tiles (old style). fix 	References. New tiles: recompile, and recreate open scripts. If coming in 	from disk, and have name conflict, References will already have new 	name."	| aPresenter putInViewer aPasteUp renderer oldKey assoc classes oldName |	oldName := self knownName.	oldName=aName ifTrue: [ ^aName ].	(renderer := self topRendererOrSelf) setNameTo: aName.	putInViewer := false.	((aPresenter := self presenter) isNil or: [renderer player isNil]) 		ifFalse: 			[putInViewer := aPresenter currentlyViewing: renderer player.			putInViewer ifTrue: [renderer player viewerFlapTab hibernate]].	"empty it temporarily"	(aPasteUp := self topPasteUp) 		ifNotNil: [aPasteUp allTileScriptingElements do: [:m | m bringUpToDate]].	"Fix References dictionary. See restoreReferences to know why oldKey is  	already aName, but oldName is the old name."	oldKey := References keyAtIdentityValue: renderer player ifAbsent: [].	oldKey ifNotNil: 			[assoc := References associationAt: oldKey.			oldKey = aName 				ifFalse: 					["normal rename"					assoc key: (renderer player uniqueNameForReferenceFrom: aName).					References rehash]].	putInViewer ifTrue: [aPresenter viewMorph: self].	"recreate my viewer"	oldKey ifNil: [^aName].	"Force strings in tiles to be remade with new name. New tiles only."	Preferences universalTiles ifFalse: [^aName].	classes := (self systemNavigation allCallsOn: assoc) 				collect: [:each | each classSymbol].	classes asSet 		do: [:clsName | (Smalltalk at: clsName) replaceSilently: oldName to: aName].	"replace in text body of all methods. Can be wrong!!"	"Redo the tiles that are showing. This is also done in caller in 	unhibernate. "	aPasteUp ifNotNil: 			[aPasteUp allTileScriptingElements do: 					[:mm | 					"just ScriptEditorMorphs"					nil.					(mm isScriptEditorMorph) 						ifTrue: 							[((mm playerScripted class compiledMethodAt: mm scriptName) 								hasLiteral: assoc) 									ifTrue: 										[mm											hibernate;											unhibernate]]]].	^aName! !!Morph methodsFor: '*Etoys-support' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!makeFenceSound	SoundService soundEnabled ifTrue:		[self playSoundNamed: 'scratch'].! !!Morph class methodsFor: 'new-morph participation' stamp: 'ar 7/21/2010 20:03'!partName: aName categories: aList documentation: aDoc sampleImageForm: aForm	"Answer a DescriptionForPartsBin which will represent a launch of a new instance of my class via the #newStandAlone protocol sent to my class. Use the category-list and documentation provided.  This variant allows an overriding image form to be provided, useful in cases where we don't want to launch a sample instance just to get the form"	| descr |	descr := DescriptionForPartsBin new		formalName: aName		categoryList: aList		documentation: aDoc		globalReceiverSymbol: self name		nativitySelector: #newStandAlone.	descr sampleImageForm: aForm.	^ descr! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'jmv 7/28/2009 18:15'!privateOtherProperties: anIdentityDictionary 	"private - change the receiver's otherProperties"	otherProperties := anIdentityDictionary ! !!MorphExtension methodsFor: '*MorphicExtras-Undo' stamp: 'ul 2/12/2011 00:29'!removeUndoCommands	| keysToBeRemoved |	otherProperties ifNil: [ ^self ].	otherProperties keysAndValuesDo: [ :key :value |		value class == Command ifTrue: [			(keysToBeRemoved ifNil: [				keysToBeRemoved := OrderedCollection new ]) add: key ] ].	keysToBeRemoved ifNil: [ ^self ].	keysToBeRemoved do: [ :each |		self removeProperty: each ]	! !!MorphicAlarm methodsFor: 'evaluating' stamp: 'jmv 3/2/2010 16:18'!value: anArgument	| nArgs |	numArgs ifNil:[numArgs := selector numArgs].	nArgs := arguments ifNil:[0] ifNotNil:[arguments size].	nArgs = numArgs ifTrue:[		"Ignore extra argument"		^self value].	^arguments		ifNil: [ receiver perform: selector with: anArgument]		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: anArgument)]! !!MorphicAlarmQueue methodsFor: 'adding' stamp: 'ul 11/15/2010 11:55'!add: aMorphicAlarm	(sequenceNumber := sequenceNumber + 1) = 16r3FFFFFFF ifTrue: [		"Sequence number overflow... reassign sequence numbers starting at 0."		| alarmList |		alarmList := self asArray sort: [:msg1 :msg2 |			 msg1 sequenceNumber < msg2 sequenceNumber		].		alarmList withIndexDo: [:msg :ind | msg sequenceNumber: ind-1].		"The #bitAnd: for the unlikely event that we have > 16r3FFFFFF messages in the queue."		sequenceNumber := alarmList last sequenceNumber + 1 bitAnd: 16r3FFFFFFF.	].	aMorphicAlarm sequenceNumber: sequenceNumber.	super add: aMorphicAlarm.		"If we doubt our sanity..."	false ifTrue: [		self isValidHeap ifFalse: [self error: 'not a valid heap!!!!!!'].	].	^aMorphicAlarm! !!MorphicModel class methodsFor: 'compilation'!compileAccessorsFor: varName	self compile: ('&var	"Return the value of &var"	^ &var'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&varPut: newValue	"Assign newValue to &var.	Add code below to update related graphics appropriately..."	&var := newValue.'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&var: newValue	"Assigns newValue to &var and updates owner"	&var := newValue.	self propagate: &var as: ''&var:'''			copyReplaceAll: '&var' with: varName)		classified: 'private - propagation' notifying: nil.! !!MorphicProject methodsFor: 'scheduling' stamp: 'fm 9/11/2010 00:54'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	^ self interruptName: labelString preemptedProcess: nil! !!MorphicProject methodsFor: 'utilities' stamp: 'nice 12/29/2010 14:50'!setAsBackground: aForm	"Set  aForm as a background image."	| thisWorld newColor |	thisWorld := self currentWorld.	newColor := InfiniteForm with: aForm.	aForm rememberCommand:		(Command new cmdWording: 'set background to a picture' translated;			undoTarget: thisWorld selector: #color: argument: thisWorld color;			redoTarget: thisWorld selector: #color: argument: newColor).	thisWorld color: newColor! !!MorphicProject methodsFor: 'flaps support' stamp: 'cmm 12/6/2010 15:09'!cleanseDisabledGlobalFlapIDsList	"Make certain that the items on the disabled-global-flap list are actually global flaps, and if not, get rid of them"	| disabledFlapIDs currentGlobalIDs oldList |	disabledFlapIDs := self parameterAt: #disabledGlobalFlapIDs ifAbsent: [Set new].	currentGlobalIDs := Flaps globalFlapTabsIfAny collect: [:f | f flapID].	oldList := Project current projectParameterAt: #disabledGlobalFlaps ifAbsent: [nil].	oldList ifNotNil:		[disabledFlapIDs := oldList select: [:aFlap | aFlap flapID]].	disabledFlapIDs := disabledFlapIDs select: [:anID | currentGlobalIDs includes: anID].	self projectParameterAt: #disabledGlobalFlapIDs put: disabledFlapIDs.	self removeParameter: #disabledGlobalFlaps.! !!MorphicProject methodsFor: 'docking bars support' stamp: 'cmm 12/6/2010 15:14'!createOrUpdateMainDockingBar	"Private - create a new main docking bar or update the current one"	| w mainDockingBars |	w := self world.	mainDockingBars := w mainDockingBars.	mainDockingBars isEmpty		ifTrue: ["no docking bar, just create a new one"			self dockingBar createDockingBar openInWorld: w.			^ self].	"update if needed"	mainDockingBars		do: [:each | self dockingBar updateIfNeeded: each]! !!MorphicProject methodsFor: 'docking bars support' stamp: 'cmm 12/6/2010 15:05'!dockingBar	^ self		projectParameterAt: #dockingBar		ifAbsent: [ TheWorldMainDockingBar instance ]! !!MorphicProject methodsFor: 'docking bars support' stamp: 'cmm 12/6/2010 15:26'!dockingBar: aTheWorldMainDockingBar 	self		projectParameterAt: #dockingBar		put: aTheWorldMainDockingBar.	self isCurrentProject ifTrue: [ TheWorldMainDockingBar instance: aTheWorldMainDockingBar ]! !!MorphicProject methodsFor: 'file in/out' stamp: 'cmm 12/6/2010 15:09'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder |	self flag: #toRemove.	self halt.  "unused"	"world == World ifTrue: [^ false]."		"self inform: 'Can''t send the current world out'."	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers. 	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	holder := Project allProjects.	"force them in to outPointers, where DiskProxys are made"	"Just export me, not my previous version"	revertSeg := self parameterAt: #revertToMe.	self projectParameters removeKey: #revertToMe ifAbsent: [].	roots := OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).	roots := roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"	catList do: [:sysCat | 		(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |			roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].	is := ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is := ImageSegment new copyFromRootsForExport: roots asArray)"	is state = #tooBig ifTrue: [^ false].	str := ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str := str, '\Project''s own world is not in the segment.' withCRs].	str isEmpty ifFalse: [		ans := (UIManager default				 chooseFrom: #('Do not write file' 'Write file anyway' 'Debug')				 title: str).		ans = 1 ifTrue: [			revertSeg ifNotNil: [self projectParameterAt: #revertToMe put: revertSeg].			^ false].		ans = 3 ifTrue: [self halt: 'Segment not written']].	is writeForExportWithSources: aFileName inDirectory: aDirectory.	revertSeg ifNotNil: [self projectParameterAt: #revertToMe put: revertSeg].	holder.	world flapTabs do: [:ft | 			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj isScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!MorphicProject methodsFor: 'file in/out' stamp: 'cmm 12/6/2010 15:11'!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileNamedirectory: aDirectory	"Store my project out on the disk as an *exported*ImageSegment.  All outPointers will be in a form that can be resolvedin the target image.  Name it <project name>.extSeg.  Whatdo we doabout subProjects, especially if they are out as local imagesegments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder collector fd mgr stacks |	"Files out a changeSet first, so that a project can containits own classes"	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any	references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers.	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	holder := Project allProjects.	"force them in to outPointers, where	DiskProxys are made"	"Just export me, not my previous version"	revertSeg := self parameterAt: #revertToMe.	self removeParameter: #revertToMe.	roots := OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand.		"; addAll: classList; addAll: (classList collect: [:cls | cls class])"	roots := roots reject: [ :x | x isNil].	"early saves may not have	active hand or thumbnail"		fd := aDirectory directoryNamed: self resourceDirectoryName.		fd assureExistence.		"Clean up resource references before writing out"		mgr := self resourceManager.		self resourceManager: nil.		ResourceCollector current: ResourceCollector new.		ResourceCollector current localDirectory: fd.		ResourceCollector current baseUrl: self resourceUrl.		ResourceCollector current initializeFrom: mgr.		ProgressNotification signal: '2:findingResources' extra:	'(collecting resources...)' translated.		"Must activate old world because this is run at #armsLength.		Otherwise references to ActiveWorld, ActiveHand, or ActiveEvent		will not be captured correctly if referenced from blocks or user code."		world becomeActiveDuring:[			is := ImageSegment new copySmartRootsExport: roots asArray.			"old way was (is := ImageSegment new	copyFromRootsForExport: roots asArray)"		].		self resourceManager: mgr.		collector := ResourceCollector current.		ResourceCollector current: nil.		ProgressNotification signal: '2:foundResources' extra: ''.		is state = #tooBig ifTrue: [			collector replaceAll.			^ false].	str := ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str := str, '\Project''s own world is not in the segment.' translated withCRs].	str isEmpty ifFalse: [		ans := UIManager default chooseFrom: {			'Do not write file' translated.			'Write file anyway' translated.			'Debug' translated.		} title: str.		ans = 1 ifTrue: [			revertSeg ifNotNil: [projectParameters at:	#revertToMe put: revertSeg].			collector replaceAll.			^ false].		ans = 3 ifTrue: [			collector replaceAll.			self halt: 'Segment not written' translated]].		stacks := is findStacks.		is			writeForExportWithSources: aFileName			inDirectory: fd			changeSet: aChangeSetOrNil.		SecurityManager default signFile: aFileName directory: fd.		"Compress all files and update check sums"		collector forgetObsolete.		self storeResourceList: collector in: fd.		self storeHtmlPageIn: fd.		self storeManifestFileIn: fd.		self writeStackText: stacks in: fd registerIn: collector.		"local proj.005.myStack.t"		self compressFilesIn: fd to: aFileName in: aDirectory	resources: collector.				"also deletes the resource directory"		"Now update everything that we know about"		mgr updateResourcesFrom: collector.	revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].	holder.	collector replaceAll.	world flapTabs do: [:ft |			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj isScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!MorphicProject methodsFor: 'enter' stamp: 'dtl 3/4/2011 12:49'!finalEnterActions	"Perform the final actions necessary as the receiver project is entered"	| navigator armsLengthCmd navType thingsToUnhibernate |	self initializeMenus.	self projectParameters 		at: #projectsToBeDeleted 		ifPresent: [ :projectsToBeDeleted |			self removeParameter: #projectsToBeDeleted.			projectsToBeDeleted do: [ :each | 				Project deletingProject: each.				each removeChangeSetIfPossible]].	Locale switchAndInstallFontToID: self localeID.	thingsToUnhibernate := world valueOfProperty: #thingsToUnhibernate ifAbsent: [#()].	thingsToUnhibernate do: [:each | each unhibernate].	world removeProperty: #thingsToUnhibernate.	navType := ProjectNavigationMorph preferredNavigator.	armsLengthCmd := self parameterAt: #armsLengthCmd ifAbsent: [nil].	navigator := world findA: navType.	(Preferences classicNavigatorEnabled and: [Preferences showProjectNavigator and: [navigator isNil]]) ifTrue:		[(navigator := navType new)			bottomLeft: world bottomLeft;			openInWorld: world].	navigator notNil & armsLengthCmd notNil ifTrue:		[navigator color: Color lightBlue].	armsLengthCmd notNil ifTrue:		[Preferences showFlapsWhenPublishing			ifFalse:				[self flapsSuppressed: true.				navigator ifNotNil:	[navigator visible: false]].		armsLengthCmd openInWorld: world].	world reformulateUpdatingMenus.	world presenter positionStandardPlayer.	self assureMainDockingBarPresenceMatchesPreference.	WorldState addDeferredUIMessage: [self startResourceLoading].! !!MorphicProject methodsFor: 'enter' stamp: 'dtl 3/4/2011 12:50'!initializeMenus	"Menu setting for these classes may have have been modified by another	Morphic project, e.g. SimpleMorphic. Ensure that they are restored to the	expected menus."	TextEditor initialize.	SmalltalkEditor initialize! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'dtl 9/24/2011 10:16'!buildPluggableButton: aSpec	| widget label state action enabled |	label := aSpec label.	state := aSpec state.	action := aSpec action.	widget := self buttonClass on: aSpec model				getState: (state isSymbol ifTrue:[state])				action: nil				label: (label isSymbol ifTrue:[label]).	widget style: aSpec style.	aSpec changeLabelWhen		ifNotNilDo: [ :event | widget whenChanged: event update: aSpec label].	self register: widget id: aSpec name.	enabled := aSpec enabled.	enabled isSymbol		ifTrue:[widget getEnabledSelector: enabled]		ifFalse:[widget enabled:enabled].	widget action: action.	widget getColorSelector: aSpec color.	widget offColor: Color white..	self buildHelpFor: widget spec: aSpec. 	(label isSymbol or:[label == nil]) ifFalse:[widget label: label].	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'rww 9/11/2010 04:23'!buildPluggableCheckBox: spec	| widget label state action |	label := spec label.	state := spec state.	action := spec action.	widget := self checkBoxClass on: spec model				getState: (state isSymbol ifTrue:[state])				action: (action isSymbol ifTrue:[action])				label: (label isSymbol ifTrue:[label]).	self register: widget id: spec name.	widget installButton."	widget getColorSelector: spec color.	widget offColor: Color white..	self buildHelpFor: widget spec: spec. 	(label isSymbol or:[label == nil]) ifFalse:[widget label: label]."	self setFrame: spec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'rww 9/11/2010 14:15'!buildPluggableDropDownList: spec	| widget model listSelector selectionSelector selectionSetter |	model := spec model.	listSelector := spec listSelector.	selectionSelector := spec selectionSelector.	selectionSetter := spec selectionSetter.	widget := self dropDownListClass new		model: model;		listSelector: listSelector;		selectionSelector: selectionSelector;		selectionSetter: selectionSetter;		yourself.	self register: widget id: spec name.	widget installDropDownList.	self setFrame: spec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'fbs 5/2/2010 15:31'!buildPluggableList: aSpec	| widget listClass getIndex setIndex |	aSpec getSelected ifNil:[		listClass := self listClass.		getIndex := aSpec getIndex.		setIndex := aSpec setIndex.	] ifNotNil:[		listClass := self listByItemClass.		getIndex := aSpec getSelected.		setIndex := aSpec setSelected.	].	widget := listClass on: aSpec model				list: aSpec list				selected: getIndex				changeSelected: setIndex				menu: aSpec menu				keystroke: aSpec keyPress.	self register: widget id: aSpec name.	widget getListElementSelector: aSpec listItem.	widget getListSizeSelector: aSpec listSize.	widget doubleClickSelector: aSpec doubleClick.	widget dragItemSelector: aSpec dragItem.	widget dropItemSelector: aSpec dropItem.	widget wantsDropSelector: aSpec dropAccept.	widget autoDeselect: aSpec autoDeselect.	widget keystrokePreviewSelector: aSpec keystrokePreview.	aSpec color isNil ifFalse: [widget color: aSpec color].	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	panes ifNotNil:[		aSpec list ifNotNil:[panes add: aSpec list].	].	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'mtf 2/4/2011 14:33'!buildPluggableWindow: aSpec	| widget children |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := (self windowClassFor: aSpec) new.	self register: widget id: aSpec name.	widget model: aSpec model.	aSpec label ifNotNil:		[:label|		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	aSpec multiWindowStyle notNil ifTrue:		[widget savedMultiWindowState: (SavedMultiWindowState on: aSpec model)].	children := aSpec children.	children isSymbol ifTrue:[		widget getChildrenSelector: children.		widget update: children.		children := #().	].	widget closeWindowSelector: aSpec closeAction.	panes := OrderedCollection new.	self buildAll: children in: widget.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: (aSpec extent ifNil:[widget initialExtent])		world: self currentWorld).	widget setUpdatablePanesFrom: panes.	^widget! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'rww 9/11/2010 03:39'!checkBoxClass	^ PluggableCheckBoxMorph! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'rww 9/11/2010 14:05'!dropDownListClass	^ PluggableDropDownListMorph! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'mtf 2/4/2011 14:32'!windowClassFor: aSpec	aSpec isDialog ifTrue: [^ PluggableDialogWindow].	^aSpec multiWindowStyle		caseOf:		{	[nil]				->	[PluggableSystemWindow].			[#labelButton]	->	[PluggableSystemWindowWithLabelButton] }		otherwise:				[PluggableSystemWindowWithLabelButton]! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'cmm 1/20/2011 10:41'!defaultTimeout	^ 60 "seconds"! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ul 5/2/2010 12:32'!findWindowInWorldLabeled: aLabel	^World submorphs		detect: [ :each |			(each isKindOf: SystemWindow)				and: [ each label = aLabel ] ]		ifNone: nil.! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ar 7/22/2010 19:44'!testUIManagerNoAcceptInitially	"Ensure that UIManager does not invoke the accept: action initially."	| accepted window |	accepted := false.	window := UIManager default edit: Text new label: 'Test' accept: [:val| accepted := true].	window delete.	self deny: accepted.! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'ul 12/12/2010 22:00'!chooseClassOrTrait: label from: environment	"Let the user choose a Class or Trait. Use ListChooser in Morphic."		| names index |	names := environment classAndTraitNames.	index := self		chooseFrom: names		lines: #()		title: label.	index = 0 ifTrue: [ ^nil ].	^environment		at: (names at: index)		ifAbsent: [ nil ]! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'cmm 5/27/2011 14:05'!displayProgress: titleString at: aPoint from: minVal to: maxVal during: workBlock 	"Display titleString as a caption over a progress bar while workBlock is evaluated."	| result progress |	progress := SystemProgressMorph		position: aPoint		label: titleString		min: minVal		max: maxVal.	[ [ result := workBlock value: progress ]		on: ProgressNotification		do:			[ : ex | ex extraParam isString ifTrue:				[ SystemProgressMorph uniqueInstance					labelAt: progress					put: ex extraParam ].			ex resume ] ] ensure: [ SystemProgressMorph close: progress ].	^ result! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'ar 7/22/2010 14:27'!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	"By default, don't style in UIManager edit: requests"	window model		shouldStyle: false;		acceptContents:  aText;		acceptAction: anAction.	^window.! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'ul 6/18/2011 11:07'!informUserDuring: aBlock	"Display a message above (or below if insufficient room) the cursor 	during execution of the given block.		UIManager default informUserDuring:[:bar|			#(one two three) do:[:info|				bar value: info.				(Delay forSeconds: 1) wait]]"	SystemProgressMorph		informUserAt: nil during: aBlock.! !!MorphicUIManager methodsFor: 'initialize-release' stamp: 'dtl 2/12/2011 15:56'!initialize	toolBuilder := MorphicToolBuilder new! !!MorphicUIManager commentStamp: 'dtl 5/2/2010 16:07' prior: 0!MorphicUIManager is a UIManager that implements user interface requests for a Morphic user interface.!!MouseOverHandler methodsFor: 'event handling' stamp: 'nice 8/8/2011 21:28'!processMouseOver: anEvent 	"Re-establish the z-order for all morphs wrt the given event"	| hand localEvt focus evt |	hand := anEvent hand.	leftMorphs := mouseOverMorphs asIdentitySet.	"Assume some coherence for the number of objects in over list"	overMorphs := WriteStream on: (Array new: leftMorphs size).	enteredMorphs := WriteStream on: #().	"Now go looking for eventual mouse overs"	hand handleEvent: anEvent asMouseOver.	"Get out early if there's no change"	(leftMorphs isEmpty and: [ enteredMorphs position = 0 ]) 		ifTrue: [ ^self initializeTrackedMorphs ].	focus := hand mouseFocus.	"Send #mouseLeave as appropriate"	evt := anEvent asMouseLeave.	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"	leftMorphs size > 1 		ifTrue:			[leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].			leftMorphs do: [ :m | 			(m == focus or: [m hasOwner: focus])				ifFalse: [ overMorphs nextPut: m ]				ifTrue: 					[ localEvt := evt transformedBy: (m transformedFrom: hand).					m handleEvent: localEvt ] ].	enteredMorphs ifNil: [ "inform: was called in handleEvent:"		^self initializeTrackedMorphs ].	"Send #mouseEnter as appropriate"	evt := anEvent asMouseEnter.	enteredMorphs contents reverseDo: [ :m | 		(m == focus or: [m hasOwner: focus]) ifTrue: [			localEvt := evt transformedBy: (m transformedFrom: hand).			m handleEvent: localEvt ] ].	"And remember the over list"	overMorphs ifNotNil: [ mouseOverMorphs := overMorphs contents ].	self initializeTrackedMorphs! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:08'!next: anInteger putAll: aCollection startingAt: startIndex	(self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [		^super next: anInteger putAll: aCollection startingAt: startIndex ].	^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:13'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'nice 8/27/2010 20:49'!upTo: delim 	| out ch |	out := WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	[(ch := self next) == nil] whileFalse: [		(ch = delim) ifTrue: [			^ out contents  "terminator is not doubled; we're done!!"		].		out nextPut: ch.	].	^ out contents.! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'ul 1/31/2011 02:04'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^super next: anInteger putAll: aCollection startingAt: startIndex! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'ul 1/20/2011 01:42'!converter	^converter ifNil: [		self initializeConverter.		converter ]! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/20/2011 01:51'!bareNext	self deprecated: 'Don''t use this method anymore.'.	^converter nextFromStream: self.! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:35'!convertStringFromCr: aString 	| inStream outStream |		self deprecated: 'This method is obsolete and private, don''t use it!!'.	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream := ReadStream on: aString.	outStream := WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:35'!convertStringToCr: aString 	| inStream outStream |		self deprecated: 'This method is obsolete and private, don''t use it!!'.	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Lf with: Cr].	"lineEndConvention == #crlf"	inStream := ReadStream on: aString.	outStream := WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: 					[outStream nextPut: Cr.					inStream peek = Lf ifTrue: [inStream next]]].	^ outStream contents! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:34'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead state |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	wantsLineEndConversion ifFalse: [self lineEndConvention: nil.					^lineEndConvention].	self closed ifTrue: [self lineEndConvention: LineEndDefault.					^lineEndConvention].	"Default if nothing else found"	numRead := 0.	state := converter saveStateOf: self.	lineEndConvention := nil.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char := self next.			char = Lf				ifTrue: 					[converter restoreStateOf: self with: state.					self lineEndConvention: #lf.					^lineEndConvention].			char = Cr				ifTrue: 					[self peek = Lf						ifTrue: [self lineEndConvention: #crlf]						ifFalse: [self lineEndConvention: #cr].					converter restoreStateOf: self with: state.					^ lineEndConvention].			numRead := numRead + 1].	converter restoreStateOf: self with: state.	self lineEndConvention: LineEndDefault.	^ lineEndConvention! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:35'!doConversion	^wantsLineEndConversion and: [ lineEndConvention notNil ]! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 12/27/2010 04:43'!next: n innerFor: aString	aString size = 0 ifTrue: [^ aString].	"if we just read a CR, and the next character is an LF, then skip the LF"	aString last == Cr ifTrue: [		| state |		state := converter saveStateOf: self.		(converter nextFromStream: self) ifNotNil: [ :peekChar |			peekChar == Lf ifFalse: [				converter restoreStateOf: self with: state ] ] ].	^aString withSqueakLineEndings! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/30/2011 04:31'!wantsLineEndConversion	^wantsLineEndConversion! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/30/2011 04:34'!next	| char |	char := converter nextFromStream: self.	"#doConversion is inlined here"	(wantsLineEndConversion and: [ lineEndConvention notNil ]) ifTrue: [		char == Cr ifTrue: [			| state |			state := converter saveStateOf: self.			(converter nextFromStream: self) ifNotNil: [ :secondChar |				secondChar == Lf ifFalse: [					converter restoreStateOf: self with: state ] ].			^Cr ].		char == Lf ifTrue: [			^Cr ] ].	^char.! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/30/2011 04:31'!next: anInteger 	| multiString |	self isBinary ifTrue: [^ super next: anInteger].	multiString := String new: anInteger.	1 to: anInteger do: [:index |		| character |		(character := self next)			ifNotNil: [ multiString at: index put: character ]			ifNil: [				multiString := multiString copyFrom: 1 to: index - 1.				(wantsLineEndConversion and: [ lineEndConvention notNil ]) "#doConversion is inlined here"					ifFalse: [ ^multiString ].				^self next: anInteger innerFor: multiString ] ].	(wantsLineEndConversion and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifFalse: [ ^multiString ].	multiString := self next: anInteger innerFor: multiString.	(multiString size = anInteger or: [self atEnd]) ifTrue: [ ^ multiString].	^ multiString, (self next: anInteger - multiString size).! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:08'!next: anInteger putAll: aCollection startingAt: startIndex	(self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [		^super next: anInteger putAll: aCollection startingAt: startIndex ].	^converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 5/17/2011 17:30'!nextPut: aCharacter	aCharacter isInteger ifTrue: [ ^super nextPut: aCharacter ].	^converter nextPut: aCharacter toStream: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:07'!nextPutAll: aCollection	(self isBinary or: [aCollection class == ByteArray]) ifTrue: [		^ super nextPutAll: aCollection.	].	^converter nextPutAll: aCollection toStream: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 3/15/2011 13:32'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next state |	state := converter saveStateOf: self.	next := self next.	converter restoreStateOf: self with: state.	^next! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:03'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteFileStream methodsFor: 'remnant' stamp: 'ul 1/30/2011 04:35'!wantsLineEndConversion: aBoolean		wantsLineEndConversion := aBoolean.	lineEndConvention ifNil: [ self detectLineEndConvention ]! !!MultiByteFileStream methodsFor: 'private' stamp: 'ul 1/30/2011 04:36'!installLineEndConventionInConverter	converter ifNotNil: [		converter installLineEndConvention: (			(wantsLineEndConversion and: [ lineEndConvention notNil ]) "#doConversion is inlined here"				ifTrue: [ LineEndStrings at: lineEndConvention ]				ifFalse: [ nil ]) ]! !!MultiByteFileStream methodsFor: 'private' stamp: 'ul 1/20/2011 01:55'!setConverterForCode	| currentPosition |	(SourceFiles at: 2)		ifNotNil: [self fullName = (SourceFiles at: 2) fullName ifTrue: [^ self]].	currentPosition := self position.	self position: 0.	self binary.	((self next: 3) = #[ 16rEF 16rBB 16rBF ]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	self position: currentPosition.	self text.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'ul 1/31/2011 02:05'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^super next: anInteger putAll: aCollection startingAt: startIndex! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08'!basicUpTo: delim	^ super upTo: delim.! !!MultiByteFileStream methodsFor: 'initialize-release' stamp: 'ul 1/30/2011 04:28'!initialize	super initialize.	wantsLineEndConversion := false.	self initializeConverter! !!MultiByteFileStream methodsFor: 'initialize-release' stamp: 'ul 1/4/2011 07:53'!initializeConverter	self converter: TextConverter defaultSystemConverter! !!MultiByteFileStream class methodsFor: 'accessing' stamp: 'cmm 10/10/2010 19:17'!lineEndDefault	"Answer the default line-ending convention that will be used by default, which was determined at start-up by looking at platform atributes."	^ LineEndDefault! !!MultiByteFileStream class methodsFor: 'as yet unclassified' stamp: 'ul 1/20/2011 02:18'!newForStdio	"Use crlf as line end convention on windows, lf on all other platforms. Also make sure that the converter is initialized."		| lineEndConvention |	lineEndConvention := self lineEndDefault.	lineEndConvention == #crlf ifFalse: [		lineEndConvention := #lf ].	^self new		lineEndConvention: lineEndConvention;		initializeConverter;		yourself! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 4/21/2011 15:45'!testLineEndConversion	| failures | 	fileName := 'foolinendconversion.txt'.	failures := OrderedCollection new.	TextConverter allSubclassesDo: [ :textConverterClass |		textConverterClass encodingNames ifNotEmpty: [			#(cr lf crlf) do: [ :lineEndConvention |				self					testLineEndConvention: lineEndConvention					withConverter: textConverterClass					ifFail: [ :expectedResult :result |						failures add: {							textConverterClass.							lineEndConvention.							expectedResult.							result } ] ] ] ].	self assert: failures isEmpty! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 4/21/2011 15:43'!testLineEndingWithWideStrings	| cr lf crlf |	fileName := 'foolinend.txt'.	cr := String cr asWideString.	lf := String lf asWideString.	crlf := String crlf asWideString.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file 			wantsLineEndConversion: false;			nextPutAll: 'line 1'; nextPutAll: cr;			nextPutAll: 'line 2'; nextPutAll: crlf;			nextPutAll: 'line 3'; nextPutAll: lf;			nextPutAll: 'line 4' ].	{		{#cr.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{#lf.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{#crlf.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{nil.  'line 1' , String cr , 'line 2' , String crlf , 'line 3' , String lf , 'line 4'}	} do: [ :lineEndingResult |		MultiByteFileStream oldFileNamed: fileName do: [ :file |			file lineEndConvention: lineEndingResult first.			self assert: file upToEnd = lineEndingResult last ] ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 1/30/2011 03:34'!testNextLine	fileName := 'foonextline.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file			wantsLineEndConversion: false;			nextPutAll: 'line 1'; cr;			nextPutAll: 'line 2'; crlf;			nextPutAll: 'line 3'; lf;			nextPutAll: 'line 4' ].	#(cr lf crlf nil) do: [:lineEnding |		MultiByteFileStream oldFileNamed: fileName do: [ :file |			file lineEndConvention: lineEnding.			self				assert: file nextLine = 'line 1';				assert: file nextLine = 'line 2';				assert: file nextLine = 'line 3';				assert: file nextLine = 'line 4';				assert: file nextLine = nil ] ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 1/31/2011 02:47'!testNextPutAllStartingAt	| result |	fileName := 'foonextputallstartingat.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		{ 'abcde' asWideString. 'abcde' } do: [ :string |			file 				next: 1 putAll: string startingAt: 5;				next: 3 putAll: string startingAt: 2;				next: 1 putAll: string startingAt: 1 ] ].	result := StandardFileStream readOnlyFileNamed: fileName do: [ :file |		file binary; contents ].	self assert: #[101 98 99 100 97 101 98 99 100 97] equals: result! !!MultiByteFileStreamTest methodsFor: 'running' stamp: 'ul 2/14/2010 13:21'!tearDown	fileName ifNotNil: [		FileDirectory default deleteFileNamed: fileName ]! !!MultiByteFileStreamTest methodsFor: 'helpers' stamp: 'ul 1/30/2011 16:06'!testLineEndConvention: lineEndConvention withConverter: textConverterClass ifFail: failBlock	| expectedResult result |	[		MultiByteFileStream forceNewFileNamed: fileName do: [ :file |			file				converter: textConverterClass new;				lineEndConvention: lineEndConvention;				cr;				nextPut: Character cr;				nextPutAll: String cr;				nextPutAll: String cr asWideString ].		result := StandardFileStream oldFileNamed: fileName do: [ :file |			file contents ].		expectedResult := String streamContents: [ :stream |			4 timesRepeat: [ stream perform: lineEndConvention ] ].		result = expectedResult ifFalse: [			failBlock value: expectedResult asByteArray value: result asByteArray ] ]		on: Error		do: [ :err | failBlock value: err messageText value: err messageText ]! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'ul 6/17/2011 12:38'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop stopCondition |	line := textLine.	rightMargin := line rightMargin.	lastIndex := line first.	self setStopConditions.		"also sets font"	characterIndex := index.  " == nil means scanning for point"	characterPoint := aPoint.	(characterPoint isNil or: [characterPoint y > line bottom])		ifTrue: [characterPoint := line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX := leftMargin := line leftMarginForAlignment: alignment.	destY := line top.	runLength := text runLengthFor: line first.	characterIndex		ifNotNil:	[lineStop := characterIndex  "scanning for index"]		ifNil:	[lineStop := line last  "scanning for point"].	runStopIndex := lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0.	[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex		in: text string rightX: characterPoint x		stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (specialWidth		ifNil: [font widthOf: (text at: lastIndex)]		ifNotNil: [specialWidth]).	(self perform: stopCondition) ifTrue:		[characterIndex			ifNil: [				"Result for characterBlockAtPoint: "				(stopCondition ~~ #cr and: [ lastIndex == line last					and: [ aPoint x > ((characterPoint x) + (lastCharacterExtent x / 2)) ]])						ifTrue: [ "Correct for right half of last character in line"							^ (CharacterBlock new stringIndex: lastIndex + 1									text: text									topLeft: characterPoint + (lastCharacterExtent x @ 0) + (font descentKern @ 0)									extent:  0 @ lastCharacterExtent y)								textLine: line ].					^ (CharacterBlock new stringIndex: lastIndex						text: text topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent - (font baseKern @ 0))								textLine: line]			ifNotNil: ["Result for characterBlockForIndex: "					^ (CharacterBlock new stringIndex: characterIndex						text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent)								textLine: line]]] repeat! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'ul 6/17/2011 12:38'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength stopCondition |	"Set up margins"	leftMargin := lineRectangle left.	leftSide ifTrue: [leftMargin := leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX := spaceX := leftMargin.	firstDestX := destX.	rightMargin := lineRectangle right.	rightSide ifTrue: [rightMargin := rightMargin - textStyle rightIndent].	lastIndex := startIndex.	"scanning sets last index"	destY := lineRectangle top.	lineHeight := baseline := 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	presentationLine := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	numOfComposition := 0.	spaceCount := 0.	self handleIndentation.	leftMargin := destX.	line leftMargin: leftMargin.	presentationLine leftMargin: leftMargin.	presentation := TextStream on: (Text fromString: (WideString new: text size)).	[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex		in: text string rightX: rightMargin stopConditions: stopConditions		kern: kern.	"See setStopConditions for stopping conditions for composing."	(self perform: stopCondition)		ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading					baseline: baseline + textStyle leading.				^ line lineHeight: lineHeight + textStyle leading					baseline: baseline + textStyle leading]] repeat! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'ul 6/17/2011 12:38'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength stopCondition |	destX := spaceX := leftMargin := aParagraph leftMarginForCompositionForLine: lineIndex.	destY := 0.	rightMargin := aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex := startIndex.	"scanning sets last index"	lineHeight := textStyle lineGrid.  "may be increased by setFont:..."	baseline := textStyle baseline.	baselineY := destY + baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	presentationLine := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	numOfComposition := 0.	presentation := TextStream on: (Text fromString: (WideString new: text size)).	spaceCount := 0.		[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex		in: text string rightX: rightMargin stopConditions: stopConditions		kern: kern.	"See setStopConditions for stopping conditions for composing."	(self perform: stopCondition)		ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading					baseline: baseline + textStyle leading.				^line lineHeight: lineHeight + textStyle leading					baseline: baseline + textStyle leading]] repeat! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'mtf 12/30/2010 23:37'!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	(anchoredMorph isMorph or: [anchoredMorph isPrimitiveCostume]) ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY := lineY.		baselineY := lineY + anchoredMorph height..		runX := destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect			rule: Form blend			fillColor: Color white 	].	^ true! !!MultiWindowLabelButtonMorph methodsFor: 'drawing' stamp: 'eem 5/6/2008 13:24'!drawOn: aCanvas 	"Be invisible."! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 17:03'!performAction	"Override to interpret the actionSelector as a menu accessor and to activate that menu."	actionSelector ifNotNil:		[(model perform: actionSelector) ifNotNil:			[:menu|			menu				invokeModalAt: self position - (0@5)				in: ActiveWorld				allowKeyboard: Preferences menuKeyboardControl]]! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState	"Answer the value of savedMultiWindowState"	^ savedMultiWindowState! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState: anObject	"Set the value of savedMultiWindowState"	savedMultiWindowState := anObject! !!MultiWindowLabelButtonMorph commentStamp: 'eem 6/30/2010 16:13' prior: 0!A MultiWindowLabelButtonMorph is  a means of implementing tabbed windows.  It cooperates with PluggableSystemWindowWithButton to provide a drop-down menu of windows when clicking in the window label.  It requires the model to create a suitable sub-instance of SavedMultiWindowState for inactive windows.  To specify multi-windows use the multiWindowStyle: setter to customize a PluggableWindowSpec.Instance Variables	savedMultiWindowState:		<SavedMultiWindowState>savedMultiWindowState	- the sequence of models in a multi-window.!!NaNError methodsFor: 'testing' stamp: 'ar 12/13/2010 23:36'!isResumable	"NaNError is always resumable"	^true! !!NaNError methodsFor: 'accessing' stamp: 'ar 12/13/2010 23:38'!messageText	"Return an exception's message text."	^messageText ifNil:['This operation would result in NaN ']! !!NaNError commentStamp: 'ar 12/14/2010 00:03' prior: 0!NaNError is signaled by various operations that would either result in or operate on an NaN input.!!NetNameResolver class methodsFor: 'lookups' stamp: 'jmv 3/2/2010 16:18'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	"NetNameResolver addressForName: '100000jobs.de' timeout: 30"	"NetNameResolver addressForName: '1.7.6.4' timeout: 30"	"NetNameResolver addressForName: '' timeout: 30 (This seems to return nil?)"	| deadline result |	self initializeNetwork.	"check if this is a valid numeric host address (e.g. 1.2.3.4)"	result := self addressFromString: hostName.	result ifNotNil: [^result].	"Look up a host name, including ones that start with a digit (e.g. 100000jobs.de or squeak.org)"	deadline := Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex		critical: [			(self waitForResolverReadyUntil: deadline)				ifTrue: [					self primStartLookupOfName: hostName.					(self waitForCompletionUntil: deadline)						ifTrue: [result := self primNameLookupResult]						ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]]				ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]].	^result! !!NewArrayNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitNewArrayNode: self! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58'!emitCodeForValue: stack encoder: encoder	encoder genPushNewArray: numElements.	stack push: 1! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58'!sizeCodeForValue: encoder	^encoder sizePushNewArray: numElements! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 12:38'!closeButtonLabel	^ 'Close' translated! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/3/2010 15:00'!initialize	super initialize.	self initializeHsvaMorph! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 11:29'!initializeHsvaMorph	hsvaMorph := HSVAColorSelectorMorph new		 hResizing: #spaceFill ;		 vResizing: #spaceFill ;		 yourself.	hsvaMorph		when: #selectedColor		send: #colorSelected:		to: self! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 12:38'!newBottomRow	^ Morph new		 color: Color transparent ;		 changeTableLayout ;		 listDirection: #leftToRight ;		 hResizing: #spaceFill; vResizing: #shrinkWrap ;		 height: 20 ;		 cellInset: 4 ;		 addMorph: (StringMorph contents: 'Current selection:' translated) ;		 addMorphBack: self newColorPresenterMorph ;		 addMorphBack: self newCloseButton! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 11:45'!newCloseButton	^ (PluggableButtonMorph		on: self		getState: nil		action: #delete		label: #closeButtonLabel)		 vResizing: #spaceFill ;		 yourself! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/3/2010 15:36'!newColorExpressionMorph	| pluggable |	pluggable := (PluggableTextMorph		on: self		text: #colorExpression		accept: #colorExpression:)		 hResizing: #spaceFill ;		 vResizing: #rigid ;		 height: 20 ;		 acceptOnCR: true ;		 retractableOrNot ;		 yourself.	pluggable textMorph autoFit: false.	^ pluggable! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/3/2010 15:34'!newColorPresenterMorph	^ (ColorPresenterMorph		on: hsvaMorph		color: #selectedColor)		 vResizing: #rigid ; height: 20 ;		 hResizing: #spaceFill ;		 yourself! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 13:46'!setTarget: objectToHaveItsColorSet originalColor: aColor setColorSelector: colorSetterSymbol 	target := objectToHaveItsColorSet.	setColorSelector := colorSetterSymbol.	hsvaMorph selectedColor: aColor.	self setup! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 11:51'!setup	self		 color: (Color white slightlyDarker alpha: 0.88) ;		 cornerStyle: #rounded ;		 changeTableLayout ;		 hResizing: #rigid ;		 vResizing: #rigid ;		 extent: 240@240 ;		 addMorphBack: hsvaMorph ;		 addMorphBack: self newColorExpressionMorph ;		 addMorphBack: self newBottomRow ;		 layoutInset: 4 ;		 cellInset: 0! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 14:55'!colorExpression	"A Smalltalk which can create this color."	^ self selectedColor printString! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/4/2010 12:27'!colorExpression: aString 	"Set my color by evaluating aString, a Smalltalk expression which results in a Color instance."	| col |	{aString. 	'Color ' , aString}		detect:			[ : each | ([ col := Compiler evaluate: each ]				on: Error				do:					[ : err | nil ]) notNil ]		ifNone: [ nil ].	col ifNotNil: [ self selectedColor: col ]! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:53'!selectedColor	"The color selected."	^ hsvaMorph selectedColor! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:53'!selectedColor: aColor	"The color selected."	hsvaMorph selectedColor: aColor! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:52'!targetColor: aColor 	"The color of my target."	target ifNotNil:		[ target			perform: setColorSelector			with: aColor ]! !!NewColorPickerMorph methodsFor: 'model' stamp: 'cmm 12/3/2010 15:11'!colorSelected: aColor	self targetColor: aColor.	self changed: #colorExpression! !!NewColorPickerMorph methodsFor: 'model' stamp: 'cmm 12/3/2010 13:39'!setColorSelector	"Answer the value of setColorSelector"	^ setColorSelector! !!NewColorPickerMorph methodsFor: 'model' stamp: 'cmm 12/3/2010 13:39'!target	"Answer the object whose color will be controlled."	^ target! !!NewColorPickerMorph commentStamp: 'cmm 12/3/2010 13:36' prior: 0!A NewColorPickerMorph is a new widget for choosing colors in Morphic.  Instantiate a NewColorPickerMorph:	(NewColorPickerMorph		on: objectToHaveItsColorSet		getColorSelector: itsColorGetterSymbol		setColorSelector: itsColorSetterSymbol) openInWorld!!NewColorPickerMorph class methodsFor: 'create' stamp: 'cmm 12/4/2010 13:48'!on: anObject 	^ self		on: anObject		originalColor: anObject color		setColorSelector: #color:! !!NewColorPickerMorph class methodsFor: 'create' stamp: 'cmm 12/4/2010 13:46'!on: objectToHaveItsColorSet originalColor: originalColor setColorSelector: colorSetterSymbol 	^ self new		setTarget: objectToHaveItsColorSet		originalColor: originalColor		setColorSelector: colorSetterSymbol! !!NewColorPickerMorph class methodsFor: 'accessing' stamp: 'cmm 12/4/2010 15:05'!useIt	<preference: 'Use the new color-picker'		category: 'colors'		description: 'When true, a newly-enhanced color-picker is used.'		type: #Boolean>	^ UseIt ifNil: [ false ]! !!NewColorPickerMorph class methodsFor: 'accessing' stamp: 'cmm 12/4/2010 14:55'!useIt: aBoolean	UseIt := aBoolean! !!NewParagraph methodsFor: 'access' stamp: 'cmm 4/5/2010 16:24'!caretWidth	^ Editor dumbbellCursor		ifTrue: [ 2 ]		ifFalse: [ 0 ]! !!NewParagraph methodsFor: 'editing' stamp: 'ar 12/13/2010 23:26'!attributesAt: aPoint	"Answer the attributes at the given point"	^text attributesAt: (self characterBlockAtPoint: aPoint) stringIndex forStyle: textStyle! !!NewParagraph methodsFor: 'private' stamp: 'ul 5/12/2011 00:30'!fastFindFirstLineSuchThat: lineBlock	"Perform a binary search of the lines array and return the index	of the first element for which lineBlock evaluates as true.	This assumes the condition is one that goes from false to true for	increasing line numbers (as, eg, yval > somey or start char > somex).	If lineBlock is not true for any element, return size+1."		^lines		findBinaryIndex: [ :each | 			(lineBlock value: each)				ifTrue: [ -1 ]				ifFalse: [ 1 ] ]		ifNone: [ :lower :upper | upper ]! !!Number methodsFor: 'converting' stamp: 'nice 10/13/2011 23:55'!adaptToComplex: rcvr andSend: selector	"If I am involved in arithmetic with a Complex number, convert me to a Complex number."	^ rcvr perform: selector with: self asComplex! !!Number methodsFor: 'converting' stamp: 'nice 10/13/2011 23:53'!asComplex	"Answer a Complex number that represents value of the the receiver."	^ Complex real: self imaginary: 0! !!Number methodsFor: 'converting' stamp: 'brp 5/13/2003 10:13'!asDuration	^ Duration nanoSeconds: self asInteger! !!Number methodsFor: 'converting' stamp: 'wiz 5/29/2011 18:34'!asNonFraction		"Answer a number equivalent to the receiver that is not a fraction. See Fraction for active method."	^self ! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:12'!day	^ self sign days! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:56'!days	^ Duration days: self! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:28'!hour	^ self sign hours! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:56'!hours	^ Duration hours: self! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:26'!milliSecond	^ self sign milliSeconds! !!Number methodsFor: 'converting' stamp: 'brp 9/25/2003 13:16'!milliSeconds	^ Duration milliSeconds: self! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:16'!minute	^ self sign minutes! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:56'!minutes	^ Duration minutes: self! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:27'!nanoSecond	^ self sign nanoSeconds! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 08:52'!nanoSeconds	^ Duration nanoSeconds: self.! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:17'!second	^ self sign seconds! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:57'!seconds	^ Duration seconds: self! !!Number methodsFor: 'converting' stamp: 'brp 1/9/2004 06:19'!week	^ self sign weeks! !!Number methodsFor: 'converting' stamp: 'brp 5/16/2003 07:57'!weeks	^ Duration weeks: self! !!Number methodsFor: 'converting' stamp: 'nice 4/23/2011 02:25'!withNegativeSign	"Answer a number with same magnitude than receiver and negative sign."	^self abs negated! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:10'!arCosh	"Answer receiver's area hyperbolic cosine.	That is the inverse function of cosh."	^self asFloat arCosh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:10'!arSinh	"Answer receiver's area hyperbolic sine.	That is the inverse function of sinh."	^self asFloat arSinh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:09'!arTanh	"Answer receiver's area hyperbolic tangent.	That is the inverse function of tanh."	^self asFloat arTanh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 02:26'!copySignTo: aNumber	"Return a number with same magnitude as aNumber and same sign as self."	^ self positive		ifTrue: [aNumber abs]		ifFalse: [aNumber withNegativeSign].! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:54'!cosh	"Answer receivers hyperbolic cosine."		^self asFloat cosh! !!Number methodsFor: 'mathematical functions' stamp: 'nice 10/31/2010 22:03'!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."		^ (90 - (180 + self \\ 360 - 180) abs) degreesToRadians sin! !!Number methodsFor: 'mathematical functions' stamp: 'nice 10/31/2010 22:01'!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."		^(90 - self) degreeCos! !!Number methodsFor: 'mathematical functions' stamp: 'jmv 10/13/2011 08:36'!nthRoot: aPositiveInteger	"Answer the nth root of the receiver."	self subclassResponsibility! !!Number methodsFor: 'mathematical functions' stamp: 'jmv 10/13/2011 08:50'!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue: [		"Do the special case of integer power"		^ self raisedToInteger: aNumber].	aNumber isFraction ifTrue: [		"Special case for fraction power"		^ (self nthRoot: aNumber denominator) raisedToInteger: aNumber numerator ].	self < 0 ifTrue: [		^ ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].	0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"	0 = self ifTrue: [				"Special case of self = 0"		aNumber < 0			ifTrue: [^ (ZeroDivide dividend: self) signal]			ifFalse: [^ self]].	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Number methodsFor: 'mathematical functions'!sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."	self > 0 ifTrue: [^1].	self < 0 ifTrue: [^-1].	^0! !!Number methodsFor: 'mathematical functions' stamp: 'nice 9/21/2010 23:24'!sign: aNumber	"Return a Number with the same sign as aNumber and same magnitude as self."	^ aNumber copySignTo: self! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:54'!sinh	"Answer receivers hyperbolic sine"		^self asFloat sinh! !!Number methodsFor: 'mathematical functions' stamp: 'jmv 10/11/2011 08:34'!sqrt	"Answer the square root of the receiver."	self subclassResponsibility! !!Number methodsFor: 'mathematical functions' stamp: 'nice 4/23/2011 00:55'!tanh	"Answer receivers hyperbolic tangent"		^self asFloat tanh! !!Number methodsFor: 'printing' stamp: 'nice 3/29/2011 21:48'!printOn: aStream showingDecimalPlaces: placesDesired	"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator."	| rounder rounded roundedFractionPart |	placesDesired <= 0 ifTrue: [^ self rounded printOn: aStream].	rounder := 10 raisedToInteger: placesDesired.	rounded := self roundTo: rounder reciprocal.	rounded negative ifTrue: [aStream nextPut: $-].	rounded := rounded abs.	rounded integerPart truncated printOn: aStream.	aStream nextPut: $..	roundedFractionPart := (rounded fractionPart * rounder) truncated.	roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true! !!Number methodsFor: 'printing' stamp: 'nice 3/29/2011 21:39'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point."	^String new: placesDesired + 10 streamContents: [:aStream |		self printOn: aStream showingDecimalPlaces: placesDesired]"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 5-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2"! !!Number methodsFor: 'truncation and round off' stamp: 'wiz 5/29/2011 17:54'!ceiling	"Answer the integer nearest the receiver toward  infinity."	| truncation |	truncation := self truncated.	self <= 0 ifTrue: [^truncation].	self = truncation		ifTrue: [^truncation]		ifFalse: [^truncation + 1]! !!Number methodsFor: 'truncation and round off' stamp: 'cbc 6/7/2011 22:20'!roundDownTo: aNumber 	"Answer the next multiple of aNumber toward negative infinity that is nearest the 	receiver." 	"Examples:		3.1479 roundDownTo: 0.01 -> 3.14		3.1479 roundDownTo: 0.1 -> 3.1		1923 roundDownTo: 10 -> 1920		3.1479 roundDownTo: 0.005 -> 3.145		-3.1479 roundDownTo: 0.01 -> -3.15"			^(self/aNumber) floor * aNumber! !!Number methodsFor: 'truncation and round off' stamp: 'cbc 6/7/2011 22:21'!roundUpTo: aNumber 	"Answer the next multiple of aNumber toward infinity that is nearest the 	receiver." 	"Examples:		3.1479 roundUpTo: 0.01 -> 3.15		3.1479 roundUpTo: 0.1 -> 3.2		1923 roundUpTo: 10 -> 1930		3.1479 roundUpTo: 0.005 -> 3.15		-3.1479 roundUpTo: 0.01 -> -3.14"	^(self/aNumber) ceiling * aNumber! !!Number methodsFor: 'truncation and round off' stamp: 'cbc 6/7/2011 22:18'!truncateTo: aNumber 	"Answer the next multiple of aNumber toward zero that is nearest the 	receiver."	"Examples:		3.1479 truncateTo: 0.01 -> 3.14		3.1479 truncateTo: 0.1 -> 3.1		1923 truncateTo: 10 -> 1920		3.1479 truncateTo: 0.005 -> 3.145		-3.1479 truncateTo: 0.01 -> -3.14"	^(self quo: aNumber)		* aNumber! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 4/2/2010 20:25'!nextIntegerBase: aRadix	"Form an integer with following digits.	Fail if no digit found"		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerBase: aRadix.	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 8/27/2010 20:51'!nextIntegerBase: aRadix ifFail: aBlock	"Form an integer with optional sign and following digits from sourceStream."		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^aBlock value].	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'ul 11/16/2010 04:55'!testIntegerFromString	"This covers parsing in Number>>readFrom:	Trailing decimal points should be ignored."	#(		('123' isInteger 123)		('-123' isInteger -123)		('123.' isFloat 123)		('-123.' isFloat -123)		('123This is not to be read' isInteger 123)		('123s could be confused with a ScaledDecimal' isInteger 123)		('123e could be confused with a Float' isInteger 123)) do: [ :each |			[ :string :typeSelector :numericValue |				| result |				result := string asNumber.				self assert: (result perform: typeSelector).				self assert: result = numericValue ] valueWithArguments: each ]! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'ul 11/16/2010 04:53'!testIntegerReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i = 123.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123sA has unary message sA'.	i := Number readFrom: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: 'sA has unary message sA' = s.		rs := ReadStream on: '123sB has unary message sB'.	i := Number readFrom: rs.	self assert: (i isInteger and: [ i = 123 ])..	s := rs upToEnd.	self assert: 'sB has unary message sB' = s.! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'nice 9/22/2010 01:18'!testNegativeZero	"This test ensure that -0.0 will produce a negativeZero"	| negativeZero |	negativeZero := Number readFrom: '-0.0' readStream.		"If it is a negative zero, it must behave like a negative zero... IEEE 754 tells how it should behave"	self deny: (negativeZero at: 1) = 0 description: 'In IEEE 754, a negative zero has its sign bit set to 1'..	self assert: negativeZero = 0 description: 'In IEEE 754, a negative zero cannot be distinguished from zero'.! !!NumberTest methodsFor: 'tests' stamp: 'adrian_lienhard 1/7/2009 17:55'!testPrintShowingDecimalPlaces	self assert: (111.2 printShowingDecimalPlaces: 2) = '111.20'.	self assert: (111.2 printShowingDecimalPlaces: 0) = '111'.	self assert: (111 printShowingDecimalPlaces: 0) = '111'.	self assert: (111111111111111 printShowingDecimalPlaces: 2) = '111111111111111.00'.	self assert: (10 printShowingDecimalPlaces: 20) ='10.00000000000000000000'.	self assert: (0.98 printShowingDecimalPlaces: 2) = '0.98'.	self assert: (-0.98 printShowingDecimalPlaces: 2) = '-0.98'.	self assert: (2.567 printShowingDecimalPlaces: 2) = '2.57'.	self assert: (-2.567 printShowingDecimalPlaces: 2) = '-2.57'.	self assert: (0.01 printShowingDecimalPlaces: 2) = '0.01'.	self assert: (-0.001 printShowingDecimalPlaces: 2) = '0.00'.! !!NumberTest methodsFor: 'tests' stamp: 'bf 6/23/2011 15:33'!testZeroDivideHandler	"Test for user-defined ZeroDivide behavior"	[		self assert: 1 / 0 = Float infinity.		self assert: -1 / 0 = Float infinity negated.		self assert: 1.0 / 0 = Float infinity.		self assert: -1.0 / 0 = Float infinity negated.		self assert: 1 / 0.0 = Float infinity.		self assert: -1 / 0.0 = Float infinity negated.		self assert: 1.0 / 0.0 = Float infinity.		self assert: -1.0 / 0.0 = Float infinity negated.	]	on: ZeroDivide		do: [:ex | ex resume: ex dividend sign * Float infinity ]! !!Object methodsFor: 'converting' stamp: 'cmm 1/24/2011 17:10'!asStringOrText	"Answer a string that represents the receiver."	^ self asString! !!Object methodsFor: 'error handling' stamp: 'dtl 5/15/2011 11:19'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given	  message to the receiver but the receiver does not understand	  this message (typically sent from the machine when a message	 is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	| exception resumeValue |	(exception := MessageNotUnderstood new)		message: aMessage;		receiver: self.	resumeValue := exception signal.	^exception reachedDefaultHandler		ifTrue: [aMessage sentTo: self]		ifFalse: [resumeValue]! !!Object methodsFor: 'events-accessing' stamp: 'jmv 5/13/2009 10:14'!actionForEvent: anEventSelector    "Answer the action to be evaluated when <anEventSelector> has been triggered."	^self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil]! !!Object methodsFor: 'events-accessing' stamp: 'nice 8/22/2010 20:57'!actionForEvent: anEventSelectorifAbsent: anExceptionBlock    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	^actions ifNil: [anExceptionBlock value]! !!Object methodsFor: 'events-accessing' stamp: 'jmv 5/13/2009 10:16'!setActionSequence: actionSequenceforEvent: anEventSelector	| action |	"This is a good time to compact the action sequence of old, garbage collected stuff."	action := actionSequence asMinimalRepresentation.	action		ifNil: [ self removeActionsForEvent: anEventSelector]		ifNotNil: [			self updateableActionMap				at: anEventSelector asSymbol				put: action]! !!Object methodsFor: 'events-removing' stamp: 'ul 8/2/2011 20:06'!removeActionsSatisfying: aOneArgBlock forEvent: anEventSelector    self        setActionSequence:            ((self actionSequenceForEvent: anEventSelector)                reject: aOneArgBlock)        forEvent: anEventSelector! !!Object methodsFor: 'finalization' stamp: 'Igor.Stasenko 5/25/2010 04:59'!hasMultipleExecutors	"All objects, except ObjectFinalizerCollection instances should answer false to this message"	^ false! !!Object methodsFor: 'message handling' stamp: 'ul 3/5/2011 10:56'!executeMethod: compiledMethod	"Execute compiledMethod against the receiver with no args"	<primitive: 189>	^ self withArgs: #() executeMethod: compiledMethod! !!Object methodsFor: 'message handling' stamp: 'ul 3/15/2011 01:39'!perform: selector withEnoughArguments: anArray	"Send selector to the receiver with arguments in anArray. Only use enough arguments for the arity of the selector; supply nils for missing ones."		| numArgs args |	(numArgs := selector numArgs) = anArray size 		ifTrue: [ args := anArray asArray ]		ifFalse: [			args := Array new: numArgs.			args 				replaceFrom: 1				to: (anArray size min: args size)				with: anArray				startingAt: 1 ].	^self perform: selector withArguments: args! !!Object methodsFor: 'message handling' stamp: 'ul 3/5/2011 10:55'!with: arg1 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1"	<primitive: 189>	^ self withArgs: {arg1} executeMethod: compiledMethod! !!Object methodsFor: 'message handling' stamp: 'ul 3/5/2011 10:55'!with: arg1 with: arg2 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1 & arg2"	<primitive: 189>	^ self withArgs: {arg1. arg2} executeMethod: compiledMethod! !!Object methodsFor: 'message handling' stamp: 'ul 3/5/2011 10:55'!with: arg1 with: arg2 with: arg3 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1, arg2, & arg3"	<primitive: 189>	^ self withArgs: {arg1. arg2. arg3} executeMethod: compiledMethod! !!Object methodsFor: 'message handling' stamp: 'ul 3/5/2011 10:55'!with: arg1 with: arg2 with: arg3 with: arg4 executeMethod: compiledMethod	"Execute compiledMethod against the receiver and arg1, arg2, arg3, & arg4"	<primitive: 189>	^ self withArgs: {arg1. arg2. arg3. arg4} executeMethod: compiledMethod! !!Object methodsFor: 'objects from disk' stamp: 'tk 11/29/2004 15:04'!fixUponLoad: aProject seg: anImageSegment	"change the object due to conventions that have changed onthe project level.  (sent to all objects in the incoming project).Specific classes should reimplement this."! !!Object methodsFor: 'objects from disk' stamp: 'cmm 5/4/2011 13:54'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  Does not file out the class of the object.  tk 6/26/97 13:48"	| aFileName |	aFileName := self class name asFileName.	"do better?"	aFileName := UIManager default 				request: 'File name?' translated initialAnswer: aFileName.	aFileName size = 0 ifTrue: [^ Beeper beep].	self saveOnFileNamed: aFileName! !!Object methodsFor: 'objects from disk' stamp: 'cmm 2/24/2011 20:45'!saveOnFileNamed: filenameString	"Save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| fileStream |	fileStream := FileStream newFileNamed: filenameString asFileName.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway, and closes the stream."! !!Object methodsFor: 'testing' stamp: 'mtf 12/30/2010 23:41'!isPrimitiveCostume"True for primitive costumes in Tweak. Added here because a Tweak override in DisplayScanner was merged into trunk for maintainability"	^false! !!Object methodsFor: 'testing' stamp: 'ul 11/23/2010 13:28'!shouldBePrintedAsLiteral	^self isLiteral! !!Object methodsFor: 'testing' stamp: 'eem 11/2/2011 10:59'!shouldBePrintedAsLiteralVisiting: aSet	^self isLiteral! !!Object methodsFor: 'updating' stamp: 'eem 6/15/2008 16:02'!okToClose	"Allows a controller to ask this of any model"	^self okToChange! !!Object methodsFor: '*Etoys-viewer' stamp: 'ul 9/28/2011 14:10'!assureUniClass	"If the receiver is not yet an instance of a uniclass, create a uniclass for it and make the receiver become an instance of that class."	| anInstance |	self belongsToUniClass ifTrue: [^ self].	anInstance := self class instanceOfUniqueClass.	self becomeForward: (self as: anInstance class).	^ anInstance! !!Object methodsFor: '*Etoys-viewer' stamp: 'ul 11/15/2010 11:55'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating to me.  Some of the messages dispatched here are not yet available in this image"	| aMenu elementType |	elementType := self elementTypeFor: anElement vocabulary: aViewer currentVocabulary.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].	self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu := MenuMorph new defaultTarget: aViewer.	#(	('implementors'			browseImplementorsOf:)		('senders'				browseSendersOf:)		('versions'				browseVersionsOf:)		-		('browse full'			browseMethodFull:)		('inheritance'			browseMethodInheritance:)		-		('about this method'		aboutMethod:)) do:			[:pair |				pair = '-'					ifTrue:						[aMenu addLine]					ifFalse:						[aMenu add: pair first target: aViewer selector: pair second argument: anElement]].	aMenu addLine.	aMenu defaultTarget: self.	#(	('destroy script'		removeScript:)		('rename script'		renameScript:)		('pacify script'		pacifyScript:)) do:			[:pair |				aMenu add: pair first target: self selector: pair second argument: anElement].	aMenu addLine.	aMenu  add: 'show categories....' target: aViewer selector: #showCategoriesFor: argument: anElement.	aMenu items size = 0 ifTrue:  "won't happen at the moment a/c the above"		[aMenu add: 'ok' action: nil].  "in case it was a slot -- weird, transitional"	aMenu addTitle: anElement asString, ' (', elementType, ')'.	aMenu popUpInWorld: self currentWorld. ! !!Object methodsFor: '*Etoys-viewer' stamp: 'ul 11/15/2010 11:55'!uniqueNameForReference	"Answer a nice name by which the receiver can be referred to by other objects.  At present this uses a global References dictionary to hold the database of references, but in due course this will need to acquire some locality"	| aName stem knownClassVars |	(aName := self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	(stem := self knownName) ifNil:		[stem := self defaultNameStemForInstances asString].	stem := stem select: [:ch | ch isLetter or: [ch isDigit]].	stem size = 0 ifTrue: [stem := 'A'].	stem first isLetter ifFalse:		[stem := 'A', stem].	stem := stem capitalized.	knownClassVars := ScriptingSystem allKnownClassVariableNames.	aName := Utilities keyLike:  stem satisfying:		[:jinaLake |			| nameSym |			nameSym := jinaLake asSymbol.			 ((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(knownClassVars includes: nameSym) not]].	References at: (aName := aName asSymbol) put: self.	^ aName! !!Object methodsFor: '*Etoys-viewer' stamp: 'ul 11/15/2010 11:55'!uniqueNameForReferenceFrom: proposedName	"Answer a satisfactory symbol, similar to the proposedName but obeying the rules, to represent the receiver"	| aName stem |	proposedName = self uniqueNameForReferenceOrNil 		ifTrue: [^ proposedName].  "No change"	stem := proposedName select: [:ch | ch isLetter or: [ch isDigit]].	stem size = 0 ifTrue: [stem := 'A'].	stem first isLetter ifFalse:		[stem := 'A', stem].	stem := stem capitalized.	aName := Utilities keyLike: stem satisfying:		[:jinaLake |			| nameSym okay |			nameSym := jinaLake asSymbol.			okay := true.			(self class bindingOf: nameSym) ifNotNil: [okay := false "don't use it"].			okay].	^ aName asSymbol! !!Object methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^false! !!Object methodsFor: '*morphic' stamp: 'ar 8/8/2009 12:01'!asDraggableMorph	"Converts the receiver into a Morph suitable for dragging"	^(StringMorph contents: (			(self respondsTo: #dragLabel) 				ifTrue:[self dragLabel] 				ifFalse:[self printString]))		color: Color white;		yourself! !!Object methodsFor: '*morphic' stamp: 'nk 2/26/2004 13:33'!asMorph	"Open a morph, as best one can, on the receiver"	^ self asStringMorph	"234 asMorph(ScriptingSystem formAtKey: #TinyMenu) asMorph'fred' asMorph"! !!Object methodsFor: '*morphic' stamp: 'nk 2/26/2004 13:35'!asStringMorph	"Open a StringMorph, as best one can, on the receiver"	^ self asStringOrText asStringMorph! !!Object methodsFor: '*morphic' stamp: 'nk 2/26/2004 13:35'!asTextMorph	"Open a TextMorph, as best one can, on the receiver"	^ TextMorph new contentsAsIs: self asStringOrText! !!Object methodsFor: '*morphic' stamp: 'sw 1/29/2002 21:45'!openAsMorph	"Open a morph, as best one can, on the receiver"	^ self asMorph openInHand"234 openAsMorph(ScriptingSystem formAtKey: #TinyMenu) openAsMorph'fred' openAsMorph"! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:32'!capturedState	"May be overridden in subclasses."	^ self shallowCopy! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:29'!commandHistory	"Return the command history for the receiver"	| w |	(w := self currentWorld) ifNotNil: [^ w commandHistory].	^ CommandHistory new. "won't really record anything but prevent breaking things"! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 12/12/2000 15:01'!purgeAllCommands	"Purge all commands for this object"	Preferences useUndo ifFalse: [^ self]. "get out quickly"	self commandHistory purgeAllCommandsSuchThat: [:cmd | cmd undoTarget == self].! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/12/2000 08:15'!redoFromCapturedState: st 	"May be overridden in subclasses.  See also capturedState"	self undoFromCapturedState: st  "Simple cases are symmetric"! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'sw 11/16/2000 14:42'!refineRedoTarget: target selector: aSymbol arguments: arguments in: refineBlock 	"Any object can override this method to refine its redo specification"	^ refineBlock		value: target		value: aSymbol		value: arguments! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'sw 11/16/2000 14:42'!refineUndoTarget: target selector: aSymbol arguments: arguments in: refineBlock 	"Any object can override this method to refine its undo specification"	^ refineBlock		value: target		value: aSymbol		value: arguments! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:30'!rememberCommand: aCommand	"Remember the given command for undo"	Preferences useUndo ifFalse: [^ self]. "get out quickly"	^ self commandHistory rememberCommand: aCommand! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:30'!rememberUndoableAction: actionBlock named: caption	| cmd result |	cmd := Command new cmdWording: caption.	cmd undoTarget: self selector: #undoFromCapturedState: argument: self capturedState.	result := actionBlock value.	cmd redoTarget: self selector: #redoFromCapturedState: argument: self capturedState.	self rememberCommand: cmd.	^ result! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:32'!undoFromCapturedState: st 	"May be overridden in subclasses.  See also capturedState"	self copyFrom: st! !!Object methodsFor: '*MorphicExtras-PartsBin' stamp: 'sw 10/24/2001 16:34'!descriptionForPartsBin	"If the receiver is a member of a class that would like to be represented in a parts bin, answer the name by which it should be known, and a documentation string to be provided, for example, as balloon help.  When the 'nativitySelector' is sent to the 'globalReceiver', it is expected that some kind of Morph will result.  The parameters used in the implementation below are for documentation purposes only!!"	^ DescriptionForPartsBin		formalName: 'PutFormalNameHere'		categoryList: #(PutACategoryHere MaybePutAnotherCategoryHere)		documentation: 'Put the balloon help here'		globalReceiverSymbol: #PutAGlobalHere		nativitySelector: #PutASelectorHere! !!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:38'!chasePointers	PointerFinder on: self! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 17:43'!explorePointers	PointerExplorer new openExplorerFor: self! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 16:28'!inboundPointers"Answers a collection of all objects in the system that point to myself"	^ self inboundPointersExcluding: #()! !!Object methodsFor: 'tracing' stamp: 'ul 11/15/2010 11:22'!inboundPointersExcluding: objectsToExclude"Answer a list of all objects in the system that point to me, excluding those in the collection of objectsToExclude. I do my best to avoid creating any temporary objects that point to myself, especially method and block contexts. Adapted from PointerFinder class >> #pointersTo:except:"	| anObj pointers objectsToAlwaysExclude |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	pointers := OrderedCollection new: 1000.	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious	 method and block contexts out of the results"	anObj := self someObject.	[0 == anObj] whileFalse: [ "We must use #== here, to avoid leaving the loop when anObj is another number that's equal to 0 (e.g. 0.0)."		anObj isInMemory			ifTrue: [((anObj instVarsInclude: self)				or: [anObj class == self])					ifTrue: [pointers add: anObj]].		anObj := anObj nextObject].	objectsToAlwaysExclude := {		pointers collector.		thisContext.		thisContext sender.		thisContext sender sender.		objectsToExclude.	}.	^ pointers removeAllSuchThat: [:ea |		(objectsToAlwaysExclude identityIncludes: ea)			or: [objectsToExclude identityIncludes: ea]]! !!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:33'!outboundPointers"Answers a list of all objects I am causing not to be garbage-collected"	| collection |	collection := OrderedCollection new.	self outboundPointersDo: [:ea | collection add: ea].	^ collection! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 15:34'!outboundPointersDo: aBlock"do aBlock for every object I point to, exactly how the garbage collector would. Adapted from PointerFinder >> #followObject:"	aBlock value: self class.	1 to: self class instSize do: [:i | aBlock value: (self instVarAt: i)].	1 to: self basicSize do: [:i | aBlock value: (self basicAt: i)].! !!Object class methodsFor: 'instance creation' stamp: 'sw 1/23/2003 09:45'!categoryForUniclasses	"Answer the default system category into which to place unique-class instances"	^ 'UserObjects'! !!ObjectExplorer methodsFor: 'menus' stamp: 'mtf 4/25/2008 17:41'!explorePointers	"Open a PointerExplorer on the current selection"	PointerExplorer new openExplorerFor: self object! !!ObjectExplorer methodsFor: 'menus' stamp: 'mtf 4/25/2008 17:40'!genericMenu: aMenu 	"Borrow a menu from my inspector"	| insideObject menu parentObject |	currentSelection		ifNil: [menu := aMenu.			menu				add: '*nothing selected*'				target: self				selector: #yourself]		ifNotNil: [insideObject := self object.			parentObject := self parentObject.			inspector				ifNil: [inspector := Inspector new].			inspector inspect: parentObject;				 object: insideObject.			aMenu defaultTarget: inspector.			inspector fieldListMenu: aMenu.			aMenu items				do: [:i | (#(#inspectSelection #exploreSelection #referencesToSelection #defsOfSelection #objectReferencesToSelection #chasePointers #explorePointers) includes: i selector)						ifTrue: [i target: self]].			aMenu addLine;				add: 'monitor changes'				target: self				selector: #monitor:				argument: currentSelection].	monitorList isEmptyOrNil		ifFalse: [aMenu addLine;				add: 'stop monitoring all'				target: self				selector: #stopMonitoring].	^ aMenu! !!ObjectFinalizer commentStamp: 'jcg 4/27/2010 01:01' prior: 0!Represents an action that is to be taken when a target object (not referenced by the ObjectFinalizer) is garbage-collected.!!ObjectFinalizerCollection methodsFor: 'finalization' stamp: 'ul 10/17/2010 03:34'!finalize	"Finalize all elements in this collection. The elements are expected to be ObjectFinalizers, but can be any object which understands #finalize."	self do: [ :each | each finalize ]! !!ObjectFinalizerCollection methodsFor: 'testing' stamp: 'Igor.Stasenko 5/25/2010 04:58'!hasMultipleExecutors	^ true! !!ObjectTracer commentStamp: '<historical>' prior: 0!An ObjectTracer can be wrapped around another object, and then give you a chance to inspect it whenever it receives messages from the outside.  For instance...	(ObjectTracer on: Display) flash: (50@50 extent: 50@50)will give control to a debugger just before the message flash is sent.Obviously this facility can be embellished in many useful ways.See also the even more perverse subclass, ObjectViewer, and its example.!!ObjectViewer methodsFor: 'very few messages' stamp: 'bf 4/5/2011 15:36'!doesNotUnderstand: aMessage 	"Check for change after sending aMessage"	| returnValue newValue |	recursionFlag ifTrue: [^ aMessage sendTo: tracedObject].	recursionFlag := true.	returnValue := aMessage sendTo: tracedObject.	newValue := valueBlock valueWithPossibleArgument: aMessage.	newValue = lastValue ifFalse:		[changeBlock valueWithPossibleArgument: aMessage..		lastValue := newValue].	recursionFlag := false.	^ returnValue! !!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'nice 8/27/2010 20:52'!editDescription	"Allow the user to see and edit the documentation for this object"	| reply helpMessage |	helpMessage := self documentation ifNil: [String new].	reply := UIManager default				multiLineRequest: 'Kindly edit the description' translated				centerAt: Sensor cursorPoint				initialAnswer: helpMessage				answerHeight: 200.	reply isEmptyOrNil		ifFalse: [self documentation: reply]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'initialize-release' stamp: 'eem 9/5/2009 21:03'!initialize	inOptimizedBlock := false! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'accessing' stamp: 'eem 9/8/2008 14:30'!readBeforeWritten	^readBeforeWritten ifNil: [IdentitySet new]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:28'!visitAssignmentNode: anAssignmentNode	anAssignmentNode value accept: self.	anAssignmentNode variable isTemp		ifTrue:			[written ifNil: [written := IdentitySet new].			 written add: anAssignmentNode variable]		ifFalse:			[anAssignmentNode variable accept: self]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:09'!visitBlockNode: aBlockNode	| savedWritten |	"If we're in the optimized block in one side of an optimized ifTrue:ifFalse: et al	 leave it to the enclosing visitMessageNode: activation to handle merging written."	inOptimizedBlock ifTrue:		[^super visitBlockNode: aBlockNode].	"If we're not then don't update written because without evaluating the guard(s)	 we can't tell if the block is evaluated or not, and we must avoid false positives."	savedWritten := written copy.	super visitBlockNode: aBlockNode.	written := savedWritten! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:03'!visitMessageNode: aMessageNode	| savedWritten writtenPostFirstArm |	(aMessageNode isOptimized	 and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: aMessageNode selector key]) ifFalse:		[^super visitMessageNode: aMessageNode].	aMessageNode receiver accept: self.	aMessageNode selector accept: self.	savedWritten := written copy.	aMessageNode argumentsInEvaluationOrder		do: [:argument|			argument isBlockNode				ifTrue: [| savedIOB |					savedIOB := inOptimizedBlock.					inOptimizedBlock := true.					[argument accept: self]						ensure: [inOptimizedBlock := savedIOB]]				ifFalse: [argument accept: self]]		separatedBy:			[writtenPostFirstArm := written.			 written := savedWritten].	(written notNil	 and: [writtenPostFirstArm notNil]) ifTrue:		[written := written intersection: writtenPostFirstArm]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/8/2008 14:43'!visitTempVariableNode: aTempVariableNode	(aTempVariableNode isArg	 or: [written notNil		and: [written includes: aTempVariableNode]]) ifTrue:		[^self].	readBeforeWritten ifNil:		[readBeforeWritten := IdentitySet new].	readBeforeWritten add: aTempVariableNode! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor commentStamp: '<historical>' prior: 0!Answer the set of temporary variables that are read before they are written in the visited parse tree.  Used by the compiler to detect those block-local temporaries of blocks in optimized loops that require nilling to prevent a value from a previous iteration persisting into a subsequent one.!!OrderedCollection methodsFor: 'accessing' stamp: 'ul 2/24/2011 08:59'!at: anInteger put: anObject 	"Put anObject at element index anInteger. at:put: cannot be used to	append, front or back, to an ordered collection; it is used by a	knowledgeable client to replace an element."	(anInteger < 1 or: [anInteger + firstIndex - 1 > lastIndex])		ifTrue: [self errorNoSuchElement]		ifFalse: [^array at: anInteger + firstIndex - 1 put: anObject]! !!OrderedCollection methodsFor: 'adding' stamp: 'ul 2/24/2011 08:46'!addFirst: newObject 	"Add newObject to the beginning of the receiver. Answer newObject."	firstIndex = 1 ifTrue: [ self makeRoomAtFirst ].	^array at: (firstIndex := firstIndex - 1) put: newObject! !!OrderedCollection methodsFor: 'adding' stamp: 'ul 2/24/2011 08:46'!addLast: newObject 	"Add newObject to the end of the receiver. Answer newObject."	array size = lastIndex ifTrue: [ self makeRoomAtLast ].	^array at: (lastIndex := lastIndex + 1) put: newObject! !!OrderedCollection methodsFor: 'removing' stamp: 'cmm 10/25/2010 22:26'!removeAll	"remove all the elements from this collection.	Keep same amount of storage"		self setCollection: (self class arrayType new: array size)! !!OrderedCollection methodsFor: 'removing' stamp: 'ul 10/17/2010 03:10'!removeAllSuchThat: aBlock 	"Remove each element of the receiver for which aBlock evaluates to true.	The method in Collection is O(N^2), this is O(N)."	| n |	n := firstIndex.	firstIndex to: lastIndex do: [:index |	    (aBlock value: (array at: index)) ifFalse: [			array at: n put: (array at: index).			n := n + 1]].	array from: n to: lastIndex put: nil.	lastIndex := n - 1! !!OrderedCollection methodsFor: 'removing' stamp: 'cmm 10/25/2010 22:26'!removeFirst: n 	"Remove first n object into an array"	| list |	list := self class arrayType new: n.	1		to: n		do:			[ : i | list				at: i				put: self removeFirst ].	^ list! !!OrderedCollection methodsFor: 'removing' stamp: 'cmm 10/25/2010 22:26'!removeLast: n 	"Remove last n object into an array with last in last position"	| list |	list := self class arrayType new: n.	n		to: 1		by: -1		do:			[ : i | list				at: i				put: self removeLast ].	^ list! !!OrderedCollection methodsFor: 'removing' stamp: 'ul 2/24/2011 14:33'!reset	"Quickly remove all elements. The objects will be still referenced, but will not be 	accessible."		self resetTo: 1! !!OrderedCollection methodsFor: 'removing' stamp: 'ul 2/24/2011 14:38'!resetTo: index	"Quickly remove all elements. The objects will be still referenced, but will not be 	accessible. Also make sure that the first object will be inserted at index. Choosing the 	right value has had great impact on performance, but it's neglible with the current 	implementation, so it's better to use #reset instead in most cases."		firstIndex := index.	lastIndex := firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'cmm 10/25/2010 22:27'!growAtFirst	"Add new empty slots to the front of array, while keeping the empty slots at the end."	| newArray newFirstIndex newLastIndex |	newArray := self class arrayType new: (array size * 2 max: 1).	newFirstIndex := newArray size - array size + firstIndex.	newLastIndex := newFirstIndex + lastIndex - firstIndex.	newArray 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array := newArray.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'cmm 10/25/2010 22:27'!growAtLast	"Add new empty slots to the end of array, while keeping the empty slots at the front."	| newArray |	newArray := self class arrayType new: (array size * 2 max: 1).	newArray 		replaceFrom: firstIndex		to: lastIndex		with: array		startingAt: firstIndex.	array := newArray! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42'!makeRoomAtFirst	"Make some empty slots at the front of the array. If we have more than 50% free space, then just move the elements, so that the first 50% of the slots are free, otherwise add new free slots to the front by growing. Precondition: firstIndex = 1"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= array size ifTrue: [ ^self growAtFirst ].	tally = 0 ifTrue: [ ^self resetTo: array size + 1 ].	newFirstIndex := array size // 2 + 1.	newLastIndex := newFirstIndex - firstIndex + lastIndex.	0 to: tally - 1 do: [ :offset |		array at: newLastIndex - offset put: (array at: lastIndex - offset) ].	array from: firstIndex to: newFirstIndex - 1 put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42'!makeRoomAtLast	"Make some empty slots at the end of the array. If we have more than 50% free space, then just move the elements, so that the last 50% of the slots are free, otherwise add new free slots to the end by growing. Precondition: lastIndex = array size"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= lastIndex ifTrue: [ ^self growAtLast ].	tally = 0 ifTrue: [ ^self resetTo: 1 ].	newLastIndex := lastIndex // 2.	newFirstIndex := newLastIndex - lastIndex + firstIndex.	array 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array from: newLastIndex + 1 to: lastIndex put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'cmm 10/25/2010 22:27'!new: anInteger 	^ self basicNew setCollection: (self arrayType new: anInteger)! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'cmm 10/25/2010 22:28'!new: anInteger withAll: anObject	^ self basicNew setContents: (self arrayType new: anInteger withAll: anObject)! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'ul 9/10/2011 15:11'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^(self new: aCollection size)		addAll: aCollection;		yourself"	OrderedCollection newFrom: {1. 2. 3}	{1. 2. 3} as: OrderedCollection	{4. 2. 7} as: SortedCollection"! !!OrderedCollection class methodsFor: 'private' stamp: 'cmm 10/25/2010 22:26'!arrayType	^ Array! !!OrderedCollectionInspector methodsFor: 'as yet unclassified' stamp: 'btc 7/11/2011 23:11'!fieldList	object ifNil: [ ^ OrderedCollection new].	^ self baseFieldList ,		(self objectSize <= (self i1 + self i2)			ifTrue: [(1 to: self objectSize)						collect: [:i | i printString]]			ifFalse: [(1 to: self i1) , (self objectSize - (self i2-1) to: self objectSize)						collect: [:i | i printString]])"OrderedCollection new inspect(OrderedCollection newFrom: #(3 5 7 123)) inspect(OrderedCollection newFrom: (1 to: 1000)) inspect"! !!OrderedCollectionInspector methodsFor: 'as yet unclassified' stamp: 'btc 7/13/2011 00:07'!objectSize	"Single stepping through a debugger might observe the state of an OrderedCollection 	instance after creation by basicNew but before initiialisation.  Thus 'object size' 	throws a DNU error for arithmetic on a nil value that needs to be handled here." 	^ [ object size ] on: Error do: [ 0 ]! !!OrderedCollectionInspectorTest methodsFor: 'as yet unclassified' stamp: 'ul 7/16/2011 11:05'!testUninitialized	"Single stepping through a debugger can observe the object state after creation but before initiialisation."	"Thus 'object size' may throw an axception for trying to do arithmetic on nil."	"Modified OrderedCollectionInspector>>fieldList to call 'self objectSize' to handle this exception."	"Original error reproduction: [ self halt. OrderedCollectionInspector openOn: (OrderedCollection new: 5) ]     "		self shouldnt:  [ (OrderedCollectionInspector openOn: OrderedCollection basicNew) delete ] raise: Error.! !!OrderedCollectionTest methodsFor: 'testsEnumerating' stamp: 'ul 3/1/2011 08:21'!testOverlappingPairsCollect	| o |	o := #(5 4 3 2 1) asOrderedCollection.	self		assert: #(9 7 5 3) asOrderedCollection		equals: (o overlappingPairsCollect: [ :a :b | a + b ])! !!PCCByCompilation methodsFor: 'ui querying' stamp: 'ul 6/17/2011 12:28'!methodsWithDisabledCall	"Answer a SortedCollection of all the methods that contain, in source  	code, the substring indicating a disabled prim."	"The alternative implementation  		^ SystemNavigation new allMethodsWithSourceString: self disabledPrimStartString									matchCase: true  	also searches in class comments."	| list string |	string := self disabledPrimStartString.	list := Set new.	'Searching all method source code...'		displayProgressFrom: 0		to: Smalltalk classNames size * 2 "classes with their metaclasses"		during: [:bar | | classCount |			classCount := 0.			SystemNavigation default				allBehaviorsDo: [:class | 					bar value: (classCount := classCount + 1).					class						selectorsDo: [:sel | 							| src | 							"higher priority to avoid source file accessing  							errors"							src := [class sourceCodeAt: sel]								valueAt: self higherPriority.							(src								findString: string								startingAt: 1								caseSensitive: true) > 0								ifTrue: [sel isDoIt ifFalse: [											list add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]]].	^ list asSortedCollection! !!PNGReadWriter methodsFor: 'chunks' stamp: 'jmv 4/15/2010 10:18'!processTransparencyChunk	| red green blue |	"Transcript show: '  TRANSPARENCY ',chunk printString."	colorType = 0 ifTrue: [		transparentPixelValue := chunk unsignedShortAt: 1 bigEndian: true.		palette at: transparentPixelValue put: Color transparent.		^self	].	colorType = 2 ifTrue: [		red := chunk at: 2.		green := chunk at: 2.		blue := chunk at: 2.		transparentPixelValue := 16rFF00 + red << 8 + green << 8 + blue.		^self	].	colorType = 3 ifTrue: [		chunk withIndexDo: [ :alpha :index |			palette at: index put: ((palette at: index) alpha: alpha/255)		].		^self	].! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'jmv 4/15/2010 10:19'!grayColorsFor: d	"return a color table for a gray image"	palette := Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^  palette		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 85.0 / 255.0).		palette at: 3 put: (Color gray: 170.0 / 255.0).		palette at: 4 put: Color white.		^ palette		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ul 2/5/2011 04:48'!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| base bits bytesLeft word |	bitsPerChannel = 16 ifTrue: [		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"		| blitter |		blitter := BitBlt current bitPokerToForm: form.		0 to: width - 1 do: [ :x |			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].			^self ].	"Just copy the bits"	"This Smalltalk version might be easier to understand than the others below."	base := y * (form width * bitsPerChannel + 31 // 32) + 1.	bits := form bits.	0 to: thisScanline size // 4 - 1 do: [ :i |		| ii |		ii := i * 4.		"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 		is to make use of faster arithmetic bytecodes, but not of slow largeintegers."		word :=			(((thisScanline at: ii + 1) * 256 + 			(thisScanline at: ii + 2) * 256 + 			(thisScanline at: ii + 3)) bitShift: 8) bitOr: 			(thisScanline at: ii + 4).		bits at: base + i put: word ].		(bytesLeft := thisScanline size bitAnd: 3) = 0 ifFalse: [		word := 0.		thisScanline size - bytesLeft + 1 to: thisScanline size do: [ :ii |			word := word * 256 + (thisScanline at: ii) ].		word := word bitShift: 8 * (4 - bytesLeft).		bits at: base + (thisScanline size // 4) put: word ].	"This interesting technique (By Andreas Raab) is faster for very large images, but might be slower for small ones"	"^self copyPixelsGrayWeirdBitBltHack: y ".	"It uses the following method:	PNGReadWriter >> copyPixelsGrayWeirdBitBltHack: y 	""Handle non-interlaced black and white color mode (colorType = 0)	By Andreas Raab""		| source dest cmap |	source := Form extent: 1 @ (thisScanline size // 4) depth: 32 bits: thisScanline.	dest := Form extent: 1 @ (form bits size) depth: 32 bits: form bits.	cmap := Smalltalk isLittleEndian		ifTrue:[ColorMap 					shifts: #(-24 -8 8 24) 					masks: #(16rFF000000 16r00FF0000 16r0000FF00 16r000000FF)].	(BitBlt toForm: dest)		sourceForm: source;		destX: 0 destY: (y * form width*bitsPerChannel//32) width: 1 height: (form width+31*bitsPerChannel//32);		colorMap: cmap;		combinationRule: 3;		copyBits."			"This interesting technique  (By Yoshiki Ohshima) is faster for very large images, but might be slower for small ones"	"form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32)".	"It uses the following method:	BitMap >> copyFromByteArray2: byteArray to: i	""This method should work with either byte orderings""	| myHack byteHack |	myHack := Form new hackBits: self.	byteHack := Form new hackBits: byteArray.	Smalltalk  isLittleEndian ifTrue: [byteHack swapEndianness].	byteHack displayOn: myHack at:  0@i"! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 7/24/2010 18:45'!drawStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1 @ 1 corner: aForm extent - 15) fillColor: Color red borderWidth: 3 borderColor: Color green.	canvas fillOval: (aForm boundingBox topRight - (15 @ -5) extent: 20 @ 20) color: Color blue borderWidth: 1 borderColor: Color white.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32 @ 32 depth: 16)) display"! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 7/24/2010 18:45'!drawTransparentStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1 @ 1 corner: aForm extent - 15) fillColor: (Color red alpha: 0.25) borderWidth: 3 borderColor: (Color green alpha: 0.5).	canvas fillOval: (aForm boundingBox topRight - (15 @ -5) extent: 20 @ 20) color: (Color white alpha: 0.75) borderWidth: 1 borderColor: Color blue.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32 @ 32 depth: 16)) display"! !!PNGReadWriterTest methodsFor: 'tests - grayscale' stamp: 'ar 1/7/2011 16:47'!grayScaleData	^#[137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 217 0 0 0 125 8 0 0 0 0 10 88 153 82 0 0 0 9 112 72 89 115 0 0 46 35 0 0 46 35 1 120 165 63 118 0 0 0 25 116 69 88 116 83 111 102 116 119 97 114 101 0 71 114 97 112 104 105 99 67 111 110 118 101 114 116 101 114 53 93 72 238 0 0 63 7 73 68 65 84 120 156 60 157 231 219 149 229 185 230 215 95 54 31 230 195 124 216 51 31 230 216 199 236 157 61 123 103 103 18 99 108 168 8 8 22 20 5 84 236 141 88 177 196 94 208 152 144 196 96 143 26 11 193 10 22 66 135 183 175 254 244 190 214 156 191 243 126 179 73 132 151 183 172 245 220 247 213 206 235 188 10 189 186 168 170 50 143 202 186 40 139 188 44 170 52 202 202 178 204 147 156 95 233 52 41 202 50 73 179 52 207 146 162 200 244 45 121 154 100 121 158 69 73 170 47 229 250 106 94 132 255 23 117 93 150 117 153 87 188 80 93 232 239 85 173 95 237 172 155 205 102 93 93 181 179 186 174 74 125 87 211 54 101 93 53 115 125 174 206 171 174 109 42 189 72 91 86 85 221 232 59 42 125 196 7 117 147 234 57 170 58 171 91 253 81 232 135 138 162 210 111 101 86 100 85 174 71 200 139 113 214 53 250 177 166 214 227 165 105 89 100 81 166 199 76 227 52 206 245 20 61 189 70 161 151 170 202 76 79 92 214 117 94 242 250 89 158 230 58 103 25 39 89 90 86 58 77 146 37 185 78 158 234 117 245 165 34 142 146 188 214 171 103 133 206 145 233 157 243 84 191 235 98 242 166 173 219 34 43 234 174 210 155 242 152 77 85 119 109 221 116 250 206 170 214 49 244 215 78 103 110 121 250 178 158 207 218 174 110 245 120 85 195 167 187 121 173 215 107 91 253 176 158 94 151 174 63 42 253 209 240 104 109 211 148 89 206 179 54 122 99 93 146 174 175 173 253 88 105 230 7 45 219 34 65 4 149 206 212 107 138 188 41 117 137 105 174 47 148 89 150 85 92 94 85 21 69 82 228 250 190 92 130 42 36 42 164 209 212 69 154 164 121 82 164 113 145 228 250 246 138 179 233 107 117 61 235 114 30 38 65 1 242 70 143 220 116 141 94 37 47 103 8 165 104 91 100 216 112 139 58 171 158 167 229 44 28 70 114 104 234 118 222 116 179 170 208 179 235 154 106 158 76 207 90 242 186 200 151 195 232 7 83 235 130 78 174 255 161 80 69 169 23 214 109 234 100 185 78 44 173 209 195 114 215 89 174 51 84 61 189 99 86 101 72 72 146 202 120 46 233 76 149 102 186 139 148 211 115 176 84 178 214 161 37 43 157 51 207 82 125 119 50 201 16 112 93 205 106 30 85 199 206 234 88 247 33 65 233 141 245 25 190 214 234 127 149 245 76 18 210 81 185 131 70 58 166 3 150 18 170 78 82 233 249 218 118 222 181 237 76 247 208 213 146 147 213 181 46 248 64 103 71 63 83 201 76 79 208 73 157 139 84 111 167 59 47 37 33 174 15 181 211 137 177 25 217 9 151 167 7 229 49 235 166 151 38 21 34 214 15 21 146 130 100 164 31 208 35 235 171 5 191 202 18 77 172 244 123 156 235 50 98 29 75 74 61 149 50 164 121 43 165 242 91 151 153 68 46 115 40 11 61 100 215 205 154 90 234 89 73 104 24 113 37 97 20 133 62 70 21 244 3 216 139 14 134 213 249 200 210 188 86 191 244 149 153 180 176 104 106 148 65 111 169 239 148 21 233 202 56 96 35 49 232 198 179 12 77 146 121 22 165 244 182 233 116 30 9 178 144 141 84 178 0 73 65 191 149 136 70 191 122 210 184 52 139 147 28 51 201 82 20 8 253 66 46 5 158 196 174 67 247 16 69 73 33 169 101 69 154 75 197 36 72 92 71 202 83 202 176 234 22 29 41 75 252 68 105 249 112 227 250 6 233 219 108 214 234 8 57 114 168 202 174 171 155 245 51 52 146 83 45 223 50 111 249 75 163 43 169 103 250 80 26 134 234 97 99 82 96 217 107 37 93 148 118 99 13 58 180 84 94 199 205 107 95 106 137 2 36 145 174 94 14 33 168 32 254 69 223 35 177 198 61 93 126 150 22 153 252 137 196 139 109 234 17 27 29 33 139 211 52 145 73 201 113 72 117 37 194 240 167 156 80 60 73 248 75 102 149 225 29 42 180 64 198 90 97 172 24 67 163 235 211 33 91 108 13 239 49 147 15 233 176 43 188 101 163 47 84 221 124 214 149 109 51 235 100 106 250 99 54 171 176 68 73 64 15 155 164 149 191 201 183 38 125 70 109 80 112 233 111 170 63 229 44 185 159 146 43 45 100 7 56 197 44 79 36 206 90 226 145 177 72 89 80 174 158 180 67 111 161 39 229 170 164 249 109 42 197 228 209 165 80 114 58 73 142 93 224 252 228 82 82 238 165 64 102 114 59 114 200 5 110 85 150 84 117 250 42 214 35 123 208 125 206 26 255 77 162 171 117 92 73 166 225 84 122 74 29 172 226 127 168 161 132 169 195 235 212 157 62 148 104 187 134 215 147 54 54 21 111 41 171 215 31 237 172 138 48 83 124 110 97 207 218 58 34 72 108 58 143 28 98 41 203 180 191 86 28 138 101 38 182 49 93 110 86 53 189 92 58 38 237 66 67 241 162 57 78 3 71 131 138 22 232 164 52 55 145 139 199 7 197 250 77 119 35 227 225 5 244 136 133 148 79 98 148 115 195 157 183 45 110 223 62 166 64 92 62 155 159 164 34 148 200 127 206 229 39 248 172 98 156 162 130 252 94 83 52 243 217 92 26 57 215 247 207 91 206 47 87 215 38 122 193 182 180 33 85 184 100 253 180 254 170 31 181 167 41 43 91 96 101 39 170 183 147 215 196 173 72 251 185 249 26 101 212 35 72 27 243 56 138 226 4 53 226 187 36 224 105 174 120 145 37 82 223 42 74 9 126 153 5 88 96 94 24 97 162 231 212 9 66 160 209 241 116 196 86 10 192 215 10 105 82 91 32 229 172 236 80 54 61 246 220 17 64 122 217 160 146 250 189 241 241 240 169 86 75 125 75 87 215 82 78 226 91 219 149 196 159 188 180 152 245 157 82 233 154 215 199 227 204 136 17 122 115 29 184 80 192 200 4 13 164 38 86 255 146 0 29 167 85 147 16 3 106 69 175 30 232 33 35 74 103 114 228 114 240 120 53 169 109 146 232 176 82 71 137 25 107 174 9 26 224 12 20 87 94 165 198 17 162 153 232 155 222 187 157 149 252 129 7 196 151 128 22 176 2 28 136 92 136 78 52 107 132 65 90 57 206 198 214 37 83 147 228 100 100 122 224 182 155 235 59 116 228 153 67 130 224 134 244 85 119 80 206 192 47 4 121 105 106 133 158 34 163 86 2 150 141 234 137 244 26 188 108 83 88 117 209 196 12 149 233 28 7 132 65 164 99 130 20 41 110 222 255 21 145 62 19 71 177 156 141 148 42 199 137 148 33 92 151 118 153 246 171 165 111 85 81 9 156 129 171 208 155 180 4 96 28 155 222 166 210 89 48 122 65 40 61 54 209 74 15 63 7 103 233 80 64 173 121 55 215 67 87 252 133 255 228 70 90 84 26 219 147 150 251 136 18 134 60 109 91 119 246 163 120 168 146 240 97 12 160 179 128 209 112 34 29 65 84 6 144 241 101 233 10 120 163 136 147 164 234 101 113 44 207 32 215 40 87 152 130 34 164 131 178 47 73 151 184 163 19 19 7 228 63 9 91 141 156 159 180 76 162 43 179 74 223 67 120 174 237 149 195 173 2 147 0 114 82 53 125 66 62 92 242 144 196 90 43 101 39 19 33 38 72 76 18 153 14 83 235 204 157 108 12 209 203 76 137 178 182 86 66 182 34 66 41 29 112 180 152 241 19 104 174 78 135 55 212 71 210 123 124 137 52 6 167 152 33 2 67 87 121 78 157 74 113 77 31 244 112 68 57 64 50 194 210 244 125 58 96 146 130 129 117 68 148 84 33 12 172 5 114 64 82 120 35 194 134 14 32 228 198 235 43 138 42 124 241 129 62 39 237 234 128 55 210 182 57 215 170 131 204 187 74 231 210 17 237 3 106 116 11 143 131 35 153 181 185 173 105 102 137 84 242 42 188 6 202 37 177 128 83 112 171 45 242 105 106 159 53 151 128 117 196 188 201 8 144 168 103 6 12 43 109 186 58 81 139 12 112 110 93 133 7 145 184 120 218 178 72 195 119 18 28 237 153 227 52 18 192 228 82 164 21 122 175 128 35 116 63 13 247 165 3 129 211 137 59 220 150 68 36 76 85 18 214 64 148 210 57 249 46 73 165 33 150 73 104 109 109 4 34 73 148 21 242 227 113 165 168 82 71 105 1 199 147 221 224 33 245 7 86 136 67 234 16 160 30 16 191 163 91 64 126 146 177 4 206 115 0 238 136 223 121 33 128 167 71 111 65 240 160 75 32 178 132 212 83 160 200 171 36 202 35 61 32 185 75 34 239 160 180 64 87 200 121 37 178 56 6 110 228 132 101 66 41 146 210 203 212 120 39 105 84 229 208 133 182 3 191 109 250 14 184 242 0 194 91 8 6 55 160 35 160 160 126 106 108 102 102 191 201 111 51 194 157 62 39 81 181 150 111 199 201 101 41 128 40 2 25 248 223 82 174 67 164 39 238 201 154 117 92 236 204 209 49 195 101 17 115 185 59 20 44 210 1 243 94 66 190 149 26 135 100 83 185 196 60 49 156 207 201 121 192 82 248 16 253 16 225 41 199 145 148 89 139 98 115 90 240 131 28 0 22 66 222 65 94 165 247 84 248 67 193 249 164 110 184 1 63 73 80 115 43 164 149 10 169 117 184 20 158 83 150 6 10 169 192 92 224 21 97 42 190 39 199 17 53 225 201 107 50 59 61 117 137 229 18 45 228 52 133 144 20 130 65 44 96 54 233 56 166 200 183 234 72 121 36 11 82 164 86 72 78 39 49 8 57 75 226 204 40 12 89 145 203 233 120 134 43 117 155 3 52 50 206 156 17 6 101 199 96 52 93 100 5 134 69 48 133 190 75 202 39 157 211 43 37 8 205 38 213 234 68 210 72 169 146 68 164 223 20 150 113 41 85 135 106 99 70 114 153 122 41 125 192 189 8 114 228 160 94 14 69 150 64 120 183 117 206 219 162 227 170 244 134 92 49 41 105 73 220 146 64 157 152 18 10 113 6 25 169 134 174 86 62 73 145 90 170 26 147 85 74 94 184 85 80 175 48 115 138 220 10 231 175 149 35 134 238 68 126 50 96 4 224 31 191 203 3 233 203 149 197 89 32 52 125 34 33 125 226 35 251 228 178 153 227 236 241 129 198 135 5 2 146 189 72 12 122 108 156 167 238 162 5 193 212 101 64 89 216 99 229 240 47 175 18 144 167 36 143 230 131 83 74 46 169 108 34 69 218 18 148 88 149 14 161 149 128 130 110 67 8 17 71 36 76 168 103 232 233 217 21 139 35 66 88 129 246 161 130 66 35 81 106 45 205 184 14 116 217 25 8 24 181 112 206 109 43 176 251 18 212 144 247 81 92 193 121 40 142 203 253 98 8 24 149 164 3 136 212 31 115 100 37 180 33 35 170 13 44 90 112 61 183 47 113 129 25 21 219 106 190 153 108 175 66 43 117 37 138 204 138 103 133 51 64 194 122 3 194 183 104 37 38 204 65 169 14 41 69 5 58 111 200 90 101 243 13 135 16 84 74 242 94 154 70 83 41 153 224 174 66 152 66 27 25 52 180 71 170 80 157 34 95 52 89 65 132 60 162 117 34 85 241 201 198 70 160 67 192 80 232 221 138 12 97 40 109 114 84 131 23 80 202 194 173 235 185 5 24 101 114 252 70 130 141 86 34 7 78 132 146 18 162 9 97 250 90 142 163 209 149 205 103 228 171 115 18 32 126 18 103 137 9 150 173 53 185 17 130 147 57 145 214 1 9 164 63 36 115 60 39 49 187 128 101 128 170 233 89 13 133 185 136 96 105 222 200 145 8 233 199 100 152 113 66 44 48 133 32 177 146 11 224 109 165 21 101 48 138 206 42 210 218 230 116 198 50 40 59 80 18 188 78 30 134 232 80 197 218 8 140 231 227 249 113 223 124 27 126 28 243 151 66 2 95 164 5 51 194 67 9 88 177 116 26 114 109 160 78 91 161 183 2 212 198 215 64 60 60 25 58 91 219 218 201 163 218 25 186 70 50 79 58 41 169 245 146 124 34 165 147 115 7 137 72 144 120 22 78 154 201 205 103 77 6 238 39 115 147 28 11 222 142 160 200 235 150 144 24 128 15 148 131 71 194 244 32 13 74 39 25 206 196 236 240 176 177 106 212 47 16 151 77 189 182 255 111 48 50 19 33 68 50 114 181 22 246 4 136 66 80 112 152 67 111 73 186 115 68 210 226 126 100 221 173 28 67 75 76 151 23 197 205 194 22 161 54 160 141 132 15 205 29 233 103 123 25 30 176 200 98 197 228 24 188 1 200 23 140 148 21 130 16 13 26 11 195 79 229 163 178 209 180 176 113 129 230 17 159 110 188 11 70 0 5 2 217 66 80 51 26 214 221 214 1 18 86 39 246 60 146 3 11 113 239 254 0 39 135 106 182 93 193 201 164 139 29 9 182 78 136 44 91 82 28 41 27 230 70 54 13 80 228 36 40 251 28 0 217 154 74 201 109 236 96 90 195 215 245 199 36 9 228 96 117 175 210 129 36 162 40 117 2 215 40 161 113 58 0 44 22 58 75 129 250 137 188 12 233 3 60 81 137 16 51 91 134 147 78 169 30 22 51 159 145 1 128 222 106 190 143 167 39 135 168 137 98 205 116 239 85 79 101 36 89 65 30 122 208 10 159 210 52 86 183 6 23 211 33 43 57 79 248 72 153 156 238 171 33 151 224 174 248 201 174 53 73 57 7 104 181 164 190 13 164 85 174 27 2 118 64 89 21 169 161 155 41 50 135 182 178 167 80 60 28 77 166 211 136 32 141 167 135 169 130 46 73 227 169 162 91 5 195 209 64 178 146 213 74 143 75 167 219 242 222 194 7 173 179 200 138 136 92 126 251 192 247 37 56 171 10 222 184 134 146 1 204 11 3 30 221 122 233 123 81 81 59 23 37 246 58 142 201 104 112 253 10 103 82 169 162 52 237 104 15 129 163 153 59 9 37 143 173 136 199 40 198 12 113 205 58 184 42 19 29 132 204 138 196 155 4 139 39 41 32 109 164 2 112 102 80 161 189 216 148 175 220 6 24 184 132 54 37 153 46 166 137 208 127 2 167 71 72 36 196 133 15 201 197 214 177 168 1 64 87 25 174 102 11 183 111 122 147 4 28 98 132 100 159 204 155 240 32 205 202 158 188 96 211 223 81 194 198 86 96 63 71 18 214 5 194 10 36 15 221 131 249 3 155 139 142 47 97 183 68 15 169 47 76 38 148 130 226 71 83 140 191 57 158 240 58 210 234 89 227 56 100 176 14 100 201 144 7 148 171 113 185 48 136 68 153 152 73 84 16 131 134 148 161 225 75 20 150 205 71 213 248 56 200 47 185 97 40 54 161 211 26 246 165 197 162 252 172 210 240 108 245 245 173 27 191 138 125 50 194 144 60 136 84 209 20 85 221 44 92 247 243 231 70 144 31 37 140 139 68 225 12 173 38 120 147 254 72 22 196 16 46 162 66 122 120 192 202 55 56 155 145 134 1 45 215 69 89 23 107 207 223 176 115 85 238 47 175 103 38 205 107 59 71 204 196 148 103 174 160 213 202 166 82 9 180 7 0 244 129 132 171 20 194 32 138 204 131 228 78 243 244 137 156 24 84 249 60 141 25 56 130 80 141 86 233 177 113 120 101 25 199 223 108 191 112 239 26 240 3 197 241 27 133 47 206 244 122 111 94 112 197 73 200 76 2 16 110 171 195 65 18 204 2 129 32 87 55 51 149 215 33 100 140 176 128 26 34 103 195 41 203 227 42 223 110 29 105 242 181 23 183 95 116 243 50 38 147 217 228 201 180 81 167 218 209 73 111 47 103 81 196 117 34 239 83 247 10 208 71 20 35 55 243 95 10 209 41 144 172 136 166 33 69 109 170 185 82 178 206 76 115 9 182 152 193 228 192 112 26 203 234 89 102 77 246 187 77 23 127 60 54 231 68 102 43 129 224 14 192 238 243 106 225 154 203 95 24 197 85 238 242 69 99 24 130 43 7 212 115 241 164 168 21 137 102 106 127 84 66 200 154 37 129 123 113 190 38 125 108 241 176 69 211 127 104 235 21 27 126 27 113 160 68 226 33 131 44 200 136 209 125 144 164 11 1 70 18 122 11 161 43 96 46 208 94 207 42 47 105 94 43 73 77 65 201 190 2 232 181 226 87 96 8 220 64 70 66 209 193 8 144 190 128 60 78 238 190 244 218 211 9 158 44 199 247 163 31 80 51 51 25 125 254 246 69 219 15 69 169 158 24 23 14 78 208 171 241 5 32 149 190 255 248 161 81 140 78 55 33 68 146 231 84 14 160 96 65 92 67 73 46 11 53 87 39 239 239 218 120 253 182 111 167 50 197 34 73 130 211 55 133 171 151 108 108 79 96 198 162 49 125 213 40 139 73 139 154 136 150 149 178 182 4 71 15 89 14 35 2 130 130 105 113 236 45 75 123 230 140 32 75 166 13 226 107 185 119 233 245 232 181 45 151 63 221 159 166 208 36 128 49 63 126 200 155 203 241 253 23 221 46 253 169 155 140 124 181 133 0 148 231 110 65 183 60 205 103 55 110 57 146 232 141 112 95 102 26 244 180 209 226 217 180 114 140 34 214 53 104 136 78 145 79 191 121 100 215 3 91 246 156 143 146 130 200 11 66 53 13 170 4 45 181 30 102 148 187 20 176 48 191 60 238 101 148 49 76 10 0 18 115 200 240 148 242 20 197 35 180 70 103 113 205 195 117 54 160 113 199 245 186 174 208 146 138 180 117 146 157 191 123 219 229 135 39 129 144 40 66 230 237 228 25 46 236 203 139 126 249 234 40 130 101 115 242 81 144 102 193 166 225 155 203 236 235 155 54 108 250 42 33 11 42 168 102 248 6 167 7 111 186 119 9 10 3 146 191 115 89 8 179 72 87 246 255 225 185 135 55 189 57 150 112 128 70 102 7 144 110 58 5 76 57 191 144 203 72 2 91 163 120 198 201 148 193 150 185 235 106 105 237 111 50 161 110 242 211 73 115 201 235 155 171 66 95 106 44 220 212 141 2 99 155 37 89 244 206 53 27 119 47 198 105 106 22 73 70 90 231 228 192 84 87 242 201 222 11 47 59 170 80 79 94 82 133 4 8 134 176 194 233 150 201 161 235 183 94 114 215 10 128 61 80 202 96 190 226 187 91 46 221 250 163 169 221 78 239 84 132 66 94 150 199 239 191 240 155 143 182 110 250 122 148 194 157 37 210 58 19 104 101 49 74 114 162 24 209 84 222 20 210 208 12 72 79 209 56 154 2 177 224 186 37 57 61 96 22 145 210 58 247 199 181 99 108 144 179 45 196 47 128 148 90 37 128 106 102 50 170 73 214 238 218 188 237 181 193 36 1 71 75 193 136 137 36 242 200 38 63 117 229 133 247 141 128 153 58 51 214 205 169 244 26 153 98 105 149 47 63 124 227 181 151 125 72 158 26 202 160 72 53 95 124 124 211 133 123 22 19 142 83 134 114 141 19 205 108 97 239 83 111 124 120 249 93 103 38 184 110 249 6 115 134 165 203 119 96 220 52 225 193 20 149 92 133 213 255 122 114 133 201 120 154 249 59 83 164 133 106 146 244 152 155 50 90 162 232 129 235 128 162 0 105 195 95 224 31 100 45 40 227 232 243 27 55 223 248 195 112 164 176 145 81 106 144 189 146 23 204 100 152 249 224 197 255 248 207 63 19 76 32 205 204 75 241 10 181 105 175 116 250 230 237 207 94 181 253 12 41 60 218 46 216 47 115 25 190 120 229 5 219 158 31 82 82 213 17 42 128 101 205 181 79 15 220 185 251 139 231 175 120 117 144 76 34 178 174 18 66 179 54 5 105 194 94 97 41 183 3 195 206 201 44 123 153 15 229 60 58 49 232 143 148 196 160 41 60 92 99 210 15 20 88 57 173 85 92 233 234 80 105 160 2 1 76 171 210 225 51 27 46 219 183 106 34 175 116 226 9 68 151 247 35 134 47 94 243 175 87 159 30 103 169 30 166 4 159 145 35 133 176 53 107 210 239 246 29 124 234 138 87 35 162 83 41 87 71 153 182 152 126 182 231 186 11 175 250 235 4 160 151 162 68 114 60 200 32 61 127 251 109 79 31 221 125 245 151 145 148 76 158 32 78 48 93 42 233 128 61 50 26 157 31 154 216 174 21 103 9 6 73 132 166 40 180 96 179 161 106 219 65 24 193 202 232 67 232 27 199 104 125 98 86 153 190 38 211 20 30 133 61 109 242 244 232 198 159 110 62 210 151 74 67 154 103 20 80 116 54 189 67 89 36 241 187 191 250 143 87 250 134 164 8 174 41 93 24 35 37 17 112 95 126 233 221 207 174 185 250 59 195 3 89 36 111 95 23 199 31 125 240 158 11 183 157 158 164 25 2 212 55 203 219 74 131 147 225 107 219 174 251 234 157 45 15 159 19 236 75 200 147 115 202 96 230 78 37 191 178 205 90 99 68 130 153 220 172 30 160 236 77 166 102 65 148 88 75 29 229 109 192 252 176 21 230 98 156 248 194 90 224 36 205 98 135 202 131 68 50 35 206 75 44 233 224 169 95 92 240 196 210 152 248 87 164 9 71 47 171 180 116 152 173 71 119 252 228 151 71 176 137 44 240 210 5 212 142 3 107 154 76 254 252 220 167 143 108 120 126 144 100 118 247 21 21 232 106 244 210 19 207 254 250 130 189 43 137 107 179 122 137 245 87 138 127 220 189 225 149 19 15 111 253 96 52 74 166 169 162 89 20 25 163 2 132 74 104 27 61 124 221 5 223 32 197 196 150 100 103 248 251 28 115 83 148 48 13 108 202 108 54 15 60 147 233 165 25 156 31 176 138 20 139 44 152 211 225 246 37 240 31 54 255 108 211 199 147 36 115 81 181 180 111 151 119 164 48 155 39 223 95 246 147 251 215 34 197 105 189 101 1 147 236 64 71 200 43 179 19 143 191 119 120 235 85 71 38 161 38 87 154 165 136 190 190 235 233 183 238 185 114 255 48 181 41 37 113 68 140 146 95 28 238 187 106 199 15 159 111 185 247 244 96 26 131 115 19 37 39 25 41 89 217 152 238 111 241 115 77 86 154 96 166 138 172 252 12 213 108 64 96 248 27 101 172 13 73 4 181 161 185 11 39 160 2 165 130 38 216 102 179 138 48 79 28 34 131 169 200 100 242 209 147 23 252 252 154 243 147 169 204 66 226 86 110 87 149 1 224 202 236 199 47 253 228 63 222 29 142 98 87 221 74 126 130 115 163 201 211 100 109 223 83 199 158 188 234 209 21 40 211 34 117 93 190 76 23 31 220 249 194 241 91 47 19 44 137 237 172 115 124 24 229 254 31 175 189 234 189 51 15 111 249 227 202 56 154 140 71 8 33 137 177 174 142 238 17 71 146 22 119 79 252 35 41 149 225 182 61 151 165 229 57 41 79 196 153 50 66 204 75 242 170 195 1 5 176 33 9 205 206 204 8 210 228 236 1 227 67 55 150 217 241 237 23 232 142 227 152 138 163 92 239 36 105 92 106 198 170 179 181 237 255 188 75 113 142 8 78 65 192 49 205 2 107 242 254 59 119 28 56 188 245 198 47 229 14 92 15 199 210 146 201 135 219 239 251 225 171 45 55 156 25 129 202 113 55 210 201 56 137 166 107 79 94 114 235 241 163 55 238 57 58 24 12 35 165 146 17 71 203 168 87 66 184 163 12 148 213 40 11 153 85 163 204 82 247 176 211 40 112 86 45 53 144 153 229 197 47 127 8 141 129 115 135 235 165 236 37 40 15 3 71 89 68 135 110 243 254 43 23 95 188 245 155 113 156 76 35 167 7 19 138 197 181 121 226 34 249 219 47 254 245 21 217 111 156 235 116 229 122 225 23 58 177 76 227 31 174 121 240 187 167 175 216 183 60 70 19 157 175 202 240 207 222 113 245 254 197 63 95 249 235 126 50 213 79 72 11 66 241 36 26 126 118 237 165 239 159 249 253 182 223 174 14 39 209 52 158 68 209 4 142 35 138 29 194 209 241 64 166 181 115 42 165 186 87 98 84 15 20 67 231 132 41 173 174 153 255 215 175 32 48 88 64 43 34 192 158 242 30 204 175 201 97 253 93 254 233 199 235 46 188 228 238 21 105 79 68 70 91 228 49 61 37 68 14 249 224 233 115 255 121 217 241 193 88 89 31 128 82 194 81 140 114 109 32 137 6 175 93 241 193 23 87 109 249 106 154 17 158 225 79 234 34 25 188 178 249 230 19 203 143 93 190 191 63 86 212 167 50 89 38 116 105 68 231 238 217 120 211 15 63 222 122 219 143 253 225 120 162 183 154 68 4 44 26 2 208 123 242 178 218 181 104 210 185 0 9 145 25 57 176 124 25 90 221 172 11 204 206 3 162 66 30 100 54 151 108 204 14 154 173 161 78 214 205 176 81 90 88 210 116 237 185 75 182 220 244 197 112 60 198 253 129 79 147 216 221 28 212 98 243 243 27 255 207 222 21 220 71 138 206 153 67 131 97 86 148 154 124 189 227 177 51 79 109 184 111 109 4 117 155 225 186 229 20 190 218 185 229 245 133 31 182 109 253 106 16 69 58 210 148 34 179 236 41 25 190 117 249 37 239 173 28 220 242 242 162 252 7 84 148 192 33 37 134 24 160 92 186 52 36 221 167 62 89 155 133 49 53 88 244 132 156 115 115 50 78 95 231 62 204 60 208 185 56 198 89 80 75 234 174 157 241 148 66 65 45 124 214 184 95 43 249 102 227 47 46 191 253 244 202 112 10 152 163 250 6 169 144 153 141 44 146 191 254 236 223 63 31 75 88 177 66 29 94 10 13 165 128 93 231 203 143 220 122 226 232 214 77 159 12 162 216 197 255 188 152 149 209 194 195 151 236 57 215 255 120 203 195 11 35 69 64 88 208 24 232 55 30 156 186 237 226 125 103 206 222 189 227 112 127 52 26 15 101 102 113 170 107 146 82 150 248 116 24 5 234 55 164 216 37 153 137 68 8 197 215 67 153 109 125 181 93 135 75 35 184 251 217 250 71 115 39 43 142 214 136 142 155 113 41 221 14 36 125 250 130 93 23 29 232 143 166 81 170 176 104 98 43 11 76 164 174 188 255 240 79 118 158 159 40 115 74 105 74 40 157 64 21 206 250 210 183 119 190 191 252 204 149 119 45 141 35 242 10 185 138 166 140 39 111 93 121 201 231 253 181 231 54 188 186 212 31 74 225 228 41 38 177 44 106 184 246 234 21 91 190 93 250 235 245 143 157 91 29 12 226 152 0 156 36 147 137 18 29 197 107 234 89 53 156 126 25 58 56 208 235 22 200 149 247 202 42 73 73 216 45 168 57 4 81 55 239 130 231 208 159 33 47 158 81 79 233 124 64 247 45 52 208 210 212 54 79 108 190 112 195 150 31 7 241 212 45 34 201 122 118 33 207 75 117 234 248 229 255 249 222 152 34 28 189 131 244 8 1 8 18 184 205 115 15 62 190 116 106 207 85 31 174 77 168 107 197 118 239 217 201 219 46 125 100 185 127 226 214 77 135 87 162 233 116 44 80 35 117 140 198 163 225 209 107 55 236 95 92 120 224 214 79 151 215 250 195 33 159 77 139 108 34 51 20 200 210 67 81 74 67 31 1 208 77 229 74 214 28 86 162 87 187 135 11 228 52 179 167 111 141 115 9 100 182 51 80 213 28 109 12 229 201 218 213 146 121 237 192 145 14 94 187 100 207 166 95 175 78 38 145 2 61 191 0 72 122 202 138 212 124 250 187 127 187 226 4 210 12 188 138 113 50 81 92 199 123 235 142 163 171 191 223 113 255 162 100 146 112 29 50 150 116 237 153 95 109 253 126 52 250 116 243 13 39 198 227 193 249 143 255 188 60 148 119 151 35 92 120 232 23 215 252 184 252 241 182 167 78 175 224 64 38 19 57 204 208 212 18 186 34 64 97 101 1 135 87 112 48 88 40 19 239 61 151 196 91 242 46 8 81 219 89 141 47 108 204 143 210 69 228 120 77 123 4 197 9 138 202 18 42 5 166 52 253 118 203 246 123 182 125 44 119 85 42 19 154 144 92 228 213 204 25 172 92 254 242 158 127 126 104 117 2 69 11 156 112 82 234 118 177 34 93 120 244 173 225 241 221 155 223 25 80 33 113 73 78 247 112 120 243 37 239 245 163 213 87 47 125 122 105 56 89 124 234 254 135 143 15 167 147 241 96 212 127 127 243 198 79 151 206 236 189 233 208 234 104 52 28 77 198 211 241 88 216 49 13 56 94 58 72 89 165 136 115 55 213 240 172 51 170 24 138 252 189 138 250 119 7 94 106 8 205 69 59 91 183 46 253 165 206 93 26 42 155 38 148 133 160 59 45 111 179 248 217 228 153 141 15 109 186 231 156 20 35 151 211 183 17 23 78 19 105 92 139 63 254 213 79 229 33 40 78 22 132 75 224 11 164 103 145 76 222 125 240 252 242 111 54 62 182 52 149 46 186 91 40 75 162 197 59 47 124 116 113 48 88 124 112 203 135 253 193 232 203 235 55 29 92 34 108 77 38 103 238 187 248 145 243 11 7 183 239 61 201 201 16 152 180 81 208 81 74 158 186 185 6 166 129 254 73 10 80 238 245 50 216 71 102 5 127 177 187 112 154 98 130 150 218 86 232 3 50 199 228 146 172 145 100 231 134 27 8 37 129 188 47 175 191 231 241 141 111 203 191 197 164 10 200 132 44 29 29 17 182 63 119 199 191 110 59 43 39 39 111 153 164 120 23 90 91 51 66 194 185 71 62 25 126 116 195 245 95 12 38 130 26 244 173 37 121 180 242 202 69 155 143 174 77 198 95 110 221 113 98 184 182 122 242 215 119 28 95 30 77 117 176 193 27 27 110 56 178 248 221 77 59 222 147 251 24 40 80 227 25 163 201 116 18 87 144 245 109 78 139 100 238 166 9 24 36 90 208 92 124 109 235 158 155 186 240 235 238 206 176 180 66 80 155 149 230 221 148 198 212 129 180 154 81 28 113 79 142 203 156 217 232 209 173 111 222 184 231 184 240 7 6 150 155 61 129 59 42 96 207 147 207 182 252 219 190 53 101 16 83 23 193 83 170 180 166 33 178 232 157 167 207 158 188 127 227 171 43 211 194 29 174 148 73 250 159 93 115 241 193 254 100 184 240 204 246 223 156 239 15 39 75 47 61 118 124 48 26 143 227 225 247 55 111 251 236 204 153 223 236 124 226 244 106 127 50 141 70 19 156 166 180 56 203 220 111 83 153 202 165 205 0 162 63 41 29 223 92 100 105 123 180 213 172 31 166 43 26 23 146 141 24 103 244 192 6 135 79 209 132 206 62 71 66 90 26 104 115 202 162 143 182 220 187 255 170 131 107 227 8 116 231 142 85 20 11 0 46 8 56 122 240 223 127 249 151 149 9 134 228 226 14 122 154 213 181 2 239 169 87 190 94 217 127 203 61 103 229 54 93 180 19 18 159 46 63 186 225 225 51 178 169 191 223 188 243 139 213 201 104 176 242 219 251 190 64 70 107 167 31 221 252 252 217 229 15 30 188 255 232 242 64 193 172 63 210 251 142 232 26 142 147 184 20 26 38 111 183 162 36 161 89 79 127 81 148 129 231 109 122 93 192 27 235 53 72 187 251 22 171 114 240 114 103 17 149 171 64 119 186 111 10 142 78 105 83 246 253 125 55 124 116 251 174 83 131 209 20 182 92 202 79 51 51 77 54 244 89 166 223 108 248 151 29 167 198 66 1 137 15 64 117 202 253 186 121 244 201 111 207 254 117 231 53 95 13 199 194 181 36 78 250 53 121 235 234 173 95 244 229 17 95 185 102 255 210 106 127 109 109 237 232 147 7 5 125 251 11 47 110 188 241 232 217 175 158 218 253 197 218 234 42 142 81 82 67 29 165 143 81 233 126 220 218 13 69 100 193 32 41 74 51 132 2 18 165 158 219 32 131 148 236 249 165 141 174 232 153 12 110 2 7 220 82 247 118 67 134 52 23 106 130 134 141 87 174 122 100 255 246 63 13 198 110 217 42 215 203 112 188 79 165 196 112 241 190 159 255 244 174 197 169 252 51 220 115 110 34 196 41 114 190 244 193 241 211 79 92 245 210 146 188 230 148 171 207 146 233 228 212 174 43 159 95 26 174 46 127 124 253 206 99 107 195 254 100 180 124 126 223 223 198 163 65 255 240 181 151 127 252 247 79 247 237 250 104 113 109 52 28 78 148 192 12 135 195 40 202 81 200 204 94 4 24 66 140 174 113 145 105 225 142 40 41 152 20 176 231 10 187 13 173 51 236 69 124 144 110 173 43 90 45 124 134 27 214 96 85 91 107 107 135 118 231 199 111 219 244 238 141 187 206 142 227 60 52 75 74 34 132 167 2 50 50 153 124 113 217 191 93 250 242 32 49 219 89 165 83 247 155 231 150 218 71 111 158 125 225 234 27 79 141 21 146 4 232 43 0 253 96 223 37 187 143 245 135 171 199 239 216 242 218 217 229 181 213 193 234 202 226 155 167 87 87 7 103 246 94 182 247 216 239 111 219 245 249 234 112 212 31 245 199 138 219 114 31 145 210 78 168 239 60 116 142 184 105 20 232 35 196 69 199 0 142 64 234 86 247 186 208 36 52 183 175 71 25 205 199 183 29 5 116 170 63 202 200 204 138 214 51 183 117 112 3 216 238 248 213 29 7 94 218 250 250 144 34 162 140 171 117 239 50 28 103 146 85 105 180 114 255 133 151 237 56 52 49 0 33 220 66 88 200 10 227 105 178 120 240 199 3 91 183 30 26 42 140 225 230 166 227 120 60 126 243 218 77 159 247 199 253 51 143 111 221 119 236 252 210 226 242 210 234 96 229 219 243 75 253 165 223 94 122 245 171 15 236 124 224 179 197 126 127 50 30 42 148 1 146 227 120 52 34 88 211 95 171 96 38 148 218 208 156 132 213 209 100 225 54 98 136 155 158 3 114 9 151 180 158 149 209 85 51 163 46 58 115 247 221 172 113 231 114 69 35 192 204 102 71 25 45 249 246 186 221 135 182 223 118 86 224 142 195 164 49 181 73 42 218 184 165 104 116 232 242 11 174 220 125 30 84 72 95 232 120 154 187 69 91 158 49 254 234 237 15 110 188 228 15 107 58 83 44 168 9 10 28 28 185 241 138 87 150 87 86 78 61 126 217 238 207 79 156 60 113 236 232 247 95 255 240 227 119 103 206 156 63 122 221 207 110 217 126 219 129 211 194 84 163 225 96 60 148 46 98 106 3 162 25 16 11 113 85 74 34 92 141 115 23 103 90 207 74 176 123 165 92 19 223 104 126 163 233 214 73 2 179 31 102 61 230 193 41 210 218 215 6 100 60 227 98 58 249 198 165 125 155 127 251 219 203 94 93 29 130 157 24 30 72 166 169 187 130 192 59 211 115 123 126 185 101 227 83 11 202 0 244 4 209 63 156 62 12 231 248 240 91 215 93 242 208 121 65 174 225 56 148 196 167 167 118 95 244 208 153 229 149 19 15 94 120 245 155 159 189 246 224 157 183 236 222 189 235 174 187 246 62 241 242 11 55 255 100 195 3 111 28 91 234 15 134 35 37 121 163 254 218 120 48 24 145 250 37 209 216 53 117 104 219 28 218 208 237 122 101 11 214 167 125 21 86 163 236 209 203 54 167 184 111 139 178 95 156 187 24 89 209 48 3 39 231 97 2 138 94 58 170 89 226 178 136 62 190 233 201 143 110 186 238 216 56 210 129 232 39 44 98 1 196 130 56 131 199 127 239 210 141 123 174 126 119 141 188 56 165 23 49 199 123 200 119 230 211 31 223 188 233 87 119 157 24 77 32 166 245 116 121 52 94 122 225 210 107 143 174 44 125 185 227 130 139 239 122 252 230 171 111 252 245 19 143 60 253 194 115 15 221 189 99 219 175 254 229 234 15 206 200 161 140 215 214 228 84 132 181 162 201 136 232 173 251 144 234 235 63 16 170 43 125 238 40 151 19 41 215 203 164 52 4 181 61 124 73 200 52 41 5 147 111 210 79 195 164 64 7 45 84 193 209 227 203 105 5 163 29 165 83 246 152 156 190 247 158 31 158 186 226 217 65 66 3 114 81 21 17 253 62 12 148 48 15 20 157 186 229 130 125 215 221 249 247 126 68 120 203 234 144 10 150 180 206 140 255 178 251 202 93 223 45 15 198 178 20 249 155 73 60 237 191 183 105 211 151 43 11 111 223 178 233 194 203 247 236 121 225 195 99 39 165 134 11 231 207 158 248 225 189 43 174 249 232 252 242 72 183 48 149 91 84 106 174 239 159 166 145 65 139 219 131 201 195 171 208 190 152 211 78 85 67 238 34 188 188 148 164 234 222 220 174 222 193 139 214 108 58 60 220 100 90 207 60 43 64 135 22 53 189 166 89 111 35 208 57 179 209 129 237 47 127 187 227 142 147 180 214 101 201 132 154 91 150 211 213 10 10 204 135 7 54 94 255 210 53 191 91 155 208 161 64 0 111 92 114 148 205 79 142 236 185 242 214 111 22 86 135 195 129 34 147 174 127 184 242 249 142 75 254 124 254 196 254 27 118 188 244 217 39 127 59 118 254 252 185 213 181 254 234 242 210 210 194 177 189 155 223 92 234 175 245 149 208 76 163 161 12 44 50 123 170 200 162 67 197 64 70 122 216 82 170 252 50 95 69 234 218 10 167 71 206 40 221 183 179 158 241 210 127 17 31 29 253 24 52 111 185 245 8 0 60 115 15 237 122 127 122 152 231 72 191 219 115 231 241 131 155 223 30 197 57 144 63 241 252 15 45 64 110 162 158 252 253 186 95 190 113 203 238 99 35 198 50 18 163 30 20 85 193 117 233 211 219 55 238 252 106 89 33 73 104 93 192 75 190 229 204 221 151 191 112 242 240 190 27 94 254 246 244 153 133 133 37 29 107 58 25 172 46 174 46 157 57 112 245 237 63 44 141 198 3 225 227 53 229 209 227 100 74 43 216 20 124 154 80 54 202 169 199 153 52 170 221 225 79 241 154 65 6 58 91 169 114 201 131 200 55 84 240 82 243 134 67 201 75 40 77 157 59 131 118 3 122 217 66 233 149 250 20 149 148 10 254 122 249 153 91 255 114 246 238 157 103 41 39 122 62 42 200 203 175 157 101 131 103 55 220 241 222 77 111 12 77 98 80 48 72 199 163 72 198 22 47 253 254 166 141 55 126 189 60 30 79 198 99 168 128 201 100 180 248 244 198 27 223 125 234 182 59 62 62 187 184 186 34 81 14 87 87 6 171 11 107 253 165 115 135 183 111 255 124 113 117 141 188 69 161 65 18 158 140 99 133 43 178 61 38 46 50 234 121 73 66 243 6 109 45 252 94 186 156 206 76 14 116 180 236 44 36 204 161 29 170 108 12 67 58 154 130 228 227 33 127 40 205 73 186 109 83 164 112 251 249 116 58 236 191 117 211 147 103 126 119 205 1 123 128 40 114 99 2 80 32 75 56 219 248 208 150 43 222 122 100 215 119 163 36 177 69 68 211 165 207 254 50 72 39 253 227 47 110 191 252 214 191 13 38 107 176 25 164 148 227 241 249 131 151 252 108 203 237 119 191 126 114 101 105 121 2 44 92 93 88 94 91 89 91 233 47 159 186 127 203 91 203 171 107 195 113 196 175 120 130 97 37 176 235 73 84 148 145 135 72 242 202 78 153 126 161 130 196 186 116 201 155 17 181 14 92 165 44 102 22 48 48 20 129 219 113 104 118 232 232 108 201 102 238 76 1 47 49 43 39 147 31 175 156 61 127 250 199 207 110 191 225 213 195 119 236 60 29 145 84 226 19 147 20 150 140 234 136 28 229 218 195 87 62 126 112 199 115 67 224 15 149 138 193 55 47 188 177 48 25 158 253 224 254 91 110 121 249 251 1 209 118 50 16 98 159 166 211 197 223 109 248 201 134 167 63 17 236 232 15 250 171 107 203 74 95 86 214 250 107 114 239 139 239 108 185 247 228 26 94 35 77 38 145 98 95 52 113 35 139 116 67 167 44 243 8 228 227 22 203 208 8 226 98 182 103 159 58 26 180 42 133 96 97 125 159 139 185 8 119 236 130 136 221 62 94 121 176 134 249 13 243 247 197 194 239 30 122 236 190 91 111 189 249 150 173 151 252 228 130 171 174 218 121 112 146 72 159 98 15 104 76 152 218 131 109 169 138 248 179 43 55 31 218 185 243 200 96 12 73 160 231 56 116 255 161 181 181 213 191 222 183 235 218 39 143 72 19 117 174 9 97 90 150 179 116 224 226 159 62 116 100 81 112 106 72 200 154 144 50 15 133 134 87 87 23 191 223 117 195 87 171 67 101 10 116 74 49 31 150 102 80 143 144 178 176 228 224 104 88 70 120 202 240 71 83 49 116 81 173 15 120 20 246 250 132 227 38 116 225 174 167 149 117 155 53 1 226 87 101 104 148 161 171 242 232 29 27 46 250 127 255 254 127 255 229 159 254 233 191 253 247 255 245 191 127 186 245 239 145 148 62 142 167 211 152 222 58 65 17 230 210 210 201 249 59 127 181 255 137 235 14 194 171 49 18 26 13 159 188 237 244 185 15 30 221 185 249 186 63 158 94 213 161 164 180 209 212 225 123 225 240 13 23 221 127 122 5 227 194 242 198 163 137 100 54 26 246 151 22 151 150 158 185 250 224 138 169 57 165 221 36 209 137 251 2 40 93 22 122 116 185 92 202 123 84 107 220 93 201 8 34 174 28 90 163 245 36 6 141 81 61 143 58 64 150 50 0 17 58 33 100 147 166 20 168 34 217 111 80 187 73 142 253 233 245 39 111 185 250 231 255 235 127 252 207 127 253 213 5 151 62 188 32 79 32 227 142 165 163 3 186 182 20 63 5 152 6 127 216 124 239 147 183 189 190 16 77 167 19 217 88 50 61 182 249 230 63 220 115 253 230 45 123 143 44 197 241 120 146 226 99 82 196 188 182 240 236 197 183 253 125 165 63 30 14 4 155 36 46 121 192 113 52 28 76 7 171 171 95 221 252 192 74 230 38 1 152 46 1 0 159 164 161 119 86 78 49 46 42 19 191 101 218 216 103 187 223 151 63 24 139 197 156 64 128 202 98 230 110 18 117 63 87 35 112 164 252 187 4 246 210 66 200 28 7 137 43 112 185 204 199 131 213 165 133 19 95 223 127 253 139 223 126 243 236 198 151 22 6 211 68 56 110 58 56 126 232 173 35 43 50 9 161 222 36 62 126 203 213 15 222 249 250 137 254 132 150 187 50 155 78 206 223 126 233 134 11 175 186 235 175 75 99 66 109 42 217 38 19 104 196 209 249 183 183 221 112 116 165 47 104 49 25 9 237 78 7 146 88 191 191 188 170 115 46 61 113 195 17 224 124 145 215 30 91 171 168 221 54 116 56 123 100 216 20 101 78 155 11 99 3 85 154 187 139 35 79 144 9 147 132 116 132 74 76 61 2 89 69 19 65 209 184 249 78 23 5 85 85 132 126 28 106 236 132 120 230 38 226 209 120 178 250 215 123 159 56 179 252 246 13 59 62 59 179 58 146 55 59 251 249 43 15 220 119 251 253 207 60 255 201 154 244 38 94 222 183 97 247 253 47 157 90 29 43 245 74 200 15 167 131 147 191 123 114 255 137 165 129 64 132 76 75 26 28 243 125 73 50 60 124 195 213 159 44 43 88 73 80 80 109 82 195 33 41 216 88 146 253 248 186 131 41 92 114 230 17 27 60 30 56 138 126 11 198 90 100 252 194 54 30 90 129 50 165 23 54 229 144 115 234 142 158 140 104 104 181 171 123 158 157 205 204 181 150 238 153 167 157 222 221 69 238 235 10 173 213 158 133 45 211 241 240 220 83 123 191 93 249 230 158 107 127 253 252 203 251 223 253 226 163 215 31 191 227 225 63 125 243 197 75 47 239 220 246 225 90 50 89 62 112 193 5 79 124 217 7 174 90 143 228 163 229 24 134 66 123 122 126 253 45 151 238 42 20 72 73 135 167 30 184 242 213 101 156 132 12 108 44 185 233 116 67 168 169 162 78 207 221 117 223 42 176 6 27 98 122 135 178 4 85 117 196 147 97 70 89 24 50 209 115 167 21 29 239 161 43 192 117 244 121 141 39 105 40 166 247 4 251 169 245 81 96 234 60 1 76 235 227 204 116 120 75 167 3 52 138 224 153 7 70 210 254 27 123 15 44 173 30 185 246 202 13 23 110 216 188 237 250 91 110 126 242 61 249 133 225 176 127 122 207 29 223 29 255 235 243 87 252 252 15 167 251 83 162 55 158 76 206 2 164 135 203 139 104 15 149 33 226 22 19 221 208 218 254 173 207 158 89 81 106 18 141 6 100 201 20 143 198 160 140 44 238 31 216 253 113 146 149 41 54 47 31 64 207 93 69 197 22 94 84 30 49 165 41 85 142 159 134 59 151 136 77 0 240 27 157 213 193 95 96 74 109 175 243 108 88 19 58 180 61 218 133 3 113 111 162 27 49 195 172 146 34 124 91 101 241 225 219 246 158 26 196 203 31 62 247 236 254 63 190 243 167 231 255 124 114 117 28 195 226 76 6 95 220 122 211 61 187 174 253 213 35 139 46 183 42 163 73 43 143 189 242 172 121 50 244 160 185 18 50 89 153 212 109 218 255 112 251 175 79 174 160 128 107 138 207 50 191 225 96 160 195 73 198 211 233 119 247 255 110 28 187 140 41 71 173 228 43 247 200 76 138 106 234 57 160 105 42 143 78 59 241 162 81 205 115 15 104 38 67 135 204 3 81 186 236 230 61 234 123 157 167 56 2 87 135 70 186 11 154 130 120 87 184 45 189 32 172 149 117 114 250 185 71 143 72 119 70 131 229 229 181 193 154 178 38 249 196 73 10 245 61 237 31 123 251 221 247 174 191 227 251 65 194 120 124 30 90 212 160 63 96 38 115 154 96 98 147 248 46 232 245 191 220 115 231 201 181 137 80 211 100 36 169 10 104 201 187 36 120 211 36 29 190 112 231 137 24 62 19 152 64 183 254 172 174 66 177 180 153 241 159 155 159 138 220 69 150 208 250 71 249 39 140 112 0 179 248 1 134 26 234 30 26 219 120 100 12 102 123 78 185 213 196 41 125 86 133 127 199 183 210 185 27 245 223 124 244 11 37 73 81 66 180 77 200 45 18 70 77 74 74 96 201 100 112 238 209 43 63 234 211 129 1 167 154 58 225 165 171 17 159 22 3 19 241 29 132 37 225 224 251 110 252 114 48 90 89 35 219 142 71 178 177 161 226 22 225 75 222 244 139 91 223 28 151 161 152 223 184 109 133 22 40 188 32 195 51 114 112 46 21 231 73 90 51 40 86 133 81 154 198 51 109 179 48 78 201 228 20 227 231 242 250 30 239 173 240 131 166 114 170 48 143 90 134 118 251 204 237 188 114 149 105 50 254 234 193 215 87 71 82 152 212 21 201 233 120 108 182 150 99 73 60 211 233 59 219 30 56 159 210 192 64 167 173 156 115 76 230 57 153 146 231 40 107 140 201 190 147 88 49 110 120 238 249 45 111 46 172 202 115 192 111 11 200 232 37 113 48 30 185 90 249 205 203 99 221 72 236 13 8 180 236 65 86 184 237 31 158 198 10 144 123 166 95 10 135 76 20 155 169 124 202 185 67 105 23 243 118 30 38 56 116 50 130 25 46 4 185 49 94 180 142 67 26 55 194 249 147 116 38 40 113 156 156 222 187 239 44 205 51 217 24 134 145 208 140 14 41 103 146 238 229 113 188 116 223 174 227 83 119 142 67 240 103 158 166 132 24 201 32 226 61 196 145 11 95 198 147 65 255 243 235 31 63 189 58 149 189 141 99 162 67 18 10 71 66 170 242 54 135 238 62 67 16 102 246 159 172 36 131 30 116 227 82 69 66 92 65 185 145 111 102 177 251 82 116 227 126 126 64 82 86 248 83 84 29 220 19 220 35 138 81 98 9 115 16 158 49 104 133 96 216 49 80 209 236 223 193 119 41 57 74 70 7 159 249 38 34 19 166 29 131 201 114 10 116 12 38 211 149 80 20 163 183 119 189 214 215 57 49 145 146 30 39 230 13 157 115 40 77 4 77 37 74 100 18 193 168 225 241 123 239 57 57 77 39 148 57 198 67 129 24 124 126 74 111 189 244 96 229 217 131 211 130 249 165 48 191 45 51 99 190 21 191 71 168 114 53 136 158 243 210 152 162 76 138 208 95 62 67 237 42 198 37 231 58 52 29 47 82 199 94 29 6 184 124 58 207 168 81 74 161 200 230 225 2 119 225 51 101 93 77 63 126 246 189 137 209 77 146 85 76 97 200 239 197 76 196 178 2 64 6 116 252 214 7 207 143 40 178 23 161 162 238 206 21 119 78 230 17 13 107 82 72 133 228 120 60 92 121 229 230 47 6 2 156 163 17 69 21 253 70 116 198 60 169 103 31 122 113 82 51 32 92 6 42 134 124 178 14 245 48 146 171 218 219 55 90 26 156 220 247 74 167 108 145 182 46 236 177 224 66 113 107 206 152 97 201 48 75 207 3 202 166 171 176 88 152 46 66 67 198 236 142 116 1 101 202 32 8 210 243 143 63 181 138 46 50 1 165 112 171 36 36 249 71 71 46 141 95 131 125 247 28 25 232 1 83 131 6 86 95 84 238 117 214 227 74 120 206 244 19 194 214 120 248 225 13 207 47 147 202 140 224 11 112 45 163 65 52 33 161 77 155 178 255 236 247 40 110 237 150 65 134 111 24 61 84 98 110 230 147 6 163 38 203 103 136 203 195 216 220 61 23 194 112 17 45 47 115 222 184 200 152 130 146 246 246 140 60 244 85 185 20 170 146 153 219 69 60 146 165 231 202 19 151 135 4 41 70 111 62 254 3 57 32 93 43 83 250 32 98 111 1 136 92 121 204 171 248 208 142 131 253 84 40 156 185 218 46 103 174 55 103 246 50 165 197 72 206 67 22 57 142 97 62 70 199 110 127 224 140 132 132 151 176 81 78 24 210 143 232 182 204 226 232 200 71 12 233 40 86 8 21 68 57 131 7 16 84 25 94 221 0 137 222 209 198 149 104 170 201 222 138 224 126 114 156 100 232 71 103 121 135 236 106 142 7 241 230 0 102 78 168 181 178 52 197 249 54 179 192 97 25 77 138 237 199 159 60 246 165 140 41 246 66 3 217 132 110 128 110 8 215 142 10 217 243 234 99 143 156 150 96 220 106 235 5 13 94 164 128 11 41 72 67 226 41 187 70 228 6 167 253 3 123 79 40 40 15 199 208 172 186 163 9 237 216 44 3 33 0 247 63 24 232 118 132 62 90 157 78 114 160 129 139 29 53 10 207 116 185 17 85 205 132 133 228 25 24 175 200 237 217 110 247 147 211 233 91 113 7 56 246 166 103 30 60 204 115 112 232 54 44 26 0 157 229 192 181 86 161 172 206 179 115 251 255 44 231 108 39 231 50 88 20 133 45 29 144 218 50 253 181 3 119 126 62 209 23 233 29 205 232 141 102 130 68 90 154 38 53 205 20 114 249 114 41 10 196 241 248 171 59 222 86 186 61 37 71 35 184 133 153 252 156 41 105 221 228 248 100 68 51 180 119 91 120 200 119 198 61 81 214 106 67 99 94 86 67 134 250 26 60 84 74 202 50 175 152 75 244 228 4 179 187 58 126 237 62 138 30 19 153 244 192 22 235 171 48 144 40 77 240 41 157 185 45 238 164 206 210 193 31 31 59 47 155 215 195 21 217 148 102 28 170 46 85 233 109 40 44 220 56 122 219 75 35 175 28 170 195 128 34 244 25 124 143 247 21 97 136 82 91 23 103 23 159 125 125 5 210 38 139 192 47 137 97 137 46 33 118 219 125 37 245 192 202 25 180 229 233 112 209 117 232 58 244 108 110 59 99 99 202 12 64 203 89 103 124 78 160 189 157 33 170 118 125 237 129 87 248 228 186 208 158 203 203 45 115 29 149 219 239 219 117 60 85 187 67 86 238 3 6 228 147 23 190 153 208 81 147 50 244 95 224 65 88 182 66 81 189 145 186 78 251 191 121 240 71 188 118 32 56 243 164 166 53 17 213 192 107 102 204 54 196 30 180 140 134 135 246 45 142 117 64 0 63 153 117 66 0 137 232 183 144 11 135 8 99 205 0 94 169 52 82 144 237 213 238 158 69 153 230 152 22 133 177 218 29 160 137 110 96 190 78 3 23 97 225 3 166 199 151 107 75 189 87 179 252 198 110 178 116 111 32 91 110 232 30 105 60 79 3 187 151 70 63 190 248 151 254 132 188 253 31 205 212 30 121 138 147 178 158 82 240 155 28 190 231 211 33 20 103 238 5 76 140 52 91 211 117 106 133 98 146 122 216 106 221 192 96 233 181 195 125 114 50 57 123 69 183 17 2 243 196 34 91 127 194 218 145 162 14 109 248 101 24 145 165 87 163 45 220 63 90 121 181 8 141 105 141 107 17 74 91 148 161 48 8 4 150 39 224 49 30 193 228 86 237 91 237 121 40 135 132 71 166 197 208 182 12 57 69 51 97 203 153 94 146 28 6 127 252 195 98 76 154 15 121 168 155 167 249 208 123 124 188 198 168 206 23 158 250 237 148 110 239 2 183 70 71 50 85 100 76 182 72 228 3 98 59 145 172 32 156 29 125 123 77 40 88 41 89 20 58 178 225 237 10 154 82 89 154 192 244 149 151 43 80 120 16 102 162 53 0 84 222 33 11 98 90 209 154 10 6 34 146 175 204 230 44 175 16 232 96 180 166 100 255 146 30 183 157 183 180 64 233 18 122 196 57 111 9 130 234 206 233 195 229 210 220 242 206 80 124 85 198 147 15 159 249 123 146 57 30 115 101 149 187 68 61 95 70 223 74 17 143 63 125 244 164 124 24 17 157 73 43 210 39 32 1 207 152 234 173 42 40 207 36 23 134 154 172 188 127 220 124 84 52 138 137 39 36 45 112 135 144 78 185 123 209 49 212 36 228 192 158 223 244 182 158 86 207 237 6 27 201 45 115 211 77 27 182 170 184 30 225 138 152 199 82 160 228 188 26 66 38 194 238 36 138 243 157 75 47 142 7 222 135 1 149 234 101 53 80 41 147 19 251 191 157 218 99 120 139 153 143 132 49 36 224 82 38 237 206 62 246 190 153 155 184 245 170 175 218 77 53 108 173 162 61 81 6 91 186 205 82 200 170 255 233 209 104 76 150 67 169 94 105 40 40 57 97 36 96 246 143 168 203 242 38 44 184 244 104 171 231 166 152 47 242 14 138 18 228 232 185 201 166 45 3 180 13 51 218 158 154 164 193 29 66 156 241 4 154 179 43 69 106 15 69 209 27 65 56 155 181 198 216 245 140 158 51 79 5 21 43 175 127 52 70 241 229 245 82 130 63 56 82 246 206 98 44 80 119 54 125 251 197 85 58 226 50 134 66 203 176 186 201 179 214 12 197 210 54 236 142 122 157 97 58 58 75 182 66 98 45 149 21 178 26 71 12 104 192 175 21 78 123 89 200 85 132 157 89 112 246 158 202 233 188 212 172 241 42 7 252 67 147 135 78 8 47 164 162 139 124 22 88 27 47 199 130 241 148 131 109 161 76 154 94 153 133 9 194 26 140 70 151 58 108 73 187 14 91 164 236 147 143 222 94 165 119 165 230 238 42 80 137 108 134 22 93 247 80 201 173 253 240 218 41 239 148 242 254 7 65 201 42 148 14 60 238 198 142 165 42 228 107 81 92 144 9 196 68 237 24 170 62 21 60 86 236 206 60 110 217 132 50 93 168 72 113 44 126 16 86 222 233 150 7 109 202 176 185 141 246 95 154 78 67 184 38 223 106 194 64 11 41 170 208 65 90 6 185 21 189 214 227 169 238 244 234 60 85 236 169 69 23 219 4 37 139 248 139 55 206 101 117 236 117 32 180 55 54 30 251 79 128 117 172 66 171 211 193 155 31 202 73 226 166 155 194 32 90 153 162 183 68 192 23 16 107 137 14 185 178 102 212 80 185 29 109 193 116 208 167 76 189 165 80 234 184 10 231 252 6 79 108 54 115 203 160 231 213 88 41 65 63 131 65 145 119 108 208 44 208 58 228 122 50 156 188 19 248 209 120 131 131 199 136 74 123 255 162 23 178 178 202 140 49 38 226 49 223 58 165 75 149 130 226 232 141 111 188 216 164 174 226 76 176 176 212 227 166 158 226 246 44 162 132 244 205 129 1 192 76 81 179 243 24 75 195 212 20 29 183 148 163 40 228 178 212 41 10 235 30 166 161 121 54 54 95 47 71 202 246 135 36 13 121 191 253 60 57 124 9 30 231 102 189 143 201 219 236 8 213 140 194 251 147 140 123 32 32 122 131 233 116 163 50 230 109 7 173 209 215 186 51 236 132 245 231 30 183 178 63 170 24 190 101 60 149 238 85 125 144 150 163 195 31 143 232 93 201 189 80 13 183 145 135 71 160 129 219 115 54 159 45 196 81 70 41 149 78 23 183 12 81 40 241 8 51 181 220 138 181 81 222 195 229 5 83 132 14 87 16 93 174 100 47 161 195 148 19 202 138 110 85 150 92 25 184 230 40 72 85 253 131 4 160 21 120 238 97 89 65 177 210 240 139 134 136 25 44 80 67 219 162 5 207 212 58 115 57 180 114 246 24 250 202 61 136 14 215 221 230 76 235 7 10 162 144 127 254 225 79 203 211 162 114 134 203 234 153 22 251 108 32 140 202 210 211 20 229 143 223 78 99 60 164 27 202 74 15 184 207 156 250 98 43 48 36 13 19 15 53 93 150 85 2 20 113 170 237 213 69 112 138 149 113 90 193 94 33 184 91 82 120 240 95 233 185 38 152 209 46 204 164 207 105 180 228 101 103 221 220 219 103 80 163 58 244 63 192 217 192 196 149 165 35 23 43 49 80 169 30 109 61 245 204 253 58 14 112 102 193 161 31 149 85 39 171 127 62 193 216 138 247 7 225 63 216 56 200 50 149 154 5 63 146 120 21 31 135 57 168 230 118 57 172 229 144 57 123 237 81 102 15 146 149 157 159 145 72 157 69 230 172 89 101 65 143 45 189 34 44 122 10 21 122 57 86 111 126 176 19 116 163 10 108 175 163 15 119 196 176 43 77 249 179 80 174 45 204 244 26 237 123 248 220 51 94 52 239 243 136 115 15 225 151 194 141 16 37 192 145 214 28 95 205 88 185 77 72 230 50 249 82 14 31 35 37 114 23 94 250 182 190 92 18 202 24 207 191 116 140 121 189 198 75 253 128 110 92 48 150 42 189 160 111 159 184 210 146 90 243 151 60 166 189 160 136 153 146 75 205 221 21 97 15 93 202 30 6 193 253 202 61 138 228 255 16 85 168 162 119 216 180 110 136 43 155 64 247 174 239 61 200 145 15 69 36 154 134 194 143 81 207 100 95 68 5 42 238 96 11 76 13 0 215 24 227 243 78 27 183 133 43 193 63 249 254 66 202 221 55 148 236 77 139 32 222 150 201 1 233 173 244 58 62 25 179 70 133 101 73 104 34 28 69 152 147 45 20 251 234 245 46 108 34 181 135 43 20 11 147 180 172 153 129 203 125 88 201 177 240 74 166 138 102 110 118 134 206 24 183 103 89 145 83 106 250 239 165 146 181 71 74 97 7 216 5 225 123 205 74 187 146 198 107 113 32 174 92 126 167 165 133 13 75 76 216 43 243 100 97 3 43 34 67 23 179 35 158 119 215 68 209 210 135 223 2 11 49 161 212 212 159 187 102 138 252 31 155 255 132 246 240 163 172 176 208 87 144 87 90 133 128 132 129 0 229 72 91 193 104 66 87 76 118 57 0 82 179 201 188 200 83 217 65 97 142 204 253 197 101 61 30 187 191 194 1 7 118 183 245 114 57 218 180 189 239 172 50 250 43 129 18 165 1 33 41 169 31 139 20 142 45 61 115 119 232 208 67 213 133 30 30 182 142 102 85 18 120 203 130 118 31 147 149 163 207 222 30 199 244 247 201 19 160 142 142 22 152 91 12 50 212 205 149 140 248 90 67 233 159 54 45 89 120 223 75 234 13 89 122 68 153 79 205 173 84 222 178 231 141 113 8 8 182 142 31 164 83 220 59 127 60 76 8 148 243 182 34 248 252 214 151 239 173 33 110 105 3 88 209 143 227 17 42 151 193 164 125 93 235 105 216 198 209 214 174 198 44 240 220 139 61 122 45 235 99 107 202 177 186 121 111 180 112 65 77 55 113 234 163 243 132 100 234 238 142 19 185 151 173 241 146 4 244 176 203 86 110 12 92 207 100 44 54 93 152 168 46 93 39 197 61 208 109 69 179 3 96 151 173 36 224 196 0 185 117 27 36 45 184 22 215 93 152 134 204 131 109 233 169 9 188 173 255 6 239 4 71 133 17 178 216 150 249 175 178 232 88 160 16 54 174 192 77 208 100 45 77 85 200 103 80 155 16 71 5 94 150 94 135 213 119 156 220 89 106 153 177 118 32 250 219 49 118 241 208 183 205 14 58 219 175 190 143 233 87 175 95 173 216 76 84 186 154 17 86 233 213 161 90 10 31 72 154 219 120 97 72 229 44 208 235 111 172 118 97 7 162 215 12 152 95 45 137 158 77 136 43 4 66 175 22 194 99 80 130 134 172 40 241 232 158 78 84 162 230 13 156 5 227 2 25 200 133 62 149 210 68 150 39 202 189 157 174 109 82 111 102 201 123 208 252 94 31 234 101 193 157 41 57 220 72 252 205 81 120 208 44 108 166 36 33 99 224 140 165 159 53 164 61 121 161 107 189 14 240 235 123 71 96 209 189 197 130 149 13 185 247 137 240 90 56 150 134 26 243 196 137 128 153 33 82 118 122 72 245 25 154 28 216 81 64 179 128 103 91 224 81 27 199 54 250 60 58 239 79 98 239 9 11 58 64 111 149 23 202 177 21 141 166 224 25 177 90 202 27 104 179 210 251 196 8 190 189 218 97 140 230 23 88 34 82 201 212 107 122 250 135 38 158 228 202 195 200 48 173 153 181 55 211 178 10 65 158 51 42 220 225 90 21 102 21 233 76 174 178 200 36 2 226 197 33 241 186 94 19 11 33 66 11 152 183 73 178 66 213 94 61 181 59 240 186 177 22 234 66 154 146 121 199 101 85 203 195 101 52 67 208 148 30 162 190 183 95 145 21 227 196 83 55 66 232 61 176 153 218 228 143 204 98 238 126 23 111 80 170 186 121 221 245 90 198 18 76 160 184 98 19 150 238 214 229 234 15 67 144 36 229 80 183 235 26 201 103 184 142 180 246 48 163 109 0 90 221 160 209 246 229 42 41 142 195 126 81 199 157 102 89 156 53 94 174 56 201 168 107 177 228 64 175 148 24 172 184 235 213 30 168 114 134 86 135 133 205 44 30 80 144 2 112 81 141 48 91 237 249 109 47 178 173 140 110 10 123 80 174 85 103 103 17 2 155 82 230 94 25 197 10 48 22 99 22 189 218 187 98 188 159 179 246 10 77 111 139 136 79 31 119 23 90 88 231 27 20 206 21 153 210 192 74 238 203 83 75 6 114 141 189 150 7 166 58 186 148 109 248 65 188 116 18 54 212 101 249 172 233 6 204 130 161 5 175 235 141 189 38 69 143 132 169 7 79 71 233 194 240 207 191 97 63 181 39 60 60 36 202 5 123 60 135 29 102 45 2 242 216 139 251 48 113 244 133 167 63 16 109 199 36 2 109 126 250 206 8 24 217 241 34 132 157 181 83 163 210 235 60 165 119 94 8 224 29 204 97 71 2 111 233 133 21 165 253 6 182 69 205 141 113 180 136 26 172 179 206 10 208 156 23 193 119 1 184 235 204 108 58 110 114 58 78 217 45 40 144 227 20 145 38 215 2 128 75 189 217 190 124 142 26 57 60 55 130 44 77 225 164 185 171 195 168 107 197 18 31 76 188 45 93 124 34 128 121 109 93 203 96 57 107 127 91 129 189 76 30 196 27 196 193 56 185 159 19 30 186 202 22 71 185 215 16 132 153 16 34 105 94 152 246 200 189 208 160 10 109 174 205 12 220 29 22 175 26 72 179 237 5 143 195 222 152 196 221 108 116 62 48 158 85 26 168 248 56 105 58 244 16 47 252 111 46 248 80 186 220 223 209 87 211 134 86 15 10 145 13 27 118 225 76 185 119 224 9 23 239 132 75 222 36 79 29 222 4 40 231 235 11 32 58 232 137 206 123 0 96 231 228 248 123 82 173 146 105 115 161 84 106 247 137 185 22 37 192 236 80 43 189 202 32 115 249 0 247 165 96 158 197 105 155 67 203 99 244 97 182 167 100 239 150 217 4 207 5 53 8 204 94 204 237 9 146 175 46 62 201 194 50 137 202 251 67 138 144 160 174 227 39 111 30 38 30 235 29 129 50 25 11 249 8 91 238 31 160 93 61 48 52 94 109 237 198 41 111 237 243 30 49 210 225 58 163 143 12 220 152 67 104 0 253 169 194 11 17 55 52 141 84 222 139 206 6 109 38 77 152 148 168 189 171 134 205 198 29 131 182 204 216 215 97 199 10 227 244 60 33 157 85 220 33 220 135 209 69 205 150 129 176 131 206 27 10 194 114 105 111 83 71 225 242 176 108 219 49 158 78 183 170 14 83 200 101 21 150 89 134 101 216 101 216 95 95 229 222 205 236 179 132 106 52 57 40 211 59 16 8 84 249 230 51 182 227 144 19 8 86 133 68 154 164 156 218 179 61 136 139 100 133 43 58 121 234 50 110 150 43 229 34 200 37 174 4 183 173 247 189 16 86 240 25 29 196 120 233 125 203 228 163 88 174 137 71 220 202 172 92 223 175 94 173 47 13 167 109 25 122 19 138 79 226 21 162 73 188 74 157 71 213 5 210 163 203 6 127 38 82 74 150 19 91 141 195 194 207 160 226 97 153 129 225 106 226 253 50 141 123 166 50 91 114 25 86 125 214 204 101 205 106 83 146 173 23 85 17 230 235 30 163 104 14 123 21 21 198 174 35 211 79 45 149 214 139 67 33 164 157 228 116 173 35 97 233 71 118 139 134 151 100 51 248 26 242 32 72 105 111 220 37 89 14 91 84 75 143 38 122 74 188 251 199 166 4 199 112 50 30 15 198 133 81 238 176 152 188 13 171 163 139 117 111 33 32 211 54 115 214 110 172 239 164 241 78 13 92 115 234 29 155 54 86 179 136 238 235 96 232 25 194 216 171 37 5 84 122 142 68 69 72 76 240 139 160 44 105 21 185 125 162 55 165 121 160 50 21 174 104 54 51 181 145 83 76 114 112 72 138 42 44 239 240 203 66 4 80 206 82 240 74 76 191 132 214 7 74 88 28 196 11 52 42 239 208 198 85 48 90 67 92 196 173 212 38 25 140 236 115 147 34 64 25 221 79 199 166 26 178 67 42 106 220 96 190 190 34 143 41 21 105 42 0 43 97 183 40 239 52 235 74 42 74 172 169 134 173 163 107 162 236 176 17 46 32 77 149 4 134 153 201 42 116 85 83 119 246 94 74 232 64 155 9 173 201 25 1 170 78 138 152 98 85 203 102 245 202 139 218 214 219 121 105 179 97 174 40 115 157 133 204 132 109 127 132 8 118 175 73 145 106 30 20 191 148 135 229 235 176 15 214 163 249 204 218 71 247 24 45 23 172 120 245 142 37 238 132 157 178 70 17 124 111 227 125 10 29 170 70 160 90 135 95 82 231 121 195 54 53 8 159 94 101 22 141 14 140 84 50 130 179 171 92 62 179 214 145 155 177 236 49 36 103 180 91 27 165 148 150 55 13 120 113 132 13 250 241 66 22 227 194 61 185 49 205 22 37 11 10 105 143 244 158 9 186 191 160 200 28 31 81 182 6 96 139 125 241 207 39 148 46 244 153 14 197 4 104 221 101 69 52 65 29 238 36 108 227 15 185 115 233 180 138 191 129 106 58 35 72 55 57 250 49 178 162 115 62 215 235 74 70 239 43 23 156 61 61 67 36 170 195 134 10 183 152 120 17 128 119 16 103 46 44 5 217 132 73 243 176 249 205 195 14 70 28 250 153 204 180 56 159 246 238 46 182 201 251 31 73 160 88 94 120 135 55 229 45 55 161 184 104 86 135 206 39 239 97 243 38 80 156 161 103 55 193 177 2 21 149 203 222 66 140 108 162 201 220 35 111 136 54 243 30 255 144 82 101 21 253 246 165 151 137 123 51 24 255 218 131 105 39 18 12 214 145 149 177 249 65 50 53 156 71 25 102 121 45 34 231 40 165 47 203 62 57 198 206 75 183 94 112 153 76 27 103 222 194 88 133 197 141 173 77 53 115 58 24 182 250 192 7 186 216 204 182 201 25 160 132 118 196 182 90 159 145 224 95 206 64 192 69 4 210 149 183 239 2 179 210 186 94 145 187 223 180 206 219 130 117 24 78 119 253 111 77 116 141 167 193 185 58 175 155 39 10 215 174 155 244 188 209 75 2 230 153 216 142 90 172 111 58 229 180 117 238 237 188 214 28 174 60 108 94 1 106 144 39 120 101 99 152 119 242 55 27 127 213 65 154 38 61 136 172 221 204 235 133 89 100 202 29 20 174 7 201 51 100 242 32 243 128 161 13 60 43 211 72 208 84 182 42 255 35 44 1 228 103 94 79 65 201 133 26 86 234 129 58 79 30 153 183 237 116 215 222 49 74 49 187 241 6 143 6 230 146 45 135 222 186 94 8 55 150 254 151 28 152 164 73 242 214 72 184 112 34 206 22 118 167 135 174 62 121 3 39 152 35 118 2 146 224 82 43 179 250 206 51 11 111 151 36 145 168 113 127 158 51 244 130 228 214 11 190 245 227 12 150 206 59 131 147 98 253 223 27 48 59 52 107 232 19 19 96 243 36 153 145 74 229 125 133 246 245 222 247 47 80 229 213 231 94 11 143 198 5 155 205 29 185 230 205 122 225 214 181 9 157 172 14 236 81 109 206 5 127 20 30 49 252 203 56 112 158 138 114 13 72 206 4 111 26 118 54 22 236 56 47 93 41 245 158 41 220 158 94 16 30 135 16 146 103 97 251 46 38 14 165 93 121 235 186 43 69 146 220 188 131 100 104 66 17 189 101 51 118 75 26 7 5 70 141 211 51 182 246 87 228 40 97 107 155 209 55 109 232 153 163 166 55 225 208 141 74 253 162 241 5 0 158 65 41 101 216 170 148 213 115 78 134 239 106 56 67 234 196 146 231 72 157 104 146 99 162 61 165 187 230 50 239 148 225 95 234 160 149 47 108 10 164 173 223 5 142 0 171 93 196 69 134 5 131 83 16 130 198 230 97 69 52 238 177 161 97 65 64 146 102 109 239 3 83 40 118 17 208 91 215 97 165 216 225 211 0 219 3 59 232 70 37 30 154 241 185 48 61 81 135 127 134 36 69 194 173 87 39 58 159 213 101 64 132 209 219 64 195 112 221 3 201 51 214 98 197 104 253 175 72 64 113 22 158 182 229 199 227 116 26 254 101 159 44 155 218 103 133 121 189 154 146 153 209 158 255 161 14 144 66 96 172 255 193 189 85 30 244 207 29 117 72 108 205 223 176 243 25 46 42 252 243 13 30 70 196 255 53 206 184 12 206 11 207 90 114 105 137 140 44 161 202 87 184 241 196 4 115 238 141 227 185 71 117 188 200 216 24 146 89 38 104 34 207 237 120 145 188 78 11 251 93 132 206 134 44 24 74 104 136 208 21 226 116 242 40 13 181 61 52 145 70 96 0 109 70 127 22 222 134 252 43 55 52 10 133 33 10 159 30 39 205 221 101 158 135 4 173 246 191 224 226 109 162 16 35 112 172 144 156 246 247 132 90 151 238 66 53 25 135 31 49 36 64 244 192 152 117 154 42 80 128 94 142 87 194 50 231 25 152 29 136 75 195 149 210 205 50 98 7 80 138 200 91 23 164 92 188 248 255 0 0 0 255 255 3 0 160 117 37 221 91 190 154 158 0 0 0 0 73 69 78 68 174 66 96 130]! !!PNGReadWriterTest methodsFor: 'tests - grayscale' stamp: 'ar 1/7/2011 16:50'!testGrayScale	| form reader |	reader := PNGReadWriter on: self grayScaleData readStream.	form := reader nextImage.	self assert: form extent = (217@125).	self assert: form depth = 8.! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 16:39'!nextImage	"read one image"	| data p |	first ifNil:[		first := false.		data := stream contentsOfEntireFile.		stream := (RWBinaryOrTextStream with: data) reset.	]	ifNotNil:[		type < 4 ifTrue:[			self error:'Plain PBM, PGM or PPM have only one image'		].	].	stream ascii.	p := stream next.	type := (stream next) asInteger - 48.	(p = $P and:[type > 0 and:[type < 8]]) ifFalse:[		self error:'Not a PNM file'	].	type = 7 ifTrue:[		self readHeaderPAM	]	ifFalse: [		self readHeader	].	type caseOf: {		[1] 	->	[^self readPlainBW].		[2] 	->	[^self readPlainGray].		[3] 	->	[^self readPlainRGB].		[4] 	->	[^self readBWreverse: false].		[5] 	->	[^self readGray].		[6] 	->	[^self readRGB].		[7] 	->	[	"PAM"					(tupleType asUppercase) caseOf: {						['BLACKANDWHITE'] 		-> [^self readBWreverse: true].						['GRAYSCALE'] 			-> [^self readGray].						['RGB'] 					-> [^self readRGB].						['RGB_ALPHA'] 			-> [^self error:'Not implemented'].						['GRAYSCALE_ALPHA'] 	-> [^self error:'Not implemented'].					} otherwise: [^self readData].				]	}! !!PackageAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:28'!build 	|pTopic|	topicToBuild := (HelpTopic named: rootToBuildFrom bookName).	rootToBuildFrom packages do: [:package|		pTopic := HelpTopic named: package.		topicToBuild addSubtopic: pTopic.		self buildPackageTopic: pTopic.			]! !!PackageAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:28'!buildPackageTopic: pTopic 	| classTopic classes |	classes := (PackageInfo named: pTopic title) classes asSortedCollection: [:cl1 :cl2 | cl1 name < cl2 name].	classes	   do: [:aClass| 		classTopic := ClassAPIHelpBuilder buildHierarchicalHelpTopicFrom: aClass withSubclasses: false withMethods: true.		pTopic addSubtopic: classTopic	]! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:40'!testBalloon	self testPackage: 'Balloon' dependsExactlyOn: #(		Kernel Collections Graphics System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:32'!testCollections	self testPackage: 'Collections' dependsExactlyOn: #(		Compiler		Kernel		Exceptions		Files		Graphics		Multilingual		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:32'!testCompression	self testPackage: 'Compression' dependsExactlyOn: #(		Collections		Exceptions		Files		Graphics		Kernel		Multilingual		SUnit		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:42'!testEtoys	self testPackage: 'EToys' dependsExactlyOn: #(		Balloon		Collections		Compiler		Exceptions		Files		Graphics		Kernel		Morphic		MorphicExtras		Network		Protocols		System		'ToolBuilder-Kernel'		Tools		SUnit	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 12/9/2011 12:09'!testExceptions	self testPackage: 'Exceptions' dependsExactlyOn: #(		Collections		Kernel		System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:33'!testFiles	self testPackage: 'Files' dependsExactlyOn: #(		Collections		Compression		Exceptions		Graphics		Kernel		Multilingual		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:33'!testGraphics	self testPackage: 'Graphics' dependsExactlyOn: #(		Collections		Compression		Exceptions		Files		Kernel		Morphic		Multilingual		System		'ToolBuilder-Kernel'		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:35'!testKernel	self testPackage: 'Kernel' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		MorphicExtras		Multilingual		System		'ToolBuilder-Kernel'		Tools		Traits	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 12/9/2011 12:10'!testMonticello	self testPackage: 'Monticello' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		Network		'PackageInfo-Base'		System		'ToolBuilder-Kernel'		'ToolBuilder-Morphic'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:41'!testMorphic	self testPackage: 'Morphic' dependsExactlyOn: #(		Balloon		Collections		Compiler		EToys		Exceptions		Files		Graphics		Kernel		Monticello		MonticelloConfigurations		MorphicExtras		Multilingual		Network		ST80		Sound		System		'ToolBuilder-Kernel'		'ToolBuilder-Morphic'		Tools		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 12/9/2011 12:10'!testNetwork	self testPackage: 'Network' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 12/9/2011 12:10'!testST80	self testPackage: 'ST80' dependsExactlyOn: #(		Collections		Compiler		Exceptions		Files		Graphics		Kernel		Morphic		Multilingual		Network		SUnit		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:41'!testSUnitGUI	self testPackage: 'SUnitGUI' dependsExactlyOn: #(		Collections		Graphics		Kernel		'PackageInfo-Base'		SUnit		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:42'!testServices	self testPackage: 'Services-Base' dependsExactlyOn: #(		Collections		Compiler		Exceptions		Graphics		Kernel		Morphic		'PackageInfo-Base'		PreferenceBrowser		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 10/28/2010 04:59'!testShoutCore	self testPackage: 'ShoutCore' dependsExactlyOn: #(		Collections		Graphics		Kernel		Monticello		System		Compiler		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:35'!testSound	self testPackage: 'Sound' dependsExactlyOn: #(		Collections		Balloon		Files		Graphics		Kernel		Morphic		MorphicExtras		Network		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 12/9/2011 12:11'!testSystem	self testPackage: 'System' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Monticello		MonticelloConfigurations		Morphic		MorphicExtras		Multilingual		Network		'PackageInfo-Base'		Sound		'ToolBuilder-Kernel'		Tools		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 12/9/2011 12:11'!testToolBuilder	self testPackage: 'ToolBuilder-Kernel' dependsExactlyOn: #(		Collections		Exceptions		Files		Graphics		Kernel		SUnit		System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 12/9/2011 12:11'!testToolBuilderMVC	self testPackage: 'ToolBuilder-MVC' dependsExactlyOn: #(		Collections		Graphics		ST80		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 12/9/2011 12:12'!testToolBuilderSUnit	self testPackage: 'ToolBuilder-SUnit' dependsExactlyOn: #(		Collections		Exceptions		Kernel		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:43'!testTools	self testPackage: 'Tools' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		MorphicExtras		Multilingual		Network		'PackageInfo-Base'		ST80		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:36'!testTrueType	self testPackage: 'TrueType' dependsExactlyOn: #(		Collections		Balloon		Exceptions		Files		Graphics		Kernel		Morphic		Multilingual		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'utilities' stamp: 'ar 9/5/2010 11:36'!testPackage: pkgName dependsExactlyOn: pkgList	"Ensure that the package with the given name depends only on the packages in pkgList.	NOTE: If you use this for fixing dependencies, classDeps includes the classes	and users from the package(s) not declared as dependents. Basically, you need	to fix all the references in classDeps to make the test pass."	| classDeps pi pkgDeps |	classDeps := IdentityDictionary new.	pi := PackageOrganizer default packageNamed: pkgName ifAbsent:[^self]. "unloaded"	pi classes do:[:pkgClass| 		(classDeps at: (pkgClass superclass ifNil:[ProtoObject]) 			ifAbsentPut:[OrderedCollection new]) add: pkgClass name, ' superclass'.	].	pi methods do:[:mref| | cm |		cm := mref compiledMethod.		1 to: cm numLiterals do:[:i| | lit |			((lit := cm literalAt: i) isVariableBinding 				and:[lit value isBehavior]) ifTrue:[(classDeps at: lit value ifAbsentPut:[OrderedCollection new]) add: cm methodClass asString, '>>', cm selector]]].	pkgDeps := Dictionary new.	classDeps keys do:[:aClass| | pkg |		pkg := PackageOrganizer default packageOfClass: aClass ifNone:[nil].		pkg ifNil:[			Transcript cr; show: 'WARNING: No package for ', aClass.			(classDeps removeKey: aClass) do:[:each| Transcript crtab; show: each].		] ifNotNil:[			(pkgDeps at: pkg name ifAbsentPut:[OrderedCollection new]) add: aClass.		].	].	(pkgDeps removeKey: pkgName ifAbsent:[#()]) 		do:[:aClass| classDeps removeKey: aClass ifAbsent:[]].	pkgList do:[:pkg|		self assert: (pkgDeps includesKey: pkg)			description: pkgName, ' no longer depends on ', pkg.		(pkgDeps removeKey: pkg ifAbsent: [#()]) 			do:[:aClass| classDeps removeKey: aClass ifAbsent:[]].	].	classDeps keysAndValuesDo:[:class :deps|		Transcript cr; show: class name, ' dependencies:'.		deps do:[:each| Transcript crtab; show: each].	].	self assert: pkgDeps isEmpty		description: pkgName, ' now depends on ', pkgDeps.! !!PackageInfo methodsFor: 'naming' stamp: 'mist 2/17/2005 12:55'!name^ self packageName! !!PackageInfo methodsFor: 'naming' stamp: 'ab 10/16/2002 16:57'!packageName	^ packageName ifNil: [packageName := self categoryName]! !!PackageInfo methodsFor: 'testing' stamp: 'bf 10/11/2011 15:09'!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		(self isOverrideCategory: methodCategory) ifFalse: [^nil].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!PackageInfo methodsFor: 'testing' stamp: 'nice 2/15/2011 23:36'!includesClass: aClass	^ self includesSystemCategory: aClass category! !!PackageInfo methodsFor: 'enumerating' stamp: 'eem 8/30/2010 10:28'!actualMethodsDo: aBlock	"Evaluate aBlock with the actual method objects in this package."	| enum |	self extensionMethods do:		[:mr|		aBlock value: mr compiledMethod].	enum := [:behavior|			behavior organization categories do:				[:cat|				(self isForeignClassExtension: cat) ifFalse:					[(behavior organization listAtCategoryNamed: cat) do:						[:s|						aBlock value: (behavior compiledMethodAt: s)]]]].	self classes do:		[:c| enum value: c; value: c classSide]		! !!PackageInfo methodsFor: '*monticello' stamp: 'cmm 3/21/2009 14:08'!mcPackage	^ MCPackage named: self packageName! !!PackageInfo methodsFor: '*monticello' stamp: 'cmm 3/18/2009 20:42'!workingCopy	^ self mcPackage workingCopy! !!PackageInfo class methodsFor: 'packages access' stamp: 'avi 11/12/2003 23:00'!named: aString	^ PackageOrganizer default packageNamed: aString ifAbsent: [(self new packageName: aString) register]! !!PackageInfo class methodsFor: 'registration / unregistration' stamp: 'ab 11/14/2002 15:05'!registerPackage: aString	"for compatibility with old fileOuts"	^ Smalltalk at: #FilePackageManager ifPresent: [:p | p registerPackage: aString]! !!PackageInfo class methodsFor: 'registration / unregistration' stamp: 'avi 11/11/2003 17:19'!registerPackageName: aString	^ PackageOrganizer default registerPackageNamed: aString! !!PackageOrganizer methodsFor: 'registering' stamp: 'ar 6/16/2010 19:57'!flushObsoletePackages: aBlock	"Flush all packages considered obsolete by evaluating the argument block."	packages keys do:[:key|		(aBlock value: (packages at: key)) ifTrue:[packages removeKey: key].	].	self changed: #packages; changed: #packageNames.! !!PackagePaneBrowser methodsFor: 'class list' stamp: 'fbs 3/3/2011 17:51'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	^ self hasSystemCategorySelected 		ifFalse: [self packageClasses]		ifTrue: [systemOrganizer listAtCategoryNamed: self selectedSystemCategory]! !!PackagePaneBrowser methodsFor: 'dragNDrop util' stamp: 'fbs 3/3/2011 17:50'!dstCategoryDstListMorph: dstListMorph internal: internal 	| dropItem |	^ internal & (dstListMorph getListSelector == #systemCategoryList)		ifTrue: [(dropItem := dstListMorph potentialDropItem) ifNotNil: [(self package , '-' , dropItem) asSymbol]]		ifFalse: [self selectedSystemCategory]! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'eem 7/1/2010 10:22'!labelString	^self package		ifNil: [super labelString]		ifNotNil:			[:pkg| | label |			label := self defaultBrowserTitle, ': ', pkg, (self selectedClass														ifNil: ['']														ifNotNil: [' ', self selectedClass printString]).			(multiWindowState notNil			 and: [multiWindowState models size > 1]) ifTrue:				[label := (multiWindowState models indexOf: self) printString, '. ', label].			label]! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'fbs 3/30/2011 21:52'!packageListIndex: anInteger 	"Set anInteger to be the index of the current package selection."	packageListIndex := anInteger.	anInteger = 0		ifFalse: [package := self packageList at: packageListIndex].	selectedMessageCategoryName := nil.	self selectSystemCategory: nil.	selectedMessageName := nil.	selectedClassName := nil.	self setClassOrganizer.	self changed: #packageSelectionChanged.	self changed: #packageListIndex.	"update my selection"	self changed: #systemCategoryList.	"update the category list"	self selectSystemCategory: nil.	"update category list selection"! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'cao 12/12/2011 19:20'!hasSystemCategorySelected	^ super selectedSystemCategory notNil.! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'fbs 3/5/2011 20:57'!selectCategoryForClass: theClass	"Set the package and category lists to display the given class."	| cat catName |	cat := theClass category.	self packageListIndex: (self packageList indexOf: (cat copyUpTo: $-)).	catName := (cat copyFrom: ((cat indexOf: $- ifAbsent: [0]) + 1) to: cat size).	self selectSystemCategory: catName.! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'cao 12/12/2011 19:21'!selectedSystemCategory	"Answer the name of the selected system category or nil."	self hasSystemCategorySelected		ifFalse: [^nil].	packageListIndex = 0		ifTrue: [^ super selectedSystemCategory ].	^ self package , '-' , super selectedSystemCategory! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'cao 12/12/2011 19:28'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	^ self selectedSystemCategory! !!PackagePaneBrowser methodsFor: 'system category list' stamp: 'cao 12/12/2011 19:51'!systemCategoryListIndex	"Answer the index of the selected class category."	^ self systemCategoryList indexOf: super selectedSystemCategory.! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^true! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'fbs 3/3/2011 17:50'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self package			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 self selectedClass					ifNil: [self selectedSystemCategory							ifNil: [s nextPutAll: pkg]							ifNotNil: [:cat| s nextPutAll: cat]]					ifNotNil:						[:class|						 s nextPutAll: pkg; space; print: class.						 self metaClassIndicated ifTrue:							[s nextPutAll: ' class']]].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:31'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'restoreToPackage:')			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 s nextPutAll: pkg.				(getarg value: 'className:')					ifNil: [(getarg value: 'category:') ifNotNil:							[:categoryName| s nextPut: $-; nextPutAll: categoryName]]					ifNotNil:						[:className|						s space; nextPutAll: className.						(getarg value: 'meta:') ifTrue:							[s nextPutAll: ' class'].						  self isHierarchy ifTrue:							[s space; nextPutAll: ' Hierarchy'].						(getarg value: 'selector:')							ifNil: [(getarg value: 'protocol:') ifNotNil:									[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]							ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24'!restoreToPackage: packageNameOrNil category: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self packageListIndex: (self packageList indexOf: packageNameOrNil).	super restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'fbs 3/3/2011 17:33'!saveMultiWindowState	^Message		selector: #restoreToPackage:category:className:protocol:selector:mode:meta:		arguments: {	self package.						self selectedSystemCategory.						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !!PackagePaneBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/3/2011 23:04'!setUp	browser := PackagePaneBrowser new.! !!PackagePaneBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 17:26'!testClassList	browser selectSystemCategory: browser class category.	self assert: browser classList = (SystemOrganization listAtCategoryNamed: browser class category).		browser selectSystemCategory: nil.	self assert: browser classList isEmpty.! !!PackagePaneBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/16/2011 07:37'!testPackageListIndex	browser packageListIndex: 0.	self assert: browser selectedClass isNil.		browser selectCategoryForClass: browser class.		"Clicking the selected package unselects the selected class."	browser packageListIndex: browser packageListIndex.	self assert: browser selectedClass isNil.! !!PackagePaneBrowserTest methodsFor: 'as yet unclassified' stamp: 'fbs 3/5/2011 20:57'!testSelectCategoryForClass	| catName pkgName |	pkgName := browser class category copyUpTo: $-.	catName := browser class category allButFirst: pkgName size + 1.	browser selectCategoryForClass: browser class.	self assert: browser selectedSystemCategory = catName.	self assert: browser packageListIndex = (browser packageList indexOf: pkgName).	browser selectSystemCategory: nil.	self assert: browser classList isEmpty.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'nice 12/29/2010 14:53'!init4	"Just a record of how Ted loaded in the paintbox button images, Feb 98"	| bb im pp newImage pic24Bit picNewBit blt |	"self loadoffImage: 'roundedPalette3.bmp'."	pic24Bit := GIFReadWriter formFromServerFile: 'updates/137roundedPalette3.bmp'.	picNewBit := Form extent: pic24Bit extent depth: 16.	pic24Bit displayOn: picNewBit.	OriginalBounds := picNewBit boundingBox.	AllOffImage := Form extent: OriginalBounds extent depth: 16.	blt := BitBlt current toForm: AllOffImage.	blt sourceForm: picNewBit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0 @ 0; copyBits.	AllOffImage mapColor: Color transparent to: Color black.	self image: AllOffImage.	self invalidRect: bounds.	self submorphsDo: [:button | button position: button position + (10 @ 10)].	(im := submorphs at: 28) class == ImageMorph ifTrue: [		im position: im position + (2 @ 0)].	"color picker"	"exercise it once"	(bb := self submorphNamed: #keep:) position: bb position + (0 @ 25).	(bb := self submorphNamed: #toss:) position: bb position + (0 @ 25).	(bb := self submorphNamed: #undo:) position: bb position + (0 @ -25).	(bb := self submorphNamed: #clear:) position: bb position + (0 @ -25).	(bb := self submorphNamed: #undo:) position: bb position + (0 @ -69).	(bb := self submorphNamed: #clear:) position: bb position + (0 @ -69).	self submorphsDo: [:button | 		button class == AlignmentMorph ifTrue: [			button position: button position + (0 @ 25)].		(button printString includesSubString: 'stamp:') ifTrue: [			button position: button position + (0 @ 25)]].	(bb := self submorphNamed: #prevStamp:) position: bb position + (0 @ 25).	(bb := self submorphNamed: #nextStamp:) position: bb position + (0 @ 25).	bb := self submorphNamed: #keep:.	newImage := bb pressedImage copy: (0 @ 4 corner: (bb pressedImage boundingBox extent)).	bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.	bb position: bb position + (4 @ 1).	pp := (bb := self submorphNamed: #toss:) pressedImage.	newImage := pp copy: (0 @ 4 corner: (bb pressedImage extent - (3 @ 0))).	bb onImage: newImage.  bb pressedImage: newImage.  	bb extent: newImage extent.	bb position: bb position + (3 @ 1).	pp := (bb := self submorphNamed: #undo:) pressedImage.	newImage := pp copy: (0 @ 0 corner: (bb pressedImage extent - (3 @ 5))).	bb onImage: newImage.  bb pressedImage: newImage.  	bb extent: newImage extent.	bb position: bb position + (3 @ -1).	pp := (bb := self submorphNamed: #clear:) pressedImage.	newImage := pp copy: (0 @ 0 corner: (bb pressedImage extent - (0 @ 5))).	bb onImage: newImage.  bb pressedImage: newImage.  	bb extent: newImage extent.	bb position: bb position + (3 @ -1).	pic24Bit := GIFReadWriter formFromServerFile: 'updates/137pencil.bmp'.	picNewBit := Form extent: pic24Bit extent depth: 16.	pic24Bit displayOn: picNewBit.	newImage := picNewBit as8BitColorForm.	newImage transparentColor: (Color r: 0 g: 0 b: 0).	(bb := self submorphNamed: #erase:) pressedImage: newImage; onImage: newImage;		extent: newImage extent.	bb position: bb position + (-11 @ -1).! !!PaintBoxMorph methodsFor: 'recent colors' stamp: 'nice 12/29/2010 14:54'!fixUpColorPicker	| chart picker |	chart := ColorChart ifNil: [ColorChart := Cursor wait showWhile: [(ColorPickerMorph colorPaletteForDepth: 16 extent: 120 @ 89)]].	chart getCanvas frameRectangle: chart boundingBox color: Color black.	picker := Form extent: (chart extent + (14 @ 12)) depth: 16.	picker fillWhite.	"top"	picker copy: (0 @ 0 extent: picker width @ 6)			from: (colorMemory image width - picker width) @ 0 			in: colorMemory image rule: Form over.	"bottom"	picker copy: (0 @  (picker height - 6) extent: picker width @ 6) 			from: (colorMemory image width - picker width) @ (colorMemory image height - 7)			in: colorMemory image rule: Form over.	"left"	picker copy: (0 @ 6 corner: 8 @ (picker height - 6))			from: (colorMemory image boundingBox topLeft + (0 @ 6)) 			in: colorMemory image rule: Form over.	"right"	picker copy: (picker width-6 @ 6 corner: picker width @ (picker height - 6))			from: (colorMemory image boundingBox topRight - (6 @ -6)) 			in: colorMemory image rule: Form over.	chart displayOn: picker at: 8 @ 6.	picker getCanvas frameRectangle: picker boundingBox color: Color black.	colorMemory image: picker.! !!Paragraph methodsFor: 'accessing' stamp: 'nice 8/3/2011 21:17'!string	^text string! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:51'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"		^self evaluateSelectionAndDo: [:result | result]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:56'!evaluateSelectionAndDo: aBlock	"Treat the current selection as an expression; evaluate it and invoke aBlock with the result."	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ nil].	(model respondsTo: #doItReceiver) 		ifTrue: [ rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [self flash. ^nil]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	^aBlock value: result! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:44'!exploreIt	self evaluateSelectionAndDo: [:result | result explore]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:44'!inspectIt	self evaluateSelectionAndDo: [:result | result inspect].! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:45'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "		self terminateAndInitializeAround:		[self evaluateSelectionAndDo: [:result |			self systemNavigation					browseAllObjectReferencesTo: result					except: #()					ifNone: [:obj | view topView flash]]]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:46'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	self evaluateSelectionAndDo: [:result |		self afterSelectionInsertAndSelect: result printString]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:59'!tallySelection	"Treat the current selection as an expression; evaluate it and return the time took for this evaluation"	| result rcvr ctxt valueAsString v |	self lineSelectAndEmptyCheck: [^self].	(model respondsTo: #doItReceiver) 		ifTrue: [ rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [ | cm |		cm := rcvr class evaluatorClass new 			compiledMethodFor: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [self flash. ^self]			logged: false.		Time millisecondsToRun: 			[v := cm valueWithReceiver: rcvr arguments: #() ].	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	"We do not want to have large result displayed"	valueAsString := v printString.	(valueAsString size > 30) ifTrue: [valueAsString := (valueAsString copyFrom: 1 to: 30), '...'].	PopUpMenu 		inform: 'Time to compile and execute: ', result printString, 'ms res: ', valueAsString.! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'nice 8/4/2011 01:13'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([<{|"''' indexOf: char ifAbsent: [ ^true ].	left := '([<{|"''' at: which.	right := ')]>}|"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'ul 11/15/2010 11:56'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars := self selection) size = 0		ifTrue:			[currentSelection := self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size = 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection := self pointIndex - 1]].	aString := self selection string.	self replaceSelectionWith: (Text string: aString reversed emphasis: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 5/8/2011 10:54'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply := Smalltalk at: symbol ifAbsent: [^nil].	(reply class == Dictionary or:[reply isKindOf: SharedPool class])		ifTrue: 			[classes := Set new.			self systemNavigation allBehaviorsDo: [:each | (each sharedPools anySatisfy: [:pool | pool == reply])					ifTrue: [classes add: each]].			classes := classes printString.			^'"is a global variable.  It is a pool which is used by the following classes ' , (classes allButFirst: 5) , '"'].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 5/8/2011 10:54'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls := model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes := (Array with: cls)				, cls allSuperclasses.	classes := classes detect: [:each | each instVarNames			anySatisfy: [:name | name = string] ] ifNone: [^nil].	classes := classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 5/8/2011 10:55'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^nil].	"not in a message"	classes := self systemNavigation allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits anySatisfy: [:each | each == symbol])				ifFalse: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 5/8/2011 10:56'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits := Array with: msg.	(whole := lits detect: [:each | each keywords anySatisfy: [:frag | frag = string] ]				ifNone: []) ~~ nil		ifTrue: [reply := ', which is the selector of this very method!!'.			s := '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole := lits detect: [:each | each keywords anySatisfy: [:frag | frag = string] ]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply := '.'.			s := '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes := self systemNavigation allClassesImplementing: whole.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 2/23/2011 21:50'!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode tempNode |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass newParser parse: model selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [:n| n name = string] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:56'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply := UIManager default request: 'Find what? ' translated initialAnswer: ''.	reply size = 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText := FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:56'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName |	stringToSave := paragraph text string.	stringToSave size = 0 ifTrue: [^ self inform: 'nothing to save.'].	parentWindow := self model dependents						detect: [:dep | dep isKindOf: SystemWindow orOf: StandardSystemView]						ifNone: [nil].	labelToUse := parentWindow		ifNil: 		['Untitled']		ifNotNil: 	[parentWindow label].	suggestedName := nil.	#(('Decompressed contents of: '		'.gz')) do:  "can add more here..."		[:leaderTrailer | | lastIndex |			(labelToUse beginsWith: leaderTrailer first) ifTrue:				[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1 to: labelToUse size.				(labelToUse endsWith: leaderTrailer last)					ifTrue:						[suggestedName := suggestedName copyFrom: 1 to: suggestedName size - leaderTrailer last size]					ifFalse:						[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].						(lastIndex = 0 or: [lastIndex = 1]) ifFalse:							[suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil:		[suggestedName := labelToUse, '.text'].				fileName := UIManager default request: 'File name?' translated			initialAnswer: suggestedName.	fileName isEmptyOrNil ifFalse:		[(FileStream newFileNamed: fileName) nextPutAll: stringToSave; close]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:56'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString := self selection string.	aString isOctetString ifTrue: [aString := aString asOctetString].	aString := self selection string copyWithoutAll: CharacterSet separators.	aString size = 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:56'!sendContentsToPrinter	| textToPrint printer parentWindow |	textToPrint := paragraph text.	textToPrint size = 0 ifTrue: [^self inform: 'nothing to print.'].	printer := TextPrinter defaultTextPrinter.	parentWindow := self model dependents 				detect: [:dep | dep isSystemWindow]				ifNone: [nil].	parentWindow isNil 		ifTrue: [printer documentTitle: 'Untitled']		ifFalse: [printer documentTitle: parentWindow label].	printer printText: textToPrint! !!ParagraphEditor methodsFor: 'new selection' stamp: 'nice 8/4/2011 02:02'!selectWord	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string := paragraph text string.	here := self pointIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^self selectFrom: 1 to: string size].	leftDelimiters := '([{<|''"'.	rightDelimiters := ')]}>|''"'.	openDelimiter := string at: here - 1.	match := leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start := here.			direction := 1.			here := here - 1.			closeDelimiter := rightDelimiters at: match]		ifFalse: 			[openDelimiter := string at: here.			match := rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop := here - 1.					direction := -1.					closeDelimiter := leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction := -1]].	level := 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar := string at: (here := here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start := 1.									"go right if hit string start"									direction := 1]]						ifFalse: [direction < 0								ifTrue: 									[start := here + 1.									"go right if hit non-token"									direction := 1]								ifFalse: [level := 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level := level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level := level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here := here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'ul 11/15/2010 11:56'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString :=  self selection string.	aString size = 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ul 11/12/2010 03:44'!blinkPrevParen	self deprecated: 'Use #blinkPrevParen:'.	self blinkPrevParen: sensor keyboardPeek! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ul 11/12/2010 03:10'!blinkPrevParen: aCharacter	| openDelimiter closeDelimiter level string here hereChar |	string := paragraph text string.	here := startBlock stringIndex.	openDelimiter := aCharacter.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	[level > 0 and: [here > 1]]		whileTrue:			[hereChar := string at: (here := here - 1).			hereChar = closeDelimiter				ifTrue:					[level := level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level := level + 1]]].! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'nice 8/2/2011 20:37'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys result |	self clearParens.  	"mikki 1/3/2005 21:31 Preference for auto-indent on return added."	char asciiValue = 13 ifTrue: [		^Preferences autoIndent 			ifTrue: [				sensor controlKeyPressed					ifTrue: [self normalCharacter: typeAheadStream]					ifFalse: [self crWithIndent: typeAheadStream]]			ifFalse: [				sensor controlKeyPressed					ifTrue: [self crWithIndent: typeAheadStream]					ifFalse: [self normalCharacter: typeAheadStream]]].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].			"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream].	result := self normalCharacter: typeAheadStream.		(')]}' includes: char)		ifTrue: [self blinkPrevParen: char ].	^result! !!ParagraphEditor methodsFor: '*Tools' stamp: 'fbs 3/5/2011 20:57'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol b |	(((b := model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol := self selectedSymbol) ifNil: [^ view flash].	self terminateAndInitializeAround:		[| foundClass |		foundClass := (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass ifNil: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model selectSystemCategory: foundClass category.		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: '*Tools' stamp: 'nice 1/31/2011 23:07'!debugIt	| method receiver context |	(model respondsTo: #doItReceiver) 		ifTrue: 			[receiver := model doItReceiver.			context := model doItContext]		ifFalse:			[receiver := context := nil].	self lineSelectAndEmptyCheck: [^self].	method := self compileSelectionFor: receiver in: context.	method notNil ifTrue:		[self debug: method receiver: receiver in: context].! !!ParagraphEditor methodsFor: '*Tools' stamp: 'ul 6/13/2011 12:19'!debug: aCompiledMethod receiver: anObject in: evalContext	| guineaPig debugger context |	guineaPig := [		aCompiledMethod			valueWithReceiver: anObject			 arguments: (evalContext ifNil: [ #() ] ifNotNil: [ { evalContext } ]) ] newProcess.	context := guineaPig suspendedContext.	debugger := Debugger new		process: guineaPig		controller: ((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: context.	debugger openFullNoSuspendLabel: 'Debug it'.	[debugger interruptedContext method == aCompiledMethod]		whileFalse: [debugger send]! !!ParagraphEditor methodsFor: 'private' stamp: 'nice 11/15/2010 21:17'!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |	wordStyle := Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines := paragraph lines.			numberOfLines := paragraph numberOfLines.			currentLineNumber  := paragraph lineIndexOfCharacterIndex: start.			currentLine := lines at: currentLineNumber]		ifFalse: [			lines := self lines.			numberOfLines := lines size.			currentLine := lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber := currentLine second].	column := start - currentLine first.	targetLineNumber := ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.	offsetAtTargetLine := (lines at: targetLineNumber) first.	targetEOL := (lines at: targetLineNumber) last + (targetLineNumber = numberOfLines ifTrue:[1]ifFalse:[0]).	targetLineNumber = currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'nice 8/4/2011 02:45'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap |	cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.			"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.		"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.	"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.			"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.			"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.			"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"	'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].	'([<{|"''' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].	"triplet = {character. comment selector. novice appropiated}"	#(		($a		#selectAll:				true)		($b		#browseIt:				false)		($c		#copySelection:			true)		($d		#doIt:						false)		($e		#exchange:				true)		($f		#find:						true)		($g		#findAgain:				true)		($h		#setSearchString:		true)		($i		#inspectIt:				false)		($j		#doAgainOnce:			true)		($k		#offerFontMenu:		true)		($l		#cancel:					true)		($m	#implementorsOfIt:		false)		($n		#sendersOfIt:			false)		($o		#spawnIt:				false)		($p		#printIt:					false)		($q		#querySymbol:			false)		($s		#save:					true)		($t		#tempCommand:		false)		($u		#align:					true)		($v		#paste:					true)		($w	#backWord:				true)		($x		#cut:						true)		($y		#swapChars:				true)		($z		#undo:					true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet | cmdMap at: triplet first asciiValue + 1 put: triplet second].	CmdActions := cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'nice 8/4/2011 02:31'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	| cmdMap |	"shift-command and control shortcuts"	cmdMap := Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.				"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.				"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.				"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.				"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.				"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"On some keyboards, these characters require a shift"	'([<{|"''' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].			"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	"triplet = {character. comment selector. novice appropiated}"	#(		($a		argAdvance:						false)		($b		browseItHere:					false)		($c		compareToClipboard:			false)		($d		duplicate:							true)		($e		methodStringsContainingIt:	false)		($f		displayIfFalse:					false)		($g		fileItIn:							false)		($h		cursorTopHome:					true)		($i		exploreIt:							false)		($j		doAgainMany:					true)		($k		changeStyle:						true)		($l		outdent:							true)		($m	selectCurrentTypeIn:			true)		($n		referencesToIt:					false)		($p		makeProjectLink:				true)		($r		indent:							true)		($s		search:							true)		($t		displayIfTrue:					false)		($u		changeLfToCr:					false)		($v		pasteInitials:						false)		($w	methodNamesContainingIt:	false)		($x		makeLowercase:					true)		($y		makeUppercase:					true)		($z		makeCapitalized:				true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet |			cmdMap at: (triplet first asciiValue         + 1) put: triplet second.		"plain keys"			cmdMap at: (triplet first asciiValue - 32 + 1) put: triplet second.		"shifted keys"			cmdMap at: (triplet first asciiValue - 96 + 1) put: triplet second.		"ctrl keys"		].	ShiftCmdActions := cmdMap! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block"	^self emitCodeForValue: stack encoder: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:37'!emitCodeForBranchOn: condition dist: dist pop: stack encoder: encoder	stack pop: 1.	dist = 0 ifTrue: [^encoder genPop].	condition		ifTrue: [encoder genBranchPopTrue: dist]		ifFalse: [encoder genBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38'!emitCodeForEffect: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genPop.	stack pop: 1! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:39'!emitCodeForJump: dist encoder: encoder	dist = 0 ifFalse: [encoder genJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38'!emitCodeForReturn: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genReturnTop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13'!sizeCode: encoder forBranchOn: condition dist: dist	dist = 0 ifTrue: [^encoder sizePop].	^condition		ifTrue: [encoder sizeBranchPopTrue: dist]		ifFalse: [encoder sizeBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:52'!sizeCode: encoder forJump: dist	^dist = 0 ifTrue: [0] ifFalse: [encoder sizeJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeCodeForValue: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:53'!sizeCodeForEffect: encoder	^(self sizeCodeForValue: encoder) + encoder sizePop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:57'!sizeCodeForReturn: encoder	^(self sizeCodeForValue: encoder) + encoder sizeReturnTop! !!ParseNode methodsFor: 'testing' stamp: 'eem 2/3/2011 09:12'!ensureCanCascade: encoder! !!ParseNode methodsFor: 'testing' stamp: 'ul 11/23/2010 13:06'!isLiteralNode	^ false! !!ParseNode methodsFor: 'testing' stamp: 'eem 8/31/2010 11:34'!isOnlySubnodeOf: aSubtree "<ParseNode>" in: aParseTree "<ParseNode>"	"Answer if the receiver only occurs within aSubtree of aParseTree, not in the rest of aParseTree.	 Assumes that aSubtree is in fact a subnode of aParseTree."	| isSubnode |	isSubnode := false.	aSubtree accept: (ParseNodeEnumerator							ofBlock: [:node| node == self ifTrue: [isSubnode := true]]).	isSubnode ifFalse:		[^false].	aParseTree accept: (ParseNodeEnumerator							ofBlock: [:node| node == self ifTrue: [^false]]							select: [:node| node ~= aSubtree]).	^true! !!ParseNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	"Accept a visitor by double-dispatching to a type-specific method on the visitor, e.g. visitBlockNode:.	 All such implementations under ParseNode should answer the result of the dispatch, e.g.		^aVisitor visitBlockNode: self"	^self subclassResponsibility! !!ParseNodeEnumerator methodsFor: 'initialize-release' stamp: 'eem 8/31/2010 11:24'!ofBlock: aBlock select: aSelectBlock	theBlock := aBlock.	theSelectBlock := aSelectBlock! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitAssignmentNode: anAssignmentNode	(theSelectBlock isNil or: [theSelectBlock value: anAssignmentNode]) ifFalse:		[^nil].	theBlock value: anAssignmentNode.	^super visitAssignmentNode: anAssignmentNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitBlockNode: aBlockNode	(theSelectBlock isNil or: [theSelectBlock value: aBlockNode]) ifFalse:		[^nil].	theBlock value: aBlockNode.	^super visitBlockNode: aBlockNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitBraceNode: aBraceNode	(theSelectBlock isNil or: [theSelectBlock value: aBraceNode]) ifFalse:		[^nil].	theBlock value: aBraceNode.	^super visitBraceNode: aBraceNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitCascadeNode: aCascadeNode	(theSelectBlock isNil or: [theSelectBlock value: aCascadeNode]) ifFalse:		[^nil].	theBlock value: aCascadeNode.	^super visitCascadeNode: aCascadeNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitCommentNode: aCommentNode	(theSelectBlock isNil or: [theSelectBlock value: aCommentNode]) ifFalse:		[^nil].	theBlock value: aCommentNode.	^super visitCommentNode: aCommentNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitFieldNode: aFieldNode	(theSelectBlock isNil or: [theSelectBlock value: aFieldNode]) ifFalse:		[^nil].	theBlock value: aFieldNode.	^super visitFieldNode: aFieldNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitFutureNode: aFutureNode	(theSelectBlock isNil or: [theSelectBlock value: aFutureNode]) ifFalse:		[^nil].	theBlock value: aFutureNode.	^super visitFutureNode: aFutureNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitInstanceVariableNode: anInstanceVariableNode	(theSelectBlock isNil or: [theSelectBlock value: anInstanceVariableNode]) ifFalse:		[^nil].	theBlock value: anInstanceVariableNode.	^super visitInstanceVariableNode: anInstanceVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitLiteralNode: aLiteralNode	(theSelectBlock isNil or: [theSelectBlock value: aLiteralNode]) ifFalse:		[^nil].	theBlock value: aLiteralNode.	^super visitLiteralNode: aLiteralNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitLiteralVariableNode: aLiteralVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aLiteralVariableNode]) ifFalse:		[^nil].	theBlock value: aLiteralVariableNode.	^super visitLiteralVariableNode: aLiteralVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitMessageNode: aMessageNode	(theSelectBlock isNil or: [theSelectBlock value: aMessageNode]) ifFalse:		[^nil].	theBlock value: aMessageNode.	^super visitMessageNode: aMessageNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitMessageNodeInCascade: aMessageNodeInCascade	(theSelectBlock isNil or: [theSelectBlock value: aMessageNodeInCascade]) ifFalse:		[^nil].	theBlock value: aMessageNodeInCascade.	^super visitMessageNodeInCascade: aMessageNodeInCascade! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitMethodNode: aMethodNode	(theSelectBlock isNil or: [theSelectBlock value: aMethodNode]) ifFalse:		[^nil].	theBlock value: aMethodNode.	^super visitMethodNode: aMethodNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitNewArrayNode: aNewArrayNode	(theSelectBlock isNil or: [theSelectBlock value: aNewArrayNode]) ifFalse:		[^nil].	theBlock value: aNewArrayNode.	^super visitNewArrayNode: aNewArrayNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitRemoteTempVectorNode: aRemoteTempVectorNode	(theSelectBlock isNil or: [theSelectBlock value: aRemoteTempVectorNode]) ifFalse:		[^nil].	theBlock value: aRemoteTempVectorNode.	^super visitRemoteTempVectorNode: aRemoteTempVectorNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitReturnNode: aReturnNode	(theSelectBlock isNil or: [theSelectBlock value: aReturnNode]) ifFalse:		[^nil].	theBlock value: aReturnNode.	^super visitReturnNode: aReturnNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitSelectorNode: aSelectorNode	(theSelectBlock isNil or: [theSelectBlock value: aSelectorNode]) ifFalse:		[^nil].	theBlock value: aSelectorNode.	^super visitSelectorNode: aSelectorNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitTempVariableNode: aTempVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aTempVariableNode]) ifFalse:		[^nil].	theBlock value: aTempVariableNode.	^super visitTempVariableNode: aTempVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13'!visitVariableNode: aVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aVariableNode]) ifFalse:		[^nil].	theBlock value: aVariableNode.	^super visitVariableNode: aVariableNode! !!ParseNodeEnumerator commentStamp: 'eem 8/31/2010 11:41' prior: 0!ParseNodeEnumerator implements ParseNode>>nodesDo:.  It can be used to enumerate an entire tree via	aParseNode accept: (ParseNodeEnumerator ofBlock: aBlock)or selectively, excluding the node and subnodes for which selectBlock answers false, via	aParseNode accept: (ParseNodeEnumerator							ofBlock: aBlock							select: selectBlock)Here's a doIt that generates and compiles the visiting methods:self superclass selectors do:	[:s|	self compile: (String streamContents:		[:str| | arg |		arg := 'a', (s allButFirst: 5) allButLast.		str nextPutAll: s, ' ', arg; crtab;			nextPutAll: '(theSelectBlock isNil or: [theSelectBlock value: '; nextPutAll: arg; nextPutAll: ']) ifFalse:'; crtab;			tab: 2; nextPutAll: '[^nil].'; crtab;			nextPutAll: 'theBlock value: '; nextPutAll: arg; nextPut: $.; crtab;			nextPutAll: '^super '; nextPutAll: s, ' ', arg])]!!ParseNodeEnumerator class methodsFor: 'instance creation' stamp: 'eem 8/31/2010 11:43'!ofBlock: aBlock select: selectBlock	^self new ofBlock: aBlock select: selectBlock! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 20:08'!visitMessageNode: aMessageNode	aMessageNode receiver accept: self.	"receiver notNil ifTrue: ''receiver is nil for cascades''		[receiver accept: self]."	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode! !!Parser methodsFor: 'error correction' stamp: 'nice 2/4/2011 22:10'!canDeclareInstanceVariable	^encoder classEncoding ~~ UndefinedObject! !!Parser methodsFor: 'error correction' stamp: 'lw 5/27/2011 18:54'!collectTemporaryDeclarationsFrom: methodNode	| tempsMarks str |	tempsMarks := OrderedCollection new.	str := requestor text asString.	methodNode accept: (ParseNodeEnumerator		ofBlock: [ :aNode | 			| mark |			(aNode class canUnderstand: #tempsMark) 				ifTrue: 					[mark := aNode tempsMark.					(mark notNil and: [ mark between: 1 and: str size ] and: [ (str at: mark) = $| ])						ifTrue: [ tempsMarks addLast: aNode ]]]).	(tempsMark notNil and: [ tempsMark between: 1 and: str size ] and: [ (str at: tempsMark) = $| ])						ifTrue: [ tempsMarks addLast: self ].	^ tempsMarks sorted: [ :a :b | a tempsMark > b tempsMark ]! !!Parser methodsFor: 'error correction' stamp: 'jcg 6/23/2010 11:46'!correctVariable: proposedVariable interval: spot 	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	(binding := requestor bindingOf: proposedVariable)		ifNotNil: [^encoder global: binding name: proposedVariable].	userSelection := requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	"Build the menu with alternatives"	action := UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!Parser methodsFor: 'error correction' stamp: 'eem 7/6/2010 15:07'!declareClassVar: name	| sym class |	sym := name asSymbol.	class := encoder classEncoding.	class := class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	Smalltalk logChange: class definition.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!Parser methodsFor: 'error correction' stamp: 'eem 5/6/2010 21:14'!declareInstVar: name	"Declare an instance variable.  Since the variable will get added after any existing	 inst vars its index is the instSize."	encoder classEncoding addInstVarName: name.	Smalltalk logChange: encoder classEncoding definition.	^InstanceVariableNode new name: name index: encoder classEncoding instSize		! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:35'!declareTemp: name at: levelTag	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^(encoder bindUndeclaredTemp: name)		tag: levelTag;		yourself! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 19:34'!declareTempAndPaste: name	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^encoder bindUndeclaredTemp: name! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:37'!declareUndeclaredTemps: methodNode	"Declare any undeclared temps, declaring them at the smallest enclosing scope."	| undeclared userSelection blocksToVars |	(undeclared := encoder undeclaredTemps) isEmpty ifTrue:		[^self].	userSelection := requestor selectionInterval.	blocksToVars := IdentityDictionary new.	undeclared do:		[:var|		(blocksToVars			at: (var tag == #method					ifTrue: [methodNode block]					ifFalse: [methodNode accept: (VariableScopeFinder new ofVariable: var)])			ifAbsentPut: [SortedCollection new]) add: var name].	(blocksToVars removeKey: methodNode block ifAbsent: []) ifNotNil:		[:rootVars|		rootVars do: [:varName| self pasteTempAtMethodLevel: varName]].	(blocksToVars keys sorted: [:a :b| a tempsMark < b tempsMark]) do:		[:block| | decl |		decl := (blocksToVars at: block) reduce: [:a :b| a, ' ', b].		block temporaries isEmpty			ifTrue:				[self substituteWord: ' | ', decl, ' |'					wordInterval: (block tempsMark + 1 to: block tempsMark)					offset: requestorOffset]			ifFalse:				[self substituteWord: decl, ' '					wordInterval: (block tempsMark to: block tempsMark - 1)					offset: requestorOffset]].	requestor selectInvisiblyFrom: userSelection first to: userSelection last + requestorOffset.	ReparseAfterSourceEditing signal! !!Parser methodsFor: 'error correction' stamp: 'eem 10/12/2010 17:30'!defineClass: className 	"prompts the user to define a new class,  	asks for it's category, and lets the users edit further  	the definition"	| sym cat def d2 |	sym := className asSymbol.	cat := UIManager default request: 'Enter class category : ' initialAnswer: self encoder classEncoding theNonMetaClass category.	cat		ifEmpty: [cat := 'Unknown'].	def := 'Object subclass: #' , sym , '		instanceVariableNames: '''' 		classVariableNames: ''''		poolDictionaries: ''''		category: ''' , cat , ''''.	d2 := UIManager default request: 'Edit class definition : ' initialAnswer: def.	d2		ifEmpty: [d2 := def].	Compiler evaluate: d2.	^ encoder		global: (Smalltalk globals associationAt: sym)		name: sym! !!Parser methodsFor: 'error correction' stamp: 'eem 8/13/2010 19:34'!pasteTempAtMethodLevel: name	| insertion delta theTextString characterBeforeMark |	theTextString := requestor text string.	characterBeforeMark := theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion := name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion := ' ', insertion].		delta := 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion := '| ' , name , ' |',String cr.		delta := 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion := insertion , String tab.			delta := delta + 1.	"the tab"		].	].	tempsMark := tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta! !!Parser methodsFor: 'error correction' stamp: 'ul 11/15/2011 14:22'!removeEmptyTempDeclarationsFrom: methodNode	| sourceCode madeChanges tempsMarkHolder |	sourceCode := requestor text asString.	tempsMarkHolder := self collectTemporaryDeclarationsFrom: methodNode.	madeChanges := false.	tempsMarkHolder do: [ :currentBlock | | tempsMarkChar0 tempsMarkChar1 tempsMarkChar2 end start |		tempsMarkChar0 := (sourceCode at: currentBlock tempsMark).		tempsMarkChar1 := (sourceCode at: currentBlock tempsMark - 1).		tempsMarkChar2 := (sourceCode at: currentBlock tempsMark - 2).		tempsMarkChar0 = $| & tempsMarkChar1 = $| 			ifTrue: 				[ end := currentBlock tempsMark. 				start := end - 1].		tempsMarkChar0 = $| & tempsMarkChar1 = $  & tempsMarkChar2 = $| 			ifTrue: 				[ end := currentBlock tempsMark. 				start := end - 2].				start notNil & end notNil ifTrue: [			| lineStart lineEnd |			lineStart := 1 + (sourceCode 				lastIndexOf: Character cr 				startingAt: start - 1				ifAbsent: [ 0 ]).			lineEnd := sourceCode 				indexOf: Character cr				startingAt: end + 1				ifAbsent: [ sourceCode size ].			((sourceCode indexOfAnyOf: CharacterSet nonSeparators startingAt: lineStart) >= start 				and: [ (sourceCode indexOfAnyOf: CharacterSet nonSeparators startingAt: end + 1) > lineEnd ]) ifTrue: [					start := lineStart.					end := lineEnd ].			requestor correctFrom: start to: end with: ''.			madeChanges := true.			currentBlock tempsMark: nil ] ].	madeChanges ifTrue: [ReparseAfterSourceEditing signal]! !!Parser methodsFor: 'error correction' stamp: 'lw 5/27/2011 19:36'!removeUnusedTemporaryNamed: temp from: str lookingAt: currentBlock movingTempMarksOf: someBlocks	| start end |	end := currentBlock tempsMark - 1.	["Beginning at right temp marker..."	start := end - temp size + 1.	end < temp size or: [ (str at: start) = $| ]		or: [ temp = (str copyFrom: start to: end) 			and: [ ((str at: start - 1) = $| | (str at: start - 1) isSeparator) 				& ((str at: end + 1) = $| | (str at: end + 1) isSeparator) ] ]]		whileFalse: [ 			"Search left for the unused temp"			end := requestor nextTokenFrom: end direction: -1 ].	(end < temp size or: [ (str at: start) = $| ])		ifFalse: 			[(str at: start - 1) = $ 				ifTrue: [ start := start - 1 ].			requestor correctFrom: start to: end with: ''.			someBlocks do: [ :aBlock | aBlock tempsMark: aBlock tempsMark - (end - start + 1)].			^true ].	^false! !!Parser methodsFor: 'error correction' stamp: 'lw 5/31/2011 17:34'!removeUnusedTemps: methodNode	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| madeChanges tempsMarkHolder unusedTempNames tempMarkHoldersToChange |	madeChanges := false.	tempMarkHoldersToChange := OrderedCollection new.	tempsMarkHolder := self collectTemporaryDeclarationsFrom: methodNode.	unusedTempNames := encoder unusedTempNames select: 		[ :temp | (encoder lookupVariable: temp ifAbsent: [ ]) isUndefTemp 				and: [ self queriedUnusedTemporaries at: temp ifAbsentPut: [UnusedVariable name: temp] ]].	tempsMarkHolder do: [ :currentBlock | 		tempMarkHoldersToChange add: currentBlock.		unusedTempNames do: 			[ :temp |			(self 				removeUnusedTemporaryNamed: temp 				from: requestor text asString 				lookingAt: currentBlock				movingTempMarksOf: tempMarkHoldersToChange) ifTrue: [ madeChanges := true ]]].	madeChanges		ifTrue: [ self removeEmptyTempDeclarationsFrom: methodNode.			ReparseAfterSourceEditing signal ]! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 10:32'!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presumed interactive) receiver.	 Update requestorOffset based on the delta size and answer the updated offset."	requestor correctFrom: spot first + o to: spot last + o with: correctWord.	requestorOffset := requestorOffset + correctWord size - spot size.	^o + correctWord size - spot size! !!Parser methodsFor: 'expression types' stamp: 'eem 2/3/2011 09:50'!cascade	" {; message} => CascadeNode."	| rcvr msgs |	parseNode canCascade ifFalse:		[^self expected: 'Cascading not'].	parseNode ensureCanCascade: encoder.	rcvr := parseNode cascadeReceiver.	msgs := OrderedCollection with: parseNode.	[self match: #semicolon]		whileTrue: 			[parseNode := rcvr.			(self messagePart: 3 repeat: false)				ifFalse: [^self expected: 'Cascade'].			parseNode canCascade ifFalse:				[^self expected: '<- No special messages'].			parseNode ensureCanCascade: encoder.				parseNode cascadeReceiver.			msgs addLast: parseNode].	parseNode := CascadeNode new receiver: rcvr messages: msgs! !!Parser methodsFor: 'expression types' stamp: 'nice 10/24/2011 18:41'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart |	[receiver := parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start := self startOfNextToken.			selector := WriteStream on: (String new: 32).			args := OrderedCollection new.			words := OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart := self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])				ifFalse: [ selector := self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence := 3]		ifFalse: [			(level >= 2 and: [hereType == #verticalBar]) ifTrue: [self transformAVerticalBarIntoABinarySelector].			(hereType == #binary and: [level >= 2])				ifTrue: 					[start := self startOfNextToken.					selector := self advance asOctetString asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args := Array with: parseNode.					precedence := 2]				ifFalse: [hereType == #word						ifTrue: 							[start := self startOfNextToken.							selector := self advance.							args := #().							words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])								ifFalse: [ selector := self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence := 1]						ifFalse: [^args notNil]]].	parseNode := MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!Parser methodsFor: 'expression types' stamp: 'lw 5/26/2011 21:24'!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	self properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	methodNode := self newMethodNode comment: messageComment.	methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties.	self interactive ifTrue:		[self declareUndeclaredTemps: methodNode.		 self removeUnusedTemps: methodNode].	^methodNode! !!Parser methodsFor: 'expression types' stamp: 'IgorStasenko 3/25/2011 14:16'!pattern: fromDoit inContext: ctxt	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>	{selector, arguments, precedence}."	| args selector |	doitFlag := fromDoit.	fromDoit ifTrue:		[^ctxt == nil			ifTrue: [{#DoIt. {}. 1}]			ifFalse: [{#DoItIn:. {encoder encodeVariable: encoder doItInContextName}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar]) ifTrue: 		[selector := self advance asSymbol.		args := Array with: (encoder bindArg: self argumentName).		^ {selector. args. 2}].	hereType == #keyword ifTrue: 		[selector := WriteStream on: (String new: 32).		args := OrderedCollection new.		[hereType == #keyword] whileTrue:[			selector nextPutAll: self advance.			args addLast: (encoder bindArg: self argumentName).		].		^ {selector contents asSymbol. args. 3}].	^self expected: 'Message pattern'! !!Parser methodsFor: 'expression types' stamp: 'ul 3/27/2011 15:33'!primaryExpression 	hereType == #word 		ifTrue: 			[parseNode := self variable.			(parseNode isUndefTemp and: [self interactive])				ifTrue: [self queryUndefined].			parseNode nowHasRef.			^ true].	hereType == #leftBracket		ifTrue: 			[self advance.			self blockExpression.			^true].	hereType == #leftBrace		ifTrue: 			[self braceExpression.			^true].	hereType == #leftParenthesis		ifTrue: 			[self advance.			self expression ifFalse: [^self expected: 'expression'].			(self match: #rightParenthesis)				ifFalse: [^self expected: 'right parenthesis'].			^true].	(hereType == #string or: [hereType == #number or: [hereType == #literal or: [hereType == #character]]])		ifTrue: 			[parseNode := encoder encodeLiteral: self advance.			^true].	(here == #- and: [tokenType == #number and: [1 + hereEnd = mark]])		ifTrue: 			[self advance.			parseNode := encoder encodeLiteral: self advance negated.			^true].	^false! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35'!temporariesIn: methodSelector	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance in: methodSelector)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 15:57'!temporaryBlockVariablesFor: aBlockNode	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse:		"There are't any temporary variables."		[aBlockNode tempsMark: prevMark + requestorOffset.		 ^#()].	variables := OrderedCollection new.	[hereType == #word] whileTrue:		[variables addLast: (encoder bindBlockTemp: self advance within: aBlockNode)].	(self match: #verticalBar) ifFalse:		[^self expected: 'Vertical bar'].	aBlockNode tempsMark: prevMark + requestorOffset.	^variables! !!Parser methodsFor: 'pragmas' stamp: 'ul 3/27/2011 15:34'!pragmaLiteral: selectorSoFar	"Read a pragma literal.  As a nicety we allow a variable name (rather	 than a literal string) as the second argument to primitive:error:"	(hereType == #string or: [ hereType == #literal or: [ hereType == #number or: [ hereType == #character ] ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	"This nicety allows one to supply a primitive error	 temp as a variable name, rather than a string."	((selectorSoFar beginsWith: 'primitive:')	 and: [(selectorSoFar endsWith: 'error:')	 and: [hereType == #word]]) ifTrue:		[^self advance].	^self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'ul 6/17/2011 12:38'!pragmaSequence	"Parse a sequence of method pragmas."		[		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ] repeat! !!Parser methodsFor: 'primitives' stamp: 'eem 10/28/2009 17:09'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType modifier retType externalName args argType module fn |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType := descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	[modifier := descriptorClass callingConventionModifierFor: token.	 modifier notNil] whileTrue:		[self advance.		 callType := callType bitOr: modifier].	"Parse return type"	self advance.	retType := self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName := here.	(self match: #string) 		ifTrue:[externalName := externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken: #'(') ifFalse:[^self expected:'argument list'].	args := WriteStream on: Array new.	[here == #')'] whileFalse:[		argType := self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken: #')') ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module := here.		(self match: #string) ifFalse:[^self expected: 'String'].		module := module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn := xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	(self matchToken: 'error:')		ifTrue:			[| errorCodeVariable |			 errorCodeVariable := here.			(hereType == #string			 or: [hereType == #word]) ifFalse:[^self expected: 'error code (a variable or string)'].			 self advance.			 self addPragma: (Pragma keyword: #primitive:error: arguments: (Array with: 120 with: errorCodeVariable)).			 fn ifNotNil: [fn setErrorCodeName: errorCodeVariable]]		ifFalse:			[self addPragma: (Pragma keyword: #primitive: arguments: #(120))].	^true! !!Parser methodsFor: 'public access' stamp: 'nice 8/27/2010 20:54'!encoder	^encoder ifNil:		[encoder := EncoderForV3PlusClosures new]! !!Parser methodsFor: 'public access' stamp: 'jmv 3/2/2010 17:11'!encoderClass: anEncoderClass	encoder ifNotNil: [		self error: 'encoder already set'].	encoder := anEncoderClass new! !!Parser methodsFor: 'public access' stamp: 'eem 8/16/2010 18:08'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of	 a parse tree. Parsing is done with respect to the argument, class, to find	 instance, class, and pool variables; and with respect to the argument,	 ctxt, to find temporary variables. Errors in parsing are reported to the	 argument, req, if not nil; otherwise aBlock is evaluated. The argument	 noPattern is a Boolean that is true if the the sourceStream does not	 contain a method header (i.e., for DoIts)."	| methNode repeatNeeded myStream s p subSelection |	category := aCategory.	myStream := sourceStream.	[repeatNeeded := false.	 p := myStream position.	 s := myStream upToEnd.	 myStream position: p.	 subSelection := req notNil and: [req selectionInterval = (p + 1 to: p + s size)].	 self encoder init: class context: ctxt notifying: self.	 self init: myStream notifying: req failBlock: [^ aBlock value].	 doitFlag := noPattern.	 failBlock:= aBlock.	 [methNode := self					method: noPattern					context: ctxt] 		on: ReparseAfterSourceEditing 		do:	[ :ex |			repeatNeeded := true.			myStream := subSelection							ifTrue:								[ReadStream									on: requestor text string									from: requestor selectionInterval first									to: requestor selectionInterval last]							ifFalse:								[ReadStream on: requestor text string]].	 repeatNeeded] whileTrue:		[encoder := self encoder class new].	methNode sourceText: s.	^methNode! !!Parser methodsFor: 'scanning' stamp: 'nice 10/24/2011 18:41'!transformAVerticalBarIntoABinarySelector	"Transform a vertical bar into a binary selector.	Eventually aggregate a serie of immediately following vertical bars and a binary selector.	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:	- either as an empty temporaries specification,	- or as a local temporaries specification in a block of arity > 0"	here := '|'.	hereType := #binary.	[tokenType == #verticalBar and: [hereMark + here size = mark]]		whileTrue: [			here := here , $|.			hereEnd := hereEnd + 1.			self scanToken].	(tokenType == #binary and: [hereMark + here size = mark])		ifTrue: [			here := here asString , token.			hereType := #binary.			hereEnd := hereEnd + token size.			self scanToken].! !!Parser methodsFor: 'accessing' stamp: 'lw 5/31/2011 17:35'!queriedUnusedTemporaries	queriedUnusedTemporaries ifNil: 		[queriedUnusedTemporaries := Dictionary new].	^queriedUnusedTemporaries! !!Parser methodsFor: 'accessing' stamp: 'lw 5/27/2011 18:47'!tempsMark	^ tempsMark! !!Parser methodsFor: 'accessing' stamp: 'lw 5/27/2011 18:47'!tempsMark: aNumbertempsMark := aNumber! !!Parser commentStamp: '<historical>' prior: 0!I parse Smalltalk syntax and create a MethodNode that is the root of the parse tree. I look one token ahead.!!Password methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:52'!serverPasswords	"Get the server passwords off the disk and decode them. The file 'sqk.info' must be in some folder that Squeak thinks is special (vm folder, or default directory).  (Note: This code works even if you are running with no system sources file.)"	| sfile |	(sfile := FileDirectory lookInUsualPlaces: 'sqk.info') ifNil: [^ nil].		"If not there, Caller will ask user for password"		"If you don't have this file, and you really do want to release an update, 		 contact Ted Kaehler."	^ (self decode: (sfile contentsOfEntireFile)) lines! !!PasteUpMorph methodsFor: 'change reporting' stamp: 'ar 6/17/2010 17:28'!invalidRect: damageRect from: aMorph	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isWorldMorph		ifTrue: [worldState recordDamagedRect: damageRect].	^super invalidRect: damageRect from: aMorph! !!PasteUpMorph methodsFor: 'event handling' stamp: 'mtf 2/20/2011 20:40'!mouseDown: evt	"Handle a mouse down event."	| grabbedMorph handHadHalos |	(Preferences generalizedYellowButtonMenu			and: [evt yellowButtonPressed])		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	grabbedMorph := self morphToGrab: evt.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		self isPartsBin ifFalse:[^evt hand grabMorph: grabbedMorph].		grabbedMorph := grabbedMorph partRepresented duplicate.		grabbedMorph restoreSuspendedEventHandler.		(grabbedMorph fullBounds containsPoint: evt position) 			ifFalse:[grabbedMorph position: evt position].		"Note: grabbedMorph is ownerless after duplicate so use #grabMorph:from: instead"		^ evt hand grabMorph: grabbedMorph from: self].	(super handlesMouseDown: evt)		ifTrue:[^super mouseDown: evt].	handHadHalos := evt hand halo notNil.	evt hand removeHalo. "shake off halos"	evt hand releaseKeyboardFocus. "shake of keyboard foci"	self submorphs		select:[:each | each hasProperty: #morphHierarchy]		thenDo:[:each | each delete].	Preferences noviceMode		ifTrue:[			self submorphs				select:[:each | (each isKindOf: MenuMorph) and:[each stayUp not]]				thenDo:[:each | each delete].		].	(evt shiftPressed not			and:[ self isWorldMorph not 			and:[ self wantsEasySelection not ]])	ifTrue:[		"explicitly ignore the event if we're not the world and we'll not select,		so that we could be picked up if need be"		evt wasHandled: false.		^ self.	].	( evt shiftPressed or: [ self wantsEasySelection ] ) ifTrue:[		"We'll select on drag, let's decide what to do on click"		| clickSelector |		clickSelector := nil.		evt shiftPressed ifTrue:[			clickSelector := #findWindow:.		]		ifFalse:[			self isWorldMorph ifTrue:[				clickSelector := handHadHalos										ifTrue: [ #delayedInvokeWorldMenu: ]										ifFalse: [ #invokeWorldMenu: ]			]		].		evt hand 				waitForClicksOrDrag: self 				event: evt 				selectors: { clickSelector. nil. nil. #dragThroughOnDesktop: }				threshold: HandMorph dragThreshold.	]	ifFalse:[		"We wont select, just bring world menu if I'm the world"		self isWorldMorph ifTrue:[			handHadHalos				ifTrue: [ self delayedInvokeWorldMenu: evt ]				ifFalse: [ self invokeWorldMenu: evt ]		]	].! !!PasteUpMorph methodsFor: 'initialization' stamp: 'ul 8/2/2011 20:07'!becomeActiveDuring: aBlock	"Make the receiver the ActiveWorld during the evaluation of aBlock.	Note that this method does deliberately *not* use #ensure: to prevent	re-installation of the world on project switches."	| priorWorld priorHand priorEvent |	priorWorld := ActiveWorld.	priorHand := ActiveHand.	priorEvent := ActiveEvent.	ActiveWorld := self.	ActiveHand := self hands first. "default"	ActiveEvent := nil. "not in event cycle"	aBlock		on: Error		do: [:ex | 			ActiveWorld := priorWorld.			ActiveEvent := priorEvent.			ActiveHand := priorHand.			ex pass]! !!PasteUpMorph methodsFor: 'layout' stamp: 'cmm 11/18/2010 17:29'!convertAlignment	self 		clipSubmorphs: true ;		layoutPolicy: nil ;		layoutInset: 0 ;		cellInset: 0 ;		vResizing: #rigid! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'ul 11/15/2010 11:56'!addWorldHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu, given that the receiver is a World"	| unlockables |	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	self addWorldToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addPlayerItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addStackItemsTo: aMenu.	self addMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size = 1 ifTrue:		[aMenu add: ('unlock "{1}"' translated format:{unlockables first externalName})action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!PasteUpMorph methodsFor: 'painting' stamp: 'nk 7/4/2003 15:59'!drawSubmorphsOn: aCanvas 	"Display submorphs back to front, but skip my background sketch."	| drawBlock |	submorphs isEmpty ifTrue: [^self].	drawBlock := [:canvas | submorphs reverseDo: [:m | m ~~ backgroundMorph ifTrue: [ canvas fullDrawMorph: m ]]].	self clipSubmorphs 		ifTrue: [aCanvas clipBy: self clippingBounds during: drawBlock]		ifFalse: [drawBlock value: aCanvas]! !!PasteUpMorph methodsFor: 'project state' stamp: 'ar 6/17/2010 20:00'!canvas: aCanvas	"Set this world's canvas"	worldState canvas: aCanvas.! !!PasteUpMorph methodsFor: 'project state' stamp: 'nk 7/4/2003 16:47'!handsDo: aBlock	^ worldState ifNotNil: [ worldState handsDo: aBlock ]! !!PasteUpMorph methodsFor: 'project state' stamp: 'nk 7/4/2003 16:46'!handsReverseDo: aBlock	^ worldState ifNotNil: [ worldState handsReverseDo: aBlock ]! !!PasteUpMorph methodsFor: 'structure' stamp: 'jmv 3/2/2010 16:10'!world	worldState ifNil: [^super world].	^self! !!PasteUpMorph methodsFor: 'submorphs-accessing' stamp: 'nk 7/4/2003 16:49'!morphsInFrontOf: someMorph overlapping: aRectangle do: aBlock	"Include hands if the receiver is the World"	self handsDo:[:m|		m == someMorph ifTrue:["Try getting out quickly"			owner ifNil:[^self].			^owner morphsInFrontOf: self overlapping: aRectangle do: aBlock].		"The hand only overlaps if it's not the hardware cursor"		m needsToBeDrawn ifTrue:[			(m fullBoundsInWorld intersects: aRectangle)				ifTrue:[aBlock value: m]]].	^super morphsInFrontOf: someMorph overlapping: aRectangle do: aBlock! !!PasteUpMorph methodsFor: 'update cycle' stamp: 'ul 6/17/2011 12:38'!startBackgroundProcess	"Start a process to update this world in the background. Return the process created."	| p |	p := [ [		self doOneCycleInBackground.		(Delay forMilliseconds: 20) wait] repeat ] newProcess.	p resume.	^ p! !!PasteUpMorph methodsFor: 'world menu' stamp: 'fbs 12/3/2010 23:33'!connectRemoteUserWithName: nameStringOrNil picture: aFormOrNil andIPAddress: aStringOrNil	"Prompt for the initials to be used to identify the cursor of a remote user, then create a cursor for that user and wait for a connection."	| initials addr h |	initials := nameStringOrNil.	initials isEmptyOrNil ifTrue: [		initials := UIManager default request: 'Enter initials for remote user''s cursor?'.	].	initials isEmpty ifTrue: [^ self].  "abort"	addr := 0.	aStringOrNil isEmptyOrNil ifFalse: [		addr := NetNameResolver addressForName: aStringOrNil timeout: 30	].	addr = 0 ifTrue: [		addr := NetNameResolver promptUserForHostAddress.	].	addr = 0 ifTrue: [^ self].  "abort"	(RemoteHandMorph ensureNetworkConnected) ifFalse: [^ self]. "abort"	h := RemoteHandMorph new userInitials: initials andPicture: aFormOrNil.	self addHand: h.	h changed.	h startListening.	h startTransmittingEventsTo: addr.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 3/13/2003 11:51'!putUpNewMorphMenu	"Put up the New Morph menu in the world"	TheWorldMenu new adaptToWorld: self; newMorph! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 3/13/2003 12:25'!undoOrRedoCommand	"Undo or redo the last command recorded in the world"	^ self commandHistory undoOrRedoCommand! !!PasteUpMorph methodsFor: 'world state' stamp: 'cmm 12/4/2010 20:55'!deleteAllHalos	self haloMorphs do:		[ : m | m target isSelectionMorph ifTrue: [ m target delete ] ].	self hands do:		[ : each | each removeHalo ]! !!PasteUpMorph methodsFor: '*Tools' stamp: 'cmm 6/13/2010 20:41'!defaultDesktopCommandKeyTriplets	"Answer a list of triplets of the form		<key> <receiver> <selector>   [+ optional fourth element, a <description> for use in desktop-command-key-help]that will provide the default desktop command key handlers.  If the selector takes an argument, that argument will be the command-key event"	| noviceKeys expertKeys |	noviceKeys := {		{ $o.	ActiveWorld.						#activateObjectsTool.						'Activate the "Objects Tool"'}.		{ $r.	ActiveWorld.						#restoreMorphicDisplay.					'Redraw the screen'}.				{ $z.	self.								#undoOrRedoCommand.					'Undo or redo the last undoable command'}.		{ $F.	Project current.					#toggleFlapsSuppressed.					'Toggle the display of flaps'}.		{ $N.	self.								#toggleClassicNavigatorIfAppropriate.	'Show/Hide the classic Navigator, if appropriate'}.		{ $M.	self.								#toggleShowWorldMainDockingBar.		'Show/Hide the Main Docking Bar'}.	}.	Preferences noviceMode			ifTrue:[^ noviceKeys].	expertKeys := {		{ $b.	SystemBrowser.					#defaultOpenBrowser.						'Open a new System Browser'}.		{ $k.	StringHolder.					#open.										'Open a new, blank Workspace'}.		{ $m.	self.								#putUpNewMorphMenu.					'Put up the "New Morph" menu'}.		{ $t.	self.	 							#findATranscript:.							'Make a System Transcript visible'}.		{ $w.	SystemWindow.					#closeTopWindow.							'Close the topmost window'}.		{ $C.	self.								#findAChangeSorter:.						'Make a Change Sorter visible'}.		{ $L.	self.								#findAFileList:.								'Make a File List visible'}.		{ $P.	self.								#findAPreferencesPanel:.					'Activate the Preferences tool'}.		{ $R.	Utilities. 								#browseRecentSubmissions.		'Make a Recent Submissions browser visible'}.		{ $W.	self. 								#findAMessageNamesWindow:.			'Make a MessageNames tool visible'}.		{ $Z.	ChangeList. 						#browseRecentLog.							'Browse recently-logged changes'}.		{ $\.	SystemWindow. 					#sendTopWindowToBack.					'Send the top window to the back'}.	}.	^ noviceKeys, expertKeys! !!PasteUpMorph commentStamp: '<historical>' prior: 0!A morph whose submorphs comprise a paste-up of rectangular subparts which "show through".  Anything called a 'Playfield' is a PasteUpMorph.Facilities commonly needed on pages of graphical presentations and on simulation playfields, such as the painting of new objects, turtle trails, gradient fills, background paintings, parts-bin behavior, collision-detection, etc., are (or will be) provided.A World, the entire Smalltalk screen, is a PasteUpMorph.  A World responds true to isWorld.  Morph subclasses that have specialized menus (BookMorph) build them in the message addBookMenuItemsTo:hand:.  A PasteUpMorph that is a world, builds its menu in HandMorph buildWorldMenu.presenter	A Presenter in charge of stopButton stepButton and goButton, 			mouseOverHalosEnabled soundsEnabled fenceEnabled coloredTilesEnabled.model		<not used>cursor		??padding		??backgroundMorph		A Form that covers the background.turtleTrailsForm			Moving submorphs may leave trails on this form.turtlePen				Draws the trails.lastTurtlePositions		A Dictionary of (aPlayer -> aPoint) so turtle trails can be drawn 						only once each step cycle.  The point is the start of the current stroke.isPartsBin		If true, every object dragged out is copied.autoLineLayout		??indicateCursor		??resizeToFit		??wantsMouseOverHalos		If true, simply moving the cursor over a submorph brings up its halo.worldState		If I am also a World, keeps the hands, damageRecorder, stepList etc.griddingOn		If true, submorphs are on a grid!!Pen methodsFor: 'geometric designs' stamp: 'ul 6/17/2011 12:39'!web   "Display restoreAfter: [Pen new web]"	"Draw pretty web-like patterns from the mouse movement on the screen.	Press the mouse button to draw, option-click to exit.	By Dan Ingalls and Mark Lentczner. "	| history newPoint ancientPoint lastPoint filter color |	"self erase."	color := 1.	[ history := OrderedCollection new.	Sensor waitButton.	Sensor yellowButtonPressed ifTrue: [^ self].	filter := lastPoint := Sensor mousePoint.	20 timesRepeat: [ history addLast: lastPoint ].	self color: (color := color + 1).	[ Sensor redButtonPressed ] whileTrue: 		[ newPoint := Sensor mousePoint.		(newPoint = lastPoint) ifFalse:			[ ancientPoint := history removeFirst.			filter := filter * 4 + newPoint // 5.			self place: filter.			self goto: ancientPoint.			lastPoint := newPoint.			history addLast: filter ] ] ] repeat! !!Pen methodsFor: 'operations' stamp: 'nice 4/28/2011 23:19'!print: str withFont: font	"Print the given string in the given font at the current heading"	| lineStart scale wasDown |	scale := sourceForm width.	wasDown := penDown.	lineStart := location.	str do:		[:char |		char = Character cr ifTrue:			[self place: lineStart; up; turn: 90; go: font height*scale; turn: -90; down]		ifFalse:			[ | charStart pix rowStart form bb backgroundCode |			form := font characterFormAt: char.			backgroundCode := 1<< (form depth // 3 * 3) - 1.			charStart := location.wasDown ifTrue: [			self up; turn: -90; go: font descent*scale; turn: 90; down.			0 to: form height-1 do:				[:y |				rowStart := location.				bb := BitBlt current bitPeekerFromForm: form.				pix := RunArray newFrom:					((0 to: form width-1) collect: [:x | bb pixelAt: x@y]).				pix runs with: pix values do:					[:run :value |					value = backgroundCode						ifTrue: [self up; go: run*scale; down]						ifFalse: [self go: run*scale]].				self place: rowStart; up; turn: 90; go: scale; turn: -90; down].].			self place: charStart; up; go: form width*scale; down].			].	wasDown ifFalse: [self up]"Display restoreAfter:[Pen new squareNib: 2; color: Color red; turn: 45;	print: 'The owl and the pussycat went to seain a beautiful pea green boat.' withFont: TextStyle defaultFont]"! !!Pen methodsFor: 'operations' stamp: 'sw 4/10/2003 22:37'!putDotOfDiameter: aDiameter at: aPoint	"Put a dot of the given size at the given point, using my colot"	(FormCanvas on: destForm) 			fillOval: (Rectangle center: aPoint extent: (aDiameter @ aDiameter))			color: self color! !!Pen methodsFor: '*Etoys' stamp: 'sw 10/5/2002 03:17'!arrowHead	"Put an arrowhead on the previous pen stroke"	" | pen | pen := Pen new. 20 timesRepeat: [pen turn: 360//20; go: 20; arrowHead]."	penDown ifTrue:		[self arrowHeadFrom: (direction degreeCos @ direction degreeSin) * -40 + location 			to: location			arrowSpec: (Preferences parameterAt: #arrowSpec ifAbsent: [5 @ 4])]! !!Pen methodsFor: '*Etoys' stamp: 'sw 10/5/2002 02:29'!arrowHeadForArrowSpec: anArrowSpec	"Put an arrowhead on the previous pen stroke""	 | pen aPoint |	aPoint := Point fromUser.	pen := Pen new.	20 timesRepeat: [pen turn: 360//20; go: 20; arrowHeadForArrowSpec: aPoint]."	penDown ifTrue:		[self arrowHeadFrom: (direction degreeCos @ direction degreeSin) * -40 + location 			to: location			arrowSpec: anArrowSpec]! !!Pen methodsFor: '*Etoys' stamp: 'sw 10/5/2002 02:25'!arrowHeadFrom: prevPt to: newPt arrowSpec: anArrowSpec	"Put an arrowhead on the pen stroke from oldPt to newPt"	| pm af myColor finalPt delta |	myColor := self color.	delta := newPt - prevPt.	delta r <= 2 "pixels" ifTrue: [^ self].	finalPt := newPt + (Point r: sourceForm width degrees: delta degrees).	"in same direction"	pm := PolygonMorph vertices: (Array with: prevPt asIntegerPoint with: finalPt asIntegerPoint)  		color: myColor  "not used"		borderWidth: sourceForm width borderColor: myColor.	pm makeOpen; makeForwardArrow.	anArrowSpec ifNotNil: [pm arrowSpec: anArrowSpec].	af := pm arrowForms first.	"render it onto the destForm"	(FormCanvas on: destForm "Display") stencil: af at: af offset + (1@1)		color: myColor! !!Pen methodsFor: '*Etoys' stamp: 'sw 10/5/2002 02:11'!arrowHeadFrom: prevPt to: newPt forPlayer: aPlayer	"Put an arrowhead on the pen stroke from oldPt to newPt"		| aSpec |	(aPlayer notNil and: [(aSpec := aPlayer costume renderedMorph valueOfProperty: #arrowSpec) notNil]) 		ifFalse:			[aSpec := Preferences parameterAt: #arrowSpec "may well be nil"].	self arrowHeadFrom: prevPt to: newPt arrowSpec: aSpec! !!PianoKeyboardMorph methodsFor: 'simple keyboard' stamp: 'nice 12/29/2010 14:56'!buildKeyboard	| wtWid bkWid keyRect octavePt nWhite nBlack |	self removeAllMorphs.	wtWid := 8. bkWid := 5.	self extent: 10 @ 10.	1 to: nOctaves + 1 do:		[:i | i <= nOctaves ifTrue: [nWhite := 7.  nBlack := 5]						ifFalse: [nWhite := 1.  nBlack := 0 "High C"].		octavePt := self innerBounds topLeft + ((7 * wtWid * (i - 1) - 1) @ -1).		1 to: nWhite do:			[:j | keyRect := octavePt + (j - 1 * wtWid @ 0) extent: (wtWid + 1) @ 36.			self addMorph: ((RectangleMorph newBounds: keyRect color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownPitch:event:noteMorph: to: self								withValue: i - 1 * 12 + (#(1 3 5 6 8 10 12) at: j))].		1 to: nBlack do:			[:j | keyRect := octavePt + ((#(6 15 29 38 47) at: j) @ 1) extent: bkWid @ 21.			self addMorph: ((Morph newBounds: keyRect color: blackKeyColor)				on: #mouseDown send: #mouseDownPitch:event:noteMorph: to: self								withValue: i - 1 * 12 + (#(2 4 7 9 11) at: j))]].	self submorphsDo:		[:m | m on: #mouseMove send: #mouseMovePitch:event:noteMorph: to: self;				on: #mouseUp send: #mouseUpPitch:event:noteMorph: to: self;				on: #mouseEnterDragging send: #mouseDownPitch:event:noteMorph: to: self;				on: #mouseLeaveDragging send: #mouseUpPitch:event:noteMorph: to: self].	self extent: (self fullBounds extent + borderWidth - 1)! !!Player methodsFor: 'misc' stamp: 'HenrikSperreJohansen 1/21/2011 18:34'!makeBounceSound: soundName	"Having bounced off an edge, produce the given sound"	SoundService soundEnabled		ifTrue: [self costume playSoundNamed: soundName]! !!Player methodsFor: 'misc' stamp: 'ul 11/15/2010 11:57'!offerAlternateViewerMenuFor: aViewer event: evt	"Put up an alternate Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld := aViewer world.	aMenu := MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size = 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' translated target: self selector: #forgetOtherCostumes]].	aMenu add: 'expunge empty scripts' translated target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'choose vocabulary...' translated target: aViewer action: #chooseVocabulary.	aMenu balloonTextForLastItem: 'Choose a different vocabulary for this Viewer.' translated.	aMenu add: 'choose limit class...' translated target: aViewer action: #chooseLimitClass.	aMenu balloonTextForLastItem: 'Specify what the limitClass should be for this Viewer -- i.e., the most generic class whose methods and categories should be considered here.' translated.	aMenu add: 'open standard lexicon' translated target: aViewer action: #openLexicon.	aMenu balloonTextForLastItem: 'open a window that shows the code for this object in traditional programmer format' translated.	aMenu add: 'open lexicon with search pane' translated target: aViewer action: #openSearchingProtocolBrowser.	aMenu balloonTextForLastItem: 'open a lexicon that has a type-in pane for search (not recommended!!)' translated.	aMenu addLine.	aMenu add: 'inspect morph' translated target: costume selector: #inspect.	aMenu add: 'inspect player' translated target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' translated target: self action: #browsePlayerClass.		aMenu add: 'inspect class' translated target: self class action: #inspect].	aMenu add: 'inspect this Viewer' translated target: aViewer selector: #inspect.	aMenu add: 'inspect this Vocabulary' translated target: aViewer currentVocabulary selector: #inspect.	aMenu addLine.	aMenu add: 'relaunch this Viewer' translated target: aViewer action: #relaunchViewer.	aMenu add: 'attempt repairs' translated target: ActiveWorld action: #attemptCleanup.	aMenu add: 'view morph directly' translated target: aViewer action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'opens a Viewer directly on the rendered morph.' translated.	(costume renderedMorph isSketchMorph) ifTrue:		[aMenu addLine.		aMenu add: 'impart scripts to...' translated target: self action: #impartSketchScripts].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: 'misc' stamp: 'ul 9/28/2011 14:08'!revertToUnscriptedPlayerIfAppropriate	| anInstance |	(self class selectors notEmpty or: [self class instVarNames notEmpty]) 		ifTrue: [^self].	anInstance := UnscriptedPlayer new.	anInstance initializeCostumesFrom: self.	self becomeForward: anInstance! !!Player methodsFor: 'pen' stamp: 'sw 4/17/2003 12:26'!getDotSize	"Answer the receiver's dotSize"	^ self costume renderedMorph valueOfProperty: #trailDotSize ifAbsentPut: [6]! !!Player methodsFor: 'pen' stamp: 'sw 3/11/2003 11:28'!getTrailStyle	"Answer the receiver's trailStyle"	^ self actorState trailStyle! !!Player methodsFor: 'pen' stamp: 'sw 4/17/2003 11:56'!setDotSize: aNumber	"Set the trail dot size as indicated, but confine matters to a reasonable range"	self costume renderedMorph setProperty: #trailDotSize toValue: ((aNumber max: 1) min: 100)! !!Player methodsFor: 'pen' stamp: 'sw 3/11/2003 11:23'!setTrailStyle: aTrailStyle	"Set the trail style"	self actorState trailStyle: aTrailStyle! !!Player methodsFor: 'pen' stamp: 'sw 3/11/2003 11:22'!trailStyleForAllPens: aTrailStyle	"Only for the Player of a World"	self costume renderedMorph trailStyleForAllPens: aTrailStyle! !!Player methodsFor: 'scripts-kernel' stamp: 'ul 11/15/2010 11:57'!newTextualScriptorFor: aSelector	"Sprout a scriptor for aSelector, opening up in textual mode.  Rather special-purpose, consult my lone sender"	| aMethodWithInterface aScriptEditor |	(self class includesSelector: aSelector) ifTrue: [self error: 'selector already exists'].	aMethodWithInterface := self class permanentUserScriptFor: aSelector player: self.	aScriptEditor := aMethodWithInterface instantiatedScriptEditorForPlayer: self.	aScriptEditor install.	aScriptEditor showSourceInScriptor.	aMethodWithInterface selector numArgs = 0 ifTrue:		[self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aMethodWithInterface selector]].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'ul 11/15/2010 11:57'!renameScript: oldSelector newSelector: newSelector	"Rename the given script to have the new selector"	| aUserScript anInstantiation |	oldSelector = newSelector ifTrue: [^ self].	oldSelector numArgs = 0		ifTrue:			[self class allSubInstancesDo:				[:aPlayer | | itsCostume aDict |					anInstantiation := aPlayer scriptInstantiationForSelector: oldSelector.					anInstantiation ifNotNil: [						newSelector numArgs = 0							ifTrue:								[anInstantiation changeSelectorTo: newSelector].						aDict := aPlayer costume actorState instantiatedUserScriptsDictionary.						itsCostume := aPlayer costume renderedMorph.						itsCostume renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.						self currentWorld renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.						aDict removeKey: oldSelector.						newSelector numArgs  = 0 ifTrue:							[aDict at: newSelector put: anInstantiation.							anInstantiation assureEventHandlerRepresentsStatus]]]]		ifFalse:			[newSelector numArgs = 0 ifTrue:				[self class allSubInstancesDo:					[:aPlayer |						anInstantiation := aPlayer scriptInstantiationForSelector: newSelector.						anInstantiation ifNotNil: [anInstantiation assureEventHandlerRepresentsStatus]]]].	aUserScript := self class userScriptForPlayer: self selector: oldSelector.	aUserScript renameScript: newSelector fromPlayer: self.		"updates all script editors, and inserts the new script in my scripts directory"	self class removeScriptNamed: oldSelector.	((self existingScriptInstantiationForSelector: newSelector) notNil and:		[newSelector numArgs > 0]) ifTrue: [self error: 'ouch'].			self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'scripts-kernel' stamp: 'ul 11/15/2010 11:58'!tilesToCall: aMethodInterface	"Answer a phrase for the non-typed command represented by aMethodInterface."	| resultType cmd argType argTile selfTile aPhrase balloonTextSelector aDocString universal |	self class namedTileScriptSelectors.	resultType := aMethodInterface resultType.	cmd := aMethodInterface selector.	(universal := self isUniversalTiles)		ifTrue:			[aPhrase := self universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs = 0			ifTrue:				[aPhrase := PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType := aMethodInterface typeForArgumentNumber: 1.				aPhrase := PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #Player					argType: argType.				argTile := ScriptingSystem tileForArgType: argType.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(self slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector := #userSlot].	(self belongsToUniClass and: [self class includesSelector: cmd])		ifTrue:			[aDocString := (self class userScriptForPlayer: self selector: cmd) documentation.			aDocString				ifNotNil: [aPhrase submorphs second setBalloonText: aDocString]				ifNil: [balloonTextSelector := #userScript]].	(universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]) balloonTextSelector: 			(balloonTextSelector ifNil: [cmd]).	universal ifFalse:		[selfTile := self tileToRefer.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile.		aPhrase makeAllTilesGreen.		aPhrase justGrabbedFromViewer: false].	^ aPhrase! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/18/2003 02:57'!insertCharacters: aString	"Insert the given characters at my current cursor position"	self costume renderedMorph insertCharacters: aString! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/18/2003 02:57'!insertContentsOf: aPlayer	"Insert the string contents of the given player at my given cursor position"	self costume renderedMorph insertContentsOf: aPlayer! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/20/2003 13:14'!tellAllContents: aMessageSelector	"Send the given message selector to all the content players within the receiver's morph"	costume renderedMorph tellAllContents: aMessageSelector! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 2/17/2003 11:46'!getCount	"Answer the number of elements"	^ self costume renderedMorph elementCount! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 2/18/2003 02:20'!getStringContents	"Answer the String contents"	^ self costume renderedMorph getCharacters! !!Player methodsFor: 'slots-user' stamp: 'ul 11/15/2010 11:56'!addInstanceVariable	"Offer the user the opportunity to add an instance variable, and if he goes through with it, actually add it."	| itsName initialValue typeChosen usedNames initialAnswer setterSelector originalString |	usedNames := self class instVarNames.	initialAnswer := Utilities keyLike: ('var' translated, (usedNames size + 1) asString)  satisfying: [:aKey | (usedNames includes: aKey) not].	originalString := UIManager default request: 'name for new variable: ' translated initialAnswer: initialAnswer.	originalString isEmptyOrNil ifTrue: [^ self].	itsName := ScriptingSystem acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: nil asSlotNameIn: self world: self costume world. 	itsName size = 0 ifTrue: [^ self].		self assureUniClass.	typeChosen := self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new initialize type: typeChosen).	initialValue := self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileInstVarAccessorsFor: itsName.	setterSelector := Utilities setterSelectorFor: itsName.	((self class allSubInstances copyWithout: self) reject: [:e | e isSequentialStub]) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: ScriptingSystem nameForInstanceVariablesCategory! !!Player methodsFor: 'slots-user' stamp: 'ul 11/15/2010 11:56'!chooseUserSlot	| names result |	(names := self slotNames) size = 1		ifTrue: [^ names first].	result := UIManager default 		chooseFrom: names 		values: names 		title: 'Please choose a variable'.	result isEmptyOrNil ifTrue: [^ nil].	^ result! !!Player methodsFor: 'slots-user' stamp: 'ul 11/16/2010 03:58'!setPrecisionFor: slotName 	"Set the precision for the given slot name"	| aList reply aGetter places |	aGetter := Utilities getterSelectorFor: slotName.	places := Utilities 				decimalPlacesForFloatPrecision: (self defaultFloatPrecisionFor: aGetter).	aList := #('0' '1' '2' '3' '4' '5' '6').	reply := UIManager default		chooseFrom: aList		values: (aList collect: [:m | m asNumber])		title: ('How many decimal places? (currently {1})' translated						format: {places}).	reply ifNotNil: 			[(self slotInfo includesKey: slotName) 				ifTrue: 					["it's a user slot"					(self slotInfoAt: slotName) 						floatPrecision: (Utilities floatPrecisionForDecimalPlaces: reply).					self class allInstancesDo: 							[:anInst | | val | 							reply = 0 								ifFalse: 									[((val := anInst instVarNamed: slotName asString) isInteger) 										ifTrue: [anInst instVarNamed: slotName asString put: val asFloat]].							anInst updateAllViewers]]				ifFalse: 					["it's specifying a preference for precision on a system-defined numeric slot"					self noteDecimalPlaces: reply forGetter: aGetter.					self updateAllViewers]]! !!Player methodsFor: 'sound' stamp: 'ar 7/21/2010 20:06'!getConePosition	"Note: Performance hacked to allow real-time sound. Assumes costume is a SpeakerMorph."	^ costume renderedMorph conePosition! !!Player methodsFor: 'sound' stamp: 'ar 7/21/2010 20:06'!setConePosition: aNumber	"Note: Performance hacked to allow real-time sound. Assumes costume is a SpeakerMorph."	costume renderedMorph conePosition: aNumber.! !!Player class methodsFor: 'housekeeping' stamp: 'ul 11/15/2010 11:58'!playersWithUnnecessarySubclasses	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithUnnecessarySubclasses size"	^ self withAllSubclasses select:		[:p | p class isSystemDefined not and: [p scripts size = 0 and: [p instVarNames size = 0]]] ! !!Player class methodsFor: 'scripts' stamp: 'ul 11/15/2010 11:58'!namedUnaryTileScriptSelectors	"Answer a list of all the selectors of named unary tile scripts"		scripts ifNil: [^ OrderedCollection new].	^ scripts select: [:aScript | | sel | (sel := aScript selector) notNil and: [sel numArgs = 0]] 		thenCollect: [:aScript | aScript selector]! !!Player class methodsFor: 'scripts' stamp: 'ul 8/2/2011 20:07'!userScriptsDo: aBlock	self scripts do: aBlock! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'ul 11/15/2010 11:58'!addDocumentationForScriptsTo: aStream	"Add documentation for every script in the receiver to the stream"	self scripts do:		[:aScript |			aScript selector ifNotNil:				[aStream cr; cr.				aStream nextPutAll: self typicalInstanceName, '.'.				self printMethodChunk: aScript selector withPreamble: false on: aStream moveSource: false toFile: nil.				aStream position: (aStream position - 2)]].	self scripts size = 0 ifTrue:		[aStream cr; tab; nextPutAll: 'has no scripts']! !!PluckedSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:11'!postCopy	super postCopy.	self copyRing! !!PluckedSound methodsFor: 'sound generation' stamp: 'ul 11/2/2010 03:08'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive:'primitiveMixPluckedSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #ring declareC: 'short int *ring'>	lastIndex := (startIndex + n) - 1.	scaledThisIndex := scaledNextIndex := scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex := scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex := ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average :=			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample := (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex := scaledNextIndex.		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	scaledIndex := scaledNextIndex.	count := count - n.! !!PluggableActionButtonSpec commentStamp: 'dtl 9/19/2011 07:51' prior: 0!PluggableActionButtonSpec is intended as a HINT for the builder that this widget will be used as push (action) button. Unless explicitly supported it will be automatically substituted by PluggableButton.!!PluggableButtonMorph methodsFor: 'accessing' stamp: 'ul 11/15/2010 11:58'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed. If the button's actionSelector takes any arguments, they are obtained dynamically by sending the argumentSelector to the argumentsProvider"	askBeforeChanging ifTrue: [model okToChange ifFalse: [^ self]].	actionSelector ifNotNil:		[actionSelector numArgs = 0			ifTrue:				[model perform: actionSelector]			ifFalse:				[argumentsProvider ifNotNil:					[arguments := argumentsProvider perform: argumentsSelector].					model perform: actionSelector withArguments: arguments]]! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:33'!style	"Treat aSymbol as a hint to modify the button appearance."	^style! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:32'!style: aSymbol	"Use aSymbol as a hint to modify the button appearance."	style := aSymbol! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'dtl 9/27/2011 22:17'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."model := model.		Weakly copied"label := label veryDeepCopyWith: deepCopier."getStateSelector := getStateSelector.		a Symbol""actionSelector := actionSelector.		a Symbol""getLabelSelector := getLabelSelector.		a Symbol""getMenuSelector := getMenuSelector.		a Symbol"shortcutCharacter := shortcutCharacter veryDeepCopyWith: deepCopier.askBeforeChanging := askBeforeChanging veryDeepCopyWith: deepCopier.triggerOnMouseDown := triggerOnMouseDown veryDeepCopyWith: deepCopier.offColor := offColor veryDeepCopyWith: deepCopier.onColor := onColor veryDeepCopyWith: deepCopier.feedbackColor := feedbackColor veryDeepCopyWith: deepCopier.showSelectionFeedback := showSelectionFeedback veryDeepCopyWith: deepCopier.allButtons := nil.		"a cache"arguments := arguments veryDeepCopyWith: deepCopier.argumentsProvider := argumentsProvider veryDeepCopyWith: deepCopier."argumentsSelector := argumentsSelector.   a Symbol" style := style.  "a Symbol"! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'dtl 9/24/2011 09:29'!drawOn: aCanvas 	| cc gradient borderColor |	cc := self color.	cc isTransparent ifTrue:[cc := Color gray: 0.9].	self enabled ifFalse:[cc := Color lightGray].	cc brightness > 0.9 ifTrue:[cc := cc adjustBrightness: 0.9 - cc brightness].	showSelectionFeedback ifTrue:[		borderColor := cc muchDarker.		gradient := GradientFillStyle ramp: {			0.0 -> cc muchDarker.			0.1-> (cc adjustBrightness: -0.2).			0.5 -> cc.			0.9-> (cc adjustBrightness: -0.1).			1 -> cc muchDarker.		}.	] ifFalse:[		borderColor := Color lightGray.		gradient := GradientFillStyle ramp: {			0.0 -> Color white.			0.1-> (cc adjustBrightness: 0.05).			0.6 -> (cc darker).		}	].	gradient origin: bounds topLeft.	gradient direction: 0@self height.	^ self roundedButtonCorners		ifTrue: [aCanvas 				frameAndFillRoundRect: bounds 				radius: 8 				fillStyle: gradient 				borderWidth: 1 				borderColor: borderColor]		ifFalse: [aCanvas 				frameAndFillRectangle: self innerBounds 				fillColor: gradient asColor 				borderWidth: 1 				borderColor: borderColor darker;				fillRectangle: (self innerBounds insetBy: 1) 				fillStyle: gradient]! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'dtl 9/24/2011 11:18'!roundedButtonCorners	"If the button is intended to invoke a menu for selection, provide a visual	distinction by inverting the rounded corners attribute."	^self class roundedButtonCorners		xor: style == #menuButton! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 3/2/2010 16:21'!getModelState	"Answer the result of sending the receiver's model the getStateSelector message."	^ getStateSelector 		ifNil: [false]		ifNotNil: [model perform: getStateSelector]! !!PluggableButtonMorph commentStamp: '<historical>' prior: 0!A PluggableButtonMorph is a combination of an indicator for a boolean value stored in its model and an action button. The action of a button is often, but not always, to toggle the boolean value that it shows. Its pluggable selectors are:		getStateSelector		fetch a boolean value from the model		actionSelector		invoke this button's action on the model		getLabelSelector		fetch this button's lable from the model		getMenuSelector		fetch a pop-up menu for this button from the modelAny of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if getStateSelector is nil, then this button shows the state of a read-only boolean that is always false.The model informs its view(s) of changes by sending #changed: to itself with getStateSelector as a parameter. The view tells the model when the button is pressed by sending actionSelector.If the actionSelector takes one or more arguments, then the following are relevant:		arguments			A list of arguments to provide when the actionSelector is called.		argumentsProvider	The object that is sent the argumentSelector to obtain arguments, if dynamic		argumentsSelector	The message sent to the argumentProvider to obtain the arguments.Options:	askBeforeChanging		have model ask user before allowing a change that could lose edits	triggerOnMouseDown	do this button's action on mouse down (vs. up) transition	shortcutCharacter		a place to record an optional shortcut key!!PluggableButtonMorphPlus methodsFor: 'updating' stamp: 'dtl 9/24/2011 11:21'!update: what	what ifNil:[^self].	what == getLabelSelector ifTrue: [		self label: (model perform: getLabelSelector)].	what == getEnabledSelector ifTrue:[^self enabled: (model perform: getEnabledSelector)].	getColorSelector ifNotNil: [ | cc |		color = (cc := model perform: getColorSelector) ifFalse:[			color := cc.			self onColor: color offColor: color.			self changed.		].	].	self getModelState			ifTrue: [self color: onColor]			ifFalse: [self color: offColor].	getEnabledSelector ifNotNil:[		self enabled: (model perform: getEnabledSelector).	].	updateMap ifNotNil:		[(updateMap at: what ifAbsent: [])			ifNotNilDo: [ :newTarget | ^self update: newTarget]].! !!PluggableButtonMorphPlus methodsFor: 'updating' stamp: 'dtl 9/24/2011 08:54'!updateMap	^ updateMap ifNil: [updateMap := Dictionary new]! !!PluggableButtonMorphPlus methodsFor: 'updating' stamp: 'dtl 9/24/2011 08:54'!whenChanged: notification update: target	"On receipt of a notification, such as #contents notification from a CodeHolder,	invoke an update as if target had been the original notification."	self updateMap at: notification put: target! !!PluggableButtonMorphPlus commentStamp: 'ar 2/11/2005 21:53' prior: 0!An extended version of PluggableButtonMorph supporting enablement, color and block/message actions.!!PluggableButtonSpec methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:06'!changeLabelWhen	"When handled in in an update: handler, treat this symbol as notification	that the button label should be updated."	^changeLabelWhen! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:09'!changeLabelWhen: aSymbol	"When the button handles aSymbol in its update: handler, treat it	as notification that the button label should be updated."	changeLabelWhen := aSymbol! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:33'!style	"Treat aSymbol as a hint to modify the button appearance."	^style! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:25'!style: aSymbol	"Use aSymbol as a hint to modify the button appearance."	style := aSymbol! !!PluggableButtonSpec commentStamp: 'ar 2/11/2005 21:57' prior: 0!A button, both for firing as well as used in radio-button style (e.g., carrying a selection).Instance variables:	action	<Symbol>	The action to perform when the button is fired.	label	<Symbol|String>	The selector for retrieving the button's label or label directly.	state	<Symbol>	The selector for retrieving the button's selection state.	enabled	<Symbo>		The selector for retrieving the button's enabled state.	color	<Symbo>		The selector for retrieving the button color.	help	<String>		The balloon help for the button.!!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!actionSelector	"Answer the value of actionSelector"	^ actionSelector! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!actionSelector: anObject	"Set the value of actionSelector"	actionSelector := anObject! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!label	"Answer the value of label"	^ label! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!label: anObject	"Set the value of label"	label := anObject! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:38'!model	"Answer the value of model"	^ model.! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!model: anObject	"Set the value of model"	model := anObject! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!valueSelector	"Answer the value of valueSelector"	^ valueSelector! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!valueSelector: anObject	"Set the value of valueSelector"	valueSelector := anObject! !!PluggableCheckBoxMorph methodsFor: 'installing' stamp: 'rww 9/11/2010 04:10'!basicPanel	^BorderedMorph new		beTransparent;		extent: 0@0;		borderWidth: 0;		layoutInset: 0;		cellInset: 0;		layoutPolicy: TableLayout new;		listCentering: #topLeft;		cellPositioning: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		yourself! !!PluggableCheckBoxMorph methodsFor: 'installing' stamp: 'rww 9/11/2010 04:10'!horizontalPanel	^self basicPanel		cellPositioning: #center;		listDirection: #leftToRight;		yourself.! !!PluggableCheckBoxMorph methodsFor: 'installing' stamp: 'rww 9/11/2010 03:36'!installButton	| aButton aLabel |	aButton := UpdatingThreePhaseButtonMorph checkBox		target: self model;		actionSelector: self actionSelector;		getSelector: self valueSelector;		yourself.	aLabel := (StringMorph contents: self label translated				font: (StrikeFont familyName: TextStyle defaultFont familyName							size: TextStyle defaultFont pointSize - 1)).	self addMorph: (self horizontalPanel		addMorphBack: aButton;		addMorphBack: aLabel;		yourself).! !!PluggableCheckBoxMorph methodsFor: 'initialization' stamp: 'rww 9/11/2010 03:45'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self model: anObject.	self valueSelector: getStateSel.	self actionSelector: actionSel.	self label: (self model perform: labelSel).! !!PluggableCheckBoxMorph class methodsFor: 'as yet unclassified' stamp: 'rww 9/11/2010 03:44'!on: anObject getState: getStateSel action: actionSel label: labelSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: nil! !!PluggableDropDownListMorph methodsFor: 'drawing' stamp: 'rww 9/11/2010 14:22'!basicPanel	^BorderedMorph new		beTransparent;		extent: 0@0;		borderWidth: 0;		layoutInset: 0;		cellInset: 0;		layoutPolicy: TableLayout new;		listCentering: #topLeft;		cellPositioning: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		yourself! !!PluggableDropDownListMorph methodsFor: 'drawing' stamp: 'rww 9/11/2010 14:22'!horizontalPanel	^self basicPanel		cellPositioning: #center;		listDirection: #leftToRight;		yourself.! !!PluggableDropDownListMorph methodsFor: 'drawing' stamp: 'rww 9/11/2010 14:20'!installDropDownList	| aButton aLabel |	aButton := PluggableButtonMorph on: self model getState: nil action: nil.	aLabel := (StringMorph contents: self model currentRemoteVatId translated				font: (StrikeFont familyName: TextStyle defaultFont familyName							size: TextStyle defaultFont pointSize - 1)).	self addMorph: (self horizontalPanel		addMorphBack: aLabel;		addMorphBack: aButton;		yourself).! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:34'!currentSelection	^ self model perform: selectionSelector! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:34'!currentSelection: obj	^ self model perform: selectionSetter with: obj! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:33'!list	"Answer the value of list"	^ self model perform: self listSelector.	! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!listSelector	"Answer the value of listSelector"	^ listSelector! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!listSelector: anObject	"Set the value of listSelector"	listSelector := anObject! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:33'!model	^ model! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!model: anObject	"Set the value of model"	model := anObject! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!selectionSelector	"Answer the value of selectionSelector"	^ selectionSelector! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!selectionSelector: anObject	"Set the value of selectionSelector"	selectionSelector := anObject! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!selectionSetter	"Answer the value of selectionSetter"	^ selectionSetter! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!selectionSetter: anObject	"Set the value of selectionSetter"	selectionSetter := anObject! !!PluggableDropDownListSpec methodsFor: 'building' stamp: 'rww 9/11/2010 13:36'!buildWith: builder	^builder buildPluggableDropDownList: self! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!listSelector	"Answer the value of listSelector"	^ listSelector! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!listSelector: anObject	"Set the value of listSelector"	listSelector := anObject! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSelector	"Answer the value of selectionSelector"	^ selectionSelector! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSelector: anObject	"Set the value of selectionSelector"	selectionSelector := anObject! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSetter	"Answer the value of selectionSetter"	^ selectionSetter! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSetter: anObject	"Set the value of selectionSetter"	selectionSetter := anObject! !!PluggableFileList class methodsFor: 'canAcceptBlocks' stamp: 'nice 8/27/2010 20:55'!fileNameSelectedAcceptBlock	^[:theDirectory :theFileName | theFileName notNil]! !!PluggableListMorph methodsFor: 'debug and other' stamp: 'bf 6/25/2011 13:36'!userString	"Do I have a text string to be searched on?"	^ String streamContents: [:strm |		1 to: self getListSize do: [:i |			"must use asStringOrText because that's what the drawing uses, too"			strm nextPutAll: (self getListItem: i) asStringOrText; cr]]! !!PluggableListMorph methodsFor: 'event handling' stamp: 'cmm 10/4/2011 22:10'!keyboardFocusChange: aBoolean 	"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	aBoolean ifFalse:		[ self class clearFilterAutomatically ifTrue:			[ self hasFilter ifTrue:				[ self					 removeFilter ;					 updateList ] ] ].	(self innerBounds areasOutside: (self innerBounds insetBy: 1)) do:		[ : rect | self invalidRect: rect ]! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 3/2/2010 16:21'!doubleClick: event	| index |	doubleClickSelector ifNil: [^super doubleClick: event].	index := self rowAtLocation: event position.	index = 0 ifTrue: [^super doubleClick: event].	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."	^ self model perform: doubleClickSelector! !!PluggableListMorph methodsFor: 'events' stamp: 'mtf 2/20/2011 20:41'!mouseDown: evt	| selectors row |	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	row := self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	selectors := Array 		with: #click:		with: (doubleClickSelector ifNotNil:[#doubleClick:])		with: nil		with: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil]).	evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: HandMorph dragThreshold "pixels".! !!PluggableListMorph methodsFor: 'events' stamp: 'cmm 8/21/2011 22:02'!mouseUp: event 	"The mouse came up within the list; take appropriate action"	| row |	row := self rowAtLocation: event position.	"aMorph ifNotNil: [aMorph highlightForMouseDown: false]."	model okToChange		ifFalse: [^ self].	"No change if model is locked"	row = self selectionIndex		ifTrue: [(autoDeselect ifNil: [true]) ifTrue:[row = 0 ifFalse: [self changeModelSelection: 0] ]]		ifFalse: [self changeModelSelection: (self modelIndexFor: row)].	Cursor normal show! !!PluggableListMorph methodsFor: 'initialization' stamp: 'cmm 3/2/2011 10:49'!getListSelector: sel 	"Set the receiver's getListSelector as indicated, and trigger a recomputation of the list"	self		 setGetListSelector: sel ;		 changed ;		 updateList! !!PluggableListMorph methodsFor: 'initialization' stamp: 'cmm 2/27/2011 15:48'!list: listOfStrings  	"lex doesn't think this is used any longer, but is not yet brave enough to remove it.  It should be removed eventually"			"Set the receiver's list as specified"	| morphList h index converter aSelector textColor font loc |self isThisEverCalled.	scroller removeAllMorphs.	list := listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [self setScrollDeltas.  ^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	font ifNil: [font := Preferences standardListFont].	converter := self valueOfProperty: #itemConversionMethod.	converter ifNil: [converter := #asStringOrText].	textColor := self valueOfProperty: #textColor.	morphList := list collect: [:each | | stringMorph item |		item := each.		item := item perform: converter.		stringMorph := item isText			ifTrue: [StringMorph contents: item font: font emphasis: (item emphasisAt: 1)]			ifFalse: [StringMorph contents: item font: font].		textColor ifNotNil: [ stringMorph color: textColor ].		stringMorph	].		(aSelector := self valueOfProperty: #balloonTextSelectorForSubMorphs)		ifNotNil:			[morphList do: [:m | m balloonTextSelector: aSelector]].	self highlightSelector ifNotNil:		[model perform: self highlightSelector with: list with: morphList].	"Lay items out vertically and install them in the scroller"	h := morphList first height "self listItemHeight".	loc := 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc := loc + (0@h)].	scroller addAllMorphs: morphList.	index := self getCurrentSelectionIndex.	self selectedMorph: ((index = 0 or: [index > morphList size]) ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0! !!PluggableListMorph methodsFor: 'model access' stamp: 'ul 10/22/2011 05:17'!basicKeyPressed: aChar 	| milliseconds slowKeyStroke listSize newSelectionIndex oldSelectionIndex startIndex |	oldSelectionIndex := newSelectionIndex := self getCurrentSelectionIndex.	listSize := self getListSize.	listSize = 0 ifTrue: [ ^self flash ].	milliseconds := Time millisecondClockValue.	slowKeyStroke := (Time		milliseconds: milliseconds		since: lastKeystrokeTime) > (self class filterableLists ifTrue: [500] ifFalse: [ 300 ]).	lastKeystrokeTime := milliseconds.	slowKeyStroke		ifTrue:			[ self class filterableLists ifTrue: [ self hasFilter ifFalse: [ priorSelection := self modelIndexFor: self selectionIndex] ].			"forget previous keystrokes and search in following elements"			lastKeystrokes := aChar asLowercase asString.			newSelectionIndex := newSelectionIndex \\ listSize + 1.			self class filterableLists ifTrue: [ list := self getFullList ] ]		ifFalse: [ "append quick keystrokes but don't move selection if it still matches"			lastKeystrokes := lastKeystrokes , aChar asLowercase asString.			newSelectionIndex := newSelectionIndex max: 1 ].	"No change if model is locked"	model okToChange ifFalse: [ ^ self ].	self class filterableLists		ifTrue:			[ self				 filterList ;				 updateList.			newSelectionIndex := self modelIndexFor: 1 ]		ifFalse:			[ startIndex := newSelectionIndex.			listSize := self getListSize.			[ (self getListItem: newSelectionIndex) asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes ] whileFalse:				[ (newSelectionIndex := newSelectionIndex \\ listSize + 1) = startIndex ifTrue: [ ^ self flash"Not in list." ] ].			newSelectionIndex = oldSelectionIndex ifTrue: [ ^ self flash ] ].	(self hasFilter and: [(self getCurrentSelectionIndex = newSelectionIndex) not]) ifTrue:		[self changeModelSelection: newSelectionIndex]! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 3/2/2010 16:21'!getCurrentSelectionIndex	"Answer the index of the current selection."	getIndexSelector ifNil: [^0].	^model perform: getIndexSelector! !!PluggableListMorph methodsFor: 'model access' stamp: 'cmm 8/20/2011 16:00'!getFullList	"The full, unfiltered list."	^ model perform: getListSelector! !!PluggableListMorph methodsFor: 'model access' stamp: 'cmm 8/22/2011 09:17'!getList	"Answer the list to be displayed.  Caches the returned list in the 'list' ivar"	getListSelector == nil ifTrue: [ ^ Array empty ].	list := self getFullList.	self class filterableLists ifTrue: [ self filterList ].	^ list ifNil: [ Array empty ]! !!PluggableListMorph methodsFor: 'model access' stamp: 'cmm 8/21/2011 23:25'!removeFilter	lastKeystrokes := String empty.	list := nil! !!PluggableListMorph methodsFor: 'model access' stamp: 'cmm 9/17/2011 21:33'!specialKeyPressed: asciiValue	"A special key with the given ascii-value was pressed; dispatch it"	| oldSelection nextSelection max howManyItemsShowing |	(#(8 13) includes: asciiValue) ifTrue:		[ "backspace key - clear the filter, restore the list with the selection" 		self removeFilter.		priorSelection ifNotNil:			[ | prior |			prior := priorSelection.			priorSelection := self getCurrentSelectionIndex.			asciiValue = 8 ifTrue: [ self changeModelSelection: prior ] ].		^ self updateList ].	asciiValue = 27 ifTrue: 		[" escape key"		^ ActiveEvent shiftPressed			ifTrue:				[ActiveWorld putUpWorldMenuFromEscapeKey]			ifFalse:				[self yellowButtonActivity: false]].	max := self maximumSelection.	max > 0 ifFalse: [^ self].	nextSelection := oldSelection := self selectionIndex.	asciiValue = 31 ifTrue: 		[" down arrow"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].	asciiValue = 30 ifTrue: 		[" up arrow"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].	asciiValue = 1 ifTrue:		[" home"		nextSelection := 1].	asciiValue = 4 ifTrue:		[" end"		nextSelection := max].	howManyItemsShowing := self numSelectionsInView.	asciiValue = 11 ifTrue:		[" page up"		nextSelection := 1 max: oldSelection - howManyItemsShowing].	asciiValue = 12 ifTrue:		[" page down"		nextSelection := oldSelection + howManyItemsShowing min: max].	model okToChange ifFalse: [^ self].	"No change if model is locked"	oldSelection = nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: (self modelIndexFor: nextSelection)! !!PluggableListMorph methodsFor: 'selection' stamp: 'cmm 8/21/2011 23:49'!modelIndexFor: selectionIndex 	"The model does not know anything about the receiver's filtering, so if I am filtered, we must determine the correct index by scanning the full list in the model."	^ (selectionIndex > 0 and: [ self hasFilter ])		ifTrue:			[ list				ifEmpty: [ 0 ]				ifNotEmpty: [ self getFullList indexOf: (self getListItem: selectionIndex) ] ]		ifFalse: [ selectionIndex ]! !!PluggableListMorph methodsFor: 'selection' stamp: 'cmm 8/21/2011 23:44'!scrollSelectionIntoView	"make sure that the current selection is visible"	| row |	row := self uiIndexFor: self getCurrentSelectionIndex.	row = 0 ifTrue: [ ^ self ].	self scrollToShow: (self listMorph drawBoundsForRow: row)! !!PluggableListMorph methodsFor: 'selection' stamp: 'cmm 8/19/2011 14:53'!selectedMorph: aMorph 	"this shouldn't be used any longer"	self isThisEverCalled .	true ifTrue: [^self]! !!PluggableListMorph methodsFor: 'selection' stamp: 'cmm 8/21/2011 22:04'!setSelectedMorph: aMorph 	self changeModelSelection: (self modelIndexFor: (scroller submorphs indexOf: aMorph))! !!PluggableListMorph methodsFor: 'selection' stamp: 'cmm 8/21/2011 22:40'!uiIndexFor: modelIndex 	"The model does not know anything about the receiver's filtering.  Answer the index in my (possibly filtered) list for modelIndex."	(modelIndex > 0 and: [ self hasFilter ])		ifTrue:			[ | selectedItem |			selectedItem := self getFullList at: modelIndex.			(list ifNil: [ self getList ]) withIndexDo:				[ : eachMatchingItem : n | eachMatchingItem = selectedItem ifTrue: [ ^ n ] ].			^ 0 ]		ifFalse: [ ^ modelIndex ]! !!PluggableListMorph methodsFor: 'updating' stamp: 'cmm 8/26/2011 16:19'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[ self updateList.		^ self ].	aSymbol == getIndexSelector ifTrue:		[ | uiIndex modelIndex |		uiIndex := self uiIndexFor: (modelIndex := self getCurrentSelectionIndex).		self selectionIndex:			(uiIndex = 0				ifTrue:					[ "The filter is preventing us from selecting the item we want - remove it."					(list notNil and: [list size > 0]) ifTrue: [ self removeFilter ].					modelIndex ]				ifFalse: [ uiIndex ]).		^ self ]! !!PluggableListMorph methodsFor: 'updating' stamp: 'cmm 8/22/2011 10:37'!updateList	| index |	"the list has changed -- update from the model"	self listMorph listChanged.	self setScrollDeltas.	scrollBar setValue: 0.0.	index := self getCurrentSelectionIndex.	self resetPotentialDropRow.	self selectionIndex: (self uiIndexFor: index).! !!PluggableListMorph methodsFor: 'updating' stamp: 'cmm 8/20/2011 16:02'!verifyContents	"Verify the contents of the receiver, reconstituting if necessary.  Called whenever window is reactivated, to react to possible structural changes.  Also called periodically in morphic if the smartUpdating preference is true"	| newList existingSelection anIndex oldList |	oldList := list ifNil: [ #() ].	newList := self getList.	oldList = newList ifTrue: [ ^ self ].	existingSelection := self selectionIndex > 0 ifTrue: [ oldList at: self selectionIndex ] ifFalse: [ nil ].	self updateList.	(existingSelection notNil and: [(anIndex := self getFullList indexOf: existingSelection asStringOrText ifAbsent: [nil]) notNil])		ifTrue:			[model noteSelectionIndex: anIndex for: getListSelector.			self selectionIndex: anIndex]		ifFalse:			[self changeModelSelection: 0]! !!PluggableListMorph methodsFor: 'filtering' stamp: 'cmm 8/29/2011 20:59'!filterList	self hasFilter		ifTrue:			[ | frontMatching substringMatching newList |			self indicateFiltered.			frontMatching := OrderedCollection new.			substringMatching := OrderedCollection new.			list withIndexDo:				[ : each : n | | foundPos |				foundPos := each asString					findString: lastKeystrokes					startingAt: 1					caseSensitive: false.				foundPos = 1					ifTrue: [ frontMatching add: each ]					ifFalse:						[ foundPos = 0 ifFalse: [ substringMatching add: each ] ] ].			newList := frontMatching , substringMatching.			newList				ifEmpty:					[ lastKeystrokes := lastKeystrokes allButLast: 1.					self						 flash ;						 filterList ]				ifNotEmpty: [ list := newList ] ]		ifFalse: [ self indicateUnfiltered ]! !!PluggableListMorph methodsFor: 'filtering' stamp: 'cmm 8/21/2011 19:56'!hasFilter	^ lastKeystrokes isEmptyOrNil not! !!PluggableListMorph methodsFor: 'filtering' stamp: 'cmm 8/20/2011 15:35'!indicateFiltered	self color: Color red muchLighter muchLighter! !!PluggableListMorph methodsFor: 'filtering' stamp: 'cmm 8/20/2011 15:35'!indicateUnfiltered	self color: Color white! !!PluggableListMorph commentStamp: 'cmm 8/21/2011 23:37' prior: 0!When a PluggableListMorph is in focus, type in a letter (or several letters quickly) to go to the next item that begins with that letter (if FilterableLists is false).Special keys (up, down, home, etc.) are also supported.!!PluggableListMorph class methodsFor: 'preferences' stamp: 'cmm 10/4/2011 22:09'!clearFilterAutomatically	<preference: 'Filterable Lists Clear Automatically'		category: 'scrolling'		description: 'When using the Filterable Lists option, if this option is also selected, then the filter will be cleared as soon as the list loses keyboard focus.'		type: #Boolean>	^ ClearFilterAutomatically ifNil: [ true ]! !!PluggableListMorph class methodsFor: 'preferences' stamp: 'cmm 10/18/2011 21:05'!clearFilterAutomatically: aBoolean	ClearFilterAutomatically := aBoolean! !!PluggableListMorph class methodsFor: 'preferences' stamp: 'cmm 10/18/2011 21:07'!filterableLists	<preference: 'Filterable Lists'		category: 'scrolling'		description: 'When true, using the keyboard on a list will filter it rather than scroll.  Pressing enter clears the filter and keeps the filtered selection.  Backspace clears the filter and returns to the prior selection.'		type: #Boolean>	^ FilterableLists ifNil: [ true ]! !!PluggableListMorph class methodsFor: 'preferences' stamp: 'cmm 10/18/2011 21:08'!filterableLists: aBoolean	"When true, using the keyboard on a list will filter it rather than scroll.  Pressing enter clears the filter and keeps the filtered selection.  Backspace clears the filter and returns to the prior selection."	FilterableLists := aBoolean! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'cmm 8/21/2011 22:05'!mouseDown: event	| oldIndex oldVal row |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	row := self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^ self].  "No change if model is locked"	"Set meaning for subsequent dragging of selection"	dragOnOrOff := (self listSelectionAt: row) not.	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self changeModelSelection: (self modelIndexFor: row)]		ifFalse: [self changeModelSelection: 0].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	self listSelectionAt: row put: dragOnOrOff.	"event hand releaseMouseFocus: aMorph."	"aMorph changed"! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'cmm 8/21/2011 22:05'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |	event position y < self top 		ifTrue: 			[scrollBar scrollUp: 1.			row := self rowAtLocation: scroller topLeft + (1 @ 1)]		ifFalse: 			[row := event position y > self bottom 				ifTrue: 					[scrollBar scrollDown: 1.					self rowAtLocation: scroller bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^self].	"No change if model is locked"	dragOnOrOff ifNil: 			["Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff := (self listSelectionAt: row) not].	"Set meaning for subsequent dragging of selection"	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [self changeModelSelection: (self modelIndexFor: row)]		ifFalse: [self changeModelSelection: 0].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	self listSelectionAt: row put: dragOnOrOff.	row changed! !!PluggableListMorphPlus methodsFor: 'drag and drop' stamp: 'cmm 9/11/2011 13:01'!startDrag: evt 		dragItemSelector ifNil:[^self].	evt hand hasSubmorphs ifTrue: [^ self].	[ | dragIndex draggedItem ddm |	(self dragEnabled and: [model okToChange]) ifFalse: [^ self].	dragIndex := self rowAtLocation: evt position.	dragIndex = 0 ifTrue:[^self].	draggedItem := model perform: dragItemSelector with: (self modelIndexFor: dragIndex).	draggedItem ifNil:[^self].	ddm := TransferMorph withPassenger: draggedItem from: self.	ddm dragTransferType: #dragTransferPlus.	evt hand grabMorph: ddm]		ensure: [Cursor normal show.			evt hand releaseMouseFocus: self]! !!PluggableListView methodsFor: 'model access' stamp: 'ul 11/15/2010 11:59'!specialKeyPressed: keyEvent	"Process the up and down arrows in a list pane."     | oldSelection nextSelection max min howMany |	(#(1 4 11 12 30 31) includes: keyEvent) ifFalse: [ ^ false ].     oldSelection := self getCurrentSelectionIndex.     nextSelection := oldSelection.     max := self maximumSelection.     min := self minimumSelection.     howMany := self numSelectionsInView.	"get this exactly??"     keyEvent = 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent = 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent = 1  ifTrue: [nextSelection := 1].  "home"     keyEvent = 4  ifTrue: [nextSelection := max].   "end"     keyEvent = 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent = 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				"self controller moveMarker"]].		^true			! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/3/2010 10:15'!adoptPaneColor: paneColor 	"Pass on to the border too."	super adoptPaneColor: paneColor.	paneColor ifNil: [ ^ self ].	self		 fillStyle: self fillStyleToUse ;		 borderStyle:			(BorderStyle inset				 width: 1 ;				 baseColor: self color twiceDarker) ;		 sliderColor:			(self enabled				ifTrue: [ paneColor twiceDarker ]				ifFalse: [ self paneColor twiceDarker paler ])! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:25'!borderStyleToUse	"Answer the borderStyle that should be used for the receiver."		^self enabled		ifTrue: [self theme sliderNormalBorderStyleFor: self]		ifFalse: [self theme sliderDisabledBorderStyleFor: self]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 15:02'!defaultColor	"Answer the default color/fill style for the receiver."		^Color white! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:19'!disable	"Disable the receiver."		self enabled: false! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:19'!enable	"Enable the receiver."		self enabled: true! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:24'!fillStyleToUse	"Answer the fillStyle that should be used for the receiver."		^self enabled		ifTrue: [self theme sliderNormalFillStyleFor: self]		ifFalse: [self theme sliderDisabledFillStyleFor: self]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:31'!getValueSelector	"Answer the value of getValueSelector"	^ getValueSelector! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:31'!getValueSelector: anObject	"Set the value of getValueSelector"	getValueSelector := anObject! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:27'!handlesMouseDown: evt	"Answer true." 	^true! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/9/2007 13:14'!initialize	"Initialize the receiver."	min := 0.	max := 1.	super initialize.	self enabled: true! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 15:00'!initializeSlider	"Make the slider raised."		super initializeSlider.	slider borderStyle: (BorderStyle raised baseColor: slider color; width: 1)! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:14'!layoutBounds: aRectangle	"Set the bounds for laying out children of the receiver.	Note: written so that #layoutBounds can be changed without touching this method"		super layoutBounds: aRectangle.	self computeSlider! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/8/2007 15:32'!minHeight	"Answer the receiver's minimum height.	Give it a bit of a chance..."		^8 max: super minHeight! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/7/2007 10:35'!mouseDown: anEvent	"Set the value directly."		self enabled ifTrue: [		self			scrollPoint: anEvent;			computeSlider].	super mouseDown: anEvent.	self enabled ifFalse: [^self].	anEvent hand newMouseFocus: slider event: anEvent.	slider		mouseEnter: anEvent copy;		mouseDown: anEvent copy! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/7/2007 10:36'!mouseDownInSlider: event	"Ignore if disabled."		self enabled ifFalse: [^self].	^super mouseDownInSlider: event! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:29'!on: anObject getValue: getSel setValue: setSel	"Use the given selectors as the interface."	self		model: anObject;		getValueSelector: getSel;		setValueSelector: setSel;		updateValue! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'MarcusDenker 12/11/2009 07:41'!scaledValue	"Answer the scaled value."	|val|	val := self value * (self max - self min) + self min.	self quantum ifNotNil: [:q |		val := val roundTo: q].	^(val max: self min) min: self max! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'MarcusDenker 12/11/2009 07:41'!scaledValue: newValue	"Set the scaled value."	|val|	val := newValue.	self quantum ifNotNil: [:q |		val := val roundTo: q].	self value: newValue - self min / (self max - self min)! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/7/2007 10:37'!scrollAbsolute: event	"Ignore if disabled."		self enabled ifFalse: [^self].	^super scrollAbsolute: event! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:28'!scrollPoint: event	"Scroll to the event position."		| r p |	r := self roomToMove.	bounds isWide		ifTrue: [r width = 0 ifTrue: [^ self]]		ifFalse: [r height = 0 ifTrue: [^ self]].	p := event position - (self sliderThickness // 2) adhereTo: r.	self descending		ifFalse:			[self setValue: (bounds isWide 				ifTrue: [(p x - r left) asFloat / r width]				ifFalse: [(p y - r top) asFloat / r height])]		ifTrue:			[self setValue: (bounds isWide				ifTrue: [(r right - p x) asFloat / r width]				ifFalse:	[(r bottom - p y) asFloat / r height])]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'MarcusDenker 12/11/2009 07:41'!setValue: newValue	"Called internally for propagation to model."	|scaled|	value := newValue.	self scaledValue: (scaled := self scaledValue).	self model ifNotNil: [		self setValueSelector ifNotNil: [:sel |			self model perform: sel with: scaled]]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/9/2007 11:18'!setValueSelector	"Answer the set selector."		^setValueSelector! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:31'!setValueSelector: aSymbol	"Directly set the selector to make more flexible."		setValueSelector := aSymbol! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:57'!sliderColor: newColor	"Set the slider colour."		super sliderColor: newColor.	slider ifNotNil: [slider borderStyle baseColor: newColor]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/8/2009 13:05'!update: aSymbol	"Update the value."		super update: aSymbol.	aSymbol == self getEnabledSelector ifTrue: [		^self updateEnabled].	aSymbol = self getValueSelector ifTrue: [		^self updateValue]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/8/2009 13:06'!updateEnabled	"Update the enablement state."	self model ifNotNil: [		self getEnabledSelector ifNotNil: [			self enabled: (self model perform: self getEnabledSelector)]]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/8/2009 13:00'!updateValue	"Update the value."		self model ifNotNil: [		self getValueSelector ifNotNil: [			self scaledValue: (self model perform: self getValueSelector)]]! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/3/2007 15:19'!enabled	"Answer the value of enabled"	^ enabled! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'cmm 12/2/2010 21:25'!enabled: anObject	"Set the value of enabled"	enabled = anObject ifTrue: [^self].	enabled := anObject.	self changed: #enabled.	self		adoptPaneColor: self color;		changed! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 9/8/2009 13:03'!getEnabledSelector	"Answer the value of getEnabledSelector"	^ getEnabledSelector! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 9/10/2009 13:32'!getEnabledSelector: aSymbol	"Set the value of getEnabledSelector"	getEnabledSelector := aSymbol.	self updateEnabled! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 10:43'!max	"Answer the value of max"	^ max! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 11:21'!max: anObject	"Set the value of max"	max := anObject.	self setValue: self value! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 10:43'!min	"Answer the value of min"	^ min! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 11:21'!min: anObject	"Set the value of min"	min := anObject.	self setValue: self value! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 11:14'!quantum	"Answer the value of quantum"	^ quantum! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 11:20'!quantum: anObject	"Set the value of quantum"	quantum := anObject.	self setValue: self value! !!PluggableSliderMorph commentStamp: 'gvc 7/16/2007 13:57' prior: 0!A pluggable slider (rather than one that auto-generates access selectors). Needs to be themed...!!PluggableSliderMorph class methodsFor: 'as yet unclassified' stamp: 'gvc 8/9/2007 11:28'!on: anObject getValue: getSel setValue: setSel	"Answer a new instance of the receiver with	the given selectors as the interface."	^self new		on: anObject		getValue: getSel		setValue: setSel! !!PluggableSliderMorph class methodsFor: 'as yet unclassified' stamp: 'gvc 8/9/2007 11:27'!on: anObject getValue: getSel setValue: setSel min: min max: max quantum: quantum	"Answer a new instance of the receiver with	the given selectors as the interface."	^self new		min: min;		max: max;		quantum: quantum;		on: anObject		getValue: getSel		setValue: setSel! !!PluggableSystemWindowWithLabelButton methodsFor: 'resize/collapse' stamp: 'eem 5/6/2008 12:58'!adjustExtraButton	labelButton ifNil: [^self].	labelButton		position: self innerBounds topLeft + (20 @ -3);		extent: self innerBounds extent * (0.4@1)! !!PluggableSystemWindowWithLabelButton methodsFor: 'geometry' stamp: 'eem 5/6/2008 10:45'!extent: newExtent	super extent: newExtent.	self adjustExtraButton! !!PluggableSystemWindowWithLabelButton methodsFor: 'accessing' stamp: 'eem 6/30/2010 18:56'!savedMultiWindowState: aSavedMultiWindowState	labelButton := MultiWindowLabelButtonMorph						on: aSavedMultiWindowState						getState: nil						action: #selectWindowsMenu.	labelButton		triggerOnMouseDown: true;		savedMultiWindowState: aSavedMultiWindowState.	labelButton		layoutFrame: (LayoutFrame "i.e. in the left 40% of the title bar"						fractions: (0@0 corner: 0.4@0)						offsets: (20@ -20 corner: 0@0));		hResizing: #spaceFill;		vResizing: #spaceFill.	self addMorphFront: labelButton.	self adjustExtraButton! !!PluggableSystemWindowWithLabelButton commentStamp: 'eem 6/29/2010 19:02' prior: 0!A PluggableSystemWindowWithLabelButton provides the pull-down menu of browser panes in the multi-pane browser.Instance Variables	labelButton:		<BrowserPaneButtonMorph>labelButton	- the labelButton is a hack to hold onto the panes of a multi-paned browser so that an inst var doesn't have to be added to the Browser hierarchy.!!PluggableTextMorph methodsFor: 'event handling' stamp: 'nice 8/2/2011 20:50'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keystroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	textMorph keyStroke: evt.	self eventHandler ifNotNil:		[self eventHandler keyStroke: evt fromMorph: self].! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 20:48'!extent: newExtent	bounds extent = newExtent ifTrue: [^ self].	super extent: (newExtent max: 36@16).	self setScrollDeltas! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 10:17'!resetExtent	"Reset the extent while maintaining the current selection.  Needed when resizing while the editor is active (when inside the pane)."	| tempSelection |	textMorph notNil ifTrue:		["the current selection gets munged by resetting the extent, so store it"		tempSelection := self selectionInterval.				"don't reset it if it's not active"		tempSelection = (Interval from: 1 to: 0) 						ifTrue: [retractableScrollBar							ifTrue:[ ^ self]].		self extent: self extent.		self setSelection: tempSelection].	super resetExtent.! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 20:48'!resizeScroller	"Also needs to resize the text morph"	super resizeScroller.	textMorph ifNotNil:		[textMorph extent: (self innerBounds width-6)@self height].! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'ar 6/17/2010 19:52'!accept 	"Inform the model of text to be accepted, and return true if OK."	| ok saveSelection saveScrollerOffset |"sps 8/13/2001 22:41: save selection and scroll info"	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not])		ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	ok := self acceptTextInModel.	ok==true ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false.		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) ifNotNil:			[:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"	["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok ifTrue: "(don't bother if there was an error during compile)"		[(model respondsTo: #updateCodePaneIfNeeded) 			ifTrue: [model updateCodePaneIfNeeded].		WorldState addDeferredUIMessage:			[self currentHand newKeyboardFocus: textMorph.			scroller offset: saveScrollerOffset.			self setScrollDeltas.			selectionInterval := saveSelection. "restore prior selection"			self selectFrom: saveSelection first to: saveSelection last]]]			on: Error do: []! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'yo 6/23/2011 00:33'!buttonForIt	self handleEdit: [textMorph editor buttonForIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'nice 3/31/2011 21:47'!exploreIt		self handleEdit:		[textMorph editor evaluateSelectionAndDo: [:result | result explore]].! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'nice 3/31/2011 21:47'!inspectIt		self handleEdit:		[textMorph editor evaluateSelectionAndDo: [:result | result inspect]]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'nice 3/31/2011 21:48'!printIt	| oldEditor |	textMorph editor selectFrom: selectionInterval first to: selectionInterval last;						model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [(oldEditor := textMorph editor) evaluateSelectionAndDo:		[:result |		selectionInterval := oldEditor selectionInterval.		textMorph installEditorToReplace: oldEditor.		textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].		selectionInterval := oldEditor selectionInterval.			textMorph editor selectFrom: selectionInterval first to: selectionInterval last.		self scrollSelectionIntoView]]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'nice 3/31/2011 21:48'!tileForIt	"Return a tile referring to the object resulting form evaluating my current selection.  Not currently threaded in, but useful in earlier demos and possibly still of value."		self handleEdit:		[textMorph editor evaluateSelectionAndDo: [:result | self currentHand attachMorph: result tileToRefer]]! !!PluggableTextMorph methodsFor: 'model access' stamp: 'jmv 3/2/2010 16:21'!getSelection	"Answer the model's selection interval."	getSelectionSelector ifNil: [^1 to: 0].	"null selection"	^model perform: getSelectionSelector! !!PluggableTextMorph methodsFor: 'model access' stamp: 'jmv 3/2/2010 16:22'!getText	"Retrieve the current model text"	| newText |	getTextSelector ifNil: [^Text new].	newText := model perform: getTextSelector.	newText ifNil: [^Text new].	^newText shallowCopy! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:56'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [self text]! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 21:05'!unacceptedEditState: stateOrNil	stateOrNil		ifNotNil:			[self setText: stateOrNil.			 hasUnacceptedEdits := true "setText: clears hasUnacceptedEdits, so must do this post setText:"]		ifNil: [hasUnacceptedEdits := false]! !!PluggableTextSpec commentStamp: 'ar 2/11/2005 21:58' prior: 0!A text editor.Instance variables:	getText	<Symbol>	The selector to retrieve the text.	setText	<Symbol>	The selector to set the text.	selection <Symbol>	The selector to retrieve the text selection.	menu	<Symbol>	The selector to offer (to retrieve?) the context menu.	color	 <Symbol>	The selector to retrieve the background color.!!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color	"Answer the selector for retrieving the button's color"	^color! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color: aSymbol	"Indicate the selector for retrieving the button's color"	color := aSymbol! !!PluggableWidgetSpec commentStamp: 'ar 2/9/2005 18:40' prior: 0!The abstract superclass for all widgets.Instance variables:	model	<Object>	The object the various requests should be directed to.	frame	<Rectangle> The associated layout frame for this object (if any).!!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:12'!isDialog	^isDialog ifNil: [false]! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 7/1/2010 11:31'!multiWindowStyle	"Answer the value of multiWindowStyle, a Symbol or nil"	^multiWindowStyle! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:44'!multiWindowStyle: aSymbol	"Set the value of multiWindowStyle, one of #labelButton or #tabbed"	multiWindowStyle := aSymbol! !!PluggableWindowSpec commentStamp: '<historical>' prior: 0!A common window. Expects to see change/update notifications when the label should change.Instance variables:	label	<String|Symbol> The selector under which to retrieve the label or the label directly	extent	<Point>	The (initial) extent of the window.	closeAction		<Symbol>	The action to perform when the window is closed.!!Point methodsFor: 'accessing' stamp: 'jrd 5/26/2010 12:32'!u	^x! !!Point methodsFor: 'accessing' stamp: 'jrd 5/26/2010 12:32'!v	^y! !!Point methodsFor: 'point functions' stamp: 'nice 12/29/2010 15:07'!eightNeighbors	^ (Array with: self + (1 @ 0)		with: self + (1 @ 1)		with: self + (0 @ 1)		with: self + (-1 @ 1)) ,	(Array with: self + (-1 @ 0)		with: self + (-1 @ -1)		with: self + (0 @ -1)		with: self + (1 @ -1))! !!Point methodsFor: 'point functions' stamp: 'wiz 8/6/2007 20:33'!fourDirections	"Return vertices for a square centered at 0 asPoint with the receiver as first corner.	Returns the four rotation of the reciever in counter clockwise order with the reciever 	appearing last. "	^ Array with: self leftRotated			with: self negated			with: self rightRotated			with: self 		! !!Point methodsFor: 'point functions' stamp: 'nice 12/29/2010 14:57'!fourNeighbors	^ Array with: self + (1 @ 0)		with: self + (0 @ 1)		with: self + (-1 @ 0)		with: self + (0 @ -1)! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 03:32'!leftRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #left centerAt: 0 asPoint .Compare to transposed and normal. "	^y  @x negated! !!Point methodsFor: 'point functions' stamp: 'wiz 7/28/2007 20:50'!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise.	For the zero point return a normal of  -1@0   ."	| n d |		n := y negated @ x.	(d := (n x * n x + (n y * n y))) = 0 ifTrue: [ ^  -1 @0  ] .	^n / d sqrt! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 02:33'!rightRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #right centerAt: 0 asPoint .Compare to transposed and normal. "	^y negated @x! !!Point methodsFor: 'point functions' stamp: 'wiz 8/1/2007 16:53'!sign^ (x sign @ y sign) .! !!Point methodsFor: '*Etoys-tiles' stamp: 'ar 7/21/2010 20:02'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Point! !!Point class methodsFor: 'instance creation' stamp: 'jrd 5/26/2010 12:31'!u: xInteger v: yInteger 	"Answer an instance of me with coordinates xInteger and yInteger."	^self new setX: xInteger setY: yInteger! !!PointTest methodsFor: 'tests - testing' stamp: 'nice 7/24/2010 18:43'!testBearingToPoint	self assert: (0 @ 0 bearingToPoint: 0 @ 0) = 0.	self assert: (0 @ 0 bearingToPoint: 0 @ -1) = 0.	self assert: (0 @ 0 bearingToPoint: 1 @ 0) = 90.	self assert: (0 @ 0 bearingToPoint: 0 @ 1) = 180.	self assert: (0 @ 0 bearingToPoint: -1 @ 0) = 270.	self assert: (0 @ 0 bearingToPoint: 1 @ 1) = 135.	self assert: (0 @ 0 bearingToPoint: 0.01 @ 0) = 90.	self assert: (0 @ 0 bearingToPoint: -2 @ -3) = 326.	self assert: (0 @ 0 bearingToPoint: -0 @ 0) = 0.		self assert: (-2 @ -3 bearingToPoint: 0 @ 0) = 146.! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:50'!testBasicFourDirections	"fourDirections returns the four rotation of the receiver in counter clockwise order with the receiver appearing last. "	| samples results rejects |	self assert:  (0 asPoint fourDirections) = (Array new: 4 withAll: 0 asPoint) . 	samples := 0 asPoint eightNeighbors  .	results := {		{ 0 @ -1 . 	-1 @  0 . 	 0 @  1 . 	 1 @  0}.		{ 1 @ -1 . 	-1 @ -1 . 	-1 @  1 . 	 1 @  1}.		{ 1 @  0 . 	 0 @ -1 . 	-1 @  0 . 	 0 @  1}.		{ 1 @  1 . 	 1 @ -1 . 	-1 @ -1 . 	-1 @  1}.		{ 0 @  1 . 	 1 @  0 . 	 0 @ -1 . 	-1 @  0}.		{-1 @  1 . 	 1 @  1 . 	 1 @ -1 . 	-1 @ -1}.		{-1 @  0 . 	 0 @  1 . 	 1 @  0 . 	 0 @ -1}.		{-1 @ -1 . 	-1 @  1 . 	 1 @  1 . 	 1 @ -1} } .	rejects := (1 to: samples size ) reject: [ :each |		 (samples at: each) fourDirections = (results at: each) ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 19:07'!testFourDirectionsInvarients" fourDirections returns the four rotation of the reciever in counter clockwise order with the reciever appearing last. "| samples  rejects |samples := 0 asPoint eightNeighbors  .rejects :=(1 to: samples size ) reject: [ :each |		 (samples at: each) fourDirections last = ( samples  at: each) ] .self assert: ( rejects isEmpty) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 20:32'!testFourDirectionsRotationInvarients" fourDirections returns the four rotation of the reciever in counter clockwise order with the reciever appearing last. "| samples  rejects |samples := 0 asPoint eightNeighbors  .rejects :=(1 to: samples size ) reject: [ :each | | answer  |		(answer :=  (samples at: each) fourDirections ) .		(1 to: 4) allSatisfy: [ :eachDirIndex | 			( answer atWrap: eachDirIndex)  leftRotated					 = (( answer atWrap: eachDirIndex + 1) )  ] ] .self assert: ( rejects isEmpty) .! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:52'!testNormal	"quick check of results for #normal."	| samples rejects results |	samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .	results :=  		{ 0.0 @ 1.0 .		-0.707106781186547 @ 0.707106781186547 .		-1.0 @ 0.0 .		-0.707106781186547 @ -0.707106781186547 .		0.0 @ -1.0 .		0.707106781186547 @ -0.707106781186547 .		1.0 @ 0.0 .		0.707106781186547 @ 0.707106781186547 .		-1 @ 0} .	rejects := (1 to: samples size ) reject:		[ :each | ((samples at: each) normal - (results at: each)) abs  < 1e-15 asPoint ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:54'!testNormal2	"quick check of results for #normal.	differs from the other testNormal in the way that the difference is measured."	| samples rejects results differences |	samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .	results := 		{ 0.0 @ 1.0 .		-0.707106781186547 @ 0.707106781186547 .		-1.0 @ 0.0 .		-0.707106781186547 @ -0.707106781186547 .		0.0 @ -1.0 .		0.707106781186547 @ -0.707106781186547 .		1.0 @ 0.0 .		0.707106781186547 @ 0.707106781186547 .		-1 @ 0} .	differences := samples with: results collect: [ :each :eachResult |		each normal - eachResult ] .	rejects := differences reject: [ :each | 		(each x closeTo: 0.0) and: [each y closeTo: 0.0] ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 17:02'!testRotations" Here we are testing rightRotated and leftRotated which are new.Because there is really no coverage for point functions this also serves as a tests of sorts for rotateBy:CenterAt:"| samples |samples :=0 asPoint eightNeighbors , (Array with: 0 asPoint) .self assert: (samples allSatisfy: [ :each |	each rightRotated leftRotated = each ] ) .self assert: (samples allSatisfy: [ :each |	each rightRotated  = (each rotateBy: #right centerAt: 0 asPoint)] ) .self assert: (samples allSatisfy: [ :each |	each leftRotated  = (each rotateBy: #left centerAt: 0 asPoint ) ] ) .self assert: (samples allSatisfy: [ :each |	each negated  = (each rotateBy: #pi centerAt: 0 asPoint ) ] ) .self assert: (samples allSatisfy: [ :each | 	each leftRotated leftRotated leftRotated leftRotated = each ]) .self assert: (samples allSatisfy: [ :each |	each rightRotated rightRotated rightRotated rightRotated  = each ] ) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 18:38'!testSign | samples results rejects |samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .self shouldnt: [ results :=				samples collect: [ :each | each sign ] ]	raise: Error .	rejects :=(1 to: samples size ) reject: [ :each |		 (samples at: each) = (results at: each) ] .self assert: ( rejects isEmpty) ! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:44'!testTheta      | result dir tan x y |	self assert: ((0 @ 1) theta - 90.0 degreesToRadians) abs < 1e-15.	self assert: ((0 @ -1) theta - 270.0 degreesToRadians) abs < 1e-15.	" See code of old and new theta"	x := 1.0 . y := -1.0.	tan := y  / x .	dir := tan arcTan.      result :=  360.0 degreesToRadians + dir.      self assert: ((x @ y) theta - result) abs < 1e-15.	x := -1.0. "Don't reuse old results when you want numeric precision!!"	tan := y  / x .	dir := tan arcTan.      result :=  180.0 degreesToRadians + dir.      self assert: ((x @ y) theta - result) abs < 1e-15.	! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 17:22'!testZeroPointNormal"old: normal of zero point raised divide by zero error.new: normal of zero point returns a direction right rotated from zero points direction."self shouldnt: [ (0 asPoint normal bearingToPoint: 0 asPoint) = 90 ] raise: Error.  ! !!PointerExplorerWrapper methodsFor: 'accessing' stamp: 'mtf 8/19/2008 22:25'!contents	| objects |	objects := Utilities pointersTo: item except: (Array with: self).	^(objects reject: [:ea | ea class = self class or: [ea class = PointerExplorer]])		collect: [:ea| self class with: ea name: ea identityHash asString model: item]! !!PointerFinder methodsFor: 'application' stamp: 'ul 11/23/2010 13:27'!follow: anObject from: parentObject	anObject == goal ifTrue: [		parents at: anObject put: parentObject.		^ true].	"Remove this after switching to new CompiledMethod format --bf 2/12/2006"	(anObject class isPointers or: [ anObject isCompiledMethod ]) ifFalse: [ ^false].	(anObject class isWeak or: [		anObject class == self class or: [		anObject isLiteral or: [		parents includesKey: anObject ] ] ])			ifTrue: [ ^false ].	parents at: anObject put: parentObject.	toDoNext add: anObject.	^ false! !!PointerFinder methodsFor: 'application' stamp: 'mtf 8/15/2008 17:28'!followObject: anObject	anObject outboundPointersDo: [:ea |		(self follow: ea from: anObject)			ifTrue: [^ true]].	^ false! !!PointerFinder class methodsFor: 'utilities' stamp: 'mtf 8/15/2008 23:52'!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. 	Remove objects in the exclusion list from the results."		^ anObject inboundPointersExcluding: objectsToExclude! !!PolygonMorph methodsFor: 'menu' stamp: 'ul 11/15/2010 11:59'!unrotatedLength	"If the receiver bears rotation without a transformation morph, answer what its length in the direction it is headed is"	vertices size = 2 ifTrue:		[^ (vertices second - vertices first) r].	^ ((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) height! !!PolygonMorph methodsFor: 'menu' stamp: 'ul 11/15/2010 11:59'!unrotatedLength: aLength	"If the receiver bears rotation without a transformation morph, answer what its length in the direction it is headed is"	vertices size = 2 ifTrue: [^ self arrowLength: aLength].	self setVertices: ((((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) height: aLength) rotationDegrees: 0) vertices! !!PolygonMorph methodsFor: 'menu' stamp: 'ul 11/15/2010 11:59'!unrotatedWidth	"If the receiver bears rotation without a transformation morph, answer what its length in the direction it is headed is"		vertices size = 2 ifTrue: [^ self borderWidth].	^ ((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) width! !!PolygonMorph methodsFor: 'smoothing' stamp: 'jmv 3/2/2010 16:22'!computeNextToEndPoints	| pointAfterFirst pointBeforeLast |	pointAfterFirst := nil.	self lineSegmentsDo: 			[:p1 :p2 | 			pointAfterFirst ifNil: [pointAfterFirst := p2 asIntegerPoint].			pointBeforeLast := p1 asIntegerPoint].	curveState at: 2 put: pointAfterFirst.	curveState at: 3 put: pointBeforeLast! !!PolygonMorph methodsFor: 'attachments' stamp: 'nice 2/14/2011 21:49'!nudgeForLabel: aRectangle	"Try to move the label off me. Prefer labels on the top and right."	| i flags nudge |	(self bounds intersects: aRectangle) ifFalse: [^ 0 @ 0 ].	flags := 0.	nudge := 0 @ 0.	i := 1.	aRectangle lineSegmentsDo: [ :rp1 :rp2 | | rectSeg |		rectSeg := LineSegment from: rp1 to: rp2.		self straightLineSegmentsDo: [ :lp1 :lp2 | | polySeg int |			polySeg := LineSegment from: lp1 to: lp2.			int := polySeg intersectionWith: rectSeg.			int ifNotNil: [ flags := flags bitOr: i ].		].		i := i * 2.	].	"Now flags has bitflags for which sides"	nudge := flags caseOf: {"no intersection"		[ 2r0000 ] -> [ 0 @ 0 ]."2 adjacent sides only" 		[ 2r1001 ] -> [ 1 @ 1 ].		[ 2r0011 ] -> [ -1 @ 1 ].		[ 2r1100 ] -> [ 1 @ -1 ].		[ 2r0110 ] -> [ -1 @ -1 ]."2 opposite sides only" 		[ 2r1010 ] -> [ 0 @ -1 ].		[ 2r0101 ] -> [ 1 @ 0 ]."only 1 side" 		[ 2r1000 ] -> [ -1 @ 0 ].		[ 2r0001 ] -> [ 0 @ -1 ].		[ 2r0010 ] -> [ 1 @ 0 ].		[ 2r0100 ] -> [ 0 @ 1 ]."3 sides" 		[ 2r1011 ] -> [ 0 @ 1 ].		[ 2r1101 ] -> [ 1 @ 0 ].		[ 2r1110 ] -> [ 0 @ -1 ].		[ 2r0111 ] -> [ -1 @ 0 ]. "all sides" 		[ 2r1111 ] -> [ 1 @ -1 "move up and to the right" ].	}.	^nudge! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'ul 6/17/2011 12:40'!fromHand: hand	"Let the user draw a polygon, clicking at each vertex, and ending		by clicking within 5 of the first point..."	| p1 poly oldVerts pN opposite |	Cursor crossHair showWhile:		[[Sensor anyButtonPressed] whileFalse:			[self currentWorld displayWorldSafely; runStepMethods].		p1 := Sensor cursorPoint].	opposite := (Display colorAt: p1) negated.	opposite = Color transparent ifTrue: [opposite := Color red].	(poly := LineMorph from: p1 to: p1 color: opposite width: 2) openInWorld.	oldVerts := {p1}.	self currentWorld displayWorldSafely; runStepMethods.		[[Sensor anyButtonPressed] whileTrue:		[pN := Sensor cursorPoint.		poly setVertices: (oldVerts copyWith: pN).		self currentWorld displayWorldSafely; runStepMethods].	(oldVerts size > 1 and: [(pN dist: p1) < 5]) ifTrue:		[hand position: Sensor cursorPoint.  "Done -- update hand pos"		^ (poly setVertices: (poly vertices copyWith: p1)) delete].	oldVerts := poly vertices.	[Sensor anyButtonPressed] whileFalse:		[pN := Sensor cursorPoint.		poly setVertices: (oldVerts copyWith: pN).		self currentWorld displayWorldSafely; runStepMethods]] repeat! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'nice 6/11/2010 21:53'!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch := Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch := ch asCharacter asLowercase.	labels := labelString lines.	occurences := 0.	1 + selection to: selection + labels size do:		[:index |		| i | i := index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences := occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ul 6/17/2011 12:40'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString lines.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[to := (from + nLinesPer) min: nLines.	subset := allLabels copyFrom: from to: to.	subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])		before: subset first.	subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].	subLines := (Array with: 1) , subLines.	index := (PopUpMenu labels: subset asStringWithCr lines: subLines)				startUpWithCaption: captionOrNil at: location.	index = 1		ifTrue: [from := to + 1.				from > nLines ifTrue: [ from := 1 ]]		ifFalse: [index = 0 ifTrue: [^ 0].				^ from + index - 2]] repeat! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ul 6/17/2011 12:41'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString lines.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[to := (from + nLinesPer) min: nLines.	subset := (allLabels copyFrom: from to: to) asOrderedCollection.	subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])		before: subset first.	subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].	subLines := (Array with: 1) , subLines.	index := (PopUpMenu labels: subset asStringWithCr lines: subLines)				startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.	index = 1		ifTrue: [from := to + 1.				from > nLines ifTrue: [ from := 1 ]]		ifFalse: [index = 0 ifTrue: [^ 0].				^ from + index - 2]] repeat! !!PopUpMenu methodsFor: 'displaying' stamp: 'ul 8/2/2011 20:07'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionForm captionSave outerFrame captionText tFrame frameSaveLoc captionBox |	marker ifNil: [self computeForm].	frame := frame align: marker leftCenter with: aPoint + (2@0).	outerFrame := frame.	captionOrNil notNil ifTrue:		[captionText := (DisplayText				text: captionOrNil asText				textStyle: MenuStyle copy centered)					foregroundColor: Color black					backgroundColor: Color white.		tFrame := captionText boundingBox insetBy: -2.		outerFrame := frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta := outerFrame amountToTranslateWithin: Display boundingBox.	frame right > Display boundingBox right		ifTrue: [delta := 0 - frame width @ delta y].	frame := frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionForm := captionText form.		captionBox := captionForm boundingBox expandBy: 4.		captionBox := captionBox align: captionBox bottomCenter								with: frame topCenter + (0@2).		captionSave := Form fromDisplay: captionBox.		Display border: captionBox width: 4 fillColor: Color white.		Display border: captionBox width: 2 fillColor: Color black.		captionForm displayAt: captionBox topLeft + 4].	marker := marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea := Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc := frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: aBlock.	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionBox topLeft]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'ul 6/17/2011 12:28'!fileInAnnouncing: announcement 	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val |	announcement 		displayProgressFrom: 0		to: self size		during: 			[:bar | 			[self atEnd] whileFalse: 					[bar value: self position.					self skipSeparators.										[ | chunk |					val := (self peekFor: $!!) 								ifTrue: [(Compiler evaluate: self nextChunk logged: false) scanFrom: self]								ifFalse: 									[chunk := self nextChunk.									self checkForPreamble: chunk.									Compiler evaluate: chunk logged: true]] 							on: InMidstOfFileinNotification							do: [:ex | ex resume: true].					self skipStyleChunk].			self close].	"Note:  The main purpose of this banner is to flush the changes file."	SmalltalkImage current logChange: '----End fileIn of ' , self name , '----'.	self flag: #ThisMethodShouldNotBeThere.	"sd"	^val! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'ul 6/17/2011 12:28'!fileInFor: client announcing: announcement	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title.	Does NOT handle preambles or postscripts specially."	| val |	announcement		displayProgressFrom: 0		to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				[ | chunk |				val := (self peekFor: $!!) ifTrue: [						(Compiler evaluate: self nextChunk for: client logged: false) scanFrom: self					] ifFalse: [						chunk := self nextChunk.						self checkForPreamble: chunk.						Compiler evaluate: chunk for: client logged: true ].				] on: InMidstOfFileinNotification				  do: [ :ex | ex resume: true].				self atEnd ifFalse: [ self skipStyleChunk ]].		self close].	"Note:  The main purpose of this banner is to flush the changes file."	SmalltalkImage current logChange: '----End fileIn of ' , self name , '----'.	^ val! !!PositionableStream methodsFor: 'positioning' stamp: 'ul 2/22/2011 16:26'!positionOfSubCollection: subCollection ifAbsent: exceptionBlock	"Return a position such that that element at the new position equals the first element of sub, and the next elements equal the rest of the elements of sub. Begin the search at the current position.	If no such match is found, answer the result of evaluating argument, exceptionBlock."	| pattern startPosition currentPosition |	pattern := subCollection readStream.	startPosition := self position.	[ pattern atEnd or: [ self atEnd ] ] whileFalse: [		self next = pattern next ifFalse: [			self position: self position - pattern position + 1.			pattern reset ] ].	currentPosition := self position.	self position: startPosition.	pattern atEnd ifTrue: [ ^currentPosition + 1 - subCollection size ].	^exceptionBlock value! !!PositionableStream methodsFor: '*packageinfo-base' stamp: 'ul 6/17/2011 12:28'!untilEnd: aBlock displayingProgress: aString	aString		displayProgressFrom: 0 to: self size		during:			[:bar |			[self atEnd] whileFalse:				[bar value: self position.				aBlock value]].! !!PositionableStream methodsFor: '*Compression' stamp: 'ar 1/2/2000 15:32'!asZLibReadStream	^ZLibReadStream on: collection from: position+1 to: readLimit! !!PositionableStream methodsFor: 'accessing - multibyte support' stamp: 'ul 4/11/2011 04:19'!basicBack	^self back! !!PositionableStream methodsFor: 'accessing - multibyte support' stamp: 'ul 4/11/2011 04:22'!basicUpTo: anObject	^self next: anObject! !!PostscriptCanvas methodsFor: 'private' stamp: 'ul 11/15/2010 11:59'!endGStateForMorph: aMorph 	morphLevel = 1		ifTrue: [ target showpage; print: 'grestore'; cr ]! !!PostscriptCanvas methodsFor: 'private' stamp: 'cmm 6/21/2010 14:31'!setColor: color 	(color notNil and: [ currentColor ~= color ]) ifTrue:		[ target write: color asColor.		currentColor := color ]! !!PostscriptCanvas methodsFor: 'private' stamp: 'ul 11/15/2010 11:59'!setupGStateForMorph: aMorph 	morphLevel = 1		ifTrue: [self writePageSetupFor: aMorph]! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'ul 11/15/2010 11:59'!postscriptFontInfoForFont: font	| decoded decodedName keys match fontName |	fontName := font textStyleName asString.	decoded := TextStyle decodeStyleName: fontName.	decodedName := decoded second.	keys := self fontMap keys asArray sort: [ :a :b | a size > b size ].	match := keys select: [ :k | decoded first = k or: [ fontName = k ] ].	match do: [ :key | | subD desired mask |		subD := self fontMap at: key.		desired := font emphasis.		mask := 31.		[			desired := desired bitAnd: mask.			subD at: desired ifPresent: [ :answer | ^answer].			mask := mask bitShift: -1.			desired > 0		] whileTrue.	].	"No explicit lookup found; try to convert the style name into the canonical Postscript name.	This name will probably still be wrong."	fontName := String streamContents: [ :s |		s nextPutAll: decodedName.		decoded third do: [ :nm | s nextPut: $-; nextPutAll: nm ].		(font emphasis = 0 and: [ (decoded last includes: 0) not ])			ifTrue: [ s nextPutAll:  '-Regular' ].		(font emphasis = 1 and: [ (decoded first anyMask: 1) not ])			ifTrue: [ s nextPutAll:  '-Bold' ].		(font emphasis = 2 and: [ (decoded first anyMask: 2) not ])			ifTrue: [ s nextPutAll:  '-Italic' ].		(font emphasis = 3 and: [ (decoded first anyMask: 3) not ])			ifTrue: [ s nextPutAll:  '-BoldItalic' ].	].	^ {fontName. 1.0}! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'nice 12/29/2010 14:58'!subCanvas:patchRect	subCanvas ifNil:		[ subCanvas := PostscriptCanvas new reset setOrigin:patchRect topLeft clipRect: (-10000 @ -10000 extent: 20000 @ 20000)].	^subCanvas.! !!Pragma methodsFor: 'comparing' stamp: 'eem 10/4/2011 10:41'!= anObject 	^self class == anObject class	  and: [keyword == anObject keyword	  and: [arguments = anObject arguments]]! !!Pragma methodsFor: 'comparing' stamp: 'eem 10/4/2011 10:41'!hash	^keyword hash + arguments hash! !!Pragma commentStamp: 'fbs 5/8/2011 18:21' prior: 0!I represent an occurrence of a pragma in a compiled method.  A pragma is a literal message pattern that occurs between angle brackets at the start of a method after any temporaries.  A common example is the primitive pragma:	<primitive: 123 errorCode: 'errorCode'>but one can add one's own and use them as metadata attached to a method.  Because pragmas are messages one can browse senders and implementors and perform them.  One can query a method for its pragmas by sending it the pragmas message, which answers an Array of instances of me, one for each pragma in the method.I can provide information about the defining class, method, its selector, as well as the information about the pragma keyword and its arguments. See the two 'accessing' protocols for details. 'accessing-method' provides information about the method the pragma is found in, while 'accessing-pragma' is about the pragma itself.Instances are retrieved using one of the pragma search methods of the 'finding' protocol on the class side.To browse all methods with pragmas in the system evaluate	SystemNavigation default browseAllSelect: [:m| m pragmas notEmpty]and to browse all nonprimitive methods with pragmas evaluate	SystemNavigation default browseAllSelect: [:m| m primitive isZero and: [m pragmas notEmpty]]!!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'nice 12/29/2010 14:58'!adjustBookControls	| inner |	proceedButton ifNil: [^ self].	proceedButton align: proceedButton topLeft with: (inner := self innerBounds) topLeft + (35 @ -4).	debugButton align: debugButton topRight with: inner topRight - (16 @ 4).! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'mir 11/10/2003 15:15'!storeLog	model storeLog! !!PreferenceBrowser methodsFor: 'user interface' stamp: 'bf 4/12/2011 12:17'!initialExtent	^ 660@440! !!Preferences commentStamp: '<historical>' prior: 0!A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  	To open the control panel:		Preferences openFactoredPanel	To read how to use the panel (and how to make a preference be per-project):		 Preferences giveHelpWithPreferencesAll messages are on the class side.To query a a preference:	Preferences logDebuggerStackToFileor some people prefer the more verbose	Preferences valueOfFlag: #logDebuggerStackToFileYou can make up a new preference any time.  Do not define a new message in Preferences class. Accessor methods are compiled automatically when you add a preference as illustrated below:To add a preference (e.g. in the Postscript of a fileout):	Preferences addPreference: #samplePreference categories: #(general browsing)		default: true balloonHelp: 'This is an example of a preference added by a do-it'		projectLocal: false changeInformee: nil changeSelector: nil.To change a preference programatically:	Preferences disable: #logDebuggerStackToFile.Or to turn it on,	Preferences enable: #logDebuggerStackToFile.!!Preferences class methodsFor: 'accessing' stamp: 'ul 1/10/2011 15:53'!accessDictionaryOfPreferencesIn: aBlock	^(AccessLock ifNil: [ AccessLock := Mutex new ])		critical: [ aBlock value: DictionaryOfPreferences ]! !!Preferences class methodsFor: 'accessing' stamp: 'ul 1/10/2011 16:37'!dictionaryOfPreferences	"The use of this accessor doesn't ensure that the dictionary is not accessed concurrently. Use #accessDictionaryOfPreferencesIn: instead."	^DictionaryOfPreferences! !!Preferences class methodsFor: 'add preferences' stamp: 'ul 1/10/2011 15:59'!addPreference: aName categories: categoryList default: aValue balloonHelp: helpString projectLocal: localBoolean changeInformee: informeeSymbol changeSelector: aChangeSelector type: aType	"Add or replace a preference as indicated.  Reuses the preexisting Preference object for this symbol, if there is one, so that UI artifacts that interact with it will remain valid."	| aPreference aPrefSymbol |	aPrefSymbol := aName asSymbol.	aPreference := self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences			 at:aPrefSymbol			 ifAbsent: [ Preference new ] ].	aPreference 		 name:aPrefSymbol		 defaultValue:aValue		 helpString:helpString		 localToProject:localBoolean		 categoryList:categoryList		 changeInformee:informeeSymbol		 changeSelector:aChangeSelector		 type: aType.	self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences at: aPrefSymbol put: aPreference ].	self  compileAccessMethodForPreference:aPreference! !!Preferences class methodsFor: 'fonts' stamp: 'ul 11/25/2010 23:37'!restoreDefaultFonts	"Since this is called from menus, we can take the opportunity to prompt for missing font styles."	"	Preferences restoreDefaultFonts	"	self setDefaultFonts: #(		(setSystemFontTo:			'Bitmap DejaVu Sans'		9)		(setListFontTo:				'Bitmap DejaVu Sans'		9)		(setFlapsFontTo:			Accushi						12)		(setEToysFontTo:			BitstreamVeraSansBold		9)		(setPaintBoxButtonFontTo:	BitstreamVeraSansBold		9)		(setMenuFontTo:			'Bitmap DejaVu Sans'		9)		(setWindowTitleFontTo:		'Bitmap DejaVu Sans Bold'	9)		(setBalloonHelpFontTo:		'Bitmap DejaVu Sans'		7)		(setCodeFontTo:			'Bitmap DejaVu Sans'		9)		(setButtonFontTo:			'Bitmap DejaVu Sans'	7)	)! !!Preferences class methodsFor: 'fonts' stamp: 'ar 7/21/2010 20:13'!restoreFontsAfter: aBlock	"Restore the currently chosen set of standard fonts after 	evaluating aBlock. Used for tests that modify the default fonts."	| standardDefaultTextFont standardListFont standardEToysFont standardMenuFont 	windowTitleFont standardBalloonHelpFont standardCodeFont standardButtonFont |	standardDefaultTextFont := Preferences standardDefaultTextFont.	standardListFont := Preferences standardListFont.	standardEToysFont := Preferences standardEToysFont.	standardMenuFont := Preferences standardMenuFont.	windowTitleFont := Preferences windowTitleFont.	standardBalloonHelpFont := Preferences standardBalloonHelpFont.	standardCodeFont := Preferences standardCodeFont.	standardButtonFont := Preferences standardButtonFont.	^aBlock ensure: [		Preferences setSystemFontTo: standardDefaultTextFont.		Preferences setListFontTo: standardListFont.		Preferences setEToysFontTo: standardEToysFont.		Preferences setMenuFontTo: standardMenuFont.		Preferences setWindowTitleFontTo: windowTitleFont.		Preferences setBalloonHelpFontTo: standardBalloonHelpFont.		Preferences setCodeFontTo: standardCodeFont.		Preferences setButtonFontTo: standardButtonFont.	].! !!Preferences class methodsFor: 'initialization' stamp: 'ul 5/22/2010 01:34'!compileAccessMethodForPreference: aPreference	"Compile an accessor method for the given preference"	self class 		compileSilently: (			'{1} ^self valueOfFlag: {2} ifAbsent: [ {3} ]'				format: {					aPreference name asString.					aPreference name asSymbol printString.					aPreference defaultValue storeString }) 		classified: '*autogenerated - standard queries'! !!Preferences class methodsFor: 'initialization' stamp: 'ul 1/10/2011 16:25'!removePreference: aSymbol 	"Remove all memory of the given preference symbol in my various structures."	| pref |	pref := self  preferenceAt:aSymbol  ifAbsent:[^ self].	pref localToProject 		 ifTrue:			[Project  allInstancesDo:					[:proj | 					proj projectPreferenceFlagDictionary  ifNotNil:							[proj projectPreferenceFlagDictionary  removeKey:aSymbol  ifAbsent:[]]]].	self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences removeKey: aSymbol ifAbsent: [] ].	self class  removeSelector:aSymbol	"Preferences removePreference: #tileToggleInBrowsers"! !!Preferences class methodsFor: 'misc' stamp: 'HenrikSperreJohansen 1/21/2011 19:44'!defaultValueTableForCurrentRelease	"Answer a table defining default values for all the preferences in the release.  Returns a list of (pref-symbol, boolean-symbol) pairs"	^  #(		(abbreviatedBrowserButtons false)		(alternativeBrowseIt false)		(annotationPanes false)		(areaFillsAreTolerant false)		(areaFillsAreVeryTolerant false)		(automaticFlapLayout true)		(automaticKeyGeneration false)		(automaticPlatformSettings true)		(automaticViewerPlacement true)		(balloonHelpEnabled true)		(balloonHelpInMessageLists false)		(batchPenTrails false)		(browseWithDragNDrop false)		(browseWithPrettyPrint false)		(browserShowsPackagePane false)		(canRecordWhilePlaying false)		(capitalizedReferences true)		(caseSensitiveFinds false)		(cautionBeforeClosing false)		(changeSetVersionNumbers true)		(checkForSlips true)		(checkForUnsavedProjects true)		(classicNavigatorEnabled false)		(clickOnLabelToEdit false)		(cmdDotEnabled true)		(collapseWindowsInPlace false)		(compactViewerFlaps false)		(compressFlashImages false)		(confirmFirstUseOfStyle true)		(conversionMethodsAtFileOut false)		(cpuWatcherEnabled false)		(debugHaloHandle true)		(debugPrintSpaceLog false)		(debugShowDamage false)		(decorateBrowserButtons true)		(diffsInChangeList true)		(diffsWithPrettyPrint false)		(dismissAllOnOptionClose false)		(dragNDropWithAnimation false)		(eToyFriendly false)		(eToyLoginEnabled false)		(enableLocalSave true)		(extractFlashInHighQuality true)		(extractFlashInHighestQuality false)		(fastDragWindowForMorphic true)		(fenceEnabled true)		(fullScreenLeavesDeskMargins true)		(haloTransitions false)		(hiddenScrollBars false)		(higherPerformance false)		(honorDesktopCmdKeys true)		(ignoreStyleIfOnlyBold true)		(includeSoundControlInNavigator false)		(infiniteUndo false)		(logDebuggerStackToFile true)		(magicHalos false)		(menuButtonInToolPane false)		(menuColorFromWorld false)		(menuKeyboardControl false)  		(modalColorPickers true)		(mouseOverForKeyboardFocus false)		(mouseOverHalos false)		(mvcProjectsAllowed true)		(navigatorOnLeftEdge true)		(noviceMode false)		(okToReinitializeFlaps true)		(optionalButtons true)		(passwordsOnPublish false)		(personalizedWorldMenu true)		(postscriptStoredAsEPS false)		(preserveTrash true)		(projectViewsInWindows true)		(projectZoom true)		(projectsSentToDisk false)		(promptForUpdateServer true)		(propertySheetFromHalo false)		(readDocumentAtStartup true)		(restartAlsoProceeds false)		(reverseWindowStagger true)		(roundedMenuCorners true)		(roundedWindowCorners true)		(scrollBarsNarrow false)		(scrollBarsOnRight true)		(scrollBarsWithoutMenuButton false)		(securityChecksEnabled false)		(selectiveHalos false)		(showBoundsInHalo false)		(showDirectionForSketches false)		(showDirectionHandles false)		(showFlapsWhenPublishing false)		(showProjectNavigator false)		(showSecurityStatus true)		(showSharedFlaps true)		(signProjectFiles true)		(simpleMenus false)		(slideDismissalsToTrash true)		(smartUpdating true)		(soundQuickStart false)		(stopSoundWhenDone false)		(soundEnabled true)		(startInUntrustedDirectory false)		(systemWindowEmbedOK false)		(thoroughSenders true)		(tileTranslucentDrag true)		(timeStampsInMenuTitles true)		(turnOffPowerManager false)		(twentyFourHourFileStamps true)		(typeCheckingInTileScripting true)		(uniTilesClassic true)		(uniqueNamesInHalos false)		(universalTiles false)		(unlimitedPaintArea false)		(updateSavesFile false)		(useButtonProprtiesToFire false)		(useUndo true)		(viewersInFlaps true)		(warnAboutInsecureContent true)		(warnIfNoChangesFile true)		(warnIfNoSourcesFile true))"Preferences defaultValueTableForCurrentRelease do:	[:pair | (Preferences preferenceAt: pair first ifAbsent: [nil]) ifNotNilDo:			[:pref | pref defaultValue: (pair last == true)]].Preferences chooseInitialSettings."! !!Preferences class methodsFor: 'parameters' stamp: 'ul 8/2/2011 20:07'!parameterAt: aKey ifAbsent: aBlock	"Answer the parameter saved at the given key; if there is no such key in the Parameters dictionary, evaluate aBlock"	^ Parameters at: aKey ifAbsent: aBlock! !!Preferences class methodsFor: 'personalization' stamp: 'ul 5/22/2010 01:33'!compileHardCodedPref: prefName enable: aBoolean	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"	self class 		compileSilently: (			'{1} ^{2}'				format: {					prefName asString.					aBoolean storeString })		classified: '*autogenerated - hard-coded prefs'.	"Preferences compileHardCodedPref: #testing enable: false"! !!Preferences class methodsFor: 'personalization' stamp: 'ul 1/10/2011 16:27'!savePersonalPreferences	"Save the current list of Preference settings as the user's personal choices"	self		setParameter:#PersonalDictionaryOfPreferences		to: (			self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |				dictionaryOfPreferences deepCopy ])! !!Preferences class methodsFor: 'personalization' stamp: 'ul 1/10/2011 16:27'!storePreferencesIn: aFileName 	| stream prefsSnapshot |	#(#Prevailing #PersonalPreferences )  do:[:ea | Parameters  removeKey:ea  ifAbsent:[]].	stream := ReferenceStream fileNamed: aFileName.	stream  nextPut:Parameters.	prefsSnapshot := self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences copy ].	prefsSnapshot keysAndValuesDo: [:key :pref | prefsSnapshot at: key put: pref asPreference].	stream  nextPut: prefsSnapshot.	Smalltalk isMorphic 		 ifTrue:[stream nextPut:World fillStyle]		 ifFalse:[stream nextPut:DesktopColor].	stream close! !!Preferences class methodsFor: 'preferences panel' stamp: 'ul 1/10/2011 16:01'!categoryNames	| aSet |	aSet := Set new.	self allPreferenceObjects do: [ :aPreference | 		aSet addAll: (			aPreference categoryList collect: [ :aCategory |				aCategory asSymbol ]) ].	^aSet! !!Preferences class methodsFor: 'preferences panel' stamp: 'ul 1/10/2011 16:06'!inspectPreferences	"Open a window on the current preferences dictionary, allowing the user to inspect and change the current preference settings.  This is fallen back upon if Morphic is not present. This is dangerous, the dictionary of preferences should not be accessed concurrently."	"Preferences inspectPreferences"	self dictionaryOfPreferences inspectWithLabel:'Preferences'! !!Preferences class methodsFor: 'preferences panel' stamp: 'ul 1/10/2011 16:24'!preferenceObjectsInCategory: aCategorySymbol 	"Answer a list of Preference objects that reside in the given category."	^self allPreferenceObjects select: [ :aPreference |		aPreference categoryList includes: aCategorySymbol ]! !!Preferences class methodsFor: 'preference-object access' stamp: 'ul 1/10/2011 15:59'!allPreferenceObjects	"Answer a list of all the Preference objects registered in the system"	^self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences values ]! !!Preferences class methodsFor: 'preference-object access' stamp: 'ul 1/10/2011 16:22'!preferenceAt: aSymbol 	"Answer the Preference object at the given symbol, or nil if not there"	^self preferenceAt: aSymbol ifAbsent: [ nil ]! !!Preferences class methodsFor: 'preference-object access' stamp: 'ul 1/10/2011 16:21'!preferenceAt: aSymbol ifAbsent: aBlock 	"Answer the Preference object at the given symbol, or the value of aBlock if not present"	^self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences at: aSymbol ifAbsent: aBlock ]! !!Preferences class methodsFor: 'reacting to change' stamp: 'ar 7/21/2010 20:20'!displaySizeChanged	self flag: #todo.	"only change font on small-land image"	self smallLandFonts.	self tinyDisplay		ifTrue: [self enable: #scrollBarsNarrow]		ifFalse: [self disable: #scrollBarsNarrow].	self tinyDisplay 		ifTrue:[self disable: #biggerHandles] 		ifFalse:[self enable: #biggerHandles]! !!Preferences class methodsFor: 'reacting to change' stamp: 'bp 1/8/2011 12:59'!noviceModeSettingChanged	"The current value of the noviceMode flag has changed;  	now react"	TheWorldMainDockingBar updateInstances.	PasteUpMorph allSubInstances		select: [:each | each isWorldMorph]		thenDo: [:each | each initializeDesktopCommandKeySelectors].	Smalltalk at: #ParagraphEditor ifPresent: [:aClass| aClass initialize]! !!Preferences class methodsFor: 'standard queries' stamp: 'sbw 4/24/2010 10:16'!annotationPanes	^ self		valueOfFlag: #annotationPanes		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries' stamp: 'cmm 1/11/2011 21:10'!showBoundsInHalo	^ self		valueOfFlag: #showBoundsInHalo		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries' stamp: 'cmm 1/10/2011 14:07'!showSplitterHandles	^ self		valueOfFlag: #showSplitterHandles		ifAbsent: [false]! !!Preferences class methodsFor: 'standard queries' stamp: 'mir 11/10/2003 14:28'!standaloneSecurityChecksEnabled	^ self		valueOfFlag: #standaloneSecurityChecksEnabled		ifAbsent: [false]! !!Preferences class methodsFor: 'window colors' stamp: 'bp 1/8/2011 13:00'!installPastelWindowColors	"Install the factory-provided default pastel window colors for all tools"	"Preferences installPastelWindowColors"	self installWindowColorsVia: [:aSpec | aSpec pastelColor]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22'!installUniformWindowColors	"Install the factory-provided uniform window colors for all tools"	"Preferences installUniformWindowColors"	self installWindowColorsVia: [:aQuad | self uniformWindowColor]! !!Preferences class methodsFor: 'window colors' stamp: 'bp 1/8/2011 12:56'!installWindowColorsVia: colorSpecBlock	"Install windows colors using colorSpecBlock to deliver the color source for each element; the block is handed a WindowColorSpec object"	"Preferences installBrightWindowColors"		WindowColorRegistry refresh.	self windowColorTable do:		[:aColorSpec | | color |			color := (Color colorFrom: (colorSpecBlock value: aColorSpec)).			self setWindowColorFor: aColorSpec classSymbol to: color].	SystemWindow withAllSubclasses do: [:c | 		c allInstances do: [:w | w refreshWindowColor]].	TheWorldMainDockingBar updateInstances! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22'!uniformWindowColor	^Color veryVeryLightGray! !!Preferences class methodsFor: 'dynamic preferences' stamp: 'ul 1/10/2011 16:20'!prefEvent: anEvent	"Check if this system event defines or removes a preference.	TODO: Queue the event and handle in background process. 	There is zero reason to be so eager here."	| aClass aSelector prefSymbol method |	(anEvent itemKind = SystemChangeNotifier classKind and: [anEvent isRemoved])		ifTrue:[self removePreferencesFor: anEvent item].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue:[		aClass := anEvent itemClass.		aClass isMeta ifFalse:[^self]. "ignore instance methods"		aClass := aClass theNonMetaClass.		aSelector := anEvent itemSelector.		(anEvent isRemoved or:[anEvent isModified]) ifTrue:[			prefSymbol := (aClass name,'>>', aSelector) asSymbol.			self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |				dictionaryOfPreferences removeKey: prefSymbol ifAbsent:[] ] ].		(anEvent isAdded or:[anEvent isModified]) ifTrue:[			method := anEvent item.			method pragmas do:[:pragma| | aPreference aPrefSymbol |				pragma keyword == #preference:category:description:type: ifTrue:[					aPrefSymbol := (aClass name,'>>', method selector) asSymbol.					aPreference := self 						preference: pragma arguments first						category: pragma arguments second 						description: pragma arguments third						type: pragma arguments fourth.					aPreference 						provider: aClass 						getter: method selector 						setter: method selector asMutator.					self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |						dictionaryOfPreferences at: aPrefSymbol put: aPreference ] ] ] ] ].! !!Preferences class methodsFor: 'dynamic preferences' stamp: 'ul 1/10/2011 16:24'!registerForEvents	"Preferences registerForEvents"		SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #prefEvent:.	Smalltalk allClassesDo:[:aClass|		aClass class methodsDo:[:method|			method pragmas do:[:pragma| | aPreference aPrefSymbol |				pragma keyword == #preference:category:description:type: ifTrue:[					aPrefSymbol := (aClass name,'>>', method selector) asSymbol.					aPreference := self 						preference: pragma arguments first						category: pragma arguments second 						description: pragma arguments third						type: pragma arguments fourth.					aPreference 						provider: aClass 						getter: method selector 						setter: method selector asMutator.					self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |						dictionaryOfPreferences at: aPrefSymbol put: aPreference ] ] ] ] ].! !!Preferences class methodsFor: 'dynamic preferences' stamp: 'ul 1/10/2011 16:27'!removePreferencesFor: aClass	"Remove all the preferences registered for the given class"	"Preferences removePreferencesFor: PreferenceExample"	self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		| map |		map := dictionaryOfPreferences select: [ :pref | pref provider == aClass ].		map keysDo: [ :prefName | dictionaryOfPreferences removeKey: prefName ] ]! !!Preferences class methodsFor: 'sound' stamp: 'HenrikSperreJohansen 1/21/2011 19:40'!soundEnablingString	self deprecated: 'Ask the sound service for this'.	^ SoundService soundEnablingString! !!Preferences class methodsFor: 'sound' stamp: 'cmm 6/21/2011 15:27'!toggleSoundEnabling	self deprecated: 'Now uses pragma preference, and is stored in SoundService'.    SoundService toggleSoundEnabled! !!PrimCallControllerAbstract commentStamp: 'nice 3/25/2010 23:02' prior: 0!A PrimCallController (PCC) serves for switching external prim calls (primitiveExternalCall) on and off: this is an abstract class, instantiate one of the subclasses PCCByLiterals and PCCByCompilation.External prim calls are used to access internal and external modules (plugins) as shown by	SmalltalkImage current listLoadedModules.	SmalltalkImage current listBuiltinModules.Note: not loaded external modules (since they have not been called so far) are not shown by these methods.Highlight: dis/en-abling prims by a PCC works for both internal and external modules!!To help you choosing the right subclass, some properties are listed in the following table:Functionality/Property							|	PCCByLiterals	PCCByCompilation------------------------------------------------------------------------------------------------------testing plugins									|		suited			not suitedpermanent disabling of external prim calls		|		no				yes------------------------------------------------------------------------------------------------------method changes visible in changeset				|		no				yesenabling survives snapshot/compilation			|		yes				yesdisabling survives snapshot/compilation			|		no				yesspeed disabling									|		fast				mediumspeed enabling									|		fast				slowCompiledMethod pointer valid after en/dis-abling	|		yes				no									Important: Be careful with mixing the use of different PCCs!! PCCByLiterals does not see prims disabled by PCCByCompilation and vice versa. For playing around you should start with PCCByLiterals; use PCCByCompilation only, if you know what you are doing!!In protocols 'ui controlling', 'ui logging' and 'ui querying' (please look into this class) are the most important user interface methods. Thereafter the methods in 'ui testing' could be of interest.Useful expressions:Controlling:	"Factorial example"	| pcc tDisabled tEnabled tEnabled2 |	pcc := PCCByLiterals new logStream: Transcript. "logStream set here for more info"	pcc disableCallsIntoModule: 'LargeIntegers'.	tDisabled := [1000 factorial] timeToRun.	pcc enableDisabled.	tEnabled := [1000 factorial] timeToRun.	tEnabled2 := [1000 factorial] timeToRun.	{tDisabled. tEnabled. tEnabled2}Note: You shouldn't switch off module 'LargeIntegers' for a longer time, since this slows down your system.Querying:	PCCByLiterals new methodsWithCall.								"all calls"	PCCByLiterals new methodsWithCall: 'prim1'.						"call in all modules or without module"	PCCByLiterals new methodsWithCallIntoModule: nil.				"all calls without module"	PCCByLiterals new methodsWithCallIntoModule: 'LargeIntegers'.	"all calls into module 'LargeIntegers'"	PCCByLiterals new		methodsWithCallIntoModule: 'LargeIntegers'		forClass: Integer.							"all calls into module 'LargeIntegers' in class Integer"	PCCByLiterals new		methodsWithCallIntoModule: 'LargeIntegers'		forClasses: Integer withAllSubclasses.		"all calls into module 'LargeIntegers' in class Integer withAllSubclasses"	| pcc | (pcc := PCCByLiterals new) methodsWithCall			collect: [:mRef | {mRef. pcc extractCallModuleNames: mRef}].Structure: treatedMethods				Dictionary of MethodReferences->#disabled/#enabled								-- contains changed methods and how they are changed last logStream					WriteStream -- shows info about changed methods ifNotNil changeStatusOfFailedCalls	Boolean -- if status of failed calls should be changed, default is false!!Process methodsFor: 'accessing' stamp: 'svp 12/5/2002 14:42'!name	^name ifNil: [ self hash asString forceTo: 5 paddingStartWith: $ ]! !!Process methodsFor: '*KernelTests-Processes' stamp: 'ar 12/31/2010 09:30'!suspendPrimitivelyOrFail	"Test support. Execute primitive 88, or fail."	<primitive: 88>	^self primitiveFailed! !!Process methodsFor: 'process specific' stamp: 'GiovanniCorriga 8/30/2009 15:42'!environmentAt: key 	^ self environmentAt: key ifAbsent: [self environmentKeyNotFound]! !!Process methodsFor: 'process specific' stamp: 'ul 8/16/2011 11:24'!environmentAt: key  ifAbsent: aBlock		^(env ifNil: [ ^aBlock value ]) at: key ifAbsent: aBlock.! !!Process methodsFor: 'process specific' stamp: 'ul 8/16/2011 11:24'!environmentAt: key put: value		^(env ifNil: [ env := Dictionary new ]) at: key put: value.! !!Process methodsFor: 'process specific' stamp: 'GiovanniCorriga 8/30/2009 15:40'!environmentKeyNotFound 	self error: 'Environment key not found'! !!Process methodsFor: 'process specific' stamp: 'GiovanniCorriga 8/30/2009 15:43'!environmentRemoveKey: key	^ self environmentRemoveKey: key ifAbsent: [self environmentKeyNotFound]! !!Process methodsFor: 'process specific' stamp: 'ul 8/16/2011 11:25'!environmentRemoveKey: key ifAbsent: errorBlock		^(env ifNil: [ ^errorBlock value ]) removeKey: key ifAbsent: errorBlock! !!Process commentStamp: 'ul 3/22/2011 05:18' prior: 0!I represent an independent path of control in the system. This path of control may be stopped (by sending the message suspend) in such a way that it can later be restarted (by sending the message resume). When any one of several paths of control can be advanced, the single instance of ProcessorScheduler named Processor determines which one will actually be advanced partly using the value of priority.(If anyone ever makes a subclass of Process, be sure to use allSubInstances in anyProcessesAbove:.)The threadId variable is used by multi-threaded CogVMs to control process-to-thread binding. It's required to be the fourth instance variable. See SmalltalkImage >> #processHasThreadIdInstVar: for further information.The island and env instance variables are not used by core squeak, but are used by external packages and included here because Monticello cannot handle external instance variables:island: used by Tweak and Croquet to partition the image into multiple address spacesenv: used by ProcessSpecific to implement per-process variables!!ProcessBrowser class methodsFor: 'class initialization' stamp: 'mtf 1/12/2011 19:34'!cleanUp"Remove terminated processes from my suspended list"	self suspendedProcesses keys do: [:ea |		ea isTerminated ifTrue: [self suspendedProcesses removeKey: ea]]! !!ProcessLocalVariable commentStamp: 'mvl 3/13/2007 12:28' prior: 0!My subclasses have values specific to the active process. They can be read with #value and set with #value:!!ProcessLocalVariable class methodsFor: 'accessing' stamp: 'ul 9/17/2011 17:41'!value: anObject		^Processor activeProcess environmentAt: self put: anObject! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'mvl 3/13/2007 14:13'!checkDynamic: value	self assert: TestDynamicVariable value = value! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'mvl 3/13/2007 14:13'!checkLocal: value	self assert: TestLocalVariable value = value! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'ul 9/17/2011 17:48'!testAssignmentToLocalVariableReturnsTheValue	self assert: 1 equals: (TestLocalVariable value: 1)! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'mvl 3/13/2007 15:02'!testDynamicVariable	| s1 s2 p1stopped p2stopped |	s1 := Semaphore new.	s2 := Semaphore new.	p1stopped := p2stopped := false.	[		TestDynamicVariable value: 1 during:[			self checkDynamic: 1.			(Delay forMilliseconds: 30) wait.			self checkDynamic: 1.			TestDynamicVariable value: 3 during:[				(Delay forMilliseconds: 30) wait.				self checkDynamic: 3			].			self checkDynamic: 1.		].		self checkDynamic: nil.		p1stopped := true.		s1 signal.	] fork.	[		TestDynamicVariable value: 2 during:[			self checkDynamic: 2.			(Delay forMilliseconds: 30) wait.			self checkDynamic: 2.		].		self checkDynamic: nil.		p2stopped := true.		s2 signal.	] fork.	"Set a maximum wait timeout so that the test case will complete 	 even if the processes fail to signal us."	s1 waitTimeoutSeconds: 2.	s2 waitTimeoutSeconds: 2.	self assert: p1stopped.	self assert: p2stopped.! !!ProcessSpecificTest methodsFor: 'testing' stamp: 'mvl 3/13/2007 15:03'!testLocalVariable	| s1 s2 p1stopped p2stopped |	s1 := Semaphore new.	s2 := Semaphore new.	p1stopped := p2stopped := false.	[		self checkLocal: 0.		TestLocalVariable value: 1.		self checkLocal: 1.		(Delay forMilliseconds: 30) wait.		self checkLocal: 1.		TestLocalVariable value: 2.		self checkLocal: 2.		p1stopped := true.		s1 signal.	] fork.	[		(Delay forMilliseconds: 30) wait.		self checkLocal: 0.		TestLocalVariable value: 3.		self checkLocal: 3.		(Delay forMilliseconds: 30) wait.		self checkLocal: 3.		TestLocalVariable value: 4.		self checkLocal: 4.		p2stopped := true.		s2 signal.	] fork.	"Set a maximum wait timeout so that the test case will complete 	 even if the processes fail to signal us."	s1 waitTimeoutMSecs: 5000.	s2 waitTimeoutMSecs: 5000.	self assert: p1stopped.	self assert: p2stopped.! !!ProcessSpecificTest methodsFor: 'running' stamp: 'ul 9/17/2011 17:50'!tearDown	"Make sure we don't pollute the running process' environment with the test variables"	{ TestLocalVariable. TestDynamicVariable } do: [ :each |		Processor activeProcess environmentRemoveKey: each ifAbsent: [] ]! !!ProcessSpecificTest commentStamp: 'mvl 3/13/2007 13:52' prior: 0!A ProcessSpecificTest is a test case for process local and dynamic variables.!!ProcessSpecificVariable commentStamp: 'mvl 3/13/2007 13:53' prior: 0!My subclasses (not instances of them) keep state specific to the current process.There are two kinds of process-specific variables: process-local (state availablefor read and write in all methods inside the process), and dynamic variables(implementing dynamic scope).!!ProcessSpecificVariable class methodsFor: 'accessing' stamp: 'mvl 3/13/2007 14:32'!default	"Answer the default value for the variable. The default for the default value is nil."	^nil! !!ProcessSpecificVariable class methodsFor: 'accessing' stamp: 'ul 8/16/2011 11:22'!hash		^hash ifNil: [ hash := super hash ]! !!ProcessSpecificVariable class methodsFor: 'accessing' stamp: 'mvl 3/13/2007 14:33'!value	"Answer the current value for this variable in the current context."	^Processor activeProcess environmentAt: self ifAbsent: [self default].! !!ProcessTest methodsFor: 'tests' stamp: 'ar 12/31/2010 10:36'!testAtomicSuspend	"Test atomic suspend of foreign processes"	| list p sema |	sema := Semaphore new.	p := [sema wait] fork.	Processor yield.	self shouldnt: [list := p suspendPrimitivelyOrFail] raise: Error.	self assert: list == sema.! !!ProcessTest methodsFor: 'running' stamp: 'GiovanniCorriga 8/30/2009 15:53'!tearDown	Processor activeProcess environmentRemoveKey: #processTests ifAbsent: []! !!ProcessTest methodsFor: 'testing' stamp: 'GiovanniCorriga 8/30/2009 15:58'!testEnvironmentAt	Processor activeProcess environmentAt: #processTests put: 42.	self assert: (Processor activeProcess environmentAt: #processTests) = 42.	self should: [Processor activeProcess environmentAt: #foobar] raise: Error! !!ProcessTest methodsFor: 'testing' stamp: 'GiovanniCorriga 8/30/2009 15:53'!testEnvironmentAtPut	self assert: (Processor activeProcess environmentAt: #processTests put: 42) = 42.! !!ProcessTest methodsFor: 'testing' stamp: 'GiovanniCorriga 8/30/2009 16:03'!testEnvironmentRemoveKey	Processor activeProcess environmentAt: #processTests put: 42.	Processor activeProcess environmentRemoveKey: #processTests.	self assert: (Processor activeProcess environmentAt: #processTests ifAbsent: []) isNil.	self should: [Processor activeProcess environmentAt: #processTests] raise: Error! !!ProcessTest commentStamp: 'ul 8/16/2011 11:35' prior: 0!I hold test cases for generic Process-related behaviour.!!ProcessorScheduler class methodsFor: 'background process' stamp: 'ul 6/17/2011 12:41'!idleProcess	"A default background process which is invisible."	[self relinquishProcessorForMicroseconds: 1000] repeat! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'ul 6/17/2011 12:41'!sweepHandIdleProcess	"A default background process which shows a sweeping circle of XOR-ed bits on the screen."	| sweepHand |	sweepHand := Pen new.	sweepHand defaultNib: 2.	sweepHand combinationRule: 6.	[		2 timesRepeat: [			sweepHand north.			36 timesRepeat: [				sweepHand place: Display boundingBox topRight + (-25@25).				sweepHand go: 20.				sweepHand turn: 10]].		self relinquishProcessorForMicroseconds: 10000] repeat! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'cmm 10/17/2011 23:10'!defaultAction	self resume! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'cmm 10/17/2011 23:10'!defaultResumeValue	^ UIManager default		displayProgress: progressTitle		at: aPoint		from: minVal		to: maxVal		during: workBlock! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 5/15/2000 11:43'!display: argString at: argPoint from: argMinVal to: argMaxVal during: argWorkBlock	progressTitle := argString.	aPoint := argPoint.	minVal := argMinVal.	maxVal := argMaxVal.	workBlock := argWorkBlock.	^self signal! !!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'RAA 5/15/2000 12:40'!sendNotificationsTo: aNewBlock	self resume: (		workBlock value: [ :barVal |			aNewBlock value: minVal value: maxVal value: barVal		]	)! !!ProgressInitiationException commentStamp: '<historical>' prior: 0!I provide a way to alter the behavior of the old-style progress notifier in String. See examples in:ProgressInitiationException testWithout.ProgressInitiationException testWith.!!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'cmm 6/15/2011 10:57'!testInnermost	"test the progress code WITHOUT special handling"	^'Now here''s some Real Progress'		displayProgressFrom: 0 		to: 10		during: [ :bar |			1 to: 10 do: [ :x | 				bar value: x. (Delay forMilliseconds: 500) wait.				x = 5 ifTrue: [1/0].	"just to make life interesting"			].			'done'		].! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 12:42'!testWith	"test progress code WITH special handling of progress notifications"	^[ self testWithAdditionalInfo ] 		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				Transcript show: min printString,'  ',max printString,'  ',curr printString; cr			].		].! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 12:04'!testWithAdditionalInfo	^{'starting'. self testWithout. 'really!!'}! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 15:45'!testWithout	"test the progress code WITHOUT special handling"	^[self testInnermost]		on: ZeroDivide		do: [ :ex | ex resume]! !!ProgressInitiationException class methodsFor: 'signalling' stamp: 'cmm 6/14/2011 22:17'!display: aString at: aPoint from: minVal to: maxVal during: workBlock 	^ self new		display: aString		at: (aPoint ifNil: [ self preferredProgressBarPoint ])		from: minVal		to: maxVal		during: workBlock! !!ProgressInitiationException class methodsFor: 'signalling' stamp: 'cmm 6/14/2011 19:15'!display: aString from: minVal to: maxVal during: workBlock 	^ self		display: aString		at: nil		from: minVal		to: maxVal		during: workBlock! !!ProgressInitiationException class methodsFor: 'accessing' stamp: 'cmm 6/15/2011 14:52'!preferredProgressBarPoint	^ self preferredProgressBarPosition = #cursorPoint		ifTrue: [ Sensor cursorPoint ]		ifFalse: [ UIManager default screenBounds perform: self preferredProgressBarPosition ]! !!ProgressInitiationException class methodsFor: 'accessing' stamp: 'cmm 6/14/2011 22:19'!preferredProgressBarPosition	^ PreferredProgressBarPosition ifNil: [ #center ]! !!ProgressInitiationException class methodsFor: 'accessing' stamp: 'cmm 6/15/2011 10:39'!preferredProgressBarPosition: aSymbol 	"Specify any of:  #center, #topCenter, #bottomCenter, #leftCenter, #rightCenter, #topLeft, #topRight, #bottomLeft or #bottomRight or #cursorPoint."	^ PreferredProgressBarPosition! !!Project methodsFor: 'accessing' stamp: 'dtl 5/2/2010 19:09'!uiManager	"Answer the manager that provides user interface services for this project "	^ uiManager		ifNil: [uiManager := Smalltalk						at: #UIManager						ifPresent: [:mgr | uiManager := mgr getDefault]]! !!Project methodsFor: 'accessing' stamp: 'ul 8/2/2011 20:08'!withChildrenDo: aBlock	"Evaluate the block first with the receiver as argument, then, recursively and depth first, with each of the receiver's children as argument"		aBlock value: self.	self children do: [:p | 		p withChildrenDo: aBlock ]! !!Project methodsFor: 'menu messages' stamp: 'cbr 5/1/2010 01:53'!toggleFullScreen	"Toggle between full screen and windowed mode."	self lastScreenModeSelected		ifTrue: [ self fullScreenOff ]		ifFalse: [ self fullScreenOn ]! !!Project methodsFor: 'project parameters' stamp: 'ul 8/2/2011 20:07'!projectParameterAt: aSymbol ifAbsent: aBlock	"Answer the project parameter stored at the given symbol, or the result of evaluating the block"	^ self projectParameters at: aSymbol ifAbsent: aBlock! !!Project methodsFor: 'project parameters' stamp: 'ul 8/2/2011 20:07'!projectPreferenceAt: aSymbol ifAbsent: aBlock	"Answer the project preference stored at the given symbol, or the result of evaluating the block"	^ self projectPreferenceFlagDictionary at: aSymbol ifAbsent: aBlock! !!Project methodsFor: 'scheduling' stamp: 'fm 9/11/2010 00:56'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	^ self subclassResponsibility! !!Project methodsFor: 'dispatching' stamp: 'dtl 2/27/2011 17:18'!dispatchTo: requestor addPrefixAndSend: baseSelector withArguments: arguments	"Sender wants to perform a method with dependencies on the type of project.	Dispatch to an appropriate method for the current project.		This method is a workaround for lack of proper ToolBuilder support in the sender,	and should be eliminated when possible (dtl Feb 2010)"	| selector |	"Flag target selectors to help identify senders"	true ifFalse: [		self flag: #mvcOpenLabel:in: .		self flag: #morphicOpenLabel:in: .		self flag: #mvcStartUpLeftFlush .		self flag: #morphicStartUpLeftFlush .		self flag: #mvcStartUpWithCaption:icon:at:allowKeyboard: .		self flag: #morphicStartUpWithCaption:icon:at:allowKeyboard: .		self flag: #mvcOpen: .		self flag: #morphicOpen: .		self flag: #mvcOpen .		self flag: #morphicOpen .		self flag: #mvcOpenOn:context:label:contents:fullView: .		self flag: #morphicOpenOn:context:label:contents:fullView:	].	selector := (self selectorPrefixForDispatch, baseSelector) asSymbol.	^ requestor perform: selector withArguments: arguments! !!Project commentStamp: 'cbr 7/27/2010 21:36' prior: 0!A Project stores the state of a complete Squeak desktop, includingthe windows, and the currently active changeSet.  A project knows whoits parent project is.  When you change projects, whether by enteringor exiting, the screen state of the project being exited is saved inthat project.A project is retained by its view in the parent world.  It iseffectively named by the name of its changeSet, which can be changedeither by renaming in a changeSorter, or by editing the label of itsview from the parent project.As the site of major context switch, Projects are the locus ofswapping between the old MVC and the new Morphic worlds.  Thedistinction is based on whether the variable 'world' contains aWorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Projectnamed: 'xxx') exportSegment, or choose 'store project on file...'.Projects may be loaded from a server and stored back.  Storing on aserver never overwrites;  it always makes a new version.  A projectremembers the url of where it lives in urlList.  The list is lengthone, for now.  The url may point to a local disk instead of a server.All projects that the user looks at are cached in the Squeakletfolder.  Sorted by server.  The cache holds the most recent versiononly.When a project is loaded into Squeak, its objects are converted tothe current version.  There are three levels of conversion.  First,each object is converted from raw bits to an object in its oldformat.  Then it is sent some or all of these messages:	comeFullyUpOnReload: smartRefStream  		Used tore-discover an object that already exists in this image, such as aresource, global variable, Character, or Symbol.  (sent to objects inoutPointers)	convertToCurrentVersion: varDict refStream: smartRefStrm		fill in fields that have been added to a class sincethe object was stored.  Used to set the extra inst var to a defaultvalue.  Or, return a new object of a different class.  (sent toobjects that changed instance variables)	fixUponLoad: aProject refStream: smartRefStrm	change the object due to conventions that have changed on theproject level.  (sent to all objects in the incoming project)Here is the calling sequence for storing out a Project:Project saveAsProject storeOnServerProject storeOnServerWithProgressInfoProject storeOnServerInnardsProject exportSegmentFileName:directory:Project exportSegmentWithChangeSet:fileName:directory:ImageSegment writeForExportWithSources:inDirectory:changeSet:!!Project class methodsFor: 'utilities' stamp: 'fm 9/11/2010 01:15'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	self flag: #toRemove. "after restarting the user interrupt watcher process"	^ self current interruptName: labelString! !!Project class methodsFor: 'utilities' stamp: 'ul 6/17/2011 12:42'!spawnNewProcess	UIProcess := [		[World doOneCycle.  Processor yield ] repeat.	] newProcess priority: Processor userSchedulingPriority.	UIProcess resume! !!ProjectLauncher methodsFor: 'running' stamp: 'ar 6/21/2010 20:33'!startUpAfterLogin	| scriptName loader isUrl |	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName := self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName := (Smalltalk documentPath) ifNil:[''].			scriptName := scriptName convertFromSystemString.			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl := (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[					"Allow for ../dir/scriptName arguments"					scriptName := (FileDirectory default uri 						resolveRelativeURI: scriptName) asString]].		]. ]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader := CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!ProjectLoading class methodsFor: 'loading' stamp: 'ul 4/28/2010 12:35'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to berepresent a Morph saved via the SmartRefStream mechanism, and open itin an appropriate Morphic world."   	| morphOrList proj trusted localDir projStream archive mgrprojectsToBeDeleted baseChangeSet enterRestricted substituteFontnumberOfFontSubstitutes exceptions |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enterproject'.		"the hard part is over"		^self inform:'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,' translated	].	ProgressNotification signal: '2:fileSizeDetermined',preStream size printString.	preStream isZipArchive		ifTrue:[	archive := ZipArchive new readFrom: preStream.				projStream := selfprojectStreamFromArchive: archive]		ifFalse:[projStream := preStream].	trusted := SecurityManager default positionToSecureContentsOf:projStream.	trusted ifFalse:		[enterRestricted := (preStream isTypeHTTP or:[aFileName isNil])			ifTrue: [Preferences securityChecksEnabled]			ifFalse: [Preferences standaloneSecurityChecksEnabled].		enterRestricted			ifTrue: [SecurityManager default enterRestrictedMode				ifFalse:					[preStream close.					^ self]]].	localDir := Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) binary				nextPutAll: preStream contents;				close.		].	].	morphOrList := projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet := ChangeSet current.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	substituteFont := Preferences standardEToysFont copy.	numberOfFontSubstitutes := 0.	exceptions := Set new.	[[morphOrList := morphOrList fileInObjectAndCodeForProject]		on: FontSubstitutionDuringLoading do: [ :ex |				exceptions add: ex.				numberOfFontSubstitutes :=numberOfFontSubstitutes + 1.				ex resume: substituteFont ]]			ensure: [ ChangeSet  newChanges: baseChangeSet].	mgr := ResourceManager new initializeFrom: ResourceCollector current.	mgr fixJISX0208Resource.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName:aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj := morphOrList arrayOfRoots			detect: [:mm | mm isKindOf: Project]			ifNone: [^self inform: 'No project found inthis file'].		proj projectParameters at: #substitutedFont put: (			numberOfFontSubstitutes > 0				ifTrue: [substituteFont]				ifFalse: [#none]).		proj projectParameters at: #MultiSymbolInWrongPlace put: false.			"Yoshiki did not put MultiSymbols intooutPointers in older images!!"		morphOrList arrayOfRoots do: [:obj |			obj fixUponLoad: proj seg: morphOrList "imageSegment"].		(proj projectParameters at: #MultiSymbolInWrongPlace) ifTrue: [			morphOrList arrayOfRoots do: [:obj | (objisKindOf: HashedCollection) ifTrue: [obj rehash]]].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		proj setParent: Project current.		projectsToBeDeleted := OrderedCollection new.		existingView ifNil: [			ChangeSet allChangeSets add: proj changeSet.			Project current openProject: proj.				"Note: in MVC we get no further than the above"		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSet allChangeSets add: proj changeSet.		Project current projectParameters			at: #deleteWhenEnteringNewProject			ifPresent: [ :ignored |				projectsToBeDeleted add: Project current.				Project current removeParameter:#deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters				at: #projectsToBeDeleted				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	Project current openViewAndEnter: morphOrList! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'muOuser 12/2/2010 07:06'!findAProject	FileList2 		morphicViewProjectLoader2InWorld: World		reallyLoad: true		dirFilterType: #initialDirectoryList! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'ul 6/17/2011 12:28'!morphsForMyContentsFrom: listOfPages sizedTo: sz	| morphsForPageSorter |	'Assembling thumbnail images...'		displayProgressFrom: 0 to: listOfPages size		during: [:bar |			morphsForPageSorter := listOfPages withIndexCollect: [ :each :index | 				bar value: index.				self sorterMorphForProjectNamed: each first			].		].	^morphsForPageSorter! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:38'!bottomBoundary	"Answert the bottommost x position the receiver could be moved."	| splitter morphs |	splitter := self splitterBelow.	morphs := self commonNeighbours: rightOrBottom with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect bottom]				ifFalse: [owner innerBounds bottom]]		ifNotNil: [splitter top])		- (self minimumHeightOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'mt 4/21/2010 09:30:03.495'!leftBoundary	"Answer the leftmost y position the receiver could be moved."	| splitter morphs |	splitter := self splitterLeft.	morphs := self commonNeighbours: leftOrTop with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect left]				ifFalse: [owner innerBounds left]]		ifNotNil: [splitter right])		 + (self minimumWidthOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'mt 4/21/2010 09:30:13.634'!rightBoundary	"Answer the rightmost x position the receiver could be moved to."	| splitter morphs |	splitter := self splitterRight.	morphs := self commonNeighbours: rightOrBottom with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect right]				ifFalse: [owner innerBounds right]]		ifNotNil: [splitter left])		- (self minimumWidthOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:37'!topBoundary	"Answer the topmost x position the receiver could be moved to."	| splitter morphs |	splitter := self splitterAbove.	morphs := self commonNeighbours: leftOrTop with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect top]				ifFalse: [owner innerBounds top]]		ifNotNil: [splitter bottom])		+ (self minimumHeightOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'displaying' stamp: 'ar 6/23/2010 16:35'!handleSize	^ self class splitterWidth @ 30! !!ProtoObject methodsFor: 'system primitives' stamp: 'mtf 8/15/2008 17:19'!instVarsInclude: anObject"Answers true if anObject is among my named or indexed instance variables, and false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!ProtoObject methodsFor: 'testing' stamp: 'ul 8/12/2010 00:04'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!ProtoObject methodsFor: 'testing' stamp: 'ul 8/12/2010 00:04'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!ProtoObject methodsFor: 'testing' stamp: 'ul 8/12/2010 00:04'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!ProtoObject methodsFor: 'tracing' stamp: 'mtf 8/15/2008 18:40'!pointsTo: anObject"Answers true if I hold a reference to anObject, or false otherwise. Or stated another way:Answers true if the garbage collector would fail to collect anObject because I hold a reference to it, or false otherwise"	^ (self instVarsInclude: anObject)		or: [self class == anObject]! !!ProtocolClient methodsFor: 'private' stamp: 'kph 9/23/2008 00:33'!ensureConnection	self isConnected		ifTrue: [^self].	self stream		ifNotNil: [self stream close].	self stream: (SocketStream openConnectionToHost: self host port: self port timeout: self standardTimeout).	self checkResponse.	self login! !!ProtocolClient methodsFor: 'private' stamp: 'kph 9/23/2008 00:33'!standardTimeout	^ Socket standardTimeout! !!PseudoClass methodsFor: 'accessing' stamp: 'ul 4/2/2011 14:01'!newCompiler	"Answer a Compiler suitable for compiling this Behavior"	^self compilerClass new parser: self newParser! !!PseudoClass methodsFor: 'accessing' stamp: 'ul 4/2/2011 00:39'!newParser	"Answer a Parser suitable for parsing source code in this Behavior"	^self parserClass new! !!PseudoClass methodsFor: 'class' stamp: 'nice 9/21/2010 10:35'!comment	^self organization commentRemoteStr		ifNil: [ self name,' has not been commented in this file']		ifNotNil: [:rStr | rStr string]! !!PseudoClass methodsFor: 'methods' stamp: 'nice 2/23/2011 21:50'!addMethodChange: aChangeRecord	| selector |	selector := self newParser parseSelector: aChangeRecord string.	self organization classify: selector under: aChangeRecord category.	self sourceCodeAt: selector put: aChangeRecord! !!PseudoClass methodsFor: 'removing' stamp: 'jmv 3/2/2010 16:24'!removeAllUnmodified	| stClass |	self exists ifFalse:[^self].	self removeUnmodifiedMethods: self selectors.	stClass := self realClass.	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].	(self hasComment and:[stClass comment asString = self commentString]) ifTrue:[ self classComment: nil].	metaClass ifNotNil: [ metaClass removeAllUnmodified]! !!PseudoClass methodsFor: 'testing' stamp: 'jmv 3/2/2010 16:24'!hasChanges	self sourceCode isEmpty ifFalse:[^true].	self organization hasNoComment ifFalse:[^true].	definition ifNotNil: [ ^true].	metaClass ifNotNil: [ ^metaClass hasChanges].	^false! !!Quadrangle methodsFor: 'displaying-generic' stamp: 'ul 11/16/2010 04:50'!displayOn: aDisplayMedium	"Display the border and insideRegion of the receiver."	borderWidth ~= 0 ifTrue: [		aDisplayMedium			border: self region			widthRectangle: borderWidth			rule: Form over			fillColor: borderColor ].	insideColor ifNotNil: [		aDisplayMedium fill: self inside fillColor: insideColor ]! !!Quadrangle methodsFor: 'displaying-generic' stamp: 'ul 11/16/2010 04:50'!displayOn: aDisplayMedium transformation: aWindowingTransformation clippingBox: aRectangle	"Display the border and region of the receiver so that it is scaled and 	translated with respect to aWindowingTransformation. The displayed 	information should be clipped so that only information with the area 	determined by aRectangle is displayed."	| screenRectangle |	screenRectangle := 		(aWindowingTransformation applyTo: self) intersect: aRectangle.	(borderWidth ~= 0 and: [ insideColor notNil ])		ifTrue: 			[aDisplayMedium fill: screenRectangle fillColor: Color black "borderColor".			aDisplayMedium				fill: (screenRectangle insetBy: borderWidth)				fillColor: insideColor]! !!QueueSound methodsFor: 'accessing' stamp: 'nice 8/27/2010 22:17'!currentSound	^ currentSound ifNil: [currentSound := self nextSound]! !!QueueSound methodsFor: 'sound generation' stamp: 'nice 8/27/2010 16:15'!doControl	super doControl.	self currentSound ifNotNil: [:curSound | curSound doControl]! !!QueueSound methodsFor: 'sound generation' stamp: 'jmv 3/2/2010 16:24'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	| finalIndex i remaining count rate |	self currentSound ifNil: [^ self].  "already done"	self startTime > Time millisecondClockValue ifTrue: [^ self].	rate := self samplingRate.	finalIndex := (startIndex + n) - 1.	i := startIndex.	[i <= finalIndex] whileTrue: [		[			self currentSound ifNil: [^ self].			(remaining := self currentSound samplesRemaining) <= 0]				whileTrue: [self currentSound: self nextSound].		count := (finalIndex - i) + 1.		remaining < count ifTrue: [count := remaining].		self currentSound mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i := i + count]! !!QueueSound methodsFor: 'sound generation' stamp: 'nice 8/27/2010 22:16'!reset	super reset.	self currentSound		ifNil: [self currentSound: self nextSound]		ifNotNil: [:curSound | curSound reset]! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'tk 6/25/97 13:22'!ascii	isBinary := false! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'tk 6/20/97 19:46'!binary	isBinary := true! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'tk 6/21/97 12:49'!contents	"Answer with a copy of my collection from 1 to readLimit."	| newArray |	isBinary ifFalse: [^ super contents].	"String"	readLimit := readLimit max: position.	newArray := ByteArray new: readLimit.	^ newArray replaceFrom: 1		to: readLimit		with: collection		startingAt: 1.! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'jm 11/4/97 08:25'!contentsOfEntireFile	"For compatibility with file streams."	^ self contents! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'tk 12/13/97 13:07'!next	| byte |	^ isBinary 			ifTrue: [byte := super next.				 byte ifNil: [nil] ifNotNil: [byte asciiValue]]			ifFalse: [super next].! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'ar 4/10/2005 19:26'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: anInteger.	^ self nextInto: newArray! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'ls 3/27/2000 22:24'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than n elements have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'nice 3/19/2010 19:06'!nextPut: charOrByte	^super nextPut: charOrByte asCharacter! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'nice 3/16/2010 23:06'!readInto: aCollection startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	^max! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'tk 6/20/97 19:47'!text	isBinary := false! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'ul 8/9/2011 13:24'!upTo: anObject	"fast version using indexOf:"	| start end |	start := position+1.	isBinary		ifTrue: [ anObject isInteger ifFalse: [ ^self upToEnd ] ]		ifFalse: [ anObject isCharacter ifFalse: [ ^self upToEnd ] ].	end := collection indexOf: anObject asCharacter startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		(end = 0 or: [end > readLimit]) ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position := end.	^((isBinary ifTrue: [ ByteArray ] ifFalse: [ String ]) new: end - start)		replaceFrom: 1		to: end - start		with: collection		startingAt: start! !!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'ar 4/10/2005 19:27'!upToEnd	"Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: self size - self position.	^ self nextInto: newArray! !!RWBinaryOrTextStream methodsFor: 'converting' stamp: 'tk 2/4/2000 09:15'!asBinaryOrTextStream	^ self! !!RWBinaryOrTextStream methodsFor: 'testing' stamp: 'tk 6/20/97 19:47'!isBinary	^ isBinary! !!RWBinaryOrTextStream methodsFor: 'positioning' stamp: 'tk 6/21/97 13:04'!reset	"Set the receiver's position to the beginning of the sequence of objects."	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].! !!RWBinaryOrTextStreamTest methodsFor: 'tests' stamp: 'topa 5/23/2011 13:49'!testExisiting	| string stream |		string := 'hello'.		stream := RWBinaryOrTextStream on: string.	self assert: stream contents = string.	stream := RWBinaryOrTextStream on: string.	stream setToEnd.	self assert: stream position = string size.! !!RandomEnvelope methodsFor: 'envelopeEditor compatibility' stamp: 'jmv 3/2/2010 16:25'!points	| env |	points ifNil: [		env := self target envelopes first.		points := OrderedCollection new.		points			add: 0@(self delta * 5 + 0.5);			add: (env points at: env loopStartIndex)x@(self highLimit -1 * 5 + 0.5);			add: (env points at: env loopEndIndex)x@(self highLimit -1 * 5 + 0.5);			add: (env points last)x@(self lowLimit -1 * 5 + 0.5).		loopStartIndex := 2.		loopEndIndex := 3.	].	^points! !!RandomEnvelope methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 10:17'!initialize	super initialize.	rand := Random new.	lowLimit := 0.994.	highLimit := 1.006.	delta := 0.0002.	currValue := 1.0.	scale := 1.0.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'ul 2/22/2011 16:31'!testPositionOfSubCollection	| stream |	stream := self streamOn: 'xyz'.	#(		'' 1		'q' 0		'x' 1		'y' 2		'z' 3		'xz' 0		'xy' 1		'yz' 2		'xyz' 1) pairsDo: [ :pattern :expectedPosition |			self				assert: expectedPosition equals: (stream positionOfSubCollection: pattern);				assert: 0 equals: stream position ]! !!ReadWriteStream methodsFor: '*Compression' stamp: 'yo 7/16/2003 14:59'!asUnZippedStream	| isGZip outputStream first strm archive which |	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else.  Also works on archives (.zip, .gZip)."	strm := self binary.	strm isZipArchive ifTrue: [		archive := ZipArchive new readFrom: strm.		which := archive members detect: [:any | any fileName asLowercase endsWith: '.ttf'] 								ifNone: [nil].		which ifNil: [archive close.					^ self error: 'Can''t find .ttf file in archive'].		strm := which contentStream.		archive close].	first := strm next.	isGZip := (strm next * 256 + first) = (GZipConstants gzipMagic).	strm skip: -2.	isGZip 		ifTrue: [outputStream := (MultiByteBinaryOrTextStream with:									(GZipReadStream on: strm) upToEnd) reset.				strm close]		ifFalse: [outputStream := strm].	^ outputStream! !!ReadWriteStream methodsFor: '*Compression' stamp: 'nk 8/21/2004 15:47'!isZipArchive	"Determine if this appears to be a valid Zip archive"	| sig |	self binary.	sig := self next: 4.	self position: self position - 4. "rewind"	^ZipArchive validSignatures includes: sig! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'cmm 6/8/2010 18:26'!standardSize	^ StandardSize! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'cmm 6/9/2010 15:12'!standardSize: extent	StandardSize := extent! !!RecategorizedEvent class methodsFor: 'instance creation' stamp: 'ar 9/5/2010 21:56'!selector: aSelector method: aMethod protocol: prot class: aClass oldProtocol: oldName	^(self method: aMethod protocol: prot class: aClass) 		itemSelector: aSelector;		oldCategory: oldName;		yourself! !!RecentMessageSet methodsFor: 'message functions' stamp: 'cmm 5/2/2011 09:57'!messageListMenu: aMenu shifted: shifted	"Answer the message-list menu"	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList:#(			('what to show...'						offerWhatToShowMenu)			-			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)			('copy reference'						copyReference)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)			-			('references... (r)'						browseVariableReferences)			('assignments... (a)'						browseVariableAssignments)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			('remove from RecentSubmissions'		removeFromRecentSubmissions)			-			('more...'								shiftedYellowButtonActivity)).	^ aMenu! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'sw 6/10/2003 12:59'!playback	"The user hit the playback button"	recorder verifyExistenceOfRecordedSound ifFalse: [^ self].	recorder pause.	recorder playback.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'sw 6/10/2003 12:59'!trim	"Show my samples in a GraphMorph."		recorder verifyExistenceOfRecordedSound ifFalse: [^ self].	recorder pause.	recorder trim: 1400 normalizedVolume: 80.0.! !!Rectangle methodsFor: 'testing' stamp: 'nice 6/20/2010 21:32'!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	"Optimized; old code answered:		(origin max: aRectangle origin) < (corner min: aRectangle corner)"	| rOrigin rCorner |	rOrigin := aRectangle origin.	rCorner := aRectangle corner.	rCorner x <= origin x	ifTrue: [^ false].	rCorner y <= origin y	ifTrue: [^ false].	rOrigin x >= corner x	ifTrue: [^ false].	rOrigin y >= corner y	ifTrue: [^ false]."None of the two rectangle shall be empty"	corner x <= origin x	ifTrue: [^ false].	corner y <= origin y	ifTrue: [^ false].	rCorner x <= rOrigin x	ifTrue: [^ false].	rCorner y <= rOrigin y	ifTrue: [^ false].	^ true! !!Rectangle methodsFor: 'transforming' stamp: 'nice 6/20/2010 21:27'!flipBy: direction centerAt: aPoint 	"Return a copy flipped #vertical or #horizontal, about aPoint."	| futureOrigin futureCorner |	direction == #horizontal		ifTrue:			[futureOrigin := self topRight.			futureCorner := self bottomLeft]		ifFalse: [direction == #vertical			ifTrue:				[futureOrigin := self bottomLeft.				futureCorner := self topRight]			ifFalse: [self error: 'unrecognizable direction']].	^ (futureOrigin flipBy: direction centerAt: aPoint)		corner: (futureCorner flipBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming' stamp: 'nice 6/20/2010 22:01'!rotateBy: direction centerAt: aPoint	"Return a copy rotated #right, #left, or #pi about aPoint"	| futureOrigin futureCorner |	direction == #pi		ifTrue:			[futureOrigin := self corner.			futureCorner := self origin]		ifFalse: [direction == #left			ifTrue:				[futureOrigin := self topRight.				futureCorner := self bottomLeft]			ifFalse: [direction == #right				ifTrue:					[futureOrigin := self bottomLeft.					futureCorner := self topRight]				ifFalse: [self error: 'unrecognizable direction']]].	^ (futureOrigin rotateBy: direction centerAt: aPoint)		corner: (futureCorner rotateBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'truncation and round off' stamp: 'fbs 12/17/2010 07:24'!rounded	"Answer a Rectangle whose origin and corner are rounded."	^Rectangle origin: origin rounded extent: self extent rounded! !!Rectangle commentStamp: 'nice 7/25/2010 14:56' prior: 0!I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.Note 1: only rectangles parallel to reference frame (Screen) can be represented by this class.Note 2: the Rectangle is represented by two extremities of one diagonal. By convention, it must be the diagonal:	from rectangle origin (the point having smallest coordinates in reference frame),	to rectangle corner (the point having largest coordinates in reference frame).Note 3: Screen coordinates conventions are:	x is horizontal axis, zero at left border, oriented toward right;	y is vertical axis, zero at top border, oriented toward bottom.This corresponds to the latin convention for writing text from left to right and top to bottom.Note 4: the Rectangle extent is obtained by subtracting rectangle origin to rectangle corner coordinates.If this leads to a negative width (extent x coordinate) and/or a negative height (extent y coordinate), then the Rectangle is degenerated and considered empty.Instance variables:	origin	<Point> the coordinates of corner having smallest coordinates (top left in Screen coordinates)	corner	<Point> the coordinates of corner having largest coordinates (bottom right in Screen coordinates)!!RectangleTest methodsFor: 'tests' stamp: 'wiz 4/29/2010 02:10'!testRoundingAfterHalfPixelTranslation	"A rectangle right on the cusp of rounding changes shape if origin and	corner are in differenct quadrants"	"self debug: #testRoundingAfterHalfPixelTranslation"	| trouble noTrouble |	trouble := 10 negated asPoint rect: 10 asPoint.	noTrouble := trouble translateBy: 15.		10 timesRepeat: [trouble := (trouble translateBy: 0.5) rounded].	10 timesRepeat: [noTrouble := (noTrouble translateBy: 0.5) rounded].		self assert: trouble extent = noTrouble extent! !!RectangleTest methodsFor: 'tests' stamp: 'fbs 12/17/2010 09:22'!testRoundingAfterHalfPixelTranslationFirstQuadrant	"A rectangle right on the cusp of rounding changes shape if origin and	corner are in differenct quadrants"	"self debug: #testRoundingAfterHalfPixelTranslation"	| a b |	a := 10 asPoint rect: 10 asPoint.	b := a translateBy: 15.		10 timesRepeat: [a := (a translateBy: 0.5) rounded].	10 timesRepeat: [b := (b translateBy: 0.5) rounded].		self assert: a extent = b extent! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:19'!testArea	| r1 empty |	r1 := 0@0 extent: 10@20.	self assert: r1 area = (10*20).	self assert: (r1 translateBy: -20@10) area = (10*20) description: 'translation preserves area'.		empty := 10@20 corner: 0@0.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.	empty := 10@0 corner: 0@20.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.	empty := 0@20 corner: 10@0.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:59'!testCenter	| r1 c |	r1 := 0@0 extent: 10@20.	c := r1 center.	self assert: (r1 containsPoint: c) description: 'the center is inside the rectangle'.	self assert: (r1 topLeft dist: c) = (r1 bottomRight dist: c).	self assert: (r1 bottomLeft dist: c) = (r1 topRight dist: c).	self assert: (r1 topLeft dist: c) = (r1 bottomLeft dist: c).	self assert: (r1 translateBy: -20@10) center = (c translateBy: -20@10) description: 'the center is translated with the rectangle'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 23:00'!testCenterEmpty	| r1 c |	r1 := 30@10 corner: 10@20.	c := r1 center.	self deny: (r1 containsPoint: c) description: 'An empty rectangle does not contain any point.'.	self assert: (r1 topLeft dist: c) = (r1 bottomRight dist: c).	self assert: (r1 bottomLeft dist: c) = (r1 topRight dist: c).	self assert: (r1 topLeft dist: c) = (r1 bottomLeft dist: c).	self assert: (r1 translateBy: -20@10) center = (c translateBy: -20@10) description: 'the center is translated with the rectangle'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:33'!testFlip	| r1 c r1Horiz r1Vert |	r1 := 30@10 extent: 10@20.	c := 5@5.	r1Horiz := r1 flipBy: #horizontal centerAt: c.	r1Vert := r1 flipBy: #vertical centerAt: c.	self assert: r1 area = r1Horiz area description: 'flip preserves area'.	self assert: r1 area = r1Vert area description: 'flip preserves area'.		self assert: r1 extent = r1Horiz extent description: 'flip preserves extent'.	self assert: r1 extent = r1Vert extent description: 'flip preserves extent'.		self assert:  (r1 flipBy: #horizontal centerAt: r1 center) = r1.	self assert:  (r1 flipBy: #vertical centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:33'!testFlipEmpty	| r1 c r1Horiz r1Vert |	r1 := 30@10 corner: 10@20.	c := 5@5.	r1Horiz := r1 flipBy: #horizontal centerAt: c.	r1Vert := r1 flipBy: #vertical centerAt: c.		self assert: r1 area = r1Horiz area description: 'flip preserves area'.	self assert: r1 area = r1Vert area description: 'flip preserves area'.		self assert: r1 extent = r1Horiz extent description: 'flip preserves extent'.	self assert: r1 extent = r1Vert extent description: 'flip preserves extent'.		self assert:  (r1 flipBy: #horizontal centerAt: r1 center) = r1.	self assert:  (r1 flipBy: #vertical centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 23:04'!testIntersectionEmpty	| rect1 empty1 empty2 |	rect1 := 10@10 corner: 40@40.	empty1 := 50@50 corner: 0@0.	empty2 := 30@30 corner: 20@20.	self		deny: (rect1 intersects: empty1);		deny: (rect1 intersects: empty2);		deny: (empty1 intersects: rect1);		deny: (empty2 intersects: rect1);		deny: (empty1 intersects: empty2);		deny: (empty2 intersects: empty1).! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:29'!testRotate	| r1 c r1Left r1Right r1Pi |	r1 := 30@10 extent: 10@20.	c := 5@5.	r1Left := r1 rotateBy: #left centerAt: c.	r1Right := r1 rotateBy: #right centerAt: c.	r1Pi := r1 rotateBy: #pi centerAt: c.		self assert: r1 area = r1Left area description: 'rotation preserves area'.	self assert: r1 area = r1Right area description: 'rotation preserves area'.	self assert: r1 area = r1Pi area description: 'rotation preserves area'.		self assert: r1 extent transposed = r1Left extent.	self assert: r1 extent transposed = r1Right extent.	self assert: r1 extent = r1Pi extent.		self assert:  (r1 rotateBy: #pi centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:29'!testRotateEmpty	| r1 c r1Left r1Right r1Pi |	r1 := 30@10 corner: 10@20.	c := 5@5.	r1Left := r1 rotateBy: #left centerAt: c.	r1Right := r1 rotateBy: #right centerAt: c.	r1Pi := r1 rotateBy: #pi centerAt: c.		self assert: r1 area = r1Left area description: 'rotation preserves area'.	self assert: r1 area = r1Right area description: 'rotation preserves area'.	self assert: r1 area = r1Pi area description: 'rotation preserves area'.		self assert: r1 extent transposed = r1Left extent.	self assert: r1 extent transposed = r1Right extent.	self assert: r1 extent = r1Pi extent.		self assert:  (r1 rotateBy: #pi centerAt: r1 center) = r1! !!ReferenceMorph methodsFor: 'misc' stamp: 'ul 11/15/2010 12:00'!fitContents	submorphs size = 1 ifTrue:		[self extent: submorphs first extent + (2 * self borderWidth).		submorphs first position: self position + self borderWidth]! !!ReferenceStream methodsFor: 'statistics' stamp: 'ul 6/17/2011 12:32'!statisticsOfRefs	"Analyze the information in references, the objects being written out"	| parents ownerBags tallies n nm owners |	parents := IdentityDictionary new: references size * 2.	n := 0.	'Finding Owners...'	displayProgressFrom: 0 to: references size	during: [:bar |	references keysDo:		[:parent | | kids |		bar value: (n := n+1).		kids := parent class isFixed			ifTrue: [(1 to: parent class instSize) collect: [:i | parentinstVarAt: i]]			ifFalse: [parent class isBits ifTrue: [Array new]					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt:i]]].		(kids select: [:x | references includesKey: x])			do: [:child | parents at: child put: parent]]].	ownerBags := Dictionary new.	tallies := Bag new.	n := 0.	'Tallying Owners...'	displayProgressFrom: 0 to: references size	during: [:bar |	references keysDo:  "For each class of obj, tally a bag of ownerclasses"		[:obj | | objParent | bar value: (n := n+1).		nm := obj class name.		tallies add: nm.		owners := ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].		(objParent := parents at: obj ifAbsent: [nil]) == nil			ifFalse: [owners add: objParent class name]]].	^ String streamContents:		[:strm |  tallies sortedCounts do:			[:assn | n := assn key.  nm := assn value.			owners := ownerBags at: nm.			strm cr; nextPutAll: nm; space; print: n.			owners size > 0 ifTrue:				[strm cr; tab; print: owners sortedCounts]]]! !!ReferenceStream methodsFor: 'writing' stamp: 'ul 11/15/2010 12:00'!isAReferenceType: typeID	"Return true iff typeID is one of the classes that can be written as a reference to an instance elsewhere in the stream."	"too bad we can't put Booleans in an Array literal"	^ (RefTypes at: typeID) = 1		"NOTE: If you get a bounds error here, the file probably has bad bits in it.  The most common cause is a file unpacking program that puts linefeeds after carriage returns."! !!ReferenceStream methodsFor: 'writing' stamp: 'nk 5/4/2004 14:40'!project	"Return the project we are writing or nil"	(topCall respondsTo: #isCurrentProject) ifTrue: [^ topCall].	(topCall respondsTo: #do:) ifTrue: [1 to: 5 do: [:ii | 		((topCall at: ii ifAbsent: [ ^nil ]) respondsTo: #isCurrentProject) ifTrue: [^ topCall at: ii]]].	^ nil! !!ReleaseBuilder methodsFor: 'utilities' stamp: 'ul 6/17/2011 12:20'!finalCleanup	"ReleaseBuilder new finalCleanup"	DataStream initialize.	Behavior flushObsoleteSubclasses.	"The pointer to currentMethod is not realy needed (anybody care to fix this) and often holds on to obsolete bindings"	MethodChangeRecord allInstancesDo: [:each | each noteNewMethod: nil].	self cleanUpEtoys.	SmalltalkImage current fixObsoleteReferences.	Smalltalk flushClassNameCache.	3 timesRepeat: [		Smalltalk garbageCollect.		Symbol compactSymbolTable.	].! !!ReleaseBuilder methodsFor: 'squeakland' stamp: 'ul 6/17/2011 12:20'!makeSqueaklandReleasePhaseCleanup	"ReleaseBuilder new makeSqueaklandReleasePhaseCleanup"	Smalltalk at: #Browser ifPresent:[:br| br initialize].	ChangeSet 		removeChangeSetsNamedSuchThat: [:cs | cs name ~= ChangeSet current name].	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk garbageCollect.	"Reinitialize DataStream; it may hold on to some zapped entitities"	DataStream initialize.	"Remove existing player references"	References keys do: [:k | References removeKey: k].	Smalltalk garbageCollect.	ScheduledControllers := nil.	Behavior flushObsoleteSubclasses.	Smalltalk		garbageCollect;		garbageCollect.	SystemNavigation default obsoleteBehaviors isEmpty 		ifFalse: [self error: 'Still have obsolete behaviors'].	"Reinitialize DataStream; it may hold on to some zapped entitities"	DataStream initialize.	Smalltalk fixObsoleteReferences.	Smalltalk abandonTempNames.	Smalltalk zapAllOtherProjects.	Smalltalk flushClassNameCache.	3 timesRepeat: 			[Smalltalk garbageCollect.			Symbol compactSymbolTable]! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'ul 6/17/2011 12:19'!makeSqueakThreeTenReleasePhaseCleanup	"ReleaseBuilderFor3dot10 new makeSqueakThreeTenReleasePhaseCleanup"| newVersion |	Smalltalk at: #Browser ifPresent:[:br| br initialize].self cleanUnwantedCs.	"Remove existing player references"	References keys do: [:k | References removeKey: k].	Smalltalk garbageCollect.	ScheduledControllers := nil.	Behavior flushObsoleteSubclasses.	SystemNavigation default obsoleteBehaviors isEmpty 		ifFalse: [self error: 'Still have obsolete behaviors'].	"Reinitialize DataStream; it may hold on to some zapped entitities"	DataStream initialize.	self fixObsoleteReferences.	"Smalltalk abandonTempNames."	Smalltalk zapAllOtherProjects.	Smalltalk flushClassNameCache.	3 timesRepeat: 			[Smalltalk garbageCollect.			Symbol compactSymbolTable]."SystemVersion current registerUpdate: 7069." "We only need for when start the release"	newVersion := 'Squeak3.10alpha.' , SystemVersion currenthighestUpdate printString. 		newVersion := newVersion ,'.'.	(SourceFiles at: 2) ifNotNil:		[SmalltalkImage current closeSourceFiles; "so copying thechanges file will always work"			 saveChangesInFileNamed: (SmalltalkImage currentfullNameForChangesNamed: newVersion)].	SmalltalkImage current saveImageInFileNamed: (SmalltalkImage currentfullNameForImageNamed: newVersion)		! !!ReleaseBuilderFor3dot11 methodsFor: 'cleaning' stamp: 'ul 8/2/2011 20:09'!cleanupPhaseFinal" ReleaseBuilderFor3dot11 new cleanupPhaseFinal "| tasks |    tasks := OrderedCollection new                        add: [Smalltalk removeEmptyMessageCategories];                add: [Workspace                        allSubInstancesDo: [:each | each initializeBindings]];                add: [Undeclared removeUnreferencedKeys];                add: [Categorizer sortAllCategories];                add: [Symbol compactSymbolTable];	add: [#(#TheWorldMenu #FileServices #AppRegistry #Preferences #FileList )		do: [:cl | (Smalltalk at: cl) removeObsolete]]; add:[Flaps freshFlapsStart]; add:[MCFileBasedRepository flushAllCaches];                 add: [HandMorph releaseCachedState;	initForEvents.self fixObsoleteReferences];                add: [	DataStream initialize.	Behavior flushObsoleteSubclasses.	"The pointer to currentMethod is not realy needed (anybody care to fix this) and often holds on to obsolete bindings"	MethodChangeRecord allInstancesDo: [:each | each noteNewMethod: nil].Smalltalk garbageCollectMost];                 yourself.Utilities        informUserDuring: [:bar | tasks                do: [:block |                    bar value: block printString.                    block                        on: Error                        do: [:error | Transcript show: error;                                 cr]]]. SystemNavigation default obsoleteClasses isEmpty        ifTrue: [SmalltalkImage current saveSession]        ifFalse: [SystemNavigation default obsoleteClasses                do: [:each | .self halt.[PointerFinder on: each]                        on: Error                        do: [:error | Transcript show: error; cr]]]! !!ReleaseBuilderFor3dot11 methodsFor: 'sources managment' stamp: 'ul 6/17/2011 12:29'!createCompressedSources" ReleaseBuilderFor3dot11 new createCompressedSources"ProtoObject allSubclassesWithLevelDo:[:cl :l| | dir | 	dir := self createDirIfnotExists:cl category.			Cursor write showWhile: [ | zipped nameToUse unzipped buffer |		nameToUse :=  cl printString , FileDirectory dot, ImageSegment compressedFileExtension. 		(dir fileExists: nameToUse) ifFalse:[			unzipped :=RWBinaryOrTextStream on: ''.			unzipped header; timeStamp.	 cl  fileOutOn: unzipped moveSource: false toFile: 0.	unzipped trailer.				unzipped reset.			zipped := dir newFileNamed: (nameToUse).	zipped binary.	zipped := GZipWriteStream on: zipped.	buffer := ByteArray new: 50000.	'Compressing ', nameToUse displayProgressFrom: 0 to: unzipped size		during:[:bar|			[unzipped atEnd] whileFalse:[				bar value: unzipped position.				zipped nextPutAll: (unzipped nextInto: buffer)].			zipped close.			unzipped close]]]] startingLevel: 0! !!ReleaseBuilderTrunk class methodsFor: 'scripts' stamp: 'chc 12/12/2011 10:35'!prepareNewBuild	"ReleaseBuilderTrunk prepareNewBuild"	"Prepare everything that should be done for a new image build"	SystemVersion setVersion.	SMLoaderPlus		setDefaultFilters: (OrderedCollection with: #filterSafelyAvailable).	self setDisplayExtent: 800 @ 600;		 setPreferences;		 switchTo43Repository;		 openWelcomeWorkspaces.	"Make DependencyBrowser accessible on the open menu."	DependencyBrowser initialize.	Smalltalk cleanUp: true.	Undeclared removeUnreferencedKeys.	Smalltalk garbageCollect! !!ReleaseBuilderTrunk class methodsFor: 'scripts' stamp: 'cmm 3/6/2011 16:17'!transferCurrentPackages	| trunkRep releaseRep |	trunkRep := self trunkRepository.	releaseRep := self releaseRepository.	MCWorkingCopy allManagers		do: [:eachWorkingCopy | eachWorkingCopy ancestors				do: [:eachVersionInfo | (releaseRep includesVersionNamed: eachVersionInfo versionName)						ifFalse: [releaseRep								storeVersion: (trunkRep versionNamed: eachVersionInfo versionName)]]]! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'chc 12/22/2011 15:55'!openWelcomeWorkspaces	TheWorldMainDockingBar instance		showWelcomeText: #squeakUserInterface		label: 'Squeak User Interface'		in: (40 @ 40 extent: 500 @ 300).	TheWorldMainDockingBar instance		showWelcomeText: #workingWithSqueak		label: 'Working With Squeak'		in: (80 @ 80 extent: 500 @ 300).	TheWorldMainDockingBar instance		showWelcomeText: #licenseInformation		label: 'License Information'		in: (120 @ 120 extent: 500 @ 300).	TheWorldMainDockingBar instance		showWelcomeText: #welcomeFutureDirections		label: 'Future Directions'		in: (160 @ 160 extent: 500 @ 300).	TheWorldMainDockingBar instance		showWelcomeText: #welcomeToSqueak43		label: 'Welcome to Squeak 4.3'		in: (200 @ 200 extent: 500 @ 300)! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'chc 12/12/2011 10:33'!releaseRepository	^ MCHttpRepository		location: self repositoryUrl , '/squeak43'		user: 'squeak'		password: 'squeak'! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 2/1/2011 18:01'!repositoryUrl 	^ 'http://source.squeak.org'! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 12/22/2011 13:38'!setDisplayExtent: extent"Uncomment next line when the primitives become available in the Squeak VM.""	DisplayScreen hostWindowSize: extent."	Display extent = extent ifFalse: [ Warning signal: 'Display extent not set to ', extent ]! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 1/12/2011 13:30'!setPreferences	Preferences 		installBrightWindowColors ;		setPreference: #scrollBarsWithoutMenuButton toValue: true ;		setPreference: #swapMouseButtons toValue: true ;		setPreference: #annotationPanes toValue: true ;		setPreference: #showSplitterHandles toValue: false ;		setPreference: #showBoundsInHalo toValue: true ;		setPreference: #alternateHandlesLook toValue: false ;		setPreference: #roundedMenuCorners toValue: false ;		setPreference: #roundedWindowCorners toValue: false.	PluggableButtonMorph roundedButtonCorners: false.	FillInTheBlankMorph roundedDialogCorners: false.	Workspace shouldStyle: false! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'chc 12/13/2011 04:23'!switchTo43Repository	| old42Repository |	MCMcmUpdater defaultUpdateURL: 'http://source.squeak.org/squeak43'.	old42Repository := MCRepositoryGroup default repositories				detect: [:each | each description includesSubString: 'squeak42'] ifNone: [nil].	old42Repository		ifNotNil: [MCRepositoryGroup default removeRepository: old42Repository].	MCRepositoryGroup default addRepository: self releaseRepository! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 2/4/2011 10:46'!trunkRepository	^ MCHttpRepository		location: self repositoryUrl , '/trunk'		user: 'squeak'		password: 'squeak'! !!ReleaseTest methodsFor: 'testing' stamp: 'ul 3/24/2011 08:31'!testNoObsoleteClasses	| obsoleteClasses |	obsoleteClasses := self systemNavigation obsoleteClasses.	self assert: #() equals: obsoleteClasses asArray	! !!ReleaseTest methodsFor: 'testing' stamp: 'mtf 12/16/2010 11:36'!testSwapMouseButtonsPreference	"Swap mouse buttons should be enabled"	self assert: Preferences swapMouseButtons! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 7/10/2010 13:06'!startTransmittingEvents	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := Socket newTCP.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 7/10/2010 13:06'!startTransmittingEventsTo: remoteAddr	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	remoteAddress := remoteAddr.	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := Socket newTCP.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph class methodsFor: 'utilities' stamp: 'fbs 12/4/2010 19:52'!ensureNetworkConnected	"Try to ensure that an intermittent network connection, such as a dialup or ISDN line, is actually connected. This is necessary to make sure a server is visible in order to accept an incoming connection. If the network connection does not work - the user has given up - return false. Otherwise, return true."	"RemoteHandMorph ensureNetworkConnected"	| address |	Utilities		informUser: 'Ensuring your network connection works...'		during: [			address := (NetNameResolver				addressForName: 'squeak.org'				timeout: 30)].	^ address notNil.! !!RemoteString methodsFor: 'accessing' stamp: 'ul 3/16/2011 23:59'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	theFile := (CurrentReadOnlySourceFiles at: (sourceFileNumber ifNil: [ ^nil ])) ifNil: [ ^nil ].	theFile size < filePositionHi ifTrue: [		self error: 'RemoteString past end of file' ].	^theFile		position: filePositionHi;		nextChunkText! !!RemoteTempVectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitRemoteTempVectorNode: self! !!RemoteTempVectorNode methodsFor: 'printing' stamp: 'jmv 3/2/2010 17:13'!printDefinitionForClosureAnalysisOn: aStream 	| refs |	aStream		nextPut: ${;		nextPutAll: key.	definingScope ifNotNil: [definingScope blockExtent ifNotNil: [:be| aStream nextPutAll: ' d@'; print: be first]].	readingScopes ifNotNil: [		refs := Set new.		readingScopes do: [:elems| refs addAll: elems].		refs asSortedCollection do: [:read| aStream nextPutAll: ' r@'; print: read]].	remoteTemps		do: [:rt| rt printDefinitionForClosureAnalysisOn: aStream]		separatedBy: [aStream nextPut: $,; space].	aStream nextPut: $}! !!RepeatingSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:11'!postCopy	"Copy my component sound."	super postCopy.	self copySound! !!ResourceManager class methodsFor: 'resource caching' stamp: 'nice 6/11/2010 21:27'!reloadCachedResources	"ResourceManager reloadCachedResources"	"Reload cached resources from the disk"	| fd files stream url localName storeBack archiveName |	CachedResources := Dictionary new.	LocalizedExternalResources := nil.	fd := Project squeakletDirectory.	files := fd fileNames asSet.	stream := [fd readOnlyFileNamed: self resourceCacheName]				on: FileDoesNotExistException 				do:[:ex| fd forceNewFileNamed: self resourceCacheName].	stream size < 50000 ifTrue:[stream := ReadStream on: stream contentsOfEntireFile].	storeBack := false.	[stream atEnd] whileFalse:[		url := stream nextLine.			localName := stream nextLine.		(localName beginsWith: 'zip://') ifTrue:[			archiveName := localName copyFrom: 7 to: localName size.			(files includes: archiveName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true].		] ifFalse:[			(files includes: localName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true]		].	].	stream close.	storeBack ifTrue:[		stream := fd forceNewFileNamed: self resourceCacheName.		CachedResources keysAndValuesDo:[:urlString :cacheLocs|			cacheLocs do:[:cacheLoc|				stream nextPutAll: urlString; cr.				stream nextPutAll: cacheLoc; cr].		].		stream close.	].! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40'!emitCodeForReturn: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40'!emitCodeForValue: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForReturn: encoder	^expr sizeCodeForReturn: encoder! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	^expr sizeCodeForReturn: encoder! !!ReturnNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitReturnNode: self! !!ReverbSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:11'!postCopy	"Copy my component sound."	super postCopy.	self copySound! !!ReverbSound methodsFor: 'private' stamp: 'ul 11/2/2010 03:08'!applyReverbTo: aSoundBuffer startingAt: startIndex count: n	| delayedLeft delayedRight i tapGain j out |	<primitive: 'primitiveApplyReverb' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #tapDelays declareC: 'int *tapDelays'>	<var: #tapGains declareC: 'int *tapGains'>	<var: #leftBuffer declareC: 'short int *leftBuffer'>	<var: #rightBuffer declareC: 'short int *rightBuffer'>	startIndex to: ((startIndex + n) - 1) do: [:sliceIndex |		delayedLeft := delayedRight := 0.		1 to: tapCount do: [:tapIndex |			i := bufferIndex - (tapDelays at: tapIndex).			i < 1 ifTrue: [i := i + bufferSize].  "wrap"			tapGain := tapGains at: tapIndex.			delayedLeft := delayedLeft + (tapGain * (leftBuffer at: i)).			delayedRight := delayedRight + (tapGain * (rightBuffer at: i))].		"left channel"		j := (2 * sliceIndex) - 1.		out := (aSoundBuffer at: j) + (delayedLeft // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		leftBuffer at: bufferIndex put: out.		"right channel"		j := j + 1.		out := (aSoundBuffer at: j) + (delayedRight // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		rightBuffer at: bufferIndex put: out.		bufferIndex := (bufferIndex \\ bufferSize) + 1].! !!RightGripMorph methodsFor: 'target resize' stamp: 'ael 6/3/2011 00:37'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin corner: oldBounds corner + (delta x @ 0))! !!RightGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultWidth	^ 5! !!RightGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (1 @ 0 corner: 1 @ 1)		offsets: (self defaultWidth negated @ self defaultHeight negated corner: 0@ 0)! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!ptName	^#right! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!resizeCursor	^ Cursor resizeForEdge: #right! !!RunArray methodsFor: 'converting' stamp: 'BG 6/8/2003 15:17'!reversed  ^self class runs: runs reversed values: values reversed! !!RunArray methodsFor: 'private' stamp: 'ul 8/2/2011 20:09'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"		values := values collect: mapBlock! !!SARInstaller methodsFor: 'client services' stamp: 'ul 9/20/2011 12:07'!fileInPackageNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as DVS packages."	| member current new baseName imagePackageLoader packageInfo streamPackageLoader packageManager |	member := self zip memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	imagePackageLoader := Smalltalk at: #ImagePackageLoader ifAbsent: [].	streamPackageLoader := Smalltalk at: #StreamPackageLoader ifAbsent: [].	packageInfo := Smalltalk at: #PackageInfo ifAbsent: [].	packageManager := Smalltalk at: #FilePackageManager ifAbsent: [].	"If DVS isn't present, do a simple file-in"	(packageInfo isNil or: [imagePackageLoader isNil or: [streamPackageLoader isNil]])		ifTrue: [ ^ self fileInMemberNamed: memberName ].	baseName := memberName copyReplaceAll: '.st' with: ''.	(packageManager allManagers anySatisfy: [ :pm | pm packageName = baseName ])		ifTrue: [			current := imagePackageLoader new package: (packageInfo named: baseName).			new := streamPackageLoader new stream: member contentStream ascii.			(new changesFromBase: current) fileIn ]		ifFalse: [ self class fileIntoChangeSetNamed: baseName fromStream: member contentStream ascii setConverterForCode. ].	packageManager registerPackage: baseName.	self installed: member.! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreAssignments	^nil! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreSelectors	^nil! !!SHParserST80 methodsFor: 'accessing' stamp: 'ul 11/15/2010 04:14'!ranges	^ranges! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:15'!nextChar	sourcePosition := sourcePosition + 1.	^source at: sourcePosition ifAbsent: $ ! !!SHParserST80 methodsFor: 'scan' stamp: 'nice 10/10/2010 21:15'!scanBinary	| c d |	c := self currentChar.	currentTokenSourcePosition := sourcePosition.	currentToken := c asString.	d := self nextChar.	((self isSelectorCharacter: c) or: [c == $:]) ifFalse: [^currentToken].	(c == $: and: [d == $=]) 		ifTrue: [" := assignment"			currentToken := currentToken , d asString.			self nextChar.			^currentToken].	c == $| ifTrue:["| cannot precede a longer token" ^currentToken].	[self isSelectorCharacter: d] 		whileTrue: [			currentToken := currentToken , d asString.			d := self nextChar].	^currentToken! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 19:29'!scanIdentifier	| c start |	start := sourcePosition.	[(c := self nextChar) isAlphaNumeric or: [c == $_ and: [self allowUnderscoreSelectors]]] whileTrue.	(c == $: and: [(self isSelectorCharacter: self peekChar) not]) 		ifTrue: [self nextChar].	currentToken := source copyFrom: start to: sourcePosition - 1.	currentTokenSourcePosition := start! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 11/15/2010 03:31'!scanNext	self scanWhitespace.	currentTokenFirst := self currentChar.	currentTokenFirst 		ifNil: [" end of input "			currentTokenFirst := $ .			currentTokenSourcePosition := nil.			currentToken := nil.			^nil].	currentTokenFirst isDigit ifTrue: [^self scanNumber].	(currentTokenFirst isLetter or: [		currentTokenFirst == $_ and: [ self allowUnderscoreSelectors ] ])			ifTrue: [^self scanIdentifier].	^self scanBinary! !!SHParserST80 methodsFor: 'token testing' stamp: 'laza 4/28/2010 17:51'!isAssignment	^self isAnsiAssignment or: [self allowUnderscoreAssignments and: [currentToken = '_']]! !!SHParserST80 methodsFor: 'token testing' stamp: 'nice 10/10/2010 21:05'!isBinary	(currentToken isNil or: [self isName or: [self isKeyword]]) 		ifTrue: [^false].	1 to: currentToken size do: [:i | | c |		c := currentToken at: i.		(self isSelectorCharacter: c) 			ifFalse: [^false]].	^true! !!SHParserST80 methodsFor: 'token testing' stamp: 'ul 11/15/2010 04:06'!isKeyword	"This method assumes that currentTokenFirst is a non-letter character when currentToken is nil."	^(currentTokenFirst isLetter or: [		currentTokenFirst == $_ and: [			currentToken notNil and: [			currentToken size > 1 and: [			self allowUnderscoreSelectors ] ] ] ]) and: [		currentToken last == $: ]! !!SHParserST80 methodsFor: 'token testing' stamp: 'ul 11/15/2010 04:05'!isName	"This method assumes that currentTokenFirst is a non-letter character when currentToken is nil."	^(currentTokenFirst isLetter or: [ 		currentTokenFirst == $_ and: [			currentToken notNil and: [			currentToken size > 1 and: [			self allowUnderscoreSelectors ] ] ] ]) and: [		currentToken last isAlphaNumeric or: [			currentToken last == $_ and: [				self allowUnderscoreSelectors ] ] ] ! !!SHParserST80 methodsFor: 'character testing' stamp: 'nice 10/10/2010 21:05'!isSelectorCharacter: aCharacter	aCharacter isAlphaNumeric ifTrue: [^false].	aCharacter isSeparator ifTrue:[^false].	('"#$'':().;[]{}^_'  includes: aCharacter) 		ifTrue:[^false].	aCharacter asciiValue = 30 ifTrue: [^false "the doIt char"].	aCharacter asciiValue = 0 ifTrue: [^false].	"Any other char is ok as a binary selector char."	^true! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22'!parse: isAMethod 	"Parse the receiver's text. If isAMethod is true    then treat text as a method, if false as an    expression with no message pattern"	self initializeInstanceVariables.	sourcePosition := 1.	arguments := Dictionary new.	temporaries := Dictionary new.	blockDepth := bracketDepth := 0.	ranges		ifNil: [ranges := OrderedCollection new: 100]		ifNotNil: [ranges reset].	errorBlock := [^false].	[self scanNext.	isAMethod 		ifTrue: [			self parseMessagePattern.			self parsePragmaSequence].	self parseMethodTemporaries.	isAMethod ifTrue: [self parsePragmaSequence].	self parseStatementList.	currentToken ifNotNil: [self error]]		ensure:[errorBlock := nil].	^true! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22'!parseBinary 	| binary type |	self parseUnary.	[self isBinary] 		whileTrue: [			binary := currentToken.			type := #binary.			(binary isEmpty or:[(Symbol lookup: binary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: binary skipping: nil)						ifNil: [#undefinedBinary]						ifNotNil:[#incompleteBinary]].				self scanPast: type. 				self parseTerm.            	self parseUnary]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 1/28/2011 00:46'!parseByteArray	[currentTokenFirst == $]] whileFalse: [		currentTokenFirst isDigit 			ifTrue: [				"do not parse the number, can be time consuming"				self scanPast: #number]			ifFalse: [				self failWhen: currentTokenFirst == $. .				self error]].	self scanPast: #byteArrayEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 11/10/2011 13:04'!parseExternalCall	[self scanNext.	((Smalltalk at: #ExternalFunction) callingConventionModifierFor: currentToken) notNil]		whileTrue.	self failUnless: currentToken notNil.	self scanPast: #externalCallType.	currentToken = '*' 		ifTrue: [self scanPast: #externalCallTypePointerIndicator].	currentTokenFirst isDigit 		ifTrue: [self scanPast: #integer]		ifFalse: 	[			self failUnless: currentTokenFirst == $'.			self parseString].	self failUnless: currentTokenFirst == $(.	self scanPast: #leftParenthesis.	[currentTokenFirst ~= $)] 		whileTrue: [			self failUnless: currentToken notNil.			self scanPast: #externalCallType.			currentToken = '*' 				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].	self scanPast: #rightParenthesis.	currentToken = 'module:' 		ifTrue: [			self scanPast: #module.			self parseStringOrSymbol ].	currentToken = 'error:' ifTrue: [		self scanPast: #primitive. "there's no rangeType for error"		self isName			ifTrue: [ self scanPast: #patternTempVar ]			ifFalse: [ self parseStringOrSymbol ] ].	self failUnless: currentToken = '>'.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22'!parseKeyword     | keyword rangeIndices |    self parseBinary.	keyword := ''.	rangeIndices := #().	[    		[self isKeyword]        		whileTrue: [				keyword := keyword, currentToken. 				self rangeType: #keyword.				"remember where this keyword token is in ranges"				rangeIndices := rangeIndices copyWith: ranges size.				self scanNext.				self parseTerm.				self parseBinary ]	] ensure: [ | type |		"do this in an ensure so that it happens even if the errorBlock evaluates before getting here"		"patch up the keyword tokens, so that incomplete and undefined ones look different"		(keyword isEmpty or:[(Symbol lookup: keyword) notNil])			ifFalse:[				type := (Symbol thatStartsCaseSensitive: keyword skipping: nil)					ifNil: [#undefinedKeyword]					ifNotNil:[#incompleteKeyword].				rangeIndices do: [:i | (ranges at: i) type: type]]]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 10/12/2010 02:47'!parsePrimitive	self scanNext.	currentTokenFirst isDigit		ifTrue: [ self scanPast: #integer ]		ifFalse: [			self parseStringOrSymbol.			currentToken = 'module:' ifTrue: [				self scanPast: #module.				self parseStringOrSymbol ] ].	currentToken = 'error:' ifTrue: [		self scanPast: #primitive. "there's no rangeType for error"		self isName			ifTrue: [ self scanPast: #patternTempVar ]			ifFalse: [ self parseStringOrSymbol ] ].	self failUnless: currentToken = '>'.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:24'!parseString	| first c answer last |	first := sourcePosition.	answer := ''.		[(c := self currentChar)		ifNil: [			self rangeType: #unfinishedString start: first - 1 end: source size.			self error	": 'unfinished string'"].	(c == $' 			ifFalse: [answer := answer copyWith: c. true] 		ifTrue: [false]	) or: [		self peekChar == $' 			ifTrue: [				sourcePosition := sourcePosition + 1.				answer := answer copyWith: $'.				true]			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #string start: first - 1 end: last.	^answer! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 10/12/2010 02:43'!parseStringOrSymbol	currentTokenFirst == $' ifTrue: [ ^self parseString ].	currentTokenFirst == $# ifTrue: [ ^self parseSymbol ].	self error! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 1/28/2011 00:54'!parseSymbol	| c |	currentToken = '#' 		ifTrue: [			"if token is just the #, then scan whitespace and comments			and then process the next character.			Squeak allows space between the # and the start of the symbol 			e.g. # (),  #  a, #  'sym' "			self rangeType: #symbol.			self scanWhitespace].	c := self currentChar.	self failWhen: (c isNil or: [c isSeparator]).	c == $( 		ifTrue: [			self nextChar.			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.			^self parseArray].	c == $' ifTrue: [^self parseSymbolString].	c == $[ ifTrue: [			self nextChar.			self scanPast: #byteArrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.			^self parseByteArray].	((self isSelectorCharacter: c) or: [c == $-]) 		ifTrue: [^self parseSymbolSelector].	(c isLetter or: [		c == $: or: [ 		c == $_ and: [self allowUnderscoreSelectors] ] ]) 			ifTrue: [^self parseSymbolIdentifier].	^self parseCharSymbol! !!SHParserST80 methodsFor: 'parse' stamp: 'laza 4/29/2010 16:18'!parseSymbolIdentifier	| c start end |	c := self currentChar.	self failUnless: (c isLetter or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]).	start := sourcePosition.		[c := self nextChar.	c isAlphaNumeric or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]] whileTrue.	end := sourcePosition - 1.	c := source copyFrom: start - 1 to: end.	self scanPast: #symbol start: start - 1 end: end.	^c! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26'!parseSymbolString	| first c last |	first := sourcePosition.	self nextChar.	[(c := self currentChar) 		ifNil: [			self rangeType: #unfinishedString start: first end: source size.			self error	": 'unfinished string'"].	c ~~ $' or: [		self peekChar == $' 			ifTrue: [sourcePosition := sourcePosition + 1.true] 			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #stringSymbol start: first - 1 end: last! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26'!parseUnary	| unary type |	    [self isName]        whileTrue: [			unary := currentToken.			type := #unary.			(unary isEmpty or:[(Symbol lookup: unary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: unary skipping: nil)						ifNil: [#undefinedUnary]						ifNotNil:[#incompleteUnary]].			self scanPast: type]! !!SHParserST80 methodsFor: 'private' stamp: 'ul 10/28/2010 00:42'!allowUnderscoreAssignments	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreAssignments])		ifNil: [Scanner allowUnderscoreAsAssignment ]! !!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:04'!allowUnderscoreSelectors	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreSelectors])		ifNil: [Scanner prefAllowUnderscoreSelectors]! !!SHTextStyler methodsFor: 'styling' stamp: 'lr 4/8/2010 15:56'!evaluateWithoutStyling: aBlock	| t |	t := stylingEnabled.	stylingEnabled := false.	^ aBlock ensure: [stylingEnabled := t]! !!SHTextStyler methodsFor: 'private' stamp: 'ul 4/28/2010 20:27'!monitor	^monitor ifNil: [monitor := Monitor new]! !!SHTextStyler methodsFor: 'copying' stamp: 'cmm 4/26/2011 14:29'!veryDeepInner: aDeepCopier	super veryDeepInner: aDeepCopier.	sem := backgroundProcess := monitor := nil.	text := text veryDeepCopyWith: aDeepCopier.	view := view veryDeepCopyWith: aDeepCopier! !!SHTextStylerST80 methodsFor: 'private' stamp: 'nice 5/8/2011 12:06'!setAttributesIn: aText fromRanges: ranges	| charAttr defaultAttr attr newRuns newValues lastAttr oldRuns lastCount | 					oldRuns := aText runs.	defaultAttr := self attributesFor: #default.	charAttr := Array new: aText size.	1 to: charAttr size do: [:i | charAttr at: i put: defaultAttr].	ranges do: [:range |		(attr := self attributesFor: range type) == nil			ifFalse:[	range start to: range end do: [:i | charAttr at: i put: attr]]].	newRuns := OrderedCollection new: charAttr size // 10.	newValues := OrderedCollection new: charAttr size // 10.	1 to: charAttr size do: [:i |		attr := charAttr at: i.		i = 1 			ifTrue: [				newRuns add: 1.				lastCount := 1.				lastAttr := newValues add: attr]			ifFalse:[				attr == lastAttr					ifTrue: [						lastCount := lastCount + 1.						newRuns at: newRuns size put: lastCount]					ifFalse: [						newRuns add: 1.						lastCount := 1.						lastAttr := newValues add: attr]]].		aText runs: (RunArray runs: newRuns values: newValues).	oldRuns withStartStopAndValueDo:[:start :stop :attribs|		(attribs anySatisfy: [:each | self shouldPreserveAttribute: each])			ifTrue: [				attribs do: [:eachAttrib | aText addAttribute: eachAttrib from: start to: stop]]].	! !!SHTextStylerST80 methodsFor: 'converting' stamp: 'nice 5/8/2011 12:07'!unstyledTextFrom: aText	"Re-implemented so that TextActions are not removed from aText"	| answer |		answer := super unstyledTextFrom: aText.	aText runs withStartStopAndValueDo: [:start :stop :attribs |		(attribs anySatisfy: [:each | each isKindOf: TextAction])			ifTrue: [				attribs do: [:eachAttrib | answer addAttribute: eachAttrib from: start to: stop]]].	^answer! !!SHTextStylerST80 methodsFor: 'copying' stamp: 'cmm 4/26/2011 14:29'!veryDeepInner: aDeepCopier 	super veryDeepInner: aDeepCopier.	classOrMetaClass := classOrMetaClass veryDeepCopyWith: aDeepCopier.	workspace := workspace veryDeepCopyWith: aDeepCopier.	"share the font?"	parser := parser veryDeepCopyWith: aDeepCopier.	sourceMap := sourceMap veryDeepCopyWith: aDeepCopier.	processedSourceMap := processedSourceMap veryDeepCopyWith: aDeepCopier! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'ul 1/28/2011 01:00'!defaultStyleTable	"color can be a valid argument to Color class>>colorFrom: , or nil to	use the editor text color.	Multiple emphases can be specified using an array e.g. #(bold italic).	If emphasis is not specified, #normal will be used.	if pixel height is not specified , then the editor font size will be used.	"								^#(	"(symbol	color		[emphasisSymbolOrArray		[textStyleName [pixelHeight]]])"			(default 								black 		)	(invalid 								red 			)	(excessCode 								red 			)	(comment 								(green muchDarker) 		italic)	(unfinishedComment 					(red muchDarker) 	italic)	(#'$'									(red muchDarker) 	)	(character								(red muchDarker) 	)	(integer									(red muchDarker) 	)	(number								(red muchDarker) 	)		(#-										(red muchDarker) 	)	(symbol									(blue muchDarker)			bold)		(stringSymbol							(blue muchDarker)			bold)		(literalArray							(blue muchDarker)			bold)	(string									(magenta muchDarker)	normal)	(unfinishedString						red			normal		)	(assignment								nil			bold			)	(ansiAssignment 						nil			bold)	(literal									nil			italic)	(keyword								(blue muchDarker)			)	(binary 								(blue muchDarker)			)		(unary									(blue muchDarker)			)	(incompleteKeyword						(gray muchDarker)			underlined)	(incompleteBinary 						(gray muchDarker)			underlined)		(incompleteUnary						(gray muchDarker)			underlined)	(undefinedKeyword						red			)	(undefinedBinary 						red			)		(undefinedUnary						red			)														(patternKeyword 						nil			bold)	(patternBinary 							nil			bold)	(patternUnary							nil			bold)		(#self 									(red muchDarker)	bold)	(#super									(red muchDarker)	bold) 	(#true 									(red muchDarker)	bold)	(#false 									(red muchDarker)	bold)	(#nil 									(red muchDarker)	bold)	(#thisContext 							(red muchDarker)	bold)	(#return								(red muchDarker)	bold)	(patternArg 							(blue muchDarker)			italic)		(methodArg 								(blue muchDarker)			italic)	(blockPatternArg 						(blue muchDarker)			italic)	(blockArg 								(blue muchDarker)			italic)	(argument 								(blue muchDarker)			italic)	(blockArgColon							black		) 	(leftParenthesis							black		) 	(rightParenthesis						black		) 	(leftParenthesis1						(green muchDarker)		) 	(rightParenthesis1						(green muchDarker)		) 	(leftParenthesis2						(magenta muchDarker)		) 	(rightParenthesis2						(magenta muchDarker)		) 	(leftParenthesis3						(red muchDarker)		) 	(rightParenthesis3						(red muchDarker)		) 	(leftParenthesis4						(green darker)		) 	(rightParenthesis4						(green darker)		) 	(leftParenthesis5						(orange darker)		) 	(rightParenthesis5						(orange darker)		) 	(leftParenthesis6						(magenta darker)		) 	(rightParenthesis6						(magenta darker)		) 	(leftParenthesis7						blue		) 	(rightParenthesis7						blue		) 	(blockStart 								black		) 	(blockEnd 								black		) 	(blockStart1								(green muchDarker)			) 	(blockEnd1								(green muchDarker)			) 	(blockStart2								(magenta muchDarker)		) 	(blockEnd2								(magenta muchDarker)		) 	(blockStart3								(red muchDarker)		) 	(blockEnd3								(red muchDarker)		) 	(blockStart4								(green darker)		) 	(blockEnd4								(green darker)		) 	(blockStart5								(orange darker)		) 	(blockEnd5								(orange darker)		) 	(blockStart6								(magenta darker)		) 	(blockEnd6								(magenta darker)		) 	(blockStart7								blue		) 	(blockEnd7								blue		) 																																																			(arrayStart								black		) 	(arrayEnd								black		) 	(arrayStart1							black		) 	(arrayEnd1								black		) 	(byteArrayStart								black		) 	(byteArrayEnd								black		) 	(byteArrayStart1							black		) 	(byteArrayEnd1								black		) 	(leftBrace 								black		) 	(rightBrace 								black		) 	(cascadeSeparator 						black		) 	(statementSeparator 						black		) 	(externalCallType 						black		) 	(externalCallTypePointerIndicator 		black		) 	(primitiveOrExternalCallStart 			black	bold	) 	(primitiveOrExternalCallEnd				black	bold	)	(methodTempBar							gray		) 	(blockTempBar 							gray		)	(blockArgsBar							gray		)	(primitive								(green muchDarker)		bold)	(pragmaKeyword						(green muchDarker)		bold)	(pragmaUnary							(green muchDarker)		bold)	(pragmaBinary							(green muchDarker)		bold)										(externalFunctionCallingConvention		(green muchDarker)		bold) 	(module									(green muchDarker)		bold)	(blockTempVar 							gray		italic)	(blockPatternTempVar					gray		italic)	(instVar 								black		bold)	(workspaceVar							black		bold)	(undefinedIdentifier						red			bold)	(incompleteIdentifier					(gray darker) 	(italic underlined))	(tempVar								(gray darker)	italic)	(patternTempVar						(gray darker)	italic)	(poolConstant							(gray darker)	italic)	(classVar								(gray darker)	bold)	(globalVar								black		bold) )							! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'ul 10/3/2010 01:16'!styleTable	^styleTable ifNil: [ styleTable := self chooseDefaultStyleTable ]! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'ul 1/28/2011 01:00'!subduedStyleTable	"color can be a valid argument to Color class>>colorFrom: , or nil to	use the editor text color.	Multiple emphases can be specified using an array e.g. #(bold italic).	If emphasis is not specified, #normal will be used.	if pixel height is not specified , then the editor font size will be used.	"								^#(	"(symbol	color		[emphasisSymbolOrArray		[textStyleName [pixelHeight]]])"			(default 								black 		)	(invalid 								red 			)	(excessCode 								red 			)	(comment 								(cyan muchDarker) 		)	(unfinishedComment 					(red muchDarker) 	italic)	(#'$'									(red muchDarker) 	)	(character								(red muchDarker) 	)	(integer									(red muchDarker) 	)	(number								(red muchDarker) 	)		(#-										(red muchDarker) 	)	(symbol									(blue muchDarker)			)		(stringSymbol							(blue muchDarker)			)		(literalArray							(blue muchDarker)			)	(string									(magenta muchDarker)	normal			)	(unfinishedString						red			normal			)	(assignment								nil			bold			)	(ansiAssignment 						nil			bold)	(literal									nil			italic)	(keyword								(blue muchDarker)			)	(binary 								(blue muchDarker)			)		(unary									(blue muchDarker)			)	(incompleteKeyword						(gray muchDarker)			underlined)	(incompleteBinary 						(gray muchDarker)			underlined)		(incompleteUnary						(gray muchDarker)			underlined)	(undefinedKeyword						red			)	(undefinedBinary 						red			)		(undefinedUnary						red			)														(patternKeyword 						nil			bold)	(patternBinary 							nil			bold)	(patternUnary							nil			bold)		(#self 									(red muchDarker)	)	(#super									(red muchDarker)	) 	(#true 									(red muchDarker)	)	(#false 									(red muchDarker)	)	(#nil 									(red muchDarker)	)	(#thisContext 							(red muchDarker)	)	(#return								(red muchDarker)	)	(patternArg 							(blue muchDarker)			)		(methodArg 								(blue muchDarker)			)	(blockPatternArg 						(blue muchDarker)			)	(blockArg 								(blue muchDarker)			)	(argument 								(blue muchDarker)			)	(blockArgColon							black		) 	(leftParenthesis							black		) 	(rightParenthesis						black		) 	(leftParenthesis1						(green muchDarker)		) 	(rightParenthesis1						(green muchDarker)		) 	(leftParenthesis2						(magenta muchDarker)		) 	(rightParenthesis2						(magenta muchDarker)		) 	(leftParenthesis3						(red muchDarker)		) 	(rightParenthesis3						(red muchDarker)		) 	(leftParenthesis4						(green darker)		) 	(rightParenthesis4						(green darker)		) 	(leftParenthesis5						(orange darker)		) 	(rightParenthesis5						(orange darker)		) 	(leftParenthesis6						(magenta darker)		) 	(rightParenthesis6						(magenta darker)		) 	(leftParenthesis7						blue		) 	(rightParenthesis7						blue		) 	(blockStart 								black		) 	(blockEnd 								black		) 	(blockStart1								(green muchDarker)			) 	(blockEnd1								(green muchDarker)			) 	(blockStart2								(magenta muchDarker)		) 	(blockEnd2								(magenta muchDarker)		) 	(blockStart3								(red muchDarker)		) 	(blockEnd3								(red muchDarker)		) 	(blockStart4								(green darker)		) 	(blockEnd4								(green darker)		) 	(blockStart5								(orange darker)		) 	(blockEnd5								(orange darker)		) 	(blockStart6								(magenta darker)		) 	(blockEnd6								(magenta darker)		) 	(blockStart7								blue		) 	(blockEnd7								blue		) 																																																			(arrayStart								black		) 	(arrayEnd								black		) 	(arrayStart1							black		) 	(arrayEnd1								black		) 	(byteArrayStart								black		) 	(byteArrayEnd								black		) 	(byteArrayStart1							black		) 	(byteArrayEnd1								black		) 	(leftBrace 								black		) 	(rightBrace 								black		) 	(cascadeSeparator 						black		) 	(statementSeparator 						black		) 	(externalCallType 						black		) 	(externalCallTypePointerIndicator 		black		) 	(primitiveOrExternalCallStart 			black		) 	(primitiveOrExternalCallEnd				black		)	(methodTempBar							gray		) 	(blockTempBar 							gray		)	(blockArgsBar							gray		)	(primitive								(green muchDarker)		bold)	(pragmaKeyword						(green muchDarker)		bold)	(pragmaUnary							(green muchDarker)		bold)	(pragmaBinary							(green muchDarker)		bold)										(externalFunctionCallingConvention		(green muchDarker)		bold) 	(module									(green muchDarker)		bold)	(blockTempVar 							gray		)	(blockPatternTempVar					gray		)	(instVar 								black		)	(workspaceVar							black		)	(undefinedIdentifier						red			)	(incompleteIdentifier					(gray darker) 	(italic underlined))	(tempVar								(gray darker)	)	(patternTempVar						(gray darker)	)	(poolConstant							(gray muchDarker)	)	(classVar								(gray muchDarker)	)	(globalVar								black		) )! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'lr 12/18/2009 11:30'!textAttributesByPixelHeight	^ textAttributesByPixelHeight ifNil: [ textAttributesByPixelHeight := Dictionary new ]! !!SMAccount methodsFor: 'files' stamp: 'gk 4/18/2006 22:53'!newFile: fileName block: aBlock	"Create a new file. Let <aBlock> fill the file with content by calling it with a stream."	| dir stream |	dir := self uploadsDirectory.	[(dir fileExists: fileName) ifTrue:[dir deleteFileNamed: fileName].	stream := dir newFileNamed: fileName.	stream binary.	aBlock value: stream] ensure: [stream close]! !!SMAccount methodsFor: '*smloader' stamp: 'cmm 1/26/2011 21:12'!downloadsDirectory	"Get the directory for uploaded files, create it if missing."	^ 'http://' , SMSqueakMap findServer , '/accountbyid/' , self id asString , '/files'! !!SMCategorizableObject methodsFor: 'accessing' stamp: 'cmm 2/7/2011 15:03'!communitySupportedCategory	^ self categories		detect: [:each | each name = 'Community Supported']		ifNone: []! !!SMCategorizableObject methodsFor: 'testing' stamp: 'cmm 2/4/2011 18:21'!beCommunitySupported	self addCategory: (self map categoryWithNameBeginning: 'Community Supported')! !!SMCategorizableObject methodsFor: 'testing' stamp: 'cmm 2/7/2011 15:03'!isCommunitySupported	^ self communitySupportedCategory notNil! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13'!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13'!hash	^self withoutListWrapper hash! !!SMCategoryWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 18:53'!asString	^ item name , ' (' , self numberOfObjects printString , ')'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:35'!category	^item! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 21:02'!contents	^ item subCategories		collect: [:n | self class with: n model: n]! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:56'!help	^ 'The categories are structured in a tree. Packages and package releases belong to several categories. You can add one or more categories as filters and enable them in the menu.'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'BJP 11/22/2002 14:17'!model	^model! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:53'!numberOfObjects"	| total |	total := 0.	model allCategoriesDo: [:c |		total := total + c objects size].	^total"	^item objects size! !!SMCategoryWrapper methodsFor: 'model access' stamp: 'btr 11/30/2006 21:02'!getList	^ Array		with: (self class with: self contents model: model)! !!SMCategoryWrapper methodsFor: 'testing' stamp: 'btr 11/30/2006 18:53'!hasContents	^ item hasSubCategories! !!SMClient methodsFor: 'private' stamp: 'cmm 1/26/2011 21:44'!client	^ client ifNil:		[ client := self class assureWebClient new			 allowRedirect: false ;			 yourself ]! !!SMClient methodsFor: 'private' stamp: 'cmm 1/30/2011 14:46'!ensurePassword	self password isEmptyOrNil ifTrue: [ self password: (UIManager default requestPassword: 'Please enter your SqueakMap password.') ].	self password isEmptyOrNil ifTrue: [ self error: 'authentication failure' ]! !!SMClient methodsFor: 'private' stamp: 'cmm 1/28/2011 15:17'!logout	^ (client notNil and: [ client isConnected ]) ifTrue:		[ (self client httpGet: self smUrl , '/account/logout')			 content ;			 yourself ]! !!SMClient methodsFor: 'private' stamp: 'cmm 2/9/2011 21:52'!smUrl	^ 'http://', SMSqueakMap findServer! !!SMClient methodsFor: 'api' stamp: 'cmm 1/27/2011 15:32'!close	self logout.	client ifNotNil: [ client close ].	client := nil! !!SMClient methodsFor: 'api' stamp: 'cmm 1/30/2011 14:46'!login	| response |	self ensurePassword.	response := self client		httpPost: self smUrl, '/login'		content: 'uusername=' , self username , '&ppassword=', self password, '&requestedUrl=%2Faccount&1-4=Log+in'		type: 'application/x-www-form-urlencoded'		do: [ : req | req headerAt: 'Connection' put: 'Keep-Alive' ].	(#(200 302 ) includes: response code) ifFalse: [ self error: 'login error' ].	"Eat up content."	response content.	^ response! !!SMClient methodsFor: 'api' stamp: 'cmm 1/25/2011 22:36'!password	"The SqueakMap user password."	^ client ifNotNil: [ client password ]! !!SMClient methodsFor: 'api' stamp: 'cmm 1/25/2011 22:31'!password: aString	"The SqueakMap user password."	self client password: aString! !!SMClient methodsFor: 'api' stamp: 'cmm 1/28/2011 10:16'!save: aSMPackageRelease 	"Save aSMPackageRelease to the SqueakMap server."	| response |	response := self client		httpPost: self smUrl , '/account/package/' , aSMPackageRelease package id asString , '/editreleases'		content: aSMPackageRelease httpPostContent		type: 'application/x-www-form-urlencoded'		do:			[ : req | req				headerAt: 'Connection'				put: 'Keep-Alive' ].	^ response		 content ;		 yourself! !!SMClient methodsFor: 'api' stamp: 'ul 2/28/2011 08:04'!uploadFile: aDirectoryEntryFile 	"Upload aDirectoryEntryFile to the uploads area of SqueakMap for my userId."	| boundary fieldMap fileStream doc |	fileStream := aDirectoryEntryFile readStream binary.	[ doc := MIMEDocument		contentType: (MIMEDocument guessTypeFromName: aDirectoryEntryFile name)		content: fileStream contents		url: fileStream asUrl ] ensure:		[ fileStream ifNotNil: [ fileStream close ] ].	boundary := (Smalltalk at: #WebUtils) multipartBoundary.	fieldMap := {'upload' -> doc}.	^ (self client		httpPost: self smUrl , '/account/upload'		content:			((Smalltalk at: #WebUtils)				encodeMultipartForm: fieldMap				boundary: boundary)		type: MIMEDocument contentTypeMultipart , '; boundary=' , boundary		do: [ : req | req headerAt: 'Connection' put: 'keep-alive' ])		 content ;		 yourself! !!SMClient methodsFor: 'api' stamp: 'cmm 1/25/2011 22:03'!uploadFileNamed: filename	"Upload filename to the uploads area of SqueakMap for my userId."	^ self uploadFile: (FileDirectory default entryAt: filename)! !!SMClient methodsFor: 'api' stamp: 'cmm 1/25/2011 22:35'!username	"The SqueakMap username."	^ client ifNotNil: [ client username ]! !!SMClient methodsFor: 'api' stamp: 'cmm 1/25/2011 22:35'!username: aString	"The SqueakMap username."	self client username: aString! !!SMClient methodsFor: 'initialize-release' stamp: 'cmm 1/26/2011 11:26'!initialize	super initialize.	self username: Utilities authorInitialsPerSe ! !!SMClient commentStamp: 'cmm 1/30/2011 14:54' prior: 0!I can be used to save packages to the SqueakMap server.  Here are the fields to save a release:	1-1 = "Select release:" = 3	1-3 = "Version" = 100	1-4 = License drop-down index = 7	1-5 = Compatibility = 5	1-6 = Squeak versions = 11	1-7 = Maturity = 4	1-8 = Download url = http%3A%2F%2Fminnow.cc.gatech.edu%2Fsqueak%2Fuploads%2F2978%2FMa%2520client%2520server-cmm.mcz.sar	1-9 = (file-selection drop-down) = 1 "None"	1-10 = Name (a cool one if you want) = [empty string]	1-11 = Summary = [empty string]	(1-12)* = Additional categories	1-13 = Release note = This+version+much+faster+than+the+prior+SqueakMap+version.%0D%0A%0D%0AThis+single+release+installs+correctly+on+3.6%2C+3.7%2C+3.8%2C+3.9alpha+and+Jasmin+0.3++%28Croquet%29+images.%0D%0A%0D%0A	1-17 = Button clicked = Save+changes	1-18 = Button clicked = 'Save as new release' encodeForHTTP	1-19 = parent release = 3!!SMClient class methodsFor: 'private' stamp: 'cmm 1/25/2011 22:16'!assureWebClient	^ (Smalltalk classNamed: #WebClient) ifNil:		[ self installWebClient.		Smalltalk classNamed: #WebClient ]! !!SMClient class methodsFor: 'private' stamp: 'cmm 1/25/2011 22:12'!installWebClient 	(Installer repository: 'http://www.squeaksource.com/WebClient')		install: 'WebClient-Core-ar.83'! !!SMFileCache methodsFor: 'services' stamp: 'cmm 2/9/2011 21:37'!add: aDownloadable 	"Conditionally download the downloadable object into the cache.	Return true on success, otherwise false."	aDownloadable downloadFileName isEmptyOrNil ifTrue: [ ^ false ].	^(self includes: aDownloadable)		ifTrue: [true]		ifFalse: [self download: aDownloadable]! !!SMFileCache methodsFor: 'services' stamp: 'cmm 1/24/2011 14:54'!includes: anSMObject 	"Check if the cache holds the file for the object."	^ anSMObject downloadFileName notNil and: [ anSMObject cacheDirectory fileExists: anSMObject downloadFileName ]! !!SMFileCache methodsFor: 'services' stamp: 'cmm 2/9/2011 21:25'!remove: aDownloadable 	"Remove aDownloadable from the cache, if it exists."	(self includes: aDownloadable) ifTrue:		[ aDownloadable cacheDirectory deleteFileNamed: aDownloadable downloadFileName ]! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:56'!packagesListIndex: anObject 	self		selectedItemWrapper: (anObject ifNotNil: [anObject = 0				ifFalse: [self packageWrapperList at: anObject]])! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 19:17'!selectedCategory	"Return selected category."	^selectedCategoryWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'accessing' stamp: 'btr 12/1/2006 15:51'!selectedCategoryWrapper: aWrapper	selectedCategoryWrapper := aWrapper.	(aWrapper notNil and:		[aWrapper withoutListWrapper objects includes: selectedItemWrapper withoutListWrapper])		ifFalse: [self selectedItemWrapper: nil].	self changed: #selectedCategoryWrapper.	self changed: #packageWrapperList.! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/22/2006 19:13'!selectedItemWrapper: aWrapper	selectedItemWrapper := aWrapper.	self changed: #selectedItemWrapper.	self contentsChanged! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:14'!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 19:27'!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or description."	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty ifTrue: [^self].	descriptions := self packageWrapperList collect: [:e | e withoutListWrapper description].	index + 1 to: list size		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	"wrap around"	1 to: index		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoader methodsFor: 'actions' stamp: 'cmm 2/9/2011 14:28'!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease				ifNil: [^ nil].	item isPackageRelease		ifTrue: [^ self installPackageRelease: item]		ifFalse: [release := item lastPublishedReleaseForCurrentSystemVersion.			release				ifNil: [(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')						ifTrue: [release := item lastPublishedRelease.							release								ifNil: [(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')										ifTrue: [release := item lastRelease]]]].			release				ifNotNil: [^ self installPackageRelease: release]]! !!SMLoader methodsFor: 'actions' stamp: 'mist 8/17/2005 13:56'!installPackageWithDependents: package	| myRelease |	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		package installWithDependencies.		myRelease = self installedReleaseOfMe ifFalse: [self reOpen].		self noteChanged]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 21:03'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45'!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoader methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 00:14'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('Installed packages' #filterInstalled 'Display only packages that are installed.')	#('Published packages' #filterPublished 'Display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'Packages in ', (model object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'initialization' stamp: 'cmm 1/19/2011 14:45'!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy! !!SMLoader methodsFor: 'initialization' stamp: 'gk 4/5/2005 21:17'!openAsMorph	"Open the loader as a Morphic window."	"SMLoader new openAsMorph"		^self createWindow openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01'!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (model categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list		collect: [:cat | SMCategoryWrapper with: cat model: self]! !!SMLoader methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				(filters ifNil: [#()]) allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNotNil:		[selectedCategory := selectedCategoryWrapper category.		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:08'!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:11'!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:05'!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoader methodsFor: 'menus' stamp: 'cmm 1/27/2011 10:47'!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [ choices add: self buttonSpecs first ].	(packageOrRelease isDownloadable and: [ packageOrRelease isCached ]) ifTrue: [ choices add: self buttonSpecs third ].	(packageOrRelease isPackageRelease and: [ packageOrRelease isDownloadable ]) ifTrue:		[ choices add: #('Copy from cache' #cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' ).		choices add: #('Force download into cache' #downloadPackageRelease 'Force a download of the selected release into the cache.' ).		packageOrRelease isPackageRelease ifTrue: [ choices add: #('Edit Release' #openReleaseEditor 'Open a browser on this release to make updates.' ) ].		choices add: #('Create new Release' #createNewRelease 'Create a new release based on this release' ) ].	choices add: self buttonSpecs second.	^ choices! !!SMLoader methodsFor: 'private' stamp: 'cmm 1/28/2011 16:44'!createNewRelease	SMReleaseBrowser		 openOn: self selectedItem newUnattachedRelease initializeMandatoryCategories ;		 yourself! !!SMLoader methodsFor: 'private' stamp: 'btr 11/26/2006 23:22'!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	self delete.	(Smalltalk at: self class name) open! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:10'!selectedPackageOrRelease	"Return selected package or package release."	^self selectedItemWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:03'!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:15'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease ifNil: [^ nil].	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:52'!buildButtonBar	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	self buttonSpecs do: [:spec |		btn := self buildButtonNamed: spec first helpText: spec third action: spec second.		aRow addMorphBack: btn]		separatedBy: [aRow addTransparentSpacerOfSize: 3@0].	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:27'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 19:04'!buildMorphicCategoriesList	"Create the hierarchical list holding the category tree."	| list |	list := (SimpleHierarchicalListMorph				on: self				list: #categoryWrapperList				selected: #selectedCategoryWrapper				changeSelected: #selectedCategoryWrapper:				menu: #categoriesMenu:				keystroke: nil) autoDeselect: true;				 enableDrag: false;				 enableDrop: true;				 yourself.	list setBalloonText: 'The categories are structured in a tree. Packages and package releases belong to several categories.You can add one or more categories as filters and enable them in the menu.'.	"list scroller submorphs do:[:each| list expandAll: each]."	list adjustSubmorphPositions.	^ list! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:22'!buildMorphicPackagesList	"Create the hierarchical list holding the packages and releases."	^(SimpleHierarchicalListMorph 		on: self		list: #packageWrapperList		selected: #selectedItemWrapper		changeSelected: #selectedItemWrapper:		menu: #packagesMenu:		keystroke: nil)		autoDeselect: false;		enableDrag: false;		enableDrop: true;		setBalloonText: 'This shows all packages with their releases that should be displayed according the current filter.';		yourself! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:13'!buildPackageButtonBar	| aRow |	"Somewhat patterned after IRCe's buttonRow method."	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'gk 5/5/2006 02:05'!buildPackagePane	"Create the text area to the right in the loader."	| ptm |	ptm := PluggableTextMorph 		on: self 		text: #contents		accept: nil		readSelection: nil "#packageSelection "		menu: nil.	ptm setBalloonText: 'This is where the selected package or package release is displayed.'.	ptm lock.	^ptm! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:08'!buildSearchPane	"Cribbed from MessageNames>>inMorphicWindowWithInitialSearchString:"	| typeInView searchButton typeInPane |	typeInView := PluggableTextMorph				on: self				text: nil				accept: #findPackage:notifying:				readSelection: nil				menu: nil.	typeInView acceptOnCR: true;		 vResizing: #spaceFill;		 hResizing: #spaceFill;		 setTextMorphToSelectAllOnMouseEnter;		 askBeforeDiscardingEdits: false;		 setProperty: #alwaysAccept toValue: true.	(typeInView respondsTo: #hideScrollBarsIndefinitely)		ifTrue: [typeInView hideScrollBarsIndefinitely]		ifFalse: [typeInView hideScrollBarIndefinitely].	searchButton := SimpleButtonMorph new target: typeInView;				 color: Color white;				 label: 'Search';				 actionSelector: #accept;				 arguments: #(); yourself.	typeInPane := AlignmentMorph newRow.	typeInPane vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 listDirection: #leftToRight;		 addMorphFront: searchButton;		 addTransparentSpacerOfSize: 6 @ 0;		 addMorphBack: typeInView;		 setBalloonText: 'Type into the pane, then press Search (or hit RETURN) to visit the next package matching what you typed.'.	^ typeInPane! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:24'!buttonSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.')		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.')		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.')		('Update' loadUpdates 'Update the package index from the servers.')		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).')		('Help' help 'What is this?'))! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 17:30'!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.3.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0.0 @ 0.0 corner: 1.0 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0.0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (0.0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0.0 @ horizDivide corner: vertDivide @ 1.0).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1.0 @ 1.0).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self! !!SMLoader methodsFor: 'interface' stamp: 'gk 7/12/2004 11:14'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:01'!defaultLabel	^'SqueakMap Package Loader'! !!SMLoader methodsFor: 'interface' stamp: 'gk 4/12/2010 00:03'!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by (installed version -> latest version).If there is no arrow, your installed version of the package is the latest.Installed packages and releases are also in bold.The checkbox menu items at the bottom let you modify which packages you''ll see. Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.If you like a package or have comments on it, please contactthe author or the squeak mailing list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/squeak/2726' asUrl]! !!SMLoader methodsFor: 'interface' stamp: 'gk 4/5/2005 21:43'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:02'!updateLabel: packagesShown	"Update the label of the window."	self setLabel: self defaultLabel , ' (',			(packagesShown size < model packages size ifTrue: [packagesShown size printString,			' shown out of '] ifFalse: ['']) , model packages size printString, ' packages)'! !!SMLoader commentStamp: 'btr 11/30/2006 18:00' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance).You can open one with:	SMLoader open!!SMLoader class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47'!initialize	"Hook us up in the world menu."	"self initialize"	Smalltalk		at: #ToolBuilder		ifAbsent: [self registerInFlapsRegistry.			(Preferences windowColorFor: #SMLoader) = Color white				ifTrue: ["not set"					Preferences						setWindowColorFor: #SMLoader						to: (Color colorFrom: self windowColorSpecification brightColor)].			(TheWorldMenu respondsTo: #registerOpenCommand:)				ifTrue: [| oldCmds |					oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].					oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].					TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoader class methodsFor: 'new-morph participation' stamp: 'ar 5/10/2010 20:56'!prototypicalToolWindow	"Do not update when creating a prototype window (used by flaps etc)"	^[self new createWindow; applyModelExtent; yourself]		valueSupplyingAnswers:{ {'*map on disk*'. false}}! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #installedPackageNameList		selected: #installedPackagesListIndex		changeSelected: #installedPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicNotInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #notInstalledPackageNameList		selected: #notInstalledPackagesListIndex		changeSelected: #notInstalledPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!createFancyWindow	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicNotInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (horizDivide / 2)).	self addMorph: (self buildMorphicInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setUpdatablePanesFrom: #(#installedPackageNameList #notInstalledPackageNameList ).	currentPackageList := #notInstalled.	self setLabel: self defaultLabel! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setLabel: self defaultLabel! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!defaultLabel	^ 'SqueakMap Categorical Package Loader'! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:58'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['Remove the above package']! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 17:27'!currentPackageList	^currentPackageList! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'btr 11/30/2006 17:44'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!installedPackagesListIndex	self currentPackageList = #installed		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!installedPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 15:09'!isOn	^false! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!notInstalledPackagesListIndex	self currentPackageList = #notInstalled		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!installedPackageNameList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!notInstalledPackageNameList	^self packageList select: [:e | e isInstalled not]! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderCategorical methodsFor: 'private' stamp: 'btr 11/30/2006 20:21'!noteChanged	self changed: #installedPackageNameList.	self changed: #notInstalledPackageNameList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategorical commentStamp: 'btr 12/1/2006 15:16' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategorical open!!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifAbsent: [	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:50'!buildFancyWith: aBuilder	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: builder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: builder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: builder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildNotInstalledPackagesListWith: builder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ (horizDivide / 2)); yourself);				add: ((self buildInstalledPackagesListWith: builder)					frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: builder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	self setUpdatablePanesFrom: #(#installedPackageList #notInstalledPackageList ).	currentPackageList := #notInstalled.	window extent: self initialExtent.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:56'!buildInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #installedPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:52'!buildNotInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #notInstalledPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:55'!buildWith: aBuilder	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: builder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: builder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: builder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)));				add: ((self buildPackagesListWith: builder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide));				add: ((self buildPackagePaneWith: builder)					frame: (0 @ horizDivide corner: 1 @ 1)); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: self initialExtent.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/4/2006 15:55'!defaultLabel	^ 'Categorical ' , super defaultLabel! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/4/2006 15:58'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['Remove the above package']! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList	^currentPackageList! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!installedPackagesListIndex	^ self currentPackageList = #installed		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!installedPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!isOn	^false! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!notInstalledPackagesListIndex	^ self currentPackageList = #notInstalled		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:03'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:52'!installedPackageList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:53'!notInstalledPackageList	^self packageList reject: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:34'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderCategoricalPlus methodsFor: 'private' stamp: 'btr 12/1/2006 17:53'!noteChanged	self changed: #installedPackageList.	self changed: #notInstalledPackageList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategoricalPlus commentStamp: 'btr 12/4/2006 15:47' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategoricalPlus open!!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifPresent: [:tb |		(TheWorldMenu respondsTo: #registerOpenCommand:)			ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:01'!commandSpecFor: selector	^ self commandSpecs detect: [:spec | spec second = selector]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'cmm 1/27/2011 14:22'!commandSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.' (item all))		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.' (item all))		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.' (item all))		('Copy from cache' cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' (item))		('Edit Release' openReleaseEditor 'Open a browser on this release to make updates.' (item))		('Create new Release' createNewRelease 'Create a new release based on the selected item' (item))		('Force download into cache' downloadPackageRelease 'Force a download of the selected release into the cache.' (item))		('Update' loadUpdates 'Update the package index from the servers.' (all))		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).' (all))		('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm '' (item))		('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm '' (item))		('Copy list' listInPasteBuffer 'Puts the list as text into the clipboard.' (all))		('Save filters' saveFiltersAsDefault 'Saves the current filters as default.' (all))		('Help' help 'What is this?' (all)))! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoaderPlus methodsFor: 'menus' stamp: 'cmm 1/26/2011 15:57'!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [ choices add: (self commandSpecFor: #installPackageRelease) ].	(packageOrRelease isDownloadable and: [ packageOrRelease isCached ]) ifTrue: [ choices add: (self commandSpecFor: #browseCacheDirectory) ].	(packageOrRelease isPackageRelease and: [ packageOrRelease isDownloadable ]) ifTrue:		[ choices add: (self commandSpecFor: #cachePackageReleaseAndOfferToCopy).		choices add: (self commandSpecFor: #downloadPackageRelease) ].	choices add: (self commandSpecFor: #emailPackageMaintainers).	packageOrRelease isPackageRelease ifTrue: [ choices add: (self commandSpecFor: #openReleaseEditor) ].	choices add: (self commandSpecFor: #createNewRelease).	^ choices! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[UIManager default informUser: 'Caching ' , release asString during: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoaderPlus methodsFor: 'actions' stamp: 'cmm 1/28/2011 16:44'!createNewRelease	SMReleaseBrowser		 openOn: self selectedItem newUnattachedRelease initializeMandatoryCategories ;		 yourself! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[UIManager default informUser: 'Downloading ' , release asString during: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/24/2006 13:49'!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or	description. "	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty		ifTrue: [^ self].	descriptions := self packageList collect: [:e | e description].	index + 1		to: list size		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	"wrap around"	1		to: index		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoaderPlus methodsFor: 'actions' stamp: 'cmm 2/9/2011 14:28'!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease				ifNil: [^ nil].	item isPackageRelease		ifTrue: [^ self installPackageRelease: item]		ifFalse: [release := item lastPublishedReleaseForCurrentSystemVersion.			release				ifNil: [(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')						ifTrue: [release := item lastPublishedRelease.							release								ifNil: [(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')										ifTrue: [release := item lastRelease]]]].			release				ifNotNil: [^ self installPackageRelease: release]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:31'!loadUpdates	[UIManager default informUser: 'Loading Updates' during: [		map loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'cmm 1/26/2011 11:18'!openReleaseEditor	SMReleaseBrowser openOn: self selectedItem ! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during: [				map upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:43'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease				ifNil: [^ nil].	dir := item isPackage				ifTrue: [map cache directoryForPackage: item]				ifFalse: [map cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir.	"withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:56'!buildButtonBarWith: aBuilder	^ aBuilder pluggablePanelSpec new		model: self;		layout: #horizontal;		children: (self commandSpecs select: [ :spec | spec fourth includes: #all]				thenCollect: [ :spec |					aBuilder pluggableActionButtonSpec new						model: self;						label: spec first;						action: spec second;						help: spec third;						enabled: ((spec fourth includes: #item) ifTrue: [#hasSelectedItem]);						yourself]);		name: #buttonBar;		yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:56'!buildCategoriesListWith: aBuilder 	"Create the hierarchical list holding the category tree."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #categoryList;		 getSelectedPath: #selectedCategoryPath;		 getChildren: #categoryChildren:;		 hasChildren: #categoryHasChildren:;		 setSelected: #selectedCategory:;		 menu: #categoriesMenu:;		 label: #categoryLabel:;		 autoDeselect: true;		 wantsDrop: true;		 name: #categoriesList;		 yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildPackagePaneWith: aBuilder	"Create the text area to the right in the loader."	^ aBuilder pluggableTextSpec new model: self; getText: #itemDescription; name: #packagePane; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildPackagesListWith: aBuilder 	"Create the hierarchical list holding the packages and releases."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #packageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 name: #packagesList;		 yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildSearchPaneWith: aBuilder	^ aBuilder pluggableInputFieldSpec new model: self;		selection: #searchSelection;		getText: #searchText; setText: #findPackage:notifying:; name: #search; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:54'!buildWith: aBuilder 	"Create the package loader window."	| buttonBarHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	vertDivide := 0.6.	horizDivide := 0.3.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;					 label: #label;					 children: (OrderedCollection new						add: ((self buildButtonBarWith: builder)							frame: (0 @ 0 corner: 1 @ buttonBarHeight));						add: ((self buildSearchPaneWith: builder)							frame: (0 @ buttonBarHeight corner: horizDivide @ (buttonBarHeight * 2)));						add: ((self buildPackagesListWith: builder)							frame: (0 @ (buttonBarHeight * 2) corner: horizDivide @ vertDivide));						add: ((self buildCategoriesListWith: builder)							frame: (0 @ vertDivide corner: horizDivide @ 1));						add: ((self buildPackagePaneWith: builder)								frame: (horizDivide @ buttonBarHeight corner: 1 @ 1));						 yourself);					 yourself).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: self initialExtent.	^ window! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!categoryChildren: aCategory	^ aCategory subCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!categoryHasChildren: aCategory	^ aCategory hasSubCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:46'!categoryLabel: aCategory	^ aCategory name! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by versions: (installed -> latest).If there is no arrow, your installed version of the package is the latest.Bold packages and releases have been installed.The checkbox menu items modify which packages you''ll see.Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.Comment on a package by emailing the author or the squeak list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/2726' asUrl]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 05:28'!initialExtent	^500@400! !!SMLoaderPlus methodsFor: 'interface' stamp: 'cmm 1/29/2011 16:43'!itemChildren: anItem 	^ anItem isPackage		ifTrue: [ self sortReleases: anItem releases ]		ifFalse: [ #() ]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!itemHasChildren: anItem 	^ anItem isPackage and: [anItem releases notEmpty]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!itemLabel: anItem 	| label |	label := anItem isPackage				ifTrue: [anItem name						, (anItem versionLabel								ifEmpty: ['']								ifNotEmptyDo: [:lbl | ' (' , anItem versionLabel , ')'])]				ifFalse: [anItem smartVersion].	^ anItem isInstalled		ifTrue: [label asText allBold]		ifFalse: [label]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:45'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	^ (self respondsTo: selector)		ifTrue: [self perform: selector]		ifFalse: [super perform: selector orSendTo: otherTarget]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchSelection	"Selects all of the default search text so that a type-in overwrites it."	^ {1. self searchText size}! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchText	"A dummy default search text so that the field describes its purpose."	^ 'Search packages'! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01'!categoryList	"Create the category list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (map categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!defaultLabel	^ 'SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/24/2006 17:17'!label	^ self		labelForShown: (packagesList				ifNil: [self packageList])! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!labelForShown: packagesShown	"Update the label of the window."	^ self defaultLabel , ' (',		(packagesShown size < map packages size ifTrue: [packagesShown size printString,		' shown out of '] ifFalse: ['']) , map packages size printString, ' packages)'! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list |	list := packagesList ifNil: [packagesList := self packageListCalculated].	selectedCategory ifNotNil: [		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^ list! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageListCalculated	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	^ self packages select: [:p |		filters allSatisfy: [:currFilter |			currFilter isSymbol				ifTrue: [(self perform: currFilter) value: p]				ifFalse: [self package: p filteredByCategory: (map object: currFilter)]]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!packageNameList	^ self packageList collect: [:e | e name]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!updateLabel: packagesShown	"Update the label of the window."	window ifNotNilDo: [:w | w setLabel: (self labelForShown: packagesShown)]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/22/2006 15:02'!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex	^ self packageList indexOf: self selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex: anObject 	self		selectedItem: (anObject = 0				ifFalse: [self packageList at: anObject])! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedCategory	"Return selected category."	^ selectedCategory! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:37'!selectedCategory: anSMCategory 	"Change the selected category."	selectedCategory := anSMCategory.	selectedCategory		ifNotNil: [(selectedCategory objects includes: self selectedItem)			ifFalse: [self selectedItem: nil]].	self changed: #selectedCategory.	self changed: #packageList! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:52'!selectedCategoryPath	"Return selected category's path."	| path |	path := #().	selectedCategory		ifNotNil: [selectedCategory parent				ifNotNilDo: [:p | path := path copyWith: p].			path := path copyWith: selectedCategory].	^ path		collect: [:cat | self categoryLabel: cat]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedItem	^ selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:27'!selectedItem: anItem	"This == workaround protects us from recursion since ToolBuilder's tree widgets will always tell us that the selection has been updated when we tell it that the selection path has been updated. Cleaner solutions invited."	anItem == selectedItem ifFalse: [		selectedItem := anItem.		self changed: #selectedItemPath.		self changed: #itemDescription.		self changed: #hasSelectedItem]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:16'!selectedItemPath	| path |	path := #().	(selectedItem isKindOf: SMPackageRelease)		ifTrue: [path := path copyWith: selectedItem package].	selectedItem		ifNotNil: [path := path copyWith: selectedItem].	^ path! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:03'!selectedPackageOrRelease	"Return selected package or package release."	^ selectedItem! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/30/2006 21:07'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically') #('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.') #('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.') #('Installed packages' #filterInstalled 'Display only packages that are installed.') #('Published packages' #filterPublished 'Display only packages that have at least one published release.') ) asOrderedCollection.	categoriesToFilterIds		do: [:catId | specs add: {'Packages in ' , (map object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filters	^filters! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterAutoInstall	^[:package | package isInstallable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterAvailable	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterInstalled	^[:package | package isInstalled]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterNotUptoDate	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterPublished	^[:package | package isPublished]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterSafelyAvailable	^[:package | package isSafelyAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 18:36'!hasSelectedItem	^ self selectedPackageOrRelease notNil! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:53'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease installer |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	installer := SMInstaller forPackageRelease: aRelease.	[UIManager default informUser: 'Downloading ' , aRelease asString during:		[installer download].	UIManager default informUser: 'Installing ' , aRelease asString during: [		installer install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 19:56'!itemDescription	^ self selectedPackageOrRelease		ifNil: ['<No package selected>']		ifNotNilDo: [:item | item fullDescription]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/24/2006 14:05'!noteChanged	filters		ifNil: [^ self reOpen].	map		ifNotNil: [packagesList := nil.			selectedCategory := nil.			self changed: #categoryList.			self changed: #packageList.			self changed: #packagesListIndex.			"update my selection"			self contentsChanged]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 16:11'!packages	"We request the packages as sorted by name by default."	^map packagesByName asArray! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/26/2006 23:22'!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	window delete.	(Smalltalk at: self class name) open! !!SMLoaderPlus methodsFor: 'private' stamp: 'cmm 1/30/2011 14:10'!representsSameBrowseeAs: anotherSMLoaderPlus	^ true! !!SMLoaderPlus methodsFor: 'private' stamp: 'cmm 2/9/2011 14:49'!sortReleases: anOrderedCollection 	"SqueakMap stores them in chronological order, let's list them in reverse-chronological order for easy-selection."	| answer headIndex |	answer := anOrderedCollection reversed.	"After that, look for the 'head' release, put it to the top."	headIndex := answer findFirst:		[ : each | each version = 'head' ].	headIndex > 1 ifTrue: [ answer addFirst: (answer removeAt: headIndex) ].	^ answer! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackagesConfirm: confirmEach 	"Tries to upgrade all installed packages to the latest published release for	this version of Squeak. If confirmEach is true we ask for every	upgrade. "	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty		ifTrue: [^ self inform: 'All ' , installed size printString , ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty		ifTrue: [^ self inform: 'None of the ' , old size printString , ' old packages of the ' , installed size printString , ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size		ifTrue: ['Of the ' , old size printString , ' old packages only ' , toUpgrade size printString , ' can be upgraded.The following packages will not be upgraded:'						, (String								streamContents: [:s | (old removeAll: toUpgrade;										 yourself)										do: [:p | s nextPutAll: p nameWithVersionLabel;												 cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info , 'About to upgrade the following packages:'				, (String						streamContents: [:s | toUpgrade								do: [:p | s nextPutAll: p nameWithVersionLabel;										 cr]]) , 'Proceed?')		ifTrue: [myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during:					[confirmEach						ifTrue: [map								upgradeOldPackagesConfirmBlock: [:p | self confirm: 'Upgrade ' , p installedRelease packageNameWithVersion , ' to ' , (p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName , '?']]						ifFalse: [map upgradeOldPackages].					self inform: toUpgrade size printString , ' packages successfully processed.'.					myRelease = self installedReleaseOfMe						ifTrue: [self noteChanged]						ifFalse: [self reOpen]]]				on: Error				do: [:ex | self informException: ex msg: ('Error occurred when upgrading old packages:\' , ex messageText , '\') withCRs]]! !!SMLoaderPlus methodsFor: 'initialization' stamp: 'cmm 1/19/2011 14:45'!on: aSqueakMap 	"Initialize instance."	map := aSqueakMap.	map synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy! !!SMLoaderPlus commentStamp: 'btr 12/1/2006 15:16' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance). It uses ToolBuilder to construct its window. You can open one with:	SMLoaderPlus openInstance Variables	categoriesToFilterIds:		<OrderedCollection> The set of categories to filter the packages list.	filters:				<OrderedCollection> The set of filters to apply to the packages list.	map:				<SMSqueakMap> The model SqueakMap.	packagesList:		<OrderedCollection> The list of packages from the map.	selectedCategory:	<SMCategory> The current category.	selectedItem:			<SMPackage> The selected package or release.	window:			<PluggableSystemWindow> The window, held only so we can reOpen.!!SMLoaderPlus class methodsFor: 'parts bin' stamp: 'btr 11/22/2006 15:02'!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'cmm 1/28/2011 10:36'!initialize	"Hook us up in the world menu."	"self initialize"	Smalltalk		at: #ToolBuilder		ifPresent:			[ : tb | self registerInFlapsRegistry.			(Preferences windowColorFor: #SMLoader) = Color white "note set" ifTrue:				[				#(#SMLoader #SMReleaseBrowser ) do:					[ : each |					Preferences						setWindowColorFor: each						to: (Color colorFrom: self windowColorSpecification brightColor) ] ].			(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue:				[ | oldCmds |				oldCmds := TheWorldMenu registry select:					[ : cmd | cmd first includesSubString: 'Package Loader' ].				oldCmds do:					[ : cmd | TheWorldMenu unregisterOpenCommand: cmd first ].				TheWorldMenu registerOpenCommand: {self openMenuString. 					{self. 					#open}} ] ].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'cmm 1/21/2011 13:48'!setDefaultFilters: anOrderedCollection	DefaultFilters := anOrderedCollection! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!initializedInstance	^ (ToolBuilder open: self new) extent: 400@400! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!newStandAlone	^ ToolBuilder open: self new! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'ar 5/10/2010 20:56'!prototypicalToolWindow	"Do not update when creating a prototype window (used by flaps etc)"	^[(ToolBuilder open: self new) applyModelExtent; yourself] 		valueSupplyingAnswers:{ {'*map on disk*'. false}}! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:02'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:13'!open	"Create and open a SqueakMap Loader."		"SMLoaderPlus open"	^ (Smalltalk at: #ToolBuilder) open: self new! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:21'!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^ (Smalltalk at: #ToolBuilder) open: (self newOn: aSqueakMap)! !!SMLoaderPlus class methodsFor: 'window color' stamp: 'btr 11/22/2006 15:02'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMMaintainableObject methodsFor: 'maintainers' stamp: 'gk 9/28/2010 21:13'!rss: anUrl	anUrl = 'nil'		ifTrue: [rss := nil]		ifFalse: [rss := anUrl]! !!SMObject methodsFor: 'accessing' stamp: 'cmm 1/24/2011 17:05'!asString	^ self name! !!SMPackage methodsFor: 'services' stamp: 'cmm 2/8/2011 19:16'!lastReleaseForCurrentSystemVersion	"Return the latest published release marked	as compatible with the current SystemVersion."	^ releases isEmpty		ifFalse: [releases reversed				detect: [:r | r isCompatibleWithCurrentSystemVersion]				ifNone: []]! !!SMPackage methodsFor: 'services' stamp: 'cmm 2/9/2011 13:59'!smartVersion	"Delegate to last release for this SystemVersion."	| r |	r := self lastReleaseForCurrentSystemVersion.	^r ifNotNil: [r smartVersion] ifNil: ['']! !!SMPackage methodsFor: 'testing' stamp: 'cmm 2/8/2011 22:24'!isSafeToInstall	"Answer if I am NOT installed and there also is a	published version for this version of Squeak available."	^ self isInstalled not		and: [self lastReleaseForCurrentSystemVersion notNil]! !!SMPackage methodsFor: 'private' stamp: 'cmm 1/28/2011 17:19'!addRelease: aSMPackageRelease 	"Add the release. Make sure package is set."	(releases includes: aSMPackageRelease) ifFalse: [ releases add: aSMPackageRelease ].	aSMPackageRelease package: self.	^ aSMPackageRelease! !!SMPackage methodsFor: '*smloader' stamp: 'cmm 1/28/2011 16:42'!newUnattachedRelease	"Create a new release that is not part of the packages list of releases.  That does not happen until the user clicks Save on the UI."	^ self newUnattachedReleaseFrom: self lastRelease   ! !!SMPackage methodsFor: '*smloader' stamp: 'cmm 1/28/2011 16:41'!newUnattachedReleaseFrom: parentRelease	"Create a new release that is not part of the packages list of releases.  That does not happen until the user clicks Save on the UI."	^(map newObject: (SMPackageRelease newFromRelease: parentRelease package: self))! !!SMPackageRelease methodsFor: 'accessing' stamp: 'cmm 1/26/2011 20:47'!downloadUrl: urlString	downloadUrl := urlString! !!SMPackageRelease methodsFor: 'accessing' stamp: 'cmm 1/24/2011 17:46'!note: aString	note := aString! !!SMPackageRelease methodsFor: 'accessing' stamp: 'cmm 1/24/2011 16:16'!version: aString 	version := aString! !!SMPackageRelease methodsFor: 'initialize-release' stamp: 'cmm 2/5/2011 14:28'!initializeFromRelease: parentRelease package: aPackage	"Initialize package release from a given parent.	Branch if needed."	self map: aPackage map id: UUID new.	package := aPackage.	aPackage isCommunitySupported ifTrue: [ self beCommunitySupported ].	automaticVersion :=		parentRelease			ifNil: [VersionNumber first]			ifNotNil: [parentRelease nextOrBranch].	version := note := downloadUrl := ''! !!SMPackageRelease methodsFor: 'printing' stamp: 'cmm 2/9/2011 14:53'!fullDescription	"Return a full textual description of the package release."	| s |	s := TextStream on: (Text new: 400).	self describe: self package name withBoldLabel: 'Package Name: ' on: s.	name isEmptyOrNil ifFalse:		[self describe: self name withBoldLabel: 'Release Name: ' on: s].	summary isEmptyOrNil ifFalse:		[self describe: self summary withBoldLabel: 'Release Summary: ' on: s].	self 		describe: self version		withBoldLabel: 'Version: '		on: s.	self note isEmptyOrNil 		ifFalse: 			[ s withAttribute: (TextIndent tabs: 1) do: [s nextPutAll: self note withSqueakLineEndings].			s cr].	categories isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Categories: '];				cr.			(self categories asSortedCollection: [:a :b | a path < b path])				do: [:c | 					s						tab;						withAttribute: TextEmphasis italic							do: 								[c parentsDo: 										[:p | 										s											nextPutAll: p name;											nextPutAll: '/'].								s nextPutAll: c name];						nextPutAll: ' - ' , c summary;						cr].			s cr].	created ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: self created;			cr].	updated ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Modified: ' ];			print: self updated;			cr].	publisher ifNotNil: [		s			withAttribute: TextEmphasis bold			do: [s nextPutAll: 'Publisher: '].		s			withAttribute: (PluggableTextAttribute					evalBlock: [self userInterface									sendMailTo: self publisher email									regardingPackageRelease: self])			do: [s nextPutAll: self publisher nameAndEmail];				cr].	url isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Homepage:'];				tab;				withAttribute: (TextURL new url: url) do: [s nextPutAll: url];				cr].	self downloadUrl isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Download:'];				tab;				withAttribute: (TextURL new url: self downloadUrl)					do: [s nextPutAll: self downloadUrl];				cr].	^s contents.! !!SMPackageRelease methodsFor: 'services' stamp: 'cmm 2/9/2011 21:32'!refreshInCache	"Delete and re-download the file back into the cache.	Return true on success, otherwise false."	map cache remove: self.	^ self 		sha1sum: nil; 		ensureInCache! !!SMPackageRelease methodsFor: 'private' stamp: 'cmm 12/6/2011 21:02'!addToLocalCache	self downloadUrl ifNotNil: [map cache add: self]! !!SMPackageRelease methodsFor: 'private' stamp: 'cmm 12/5/2011 22:48'!removeFromLocalCache	self downloadUrl ifNotNil: [map cache remove: self]! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/24/2011 15:33'!compatibility	^ self categories		detect:			[ : each | each parent = self map compatibilityLevels ]		ifNone: [  ]! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/27/2011 14:40'!compatibility: aSMCategory 	| comp |	aSMCategory parent = self map compatibilityLevels ifFalse: [ self error: 'Not a compatibility category.' ].	[ comp := self compatibility.	comp notNil ] whileTrue: [ self removeCategory: comp ].	self addCategory: aSMCategory! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/25/2011 16:08'!compatibilityIndex	"Answer my position in the list of my maps compatibilitys."	^ self map compatibilityLevels subCategories indexOf: self compatibility! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/29/2011 17:20'!fullyQualifiedScriptName	^ self package owner downloadsDirectory , '/', self scriptName ! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 2/7/2011 15:03'!httpPostContent	"Answer the url-encoded parameters for this object."	| allCategories |	^ String streamContents:		[ : stream | self isNewObject			ifTrue:				[ "Make the parent release the selected."				self parentReleaseIndex > 0 ifTrue: [ stream nextPutAll: '1-1=' , self parentReleaseIndex , '&' ] ]			ifFalse:				[ "Make this release the selected."				self releaseIndex > 0 ifTrue: [ stream nextPutAll: '1-1=' , self releaseIndex , '&' ] ].		"The following category fields must remain in alphabetical order.  Add 1 to category indexes because web-server expects the first item to always be nil."		stream			 nextPutAll: '1-3=' , self version asString encodeForHTTP ;			 nextPutAll: '&1-4=' , (self compatibilityIndex + 1) ;			 nextPutAll: '&1-5=' , (self licenseIndex + 1) ;			 nextPutAll: '&1-6=' , (self maturityIndex + 1) ;			 nextPutAll: '&1-7=' , (self squeakVersionIndex + 1) ;			 nextPutAll: '&1-8=' , self downloadUrl "already http encoded" ;			 nextPutAll: '&1-9=1&1-10=&1-11=' "No file selection, 'cool' name or summary".		"Specify only the mandatory categories for 'additional categories', otherwise prior mandatory selections will be reflected in the objects categories, causing the highest-in-the-list to always win.  Ugh.."		allCategories := SMSqueakMap default sortedCategories.		{allCategories indexOf: self compatibility. 		allCategories indexOf: self license. 		allCategories indexOf: self maturity. 		allCategories indexOf: self squeakVersion} do:			[ : each | stream nextPutAll: '&1-12=' , each asString ].		self isCommunitySupported ifTrue: [ stream nextPutAll: '&1-12=', (allCategories indexOf: self communitySupportedCategory) asString ].		stream nextPutAll: '&1-13=' , self note asString encodeForHTTP.		self isNewObject			ifTrue: [ stream nextPutAll: '&1-18=Save+as+new+release' ]			ifFalse: [ stream nextPutAll: '&1-17=Save+changes' ].		self parentRelease ifNotNilDo:			[ : pr | stream nextPutAll: '&1-19=' , pr releaseIndex ] ]! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/28/2011 10:45'!initializeMandatoryCategories	"Set default mandatory categories."	self		 license: self map mit ;		 squeakVersion: self map currentSqueakVersion ;		 compatibility: self map onlyExtensions ;		 maturity: self map alpha! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/29/2011 16:50'!isNewObject	^ (self package releases includes: self) not! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/24/2011 15:33'!license	^ self categories		detect:			[ : each | each parent = self map licenses ]		ifNone: [  ]! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/27/2011 14:40'!license: aSMCategory 	| lic |	aSMCategory parent = self map licenses ifFalse: [ self error: 'Not a license category.' ].	[ lic := self license.	lic notNil ] whileTrue: [ self removeCategory: lic ].	self addCategory: aSMCategory! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/25/2011 16:08'!licenseIndex	"Answer my position in the list of my maps licenses."	^ self map licenses subCategories indexOf: self license! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/24/2011 15:34'!maturity	^ self categories		detect:			[ : each | each parent = self map maturityLevels ]		ifNone: [ nil ]! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/27/2011 14:39'!maturity: aSMCategory 	| mat |	aSMCategory parent = self map maturityLevels ifFalse: [ self error: 'Not a maturity category.' ].	[ mat := self maturity.	mat notNil ] whileTrue: [ self removeCategory: mat ].	self addCategory: aSMCategory! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/25/2011 16:08'!maturityIndex	"Answer my position in the list of my maps maturitys."	^ self map maturityLevels subCategories indexOf: self maturity! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/28/2011 16:41'!newUnattachedRelease	"Create and answer a new release based on this release."	^ self package newUnattachedReleaseFrom: self! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/29/2011 17:15'!parentReleaseIndex	"Answer my position in the list of my packages releases."	^ self parentRelease		ifNil: [ 0 ]		ifNotNil: [ : pr | pr releaseIndex ]! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/25/2011 15:16'!releaseIndex	"Answer my position in the list of my packages releases."	^ self package releases indexOf: self! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 2/9/2011 14:02'!scriptName	^ 'install-', self package name, '-', self version, '.st'! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/24/2011 16:03'!squeakVersion	^ self categories		detect:			[ : each | each parent = self map squeakVersions ]		ifNone: [  ]! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/27/2011 14:35'!squeakVersion: aSMCategory 	| vers |	aSMCategory parent = self map squeakVersions ifFalse: [ self error: 'Not a squeakVersion category.' ].	"Remove all squeakVersion-categories."	[ vers := self squeakVersion.	vers notNil ] whileTrue: [ self removeCategory: vers ].	self addCategory: aSMCategory! !!SMPackageRelease methodsFor: '*smloader' stamp: 'cmm 1/25/2011 16:08'!squeakVersionIndex	"Answer my position in the list of my maps squeakVersions."	^ self map squeakVersions subCategories indexOf: self squeakVersion! !!SMPackageReleaseWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 21:30'!asString	"Show installed releases with a trailing asterisk."	| string |	string := item smartVersion.	"Older SMBase versions don't have isInstalled.'"	(item respondsTo: #isInstalled) ifTrue:		[item isInstalled ifTrue: [string := (string , ' *') asText allBold]].	^ string! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 17:14'!contents	^ #()! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString	! !!SMPackageWrapper methodsFor: 'comparing' stamp: 'dvf 9/21/2003 16:25'!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMPackageWrapper methodsFor: 'converting' stamp: 'btr 11/22/2006 00:54'!asString	| string |	string := item name, ' (', item versionLabel, ')'.	item isInstalled ifTrue: [string := string asText allBold].	"(string includesSubString: '->') ifTrue: [string := string asText color: Color green]."	^ string! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'dvf 10/14/2003 18:58'!contents	^item releases reversed collect: [:e | SMPackageReleaseWrapper with: e]! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:55'!help	^ 'This shows all packages with their releases that should be displayed according the current filter.'! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString! !!SMPackageWrapper methodsFor: 'testing' stamp: 'dvf 9/21/2003 16:25'!hash	^self withoutListWrapper hash! !!SMPackageWrapper methodsFor: 'printing' stamp: 'dvf 9/21/2003 16:22'!printOn: aStream	aStream nextPutAll: 'wrapper for: ', item printString! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/25/2011 19:36'!annotation	^ String streamContents:		[ : stream | stream			 nextPutAll: 'last saved ' ;			 print: release updated ]! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/28/2011 14:25'!buildCodePaneWith: aToolBuilder 	^ (super buildCodePaneWith: aToolBuilder)		 name: #content ;		 yourself! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/25/2011 19:21'!buildWith: aToolBuilder 	| windowSpec row2Top row3Top |	row2Top := 0.1.	row3Top := 0.5.	windowSpec := self		buildWindowWith: aToolBuilder		specs: {(0 @ 0 corner: 0.5 @ 0.05) -> (self newVersionSpec: aToolBuilder).			(0.0 @ 0.05 corner: 0.5@ row2Top) -> (self newAuthenticationPane: aToolBuilder).			(0.5 @ 0 corner: 1.0 @ row2Top) -> (self newReleaseNotesPaneSpec: aToolBuilder).			(0@row2Top corner: 0.25@row3Top) -> (self newLicenseListSpec: aToolBuilder).			(0.25@row2Top corner: 0.50@row3Top) -> (self newSqueakVersionSpec: aToolBuilder).		(0.50@row2Top corner: 0.75@row3Top) -> (self newCompatibilitySpec: aToolBuilder).		(0.75@row2Top corner: 1.00@row3Top) -> (self newMaturitySpec: aToolBuilder).		(0.0@row3Top corner: 1.00@1.00) -> (self buildCodePaneWith: aToolBuilder) }.	^ aToolBuilder build: windowSpec! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/26/2011 18:31'!contents	^ self loadScript! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/26/2011 16:46'!labelString	^ String streamContents:		[ : stream | stream nextPutAll: release package name.		release version isEmptyOrNil ifFalse:			[ stream				 space ;				 nextPutAll: release version ] ]! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:52'!newAuthenticationPane: aToolBuilder 	^ aToolBuilder pluggablePanelSpec new		 model: self ;		 children:		(OrderedCollection			with:				(aToolBuilder pluggableInputFieldSpec new					 model: self ;					 name: #username ;					 help: 'Your SqueakMap Id.' ;					 getText: #username ;					 setText: #username: ;					 frame: (0.02@0 corner: 0.38@1) ;					 yourself)			with:				(aToolBuilder pluggableInputFieldSpec new					 model: self ;					 name: #password ; 					 help: 'Your SqueakMap password.' ;					 getText: #password ;					 setText: #password: ;					 frame: (0.40@0 corner: 0.75@1) ;					 yourself)			with:				(aToolBuilder pluggableButtonSpec new					 model: self ;					 help: 'Save this release to the SqueakMap server and close the window.' ;					 label: 'Save' ;					 action: #save ;					 frame: (0.77@0 corner: 0.98@1) ;					 yourself)) ;		 yourself! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/24/2011 17:25'!newCompatibilitySpec: aToolBuilder	^ aToolBuilder pluggableListSpec new		 model: self ;		 name: #compatibilities ;		 help: 'Select the type of changes this release makes to the image.' ;		 autoDeselect: false ;		 list: #compatibilities ;		 getSelected: #compatibility ;		 setSelected: #compatibility: ;		 yourself! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/24/2011 17:19'!newLicenseListSpec: aToolBuilder 	^ aToolBuilder pluggableListSpec new		 model: self ;		 name: #licenses ;		 help: 'Select the license for this release.' ;		 autoDeselect: false ;		 list: #licenses ;		 getSelected: #license ;		 setSelected: #license: ;		 yourself! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/24/2011 17:28'!newMaturitySpec: aToolBuilder	^ aToolBuilder pluggableListSpec new		 model: self ;		 name: #maturities ;		 help: 'Select the type of changes this release makes to the image.' ;		 autoDeselect: false ;		 list: #maturities ;		 getSelected: #maturity ;		 setSelected: #maturity: ;		 yourself! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/28/2011 13:38'!newReleaseNotesPaneSpec: aToolBuilder	^ aToolBuilder pluggableTextSpec new		model: self ;		name: #note ;		help: 'Notes about this release.' ;		askBeforeDiscardingEdits: true ;		getText: #note ;		setText: #note: ;		yourself! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/24/2011 17:22'!newSqueakVersionSpec: aToolBuilder	^ aToolBuilder pluggableListSpec new		 model: self ;		 name: #licenses ;		 help: 'Select the image version for this release.' ;		 autoDeselect: false ;		 list: #squeakVersions ;		 getSelected: #squeakVersion ;		 setSelected: #squeakVersion: ;		 yourself! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/24/2011 20:08'!newVersionSpec: aToolBuilder 	^ aToolBuilder pluggableInputFieldSpec new		 model: self ;		 name: #version ;		 help: 'Specify the version name of this release.' ;		 getText: #version ;		 setText: #version:! !!SMReleaseBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/28/2011 13:48'!okToChange	"Answer true so that merely selecting different categories doesn't cause a pop-up."	^ true! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 1/28/2011 14:38'!closeWindow	self dependents do:		[ : each | each isSystemWindow ifTrue: [ each delete ] ]! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 2/9/2011 14:45'!deleteInstallFile	FileDirectory default deleteFileNamed: release scriptName! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 2/9/2011 19:21'!downloadUrl	^ self smAccount downloadsDirectory , '/' , release scriptName! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 1/26/2011 19:27'!login	smClient login! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 1/27/2011 18:54'!logout	smClient close.	self		 changed: #username ;		 changed: #password! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 1/29/2011 17:51'!release	^ release! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 1/29/2011 17:51'!representsSameBrowseeAs: anotherModel	^ release = anotherModel release! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 12/6/2011 21:02'!savePackageRelease: downloadUrlString 	"We actually save the package-release to the users who is posting it, even if that is different than the owner."	"Set sha1sum so it will be 'correct' until the next update from the SM server."	| response |	release		 downloadUrl: downloadUrlString ;		 sha1sum: nil.	response := smClient save: release.	(response isSuccess not or:		[ #('error' 'failed' ) anySatisfy:			[ : each | response content				includesSubstring: each				caseSensitive: false ] ]) ifTrue: [ self error: 'failed' ].	release		 removeFromLocalCache ;		 addToLocalCache! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 2/7/2011 17:57'!smAccount	^ SMSqueakMap default accountForUsername: self username! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 1/28/2011 15:38'!uploadInstallFile	| response |	response := smClient uploadFileNamed: release scriptName.	(#(200 302) includes: response code) ifFalse: [ self halt: 'non-successful response' ]! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 2/7/2011 17:37'!userError: aString	UIManager default inform: aString! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 2/12/2011 16:51'!validateCanSave	self username isEmptyOrNil ifTrue: [ self userError: 'username required' ].	self note isEmptyOrNil ifTrue: [ self userError: 'note required' ].	self version isEmptyOrNil		ifTrue: [ self userError: 'version required' ]		ifFalse:			[ (self version includes: $+) ifTrue: [ self userError: 'Plus sign not allowed in version name because it is reserved by HTTP.' ] ]! !!SMReleaseBrowser methodsFor: 'private' stamp: 'cmm 2/9/2011 14:45'!writeInstallFile	(FileDirectory default fileExists: release scriptName)		ifTrue: [Warning signal: release scriptName , ' already exists and will be deleted.'].	self deleteInstallFile.	FileStream		fileNamed: release scriptName		do: [:stream | stream nextPutAll: self loadScript asString]! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 20:22'!compatibilities	^ SMSqueakMap default compatibilityLevels subCategories! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 17:25'!compatibility	^ release compatibility! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 21:38'!compatibility: aSMCategory 	release compatibility: aSMCategory.	self changed: #compatibility! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/26/2011 16:16'!contents: aText	self loadScript: aText.	self changed: #contents! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 17:19'!license	^ release license! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 21:38'!license: aSMCategory	release license: aSMCategory.	self changed: #license! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/25/2011 15:27'!licenses	"Answer the 'Licenses' subCagegories."	^ SMSqueakMap default licenses subCategories! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/26/2011 16:12'!loadScript	"The Smalltalk code needed to install this release of this package."	^ loadScript ifNil:		[ | scriptName |		scriptName := release downloadFileName.		loadScript := scriptName isEmptyOrNil ifFalse:			[ (scriptName asLowercase endsWith: '.st') ifTrue: [ release contents ] ] ]! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 8/13/2011 18:55'!loadScript: aString 	"The Smalltalk code needed to load this release of this package."	loadScript := aString asString.	self		 changed: #loadScript ;		 changed: #contents! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 20:23'!maturities	^ SMSqueakMap default maturityLevels subCategories! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 17:26'!maturity	^ release maturity! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 21:38'!maturity: aSMCategory 	release maturity: aSMCategory.	self changed: #maturity! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 17:54'!note	^ release note! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 21:38'!note: aString 	release note: aString.	self changed: #note! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 13:57'!parentRelease	^ release ifNotNil: [ release parentRelease ]! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 15:22'!parentVersion	^ self parentRelease ifNotNilDo:		[ : pr | pr version ]! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/25/2011 22:37'!password	"The SqueakMap password."	^ smClient password! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/25/2011 22:37'!password: aString	"The SqueakMap username."	smClient password: aString asString.	self changed: #password! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 17:18'!squeakVersion	^ release squeakVersion! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 21:39'!squeakVersion: aSMCategory 	release squeakVersion: aSMCategory.	self changed: #squeakVersion! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/25/2011 15:33'!squeakVersions	"Answer the squeak-versions subcategories."	^ SMSqueakMap default squeakVersions subCategories! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 8/13/2011 18:50'!updateLoadScript	self loadScript: self loadScript withLoadedPackageVersions! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/25/2011 22:36'!username	"The SqueakMap username."	^ smClient username! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/25/2011 22:37'!username: aString	"The SqueakMap username."	smClient username: aString asString.	self changed: #username! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/24/2011 14:20'!version	^ release ifNotNil: [ release version ]! !!SMReleaseBrowser methodsFor: 'model access' stamp: 'cmm 1/28/2011 13:15'!version: aString 	release ifNotNil: [ release version: aString asString ].	self		 changed: #version ;		 changed: #labelString! !!SMReleaseBrowser methodsFor: 'initialize-release' stamp: 'cmm 1/25/2011 22:41'!initialize	super initialize.	smClient := SMClient new! !!SMReleaseBrowser methodsFor: 'initialize-release' stamp: 'cmm 1/28/2011 13:45'!postInitialize	(release downloadUrl endsWith: '.st') ifTrue:		[ release ensureInCache ifTrue: [ self loadScript: release contents ] ]! !!SMReleaseBrowser methodsFor: 'initialize-release' stamp: 'cmm 2/12/2011 14:17'!save	"Save the release to SqueakMap."	Cursor wait showWhile:		[ self dependents do:			[ : eachWidget | #(#username #password #note #version #content ) do:				[ : eachName | eachWidget knownName = eachName ifTrue:					[ eachWidget hasUnacceptedEdits ifTrue: [ eachWidget accept ] ] ] ].		self validateCanSave.		[ self			 writeInstallFile ;			 login.		"Save without a downloadUrl so that SM will update its cache and we can also verify success before uploading the file."		self savePackageRelease: nil.		self loadScript isEmptyOrNil ifFalse:			[ self uploadInstallFile.			release package addRelease: release.			"Now save with the correct downloadUrl."			self				 savePackageRelease: self downloadUrl ;				 deleteInstallFile ] ] ensure: [ self logout ] ].	self closeWindow! !!SMReleaseBrowser methodsFor: 'initialize-release' stamp: 'cmm 1/28/2011 13:40'!setRelease: aSMPackageRelease	release := aSMPackageRelease.	self postInitialize! !!SMReleaseBrowser commentStamp: 'cmm 1/23/2011 17:44' prior: 0!A browser for specific SqueakMap packages.- Across the top:	- version name text input (across the top)	- parent release (uneditable text)- Four lists across the width:	- license single-select.	- versions multi-select.	- compatibility single-select.	- maturity single-select.X File to upload | elipsis.- Load-script paragraph | Release notes paragraph.- Buttons:	- Save.	- Cancel.!!SMReleaseBrowser class methodsFor: 'open' stamp: 'cmm 1/24/2011 14:19'!open	^ ToolBuilder open: self! !!SMReleaseBrowser class methodsFor: 'open' stamp: 'cmm 1/24/2011 14:23'!openOn: aSMPackageRelease	^ ToolBuilder open: (self release: aSMPackageRelease)! !!SMReleaseBrowser class methodsFor: 'instance creation' stamp: 'cmm 1/24/2011 14:22'!release: aSMPackageRelease 	^ self new		 setRelease: aSMPackageRelease ;		 yourself! !!SMReleaseBrowser class methodsFor: 'window color' stamp: 'cmm 1/28/2011 10:23'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Release Browser'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Release Browser'! !!SMReleaseBrowser class methodsFor: 'menu' stamp: 'cmm 8/13/2011 18:49'!yellowButtonMenuItems	"Returns the standard yellow button menu items"	^super yellowButtonMenuItems, {			{'update with loaded versions' translated. #updateLoadScript}.		}! !!SMSimpleInstaller methodsFor: 'services' stamp: 'ul 6/17/2011 12:29'!unpack	"This basic installer simply checks the file extension of	the downloaded file to choose suitable method for unpacking.	Currently it only supports .gz decompression.	If a file exists with the same name it is first deleted.	The unpacked filename is set on succesfull decompression or	if the file was not recognized as a compressed file."	| unzipped zipped buffer |	(fileName endsWith: '.gz')		ifTrue:[			unpackedFileName := fileName copyUpToLast: FileDirectory extensionDelimiter.			(dir fileExists: unpackedFileName) ifTrue:[ dir deleteFileNamed: unpackedFileName ].			unzipped := dir newFileNamed: unpackedFileName.			unzipped binary.			zipped := GZipReadStream on: ((dir readOnlyFileNamed: fileName) binary; yourself).			buffer := ByteArray new: 50000.			'Extracting ' , fileName				displayProgressFrom: 0				to: zipped sourceStream size				during: [:bar | 					[zipped atEnd]						whileFalse: 							[bar value: zipped sourceStream position.							unzipped nextPutAll: (zipped nextInto: buffer)].					zipped close.					unzipped close]]		ifFalse:[unpackedFileName := fileName]! !!SMSqueakMap methodsFor: 'accessing' stamp: 'cmm 2/6/2011 23:24'!sortedCategories	"Lazily maintain a cache of all known category objects."	^ self categories		asSortedCollection: [:a :b | (a name compare: b name caseSensitive: true)				= 1]! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'cmm 2/5/2011 15:12'!saveCheckpoint: contentWithFilename	"Save the map checkpoint to disk if it is not there already."	| file directory sz fname content |	directory := self directory.	sz := contentWithFilename size.	fname := contentWithFilename last: sz - (contentWithFilename lastIndexOf: $:).	content := contentWithFilename first: sz - fname size - 1.	(directory fileExists: fname) ifFalse: [		"Please do not upgrade the following to use Squeak 4.0 or later API's (e.g., #newFileNamed:do:) until we can convert the SMServer code to latest Squeaks."		[file := StandardFileStream newFileNamed: (directory fullNameFor: fname).		file nextPutAll: content]			ensure: [file close]]! !!SMSqueakMap methodsFor: 'public-installation' stamp: 'cmm 2/9/2011 16:20'!installPackageNamed: aString version: version	"Install the release <version> of the package with a name	beginning with aString (see method comment	of #packageWithNameBeginning:). <version> is the	user-specified version name."	| package release |	package := self packageWithNameBeginning: aString.	package ifNil: [self error: 'No package found with name beginning with ', aString].	release := package releaseWithVersion: version.	release ifNil: [self error: 'No package release found with version ', version].	^self installPackageRelease: release! !!SMSqueakMap methodsFor: 'queries' stamp: 'cmm 5/8/2011 18:11'!packageWithName: aName 	"Look up a package by exact match on name. Signal an exception if missing."	^ self		packageWithName: aName		ifAbsent: [ self error: aName , ' is not in the cached catalog.' ]! !!SMSqueakMap methodsFor: 'queries' stamp: 'cmm 5/8/2011 18:19'!packageWithName: aName ifAbsent: aBlock 	"Look up a package by exact match on name. Answer the value of aBlock if missing."	^ self packages		detect: [ : package | package name = aName ]		ifNone: aBlock! !!SMSqueakMap methodsFor: '*smloader' stamp: 'cmm 1/28/2011 10:44'!alpha	"Answer the default license selection for new packages, MIT."	^ self categoryWithNameBeginning: 'Alpha'! !!SMSqueakMap methodsFor: '*smloader' stamp: 'cmm 1/24/2011 15:30'!compatibilityLevels	^ self categoryWithNameBeginning: 'Compatibility level'! !!SMSqueakMap methodsFor: '*smloader' stamp: 'cmm 1/28/2011 10:47'!currentSqueakVersion	"Answer the default license selection for new packages, MIT."	^ (self categoryWithNameBeginning: SystemVersion current version) ifNil: [ (self categoryWithNameBeginning: 'trunk') ifNil: [ self squeakVersions subCategories last ] ]! !!SMSqueakMap methodsFor: '*smloader' stamp: 'cmm 1/24/2011 15:29'!licenses	^ self categoryWithNameBeginning: 'Licenses'! !!SMSqueakMap methodsFor: '*smloader' stamp: 'cmm 1/24/2011 15:30'!maturityLevels	^ self categoryWithNameBeginning: 'Maturity level'! !!SMSqueakMap methodsFor: '*smloader' stamp: 'cmm 1/28/2011 10:40'!mit	"Answer the default license selection for new packages, MIT."	^ self categoryWithNameBeginning: 'MIT'  ! !!SMSqueakMap methodsFor: '*smloader' stamp: 'cmm 1/28/2011 10:44'!onlyExtensions	"Answer the default license selection for new packages, MIT."	^ self categoryWithNameBeginning: 'Only extensions, no changes'! !!SMSqueakMap methodsFor: '*smloader' stamp: 'cmm 1/25/2011 15:33'!squeakVersions	"Answer the parent SMCategory whose sub-categories each represent a version of Squeak."	^ self categoryWithNameBeginning: 'Squeak versions'! !!SUnitExtensionsTest methodsFor: 'accessing' stamp: 'nice 8/27/2010 21:01'!stream	^stream ifNil: [stream := WriteStream on: String new]! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:26'!testTestTimeout	self should:[(Delay forSeconds: 6) wait] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ul 6/17/2011 12:42'!testTestTimeoutLoop	<timeout: 1>	self should:[[] repeat] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:25'!testTestTimeoutTag	<timeout: 1>	self should:[(Delay forSeconds: 3) wait] raise: TestFailure.! !!SUnitToolBuilderTests methodsFor: 'tests' stamp: 'cmm 10/18/2011 20:09'!testHandlingNotification	| receivedSignal resumed |	receivedSignal := resumed := false.	[ | count |	"client-code puts up progress, and signals some notications"	count := 0.	'doing something'		displayProgressFrom: 0		to: 10		during:			[ : bar | 10 timesRepeat:				[ bar value: (count := count + 1).				(Delay forMilliseconds: 200) wait.				Notification signal: 'message'.				resumed := true ] ] ]		on: Notification		do:			[ : noti | receivedSignal := true.			noti resume ].	self		 assert: receivedSignal ;		 assert: resumed! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 5/23/2007 11:54'!adoptPaneColor: paneColor	"Pass on to the border too."		super adoptPaneColor: paneColor.	self borderStyle baseColor: paneColor twiceDarker! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 14:15'!basicColor: aColor	"Set the gradient colors."		super color: aColor asNontranslucentColor.	self		fillStyle: self gradient! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 15:13'!blackGradient	"Answer the black gradient. Top to bottom, transparent to black."	^(InterpolatedGradientFillStyle colors: {Color black alpha: 0. Color black})		origin: self innerBounds topLeft;		direction: 0@self innerBounds height! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 11:36'!blackGradientMorph	"Answer the black gradient morph."	^Morph new		hResizing: #spaceFill;		vResizing: #spaceFill;		fillStyle: self blackGradient! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 15:19'!borderWidth: anInteger	"Update the gradients after setting."		super borderWidth: anInteger.	self updateGradients! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 14:15'!color: aColor	"Set the gradient colors."		self		basicColor: aColor;		selectedColor: (Color h: aColor hue s: self selectedColor saturation v: self selectedColor brightness)! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 10:42'!colorAt: aPoint	"Answer the color in the world at the given point."		^self isInWorld		ifTrue: [(Display colorAt: aPoint) asNontranslucentColor ]		ifFalse: [Color black]! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 10:33'!extent: p	"Update the gradient directions."	super extent: p.	self updateGradients! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 10:49'!fillStyle: fillStyle	"If it is a color then override with gradient."		fillStyle isColor		ifTrue: [self color: fillStyle]		ifFalse: [super fillStyle: fillStyle]! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2009 13:52'!gradient	"Answer the base gradient."	|b|	b := self innerBounds.	^(GradientFillStyle colors: {Color white. self color})		origin: b topLeft;		direction: (b width@0)! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/20/2006 12:50'!handlesMouseDown: evt	"Yes for down and move.." 	^true! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 16:33'!handlesMouseOverDragging: evt	"Yes, make the location morph visible when leaving."		^true! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 11:25'!hideLocation	"Hide the location morph and update the display."		self locationMorph visible: false.	World displayWorldSafely.! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 10:22'!initialize	"Initialize the receiver."	super initialize.	self locationMorph: self newLocationMorph.	self		clipSubmorphs: true;		color: Color blue;		borderStyle: (BorderStyle inset width: 1);		addMorphBack: self locationMorph;		addMorphBack: self blackGradientMorph! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/26/2006 12:23'!layoutBounds: aRectangle	"Set the bounds for laying out children of the receiver.	Note: written so that #layoutBounds can be changed without touching this method"		super layoutBounds: aRectangle.	self updateGradients! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 3/19/2010 16:21'!mouseDown: evt 	"Handle a mouse down event. Select the color at the mouse position."		evt redButtonPressed		ifFalse: [^super mouseDown: evt].	evt hand showTemporaryCursor: (Cursor crossHair copy offset: -9 @ -9).	self hideLocation.	self selectColorAt: evt position.	^super mouseDown: evt! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 3/19/2010 16:21'!mouseEnterDragging: evt	"Make the location morph invisible when entering."		self hideLocation.	evt hand showTemporaryCursor: (Cursor crossHair copy offset: -9 @ -9).! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 5/23/2007 11:56'!mouseLeaveDragging: evt	"Make the location morph visible when leaving."		evt hand showTemporaryCursor: nil.	self showLocation! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 12:11'!mouseMove: evt 	"Handle a mouse move event. Select the color at the mouse position."		evt redButtonPressed		ifFalse: [^super mouseMove: evt].	self selectColorAt: evt position.	^super mouseMove: evt! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 12:12'!mouseUp: evt 	"Handle a up event. Show the location morph again."		evt hand showTemporaryCursor: nil.	self updateSelectedLocation.	self locationMorph visible: true! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 12:16'!newLocationMorph	"Answer a new morph indicating the location of the selected color."	^ImageMorph new		image: Cursor crossHair withMask asCursorForm! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 12:12'!selectColorAt: aPoint	"Set the color at the given position."		|b p|	b := self innerBounds.	p := (b containsPoint: aPoint)		ifTrue: [aPoint]		ifFalse: [b pointNearestTo: aPoint].	p := p - b topLeft / b extent.	self selectedColor: (Color		h: self color hue		s: p x		v: 1.0 - p y)! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 15:25'!selectedLocation	"Answer the location within the receiver of the selected colour	relative to the receiver's top left."	|b c x y|	b := self innerBounds.	c := self selectedColor.	x := c saturation * (b width - 1).	y := 1 - c brightness * (b height - 1).	^(x truncated @ y truncated) + b topLeft! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 11:26'!showLocation	"Show the location morph and update the display."		self locationMorph visible: true.	World displayWorldSafely.! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2009 13:52'!updateGradients	"Update the gradient directions."	|bgm b|	b := self innerBounds.	bgm := self submorphs last.	bgm bounds: b.	bgm fillStyle		origin: b topLeft;		direction: 0@b height.	self fillStyle		origin: b topLeft;		direction: (b width@0).	self updateSelectedLocation! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 12:17'!updateSelectedLocation	"Position the location morph to indicate the selected colour."		self locationMorph		position: (self selectedLocation - (self locationMorph extent // 2 + (self locationMorph extent \\ 2)))! !!SVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/20/2006 13:37'!locationMorph	"Answer the value of locationMorph"	^ locationMorph! !!SVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/20/2006 13:37'!locationMorph: anObject	"Set the value of locationMorph"	locationMorph := anObject! !!SVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 15:08'!selectedColor	"Answer the value of selectedColor"	^selectedColor ifNil: [self color]! !!SVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/21/2006 14:01'!selectedColor: aColor	"Set the value of selectedColor."	selectedColor := aColor.	self locationMorph visible ifTrue: [self updateSelectedLocation].	self triggerEvent: #colorSelected with: aColor! !!SVColorSelectorMorph commentStamp: 'gvc 8/8/2007 14:36' prior: 0!A colour selector that displays an area with saturation on the x axis and volume on the y axis. Provides interactive selection of colour by mouse. For the moment it is event rather than model based.Setting the color will specify the hue and setting the selectedColor will specify the saturation and volume (may have a different hue to that displayed if not in sync).!!SampledInstrument methodsFor: 'accessing' stamp: 'alain.plantec 5/28/2009 10:19'!initialize	super initialize.	sustainedThreshold := 0.15.	loudThreshold := 0.5.! !!SampledInstrument methodsFor: 'other' stamp: 'nice 8/19/2010 16:34'!allNotes	"Answer a collection containing of all the unique sampled sounds used by this instrument."	| r |	r := IdentitySet new.	r addAll: sustainedLoud.	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].	^ r asArray sort: [:n1 :n2 | n1 pitch < n2 pitch]! !!SampledSound methodsFor: 'playing' stamp: 'ul 11/2/2010 03:08'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex outIndex sampleIndex sample i s overflow |	<primitive:'primitiveMixSampledSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #samples declareC: 'short int *samples'>	lastIndex := (startIndex + n) - 1.	outIndex := startIndex.    "index of next stereo output sample pair"	sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).	[(sampleIndex <= samplesSize) and: [outIndex <= lastIndex]] whileTrue: [		sample := ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i := (2 * outIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * outIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]].		scaledIndex := scaledIndex + scaledIncrement.		scaledIndex >= ScaledIndexOverflow ifTrue: [			overflow := scaledIndex >> IncrementFractionBits.			indexHighBits := indexHighBits + overflow.			scaledIndex := scaledIndex - (overflow << IncrementFractionBits)].		sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).		outIndex := outIndex + 1].	count := count - n.! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 4/14/2003 00:01'!assimilateSoundsFrom: aDictionary	"assimilate sounds with new keys from the given dictionary"	aDictionary associationsDo:		[:assoc | (SoundLibrary includesKey: assoc key) ifFalse:			[SoundLibrary add: assoc]]! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 4/13/2003 20:58'!universalSoundKeys	"Answer a list of the sound-names that are expected to be found in the SoundLibrary of every image."	^ #('splash' 'peaks' 'clink' 'croak' 'scratch' 'chirp' 'scritch' 'warble' 'scrape' 'camera' 'coyote' 'silence' 'motor')! !!SampledSound class methodsFor: 'utilities' stamp: 'dtl 10/24/2010 12:39'!convert8bitSignedFrom: aByteArray to16Bit: aSoundBuffer	"Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples."	| n s |	<primitive: 'primitiveConvert8BitSigned' module: 'MiscPrimitivePlugin'>	<var: #aByteArray declareC: 'unsigned char *aByteArray'>	<var: #aSoundBuffer declareC: 'unsigned short *aSoundBuffer'>	n := aByteArray size.	1 to: n do: [:i |		s := aByteArray at: i.		s > 127			ifTrue: [aSoundBuffer at: i put: ((s - 256) bitShift: 8)]			ifFalse: [aSoundBuffer at: i put: (s bitShift: 8)]].! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:14'!addNewWindow	self addWindow: prototype clone! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 19:01'!addWindow: aModel	aModel multiWindowState: self.	self assert: models size = modelStates size.	models := models					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: aModel).	modelStates := modelStates					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: self emptyEditState).	self assert: models size = modelStates size.	self selectWindowIndex: (currentModelIndex = 0 ifTrue: [currentModelIndex := 1] ifFalse: [currentModelIndex + 1]).	self assert: models size = modelStates size.	1 to: models size do:		[:idx|		self assert: (idx = currentModelIndex					or: [(modelStates at: idx) isArray and: [(modelStates at: idx) size = 2]])]! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:10'!copyWindow	self addWindow: (models at: currentModelIndex) copy breakDependents! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 21:15'!removeCurrentWindow	"Remove the current pane."	| deletedIndex |	self assert: models size > 1.	self assert: models size = modelStates size.	(models at: currentModelIndex) okToChange ifFalse:		[^self].	deletedIndex := currentModelIndex.	self selectWindowIndex: (currentModelIndex = 1								ifTrue: [currentModelIndex + 1]								ifFalse: [currentModelIndex - 1]).	models := models copyWithoutIndex: deletedIndex.	modelStates :=  modelStates copyWithoutIndex: deletedIndex.	currentModelIndex > deletedIndex ifTrue:		[currentModelIndex := currentModelIndex - 1].	(models at: currentModelIndex) changed: #relabel! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 8/11/2010 13:27'!selectWindowsMenu	| menu currentItem |	menu := MenuMorph new defaultTarget: self.	models withIndexDo:		[:model :index| | modelLabel |		modelLabel := index = currentModelIndex							ifTrue: [model multiWindowName]							ifFalse: [model multiWindowNameForState: (modelStates at: index) first].		models size > 1 ifTrue:			[modelLabel := index printString, '. ', modelLabel].		menu			add: (index = currentModelIndex					ifTrue: [Text string: modelLabel attribute: TextEmphasis bold]					ifFalse:						[((modelStates at: index) last anySatisfy: [:editState| editState notNil])							ifTrue: [Text string: modelLabel attribute: TextColor red]							ifFalse: [modelLabel]])			target: self			selector: #selectWindowIndex:			argument: index.		index = currentModelIndex ifTrue:			[currentItem := menu lastItem]].	menu		addLine;		add: 'new window' target: self selector: #addNewWindow;		add: 'copy this window' target: self selector: #copyWindow;		add: 'remove this window' target: self selector: #removeCurrentWindow.	models size <= 1 ifTrue:		[menu lastItem isEnabled: false].	menu selectItem: currentItem event: nil.	^menu! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 15:01'!currentModelIndex	^currentModelIndex! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 21:07'!emptyEditState	^#(nil ())! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 19:03'!models	^models! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 7/1/2010 10:40'!prototype	^prototype! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!editState	| textState |	textState := WeakIdentityKeyDictionary new.	modelDependents do:		[:dep|		dep canHaveUnacceptedEdits ifTrue:			[textState at: dep put: dep unacceptedEditState]].	^textState! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!restoreEditState: aWeakDictionary	aWeakDictionary keysAndValuesDo:		[:depOrNil :unacceptedEditState|		depOrNil ifNotNil:			[depOrNil unacceptedEditState: unacceptedEditState]]! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 21:09'!selectWindowIndex: index	| currentModel newModel newModelState |	index = currentModelIndex ifTrue: [^self].	currentModel := models at: currentModelIndex.	newModel := models at: index.	modelDependents addAll: currentModel dependents.	modelStates at: currentModelIndex put: { currentModel saveMultiWindowState. self editState }.	"the become makes things confusing.  currentModel will end up being newModel and vice verce"	models swap: currentModelIndex with: index.	currentModel become: newModel.	currentModel := models at: currentModelIndex.	newModel := models at: index.	newModel myDependents: (DependentsArray withAll: modelDependents asArray).	currentModel myDependents: nil.	"Change currentModelIndex before restoreMultiWIndowState: so label index is shown correctly"	currentModelIndex := index.	newModelState := modelStates at: index.	newModelState first ifNotNil: "emptyState has nil for savedModelState.  Don;t restore state for a new window"		[:savedModelState| newModel restoreMultiWindowState: savedModelState].	self restoreEditState: newModelState last.	modelStates at: index put: nil.	newModel changed: #relabel! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 15:12'!initialize	models := OrderedCollection new.	modelStates := OrderedCollection new.	modelDependents := IdentitySet new.	currentModelIndex := 0! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 18:42'!on: aModel	prototype := aModel clone.	self addWindow: aModel! !!SavedMultiWindowState methodsFor: 'testing' stamp: 'eem 6/30/2010 22:11'!okToClose	"Answer if the unaccepted edit states are void.  If they are not then	 offer to select a window with non-empty unaccepted edit state."	modelStates withIndexDo:		[:savedState :index|		savedState ifNotNil:			[(savedState last anySatisfy: [:editState| editState notNil]) ifTrue:				[(PopUpMenu					confirm: 'One or more windows have unsaved changes.'					trueChoice: 'Close Anyway'					falseChoice: 'Select Unsaved') ifTrue: [^true].				 self selectWindowIndex: index.				 ^false]]].	^true! !!SavedMultiWindowState commentStamp: 'eem 6/30/2010 15:45' prior: 0!A SavedMultiWindowState is a collection of states of inactive windows for a multi-window tool ui where one can select between multiple copies of a tool sharing a single system window, each tol having its own state.  It manages switching between windows, swapping unaccepted edit state (e.g. in text views) as it does so.Instance Variables	currentModelIndex:		<Integer>	modelDependents:		<IdentitySet>	modelStates:			<OrderedCollection of: (Array													with: modelState <Object>													with: unacceptedEditStates <WeakIdentityKeyDictionary>) >	models:					<OrderedCollection of: Model>currentModelIndex	- index into models and modelStates of current window selectionmodelDependents	- set of all dependentsmodelStates	- the pairs of model-specific selection state and widget-specfic unaccepted edit state for each unselected/inactive windowmodels	- the models for each window!!SavedMultiWindowState class methodsFor: 'instance creation' stamp: 'eem 6/30/2010 13:46'!on: aModel	^self new on: aModel! !!ScaledDecimal methodsFor: 'mathematical functions' stamp: 'nice 10/14/2011 22:21'!nthRoot: anInteger	"Answer the nth root of the receiver.	Preserve receiver class and scale if answer is exact.	Otherwise, answer a Float to denote inexactness."	| nthRoot |	nthRoot := self asFraction nthRoot: anInteger.	^nthRoot isFloat		ifTrue: [nthRoot]		ifFalse: [nthRoot asScaledDecimal: scale]! !!ScaledDecimal methodsFor: 'mathematical functions' stamp: 'nice 10/14/2011 22:02'!sqrt	"Answer the square root of the receiver.	Preserve receiver class and scale if answer is exact.	Otherwise, answer a Float to denote inexactness."	| squareRoot |	squareRoot := self asFraction sqrt.	^squareRoot isFloat		ifTrue: [squareRoot]		ifFalse: [squareRoot asScaledDecimal: scale]! !!ScaledDecimal methodsFor: 'printing' stamp: 'nice 3/29/2011 21:52'!printFractionAsDecimalOn: stream 	"Please note: this is different from printOn:showingDecimalPlaces: because it prints truncated."	fraction printTruncatedOn: stream showingDecimalPlaces: scale! !!ScaledDecimal methodsFor: 'printing' stamp: 'ul 11/29/2010 00:19'!printOn: stream	self		printFractionAsDecimalOn: stream;		printScaleOn: stream! !!ScaledDecimal methodsFor: 'printing' stamp: 'nice 3/29/2011 21:59'!printOn: aStream showingDecimalPlaces: placesDesired	"Same as super, except the fraction knows better how to do it."	fraction printOn: aStream showingDecimalPlaces: placesDesired! !!ScaledDecimal methodsFor: 'printing' stamp: 'ul 11/29/2010 00:14'!printScaleOn: stream	stream nextPut: $s.	scale printOn: stream! !!ScaledDecimal methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28'!storeOn: aStream 	"SxaledDecimal sometimes have more digits than they print (potentially an infinity).	In this case, do not use printOn: because it would loose some extra digits"		self shouldBePrintedAsLiteral		ifTrue: [self printOn: aStream]		ifFalse: [aStream			nextPut: $(;		 	store: fraction numerator;			nextPut: $/;			store: fraction denominator;			nextPut: $s;			store: scale;			nextPut: $)]! !!ScaledDecimal methodsFor: 'testing' stamp: 'ul 11/29/2010 20:06'!negative	^fraction negative! !!ScaledDecimal commentStamp: 'nice 9/7/2011 19:09' prior: 0!ScaledDecimal provides a numeric representation of fixed point decimal numbers able to accurately represent decimal fractions.  It supports unbounded precision, with no limit to the number of digits before and after the decimal point.	ScaledDecimal complies with the ANSI protocols:	Object	number	ScaledDecimal	????#todo. "finish protocol list."Implementation Notes:In order to fullfil exact arithmetic requirements, ScaledDecimal is implemented using a Fraction (or an Integer if fraction part is zero) in the fraction instance variable, and a positive Integer number of digits after the decimal point in the scale instance variable. A scaled decimal will perform arithmetic by coercing the arguments to fractions, and perform the operations with exact arithmetic.Note that the denominator needs not being a power of two. If denominator has other prime factors than 2 and 5, then it cannot be printed in decimal form with a finite number of digits. Instead, the printed representation will be truncated to the number of digits prescribed in scale. But beware, the number still has hidden precision.Example: | x |x := 1 / 3.0s2.^{ x printString -> 'truncated print'.  3 * x -> 'but full precision'}!!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testAsNumber	"Ensure no loss of precision"	| sd |	sd := '1.40s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '1.40s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testAsNumberNegatedWithoutDecimalPoint	| sd |	sd := '-123s0' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 0.	self assert: '-123s0' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testAsNumberNegatedWithoutDecimalPoint2	| sd |	sd := '-123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '-123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testAsNumberWithExtendedScale	| sd |	sd := '123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testAsNumberWithoutDecimalPoint	| sd |	sd := '123s0' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 0.	self assert: '123s0' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testAsNumberWithoutDecimalPoint2	| sd |	sd := '123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testAsNumberWithRadix	| sd |	sd := '10r-22.2s5' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 5.	self assert: '-22.20000s5' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testAsNumberWithSuperfluousDecimalPoint	| sd |	sd := '123.s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 11/1/2011 18:25'!testConvertFromFloat	| aFloat sd f2 diff |	aFloat := 11/13 asFloat.	sd := aFloat asScaledDecimal: 2.	self assert: 2 = sd scale.	self assert: '0.84s2' = sd printString.	self assert: '-0.84s2' = sd negated printString.	f2 := sd asFloat.	diff := f2 - aFloat.	self assert: diff abs < 1.0e-9. "actually, f = f2, but this is not a requirement"! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 11/1/2011 18:27'!testConvertFromFractionWithScale	| sd |	sd := (13 / 11) asScaledDecimal: 6.	self assert: ScaledDecimal == sd class.	self assert: ('1.181818s6' = sd printString).	self assert: 6 = sd scale.	sd := (-13 / 11) asScaledDecimal: 6.	self assert: ScaledDecimal == sd class.	self assert: ('-1.181818s6' = sd printString).	self assert: 6 = sd scale! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 10/14/2011 22:23'!testExactNthRoot	| eight thousandth tenth two |	eight := 8.0s1.	two := eight raisedTo: 1/3.	self assert: two = 2.	self assert: (two class = eight class and: [two scale = eight scale]).	thousandth := 0.001s3.	tenth := thousandth raisedTo: 1/3.	self assert: tenth * 10 = 1.	self assert: (tenth class = thousandth class and: [tenth scale = thousandth scale]).! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 10/14/2011 21:57'!testExactSqrt	| four hundredth tenth two |	four := 4.0s1.	two := four sqrt.	self assert: two = 2.	self assert: (two class = four class and: [two scale = four scale]).	hundredth := 0.01s2.	tenth := hundredth sqrt.	self assert: tenth * 10 = 1.	self assert: (tenth class = hundredth class and: [tenth scale = hundredth scale]).! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 10/14/2011 22:25'!testInexactNthRoot	| tenth cubicRoot3 fifthRootTenth three |	three := 3.0s1.	cubicRoot3 := three raisedTo: 1/3.	self assert: cubicRoot3 class = Float.	self deny: cubicRoot3 squared = 3.	tenth := 0.10s2.	fifthRootTenth := tenth raisedTo: 1/5.	self assert: fifthRootTenth class = Float.	self deny: fifthRootTenth squared = tenth.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'nice 10/14/2011 21:59'!testInexactSqrt	| tenth sqrt3 sqrtTenth three |	three := 3.0s1.	sqrt3 := three sqrt.	self assert: sqrt3 class = Float.	self deny: sqrt3 squared = 3.	tenth := 0.10s2.	sqrtTenth := tenth sqrt.	self assert: sqrtTenth class = Float.	self deny: sqrtTenth squared = tenth.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02'!testLiteral	| sd |	sd := 1.40s2.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '1.40s2' = sd printString! !!Scanner methodsFor: 'expression types' stamp: 'ul 3/27/2011 22:21'!scanAllTokenPositionsInto: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."	| lastMark |	lastMark := 1.	[currentComment ifNotNil:		[currentComment do:			[:cmnt| | idx |			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.			 (idx > 0 and: [idx < mark]) ifTrue:				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].		 currentComment := nil].	mark ifNotNil:		[(token == #- 		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue:			[| savedMark |			 savedMark := mark.			 self scanToken.			 token := token negated.			 mark := savedMark].		"Compensate for the fact that the parser uses two character lookahead.  Normally we must		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."		 aBlock			value: mark			value: (source atEnd					ifTrue: [tokenType := #doIt. "to cause an immediate ^self" source position]					ifFalse: [source position - 2])].	 (tokenType == #rightParenthesis	  or: [tokenType == #doIt]) ifTrue:		[^self].	tokenType == #leftParenthesis		ifTrue: 			[self scanToken; scanAllTokenPositionsInto: aBlock]		ifFalse: 			[(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])				ifTrue: 					[self scanLitWord.					 token == #true ifTrue: [token := true].					 token == #false ifTrue: [token := false].					 token == #nil ifTrue: [token := nil]]				ifFalse:					[(token == #- 					  and: [(self typeTableAt: hereChar) == #xDigit])						ifTrue: 							[self scanToken.							 token := token negated]]].		self scanToken ] repeat! !!Scanner methodsFor: 'expression types' stamp: 'ul 3/15/2011 04:02'!scanLitByteVec	| stream |	stream := (ByteArray new: 16) writeStream.	[ tokenType == #rightBracket or: [ tokenType == #doIt ] ] whileFalse: [		tokenType == #word			ifTrue: [ self scanLitWord ].		(token isInteger and: [ token between: 0 and: 255 ])			ifFalse: [ ^ self offEnd: '8-bit integer or right bracket expected' ].		stream nextPut: token.		self scanToken ].	token := stream contents! !!Scanner methodsFor: 'expression types' stamp: 'ul 3/15/2011 04:00'!scanLitVec	| s |	s := WriteStream on: (Array new: 16).	[tokenType == #rightParenthesis or: [tokenType == #doIt]] whileFalse:		[tokenType == #leftParenthesis			ifTrue: 				[self scanToken; scanLitVec]			ifFalse: 				[(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])					ifTrue: 						[self scanLitWord.						token == #true ifTrue: [token := true].						token == #false ifTrue: [token := false].						token == #nil ifTrue: [token := nil]]					ifFalse:						[(token == #- 						  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: 							[self scanToken.							 token := token negated]]].		s nextPut: token.		self scanToken].	token := s contents! !!Scanner methodsFor: 'expression types' stamp: 'ul 4/3/2011 02:11'!scanLitWord	"Accumulate keywords and asSymbol the result."	token := (String streamContents: [ :stream |		stream nextPutAll: token.		[ (self typeTableAt: hereChar) == #xLetter ] whileTrue: [			self xLetter.			stream nextPutAll: token ] ]) asSymbol! !!Scanner methodsFor: 'expression types' stamp: 'ul 3/27/2011 22:17'!scanStringStruct	| s |	s := WriteStream on: (Array new: 16).	[tokenType == #rightParenthesis or: [tokenType == #doIt]]		whileFalse: 			[tokenType == #leftParenthesis				ifTrue: 					[self scanToken; scanStringStruct]				ifFalse: 					[tokenType == #word ifFalse:						[^self error: 'only words and parens allowed']].			s nextPut: token.			self scanToken].	token := s contents! !!Scanner methodsFor: 'expression types' stamp: 'ul 3/27/2011 23:25'!scanToken	[(tokenType := self typeTableAt: hereChar) == #xDelimiter]		whileTrue: [self step].  "Skip delimiters fast, there almost always is one."	mark := (aheadChar == DoItCharacter and: [source atEnd])		ifTrue: [source position]		ifFalse: [source position - 1].	(tokenType at: 1) == $x "x as first letter"		ifTrue: [self perform: tokenType "means perform to compute token & type"]		ifFalse: [token := self step asSymbol "else just unique the first char"].	^token! !!Scanner methodsFor: 'expression types' stamp: 'ul 3/27/2011 23:31'!step	| c |	c := hereChar.	hereChar := aheadChar.	source atEnd		ifTrue: [aheadChar := DoItCharacter]		ifFalse: [aheadChar := source next].	^c! !!Scanner methodsFor: 'initialize-release' stamp: 'ul 3/27/2011 23:07'!initialize	super initialize.	buffer := WriteStream on: (String new: 40).	typeTable := TypeTable! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 10/24/2011 18:14'!xBinary	| startOfToken |	tokenType := #binary.	startOfToken := mark.	token := String with: self step.	[(self typeTableAt: hereChar) == #xBinary or: [(self typeTableAt: hereChar) == #verticalBar]] whileTrue:		[(hereChar == $- and: [(self typeTableAt: aheadChar) == #xDigit])			ifTrue: [^self ambiguousSelector: (token , '-')					inRange: (startOfToken to: source position - 1).].		token := token, (String with: self step)].	token := token asSymbol! !!Scanner methodsFor: 'multi-character scans' stamp: 'ul 3/27/2011 23:32'!xColon	"Allow := for assignment"		aheadChar == $= ifTrue:		[self step.		tokenType := #leftArrow.		self step.		^ token := #':='].	"Otherwise, just do what normal scan of colon would do"	tokenType := #colon.	^ token := self step asSymbol! !!Scanner methodsFor: 'multi-character scans' stamp: 'ul 3/27/2011 23:25'!xDigit	"Form a number."	tokenType := #number.	(aheadChar == DoItCharacter and: [source atEnd			and:  [source skip: -1. source next ~~ DoItCharacter]])		ifTrue: [source skip: -1 "Read off the end last time"]		ifFalse: [source skip: -2].	token := (SqNumberParser on: source)		failBlock: [:errorString :position | self notify: errorString at:position];		nextNumber.	self step; step! !!Scanner methodsFor: 'multi-character scans' stamp: 'ul 4/2/2011 00:49'!xDollar	"Form a Character literal."	self step. "pass over $"	token := self step.	tokenType := #character! !!Scanner methodsFor: 'multi-character scans' stamp: 'ul 3/27/2011 23:25'!xDoubleQuote    "Collect a comment."    "wod 1/10/98: Allow 'empty' comments by testing the first characterfor $"" rather than blindly adding it to the comment being collected."	buffer reset.	self step.	[ hereChar == $" ] whileFalse: [		(hereChar == DoItCharacter and: [ source atEnd ]) ifTrue: [			^self offEnd: 'Unmatched comment quote' ].		buffer nextPut: self step ].	self step.	(currentComment ifNil: [ 		currentComment := OrderedCollection new ])			add: buffer contents.	self scanToken! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 7/25/2010 12:23'!xIllegal	"An illegal character was encountered"	self notify: 'Illegal character (char code ' , hereChar charCode , ' ' , hereChar charCode storeStringHex , ')' at: mark! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 3/25/2011 09:16'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type := self typeTableAt: hereChar) == #xLetter		or: [type == #xDigit		or: [type == #xUnderscore and:[self allowUnderscoreSelectors]]]] whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar := aheadChar.			aheadChar := source atEnd							ifTrue: [30 asCharacter "doit"]							ifFalse: [source next]].	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~~ $=]])					ifTrue: 						[buffer nextPut: self step.						"Allow any number of embedded colons in literal symbols"						[(self typeTableAt: hereChar) == #xColon] whileTrue:							[buffer nextPut: self step].						#keyword]					ifFalse: 						[#word].	token := buffer contents! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 10/4/2011 21:12'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start := mark.	self step. "litQuote"	self scanToken.	tokenType == #leftParenthesis		ifTrue: [self scanToken; scanLitVec.			mark := start + 1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse: [tokenType == #leftBracket				ifTrue: [self scanToken; scanLitByteVec.					mark := start + 1.					tokenType == #doIt						ifTrue: [self offEnd: 'Unmatched bracket']]				ifFalse: [(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])						ifTrue: [self scanLitWord]						ifFalse: [tokenType == #string							ifTrue: [token := token asSymbol]							ifFalse: [(tokenType == #binary or: [ tokenType == #verticalBar ]) 								ifFalse: [(token isCharacter and: [self class prefAllowUnicharSymbol])									ifTrue:										[tokenType := Symbol.										token := Symbol with: token]									ifFalse: [self notify: 'Invalid literal character' at: start + 1]]]]]].	mark := start.	tokenType := #literal	"#(Pen)	#Pen	#'Pen'	##Pen	###Pen	"! !!Scanner methodsFor: 'multi-character scans' stamp: 'ul 3/27/2011 23:26'!xSingleQuote	"String."	self step.	buffer reset.	[hereChar == $' 		and: [aheadChar == $' 				ifTrue: [self step. false]				ifFalse: [true]]]		whileFalse: 			[buffer nextPut: self step.			(hereChar == DoItCharacter and: [source atEnd])				ifTrue: [^self offEnd: 'Unmatched string quote']].	self step.	token := buffer contents.	tokenType := #string! !!Scanner methodsFor: 'multi-character scans' stamp: 'eem 11/16/2010 15:05'!xUnderscore	self allowUnderscoreAssignments ifTrue:[ | type |		"Figure out if x _foo (no space between _ and foo) 		should be a selector or assignment"		(((type := self typeTableAt: aheadChar) == #xLetter			or:[type == #xDigit or:[type == #xUnderscore]]) 			and:[self allowUnderscoreSelectors]) ifFalse:[				self step.				tokenType := #leftArrow.				^token := #'_'		].	].	self allowUnderscoreSelectors ifTrue:[^self xLetter].	^self xIllegal! !!Scanner methodsFor: 'public access' stamp: 'ul 3/27/2011 23:37'!scanFieldNames: stringOrArray	"Answer an Array of Strings that are the identifiers in the input string, 	stringOrArray. If passed an Array, just answer with that Array, i.e., 	assume it has already been scanned."	| strm |	(stringOrArray isMemberOf: Array)		ifTrue: [^stringOrArray].	self scan: (ReadStream on: stringOrArray asString).	strm := WriteStream on: (Array new: 10).	[tokenType == #doIt]		whileFalse: 			[tokenType == #word ifTrue: [strm nextPut: token].			self scanToken].	^strm contents	"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )"! !!Scanner methodsFor: 'public access' stamp: 'ul 3/27/2011 22:16'!scanMessageParts: sourceString	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"	| coll nonKeywords |	coll := OrderedCollection new.	self scan: (ReadStream on: sourceString asString).	nonKeywords := 0.	[tokenType == #doIt] whileFalse:		[(currentComment == nil or: [currentComment isEmpty])			ifTrue: [coll addLast: nil]			ifFalse: [coll addLast: currentComment removeFirst.				[currentComment isEmpty] whileFalse:					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].		(token numArgs < 1 or: [token = #| and: [ coll size > 1 ] ])			ifTrue: [(nonKeywords := nonKeywords + 1) > 1 ifTrue: [^ coll]]						"done with header"			ifFalse: [nonKeywords := 0].		coll addLast: token.		self scanToken].	(currentComment == nil or: [currentComment isEmpty])		ifTrue: [coll addLast: nil]		ifFalse: [coll addLast: currentComment removeFirst.			[currentComment isEmpty] whileFalse: [				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].	^ coll! !!Scanner methodsFor: 'public access' stamp: 'ul 3/27/2011 23:39'!typedScanTokens: textOrString 	"Answer an Array that has been tokenized with literals mapped to literals,	 special characters mapped to symbols and variable names and keywords	 to strings. This methiod accepts _ (underscore) as an assignment token	 irrespective of whether the system prefers := as the assignment token."	| s |	self initScannerForTokenization.	self scan: (ReadStream on: textOrString asString).	s := WriteStream on: (Array new: 16).	[tokenType == #doIt] whileFalse:		[(token == #- 		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: 			[self scanToken.			 token := token negated].		s nextPut: token.		self scanToken].	^s contents	"Scanner new typedScanTokens: (Scanner sourceCodeAt: #typedScanTokens:)"! !!Scanner methodsFor: 'private' stamp: 'ul 10/28/2010 00:41'!allowUnderscoreAssignments	"Query preference"	^self class allowUnderscoreAsAssignment! !!Scanner commentStamp: 'ul 4/3/2011 02:04' prior: 0!I scan a string or text, picking out Smalltalk syntactic tokens. I look one character ahead. I put each token found into the instance variable, token, and its type (a Symbol) into the variable, tokenType. At the end of the input stream, I pretend to see an endless sequence of special characters called doIts.Instance Variables	aheadChar:		<Character>	buffer:		<WriteStream>	currentComment:		<OrderedCollection>	hereChar:		<Character>	mark:		<Integer>	source:		<ReadStream>	token:		<Symbol|String|NumberCharacter|Boolean|nil>	tokenType:		<Symbol>	typeTable:		<Array>aheadChar	- the next character in the input streambuffer	- a reusable WriteStream on a String which is used for building strings. Shouldn't be used from multiple methods without resetting.currentComment	- an OrderedCollection of strings which contain all comments between the current token and the previous token or the beginning of the source.hereChar	- the current charactermark	- the position of the current token in the source streamsource	- the input stream of characterstoken	- the current tokentokenType	- the type of the current token. The possible token types are: #binary, #character, #colon, #doIt, #keyword, #leftArrow, #leftBrace, #leftBracket, #leftParenthesis, #literal, #period, #rightBrace, #rightBracket, #rightParenthesis, #semicolon, #string, #upArrow, #verticalBar, #word, #xBinary, #xColon, #xDelimiter, #xDigit, #xDollar, #xDoubleQuote, #xLetter, #xLitQuote, #xSingleQuote, #xUnderscoretypeTable	- an array that maps each an evaluable tokenType to each character with asciiValue between 0 and 255!!Scanner class methodsFor: 'testing' stamp: 'nice 11/19/2010 17:22'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type next last |	i := aSymbol size.	i = 0 ifTrue: [^ false].	"TypeTable should have been origined at 0 rather than 1 ..."	ascii := (aSymbol at: 1) asciiValue.	type := TypeTable at: ascii ifAbsent: [^false].	type == #xLetter ifTrue: [		next := last := nil.		[i > 1]				whileTrue: 					[ascii := (aSymbol at: i) asciiValue.					type := TypeTable at: ascii ifAbsent: [^false].					(type == #xLetter or: [type == #xDigit or: [type == #xColon							and: [								next == nil									ifTrue: [last := #xColon. true] 									ifFalse: [last == #xColon and: [next ~~ #xDigit and: [next ~~ #xColon]]]]]])						ifFalse: [^ false].					next := type.					i := i - 1].			^ true].	type == #xBinary ifTrue:		[^(2 to: i) allSatisfy: [:j |			ascii := (aSymbol at: j) asciiValue.			(TypeTable at: ascii ifAbsent: []) == #xBinary]].	type == #verticalBar ifTrue: [^i = 1].	^false! !!Scanner class methodsFor: 'initialization' stamp: 'ul 3/27/2011 23:06'!initialize		self initializeTypeTable.	DoItCharacter := Character value: 30! !!Scanner class methodsFor: 'initialization' stamp: 'ul 3/27/2011 23:06'!initializeTypeTable	"self initializeTypeTable"	| newTable |	newTable := Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	1 to: 255		do: [:index |			(Character value: index) isLetter				ifTrue: [newTable at: index put: #xLetter]].	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #xUnderscore.	newTable at: $| asciiValue put: #verticalBar.	TypeTable := newTable "bon voyage!!"! !!Scanner class methodsFor: 'preferences' stamp: 'ul 6/10/2011 22:19'!allowBlockArgumentAssignment	"Accessor for the system-wide preference"		<preference: 'Allow block argument assignment.'		category: 'Compiler'		description: 'If enabled, the compiler will allow assignment into block arguments.This provides backward compatibility with the pre-closure compiler.'		type: #Boolean>	^AllowBlockArgumentAssignment ifNil: [ false ]! !!Scanner class methodsFor: 'preferences' stamp: 'ul 6/10/2011 22:20'!allowBlockArgumentAssignment: aBoolean	"Accessor for the system-wide preference"		AllowBlockArgumentAssignment := aBoolean! !!Scanner class methodsFor: 'preferences' stamp: 'ul 10/28/2010 00:40'!allowUnderscoreAsAssignment	"Accessor for the system-wide preference"	<preference: 'Allow underscore assignments'		category: 'Compiler'		description: 'When true, underscore can be used as assignment operator'		type: #Boolean>	^AllowUnderscoreAssignments ifNil:[true]! !!Scanner class methodsFor: 'preferences' stamp: 'ul 10/28/2010 00:40'!allowUnderscoreAsAssignment: aBool	"Accessor for the system-wide preference"	AllowUnderscoreAssignments := aBool! !!Scanner class methodsFor: 'preferences' stamp: 'ul 10/28/2010 00:40'!prefAllowUnderscoreAssignments	"Accessor for the system-wide preference"		self deprecated: 'Use #allowUnderscoreAsAssignment'.	^self allowUnderscoreAsAssignment! !!Scanner class methodsFor: 'preferences' stamp: 'ul 10/28/2010 00:41'!prefAllowUnderscoreAssignments: aBool	"Accessor for the system-wide preference"		self deprecated: 'Use #allowUnderscoreAsAssignment:'.	self allowUnderscoreAsAssignment: aBool! !!Scanner class methodsFor: 'preferences' stamp: 'nice 10/4/2011 21:08'!prefAllowUnicharSymbol	"Accessor for the system-wide preference"	<preference: 'Allow symbols with unique character like #,'		category: 'Compiler'		description: 'When true, the historical syntax #, #; or #. is allowed.'		type: #Boolean>	^AllowUnicharSymbol ifNil: [false]! !!Scanner class methodsFor: 'preferences' stamp: 'nice 10/4/2011 21:13'!prefAllowUnicharSymbol: aBoolean	"Accessor for the system-wide preference"	AllowUnicharSymbol := aBoolean! !!ScorePlayer methodsFor: 'copying' stamp: 'nice 1/12/2010 20:14'!postCopy	"Copy my component sounds."	super postCopy.	self copySounds! !!ScorePlayerMorph class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:25'!initialize	FileServices registerFileReader: self! !!ScorePlayerMorph class methodsFor: 'initialize-release' stamp: 'ar 9/5/2010 09:25'!unload	FileServices unregisterFileReader: self ! !!ScreenController methodsFor: 'menu messages' stamp: 'HenrikSperreJohansen 1/21/2011 18:37'!soundOnOrOff	SoundService toggleSoundEnabled! !!ScreenController methodsFor: 'nested menus' stamp: 'HenrikSperreJohansen 1/21/2011 18:39'!helpMenu 	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(			'about this system...'			'update code from server'			'preferences...'			'command-key help'			'font size summary'			'useful expressions'			'view graphical imports'			'standard graphics library'),			(Array with: (SoundService soundEnablingString)) ,		#(	'set author initials...'			'vm statistics'			'space left')		lines: #(1 4 6 11)		selections: #( aboutThisSystem absorbUpdatesFromServereditPreferences  openCommandKeyHelp fontSizeSummary openStandardWorkspace viewImageImportsstandardGraphicsLibrary soundOnOrOff setAuthorInitials vmStatistics garbageCollect)"ScreenController new helpMenu startUp"! !!ScreenedVocabulary methodsFor: 'enumeration' stamp: 'ul 8/2/2011 20:09'!categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass	"Answer the category list for the given object/class, considering only code implemented in mostGenericClass and lower"	^(super categoryListForInstance: anObject ofClass: aClass limitClass: mostGenericClass)		select: categoryScreeningBlock! !!ScriptActivationButton methodsFor: 'menu' stamp: 'sw 3/2/2004 20:58'!addCustomMenuItems: aMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	aMenu add: 'open underlying scriptor' translated target: target selector: #openUnderlyingScriptorFor: argument: arguments first! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'ul 11/15/2010 12:02'!updateStatus	"Update that status in the receiver's header.  "	(self topEditor == self and: [firstTileRow ~= 1]) ifTrue:		[(submorphs size = 0 or: [(self firstSubmorph findA: ScriptStatusControl) isNil])			ifTrue:				[self replaceRow1].		self updateStatusMorph: (self firstSubmorph findA: ScriptStatusControl)]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'nice 12/29/2010 15:00'!extent: x	| newExtent tw menu |	newExtent := x max: self minWidth @ self minHeight.	(tw := self findA: TwoWayScrollPane) ifNil:		["This was the old behavior"		^ super extent: newExtent].	(self hasProperty: #autoFitContents) ifTrue: [		menu := MenuMorph new defaultTarget: self.		menu addUpdating: #autoFitString target: self action: #autoFitOnOff.		menu addTitle: 'To resize the script, uncheck the box below' translated.		menu popUpEvent: nil in: self world	.		^ self].	"Allow the user to resize to any size"	tw extent: ((newExtent x max: self firstSubmorph width)				@ (newExtent y - self firstSubmorph height)) - (borderWidth * 2) + (-4 @ -4).  "inset?"	^ super extent: newExtent! !!ScriptEditorMorph methodsFor: 'menu commands' stamp: 'nice 12/29/2010 14:59'!createThreadShowing	| vertices |	self deleteThreadShowing.	vertices := OrderedCollection new.	self tileRows do: [:row | | b |		row first isTurtleRow ifTrue: [			b := row first bounds.			vertices add: ((b topLeft + (4 @ 0)) + ((0 * 0.1 * b width) @ 0)).			0 to: 9 do: [:i |				vertices add: ((b topLeft + (4 @ 4))+ ((i * 0.1 * b width ) @ 0)).				vertices add: ((b bottomLeft + (4 @ -4)) + ((i * 0.1 * b width) @ 0)).			].				vertices add: ((b bottomLeft + (4 @ 0)) + ((9 * 0.1 * b width) @ 0)).		] ifFalse: [			b := row first bounds.			vertices add: ((b origin x + b corner x) // 2) @ (b origin y).			vertices add: ((b origin x + b corner x) // 2) @ (b origin y + 4).			vertices add: ((b origin x + b corner x) // 2) @ (b corner y - 4).			vertices add: ((b origin x + b corner x) // 2) @ (b corner y).		].	].	threadPolygon := PolygonMorph vertices: vertices color: Color black borderWidth: 2 borderColor: Color black.	threadPolygon makeOpen.	threadPolygon openInWorld.! !!ScriptLoader methodsFor: 'cleaning' stamp: 'ul 6/17/2011 12:19'!finalCleanup	"self new finalCleanup"	DataStream initialize.	Behavior flushObsoleteSubclasses.	"The pointer to currentMethod is not realy needed (anybody care to fix this) and often holds on to obsolete bindings"	MethodChangeRecord allInstancesDo: [:each | each noteNewMethod: nil].	self cleanUpEtoys.	SmalltalkImage current fixObsoleteReferences.	Smalltalk flushClassNameCache.	SystemOrganization removeEmptyCategories.	3 timesRepeat: [		Smalltalk garbageCollect.		Symbol compactSymbolTable.	].	! !!ScrollBar methodsFor: 'scroll timing' stamp: 'jmv 3/2/2010 16:29'!waitForDelay1: delay1 delay2: delay2 	"Return true if an appropriate delay has passed since the last scroll operation.	The delay decreases exponentially from delay1 to delay2."	| now scrollDelay |	timeOfLastScroll ifNil: [self resetTimer].	"Only needed for old instances"	now := Time millisecondClockValue.	(scrollDelay := currentScrollDelay) isNil 		ifTrue: [scrollDelay := delay1	"initial delay"].	currentScrollDelay := scrollDelay * 9 // 10 max: delay2.	"decrease the delay"	timeOfLastScroll := now.	^true! !!ScrollPane methodsFor: 'geometry' stamp: 'nice 12/29/2010 15:00'!vResizeScrollBar	| w topLeft borderHeight innerWidth |	w := self scrollBarThickness.	innerWidth := self flatColoredScrollBarLook 		ifTrue: 			[borderHeight := borderWidth.			0]		ifFalse: 			[borderHeight := 0.			 1].	topLeft := scrollBarOnLeft 				ifTrue: 					[retractableScrollBar 						ifTrue: [bounds topLeft - ((w - borderWidth) @ (0 - borderHeight))]						ifFalse: [bounds topLeft + ((borderWidth - innerWidth) @ borderHeight)]]				ifFalse: 					[retractableScrollBar 						ifTrue: [bounds topRight - (borderWidth @ (0 - borderHeight))]						ifFalse: 							[bounds topRight - ((w + borderWidth - innerWidth) @ (0 - borderHeight))]].				scrollBar 		bounds: (topLeft + ((scrollBarOnLeft ifTrue: [-1] ifFalse: [1]) @ -1) extent: w @ self vScrollBarHeight)	! !!ScrollPane methodsFor: 'scrolling' stamp: 'ul 11/15/2010 12:02'!hideOrShowScrollBars	| wasHShowing wasVShowing |	wasVShowing := self vIsScrollbarShowing.	wasHShowing := self hIsScrollbarShowing.	self 		vHideOrShowScrollBar; 		hHideOrShowScrollBar; 		resizeScrollBars.	(wasVShowing and: [self vIsScrollbarShowing not]) ifTrue:		["Make sure the delta is 0"		(scroller offset y = 0) 				ifFalse:[ scroller offset: (scroller offset x@0) ]].				(wasHShowing and: [self hIsScrollbarShowing not]) ifTrue:		[(scroller offset x <= 0)				ifFalse:[ scroller offset: (self hMargin negated@scroller offset y)]].! !!SearchingViewer methodsFor: 'search' stamp: 'sw 4/10/2003 21:36'!doSearchFrom:  aSource	"Perform the search operation"	^ self doSearchFrom: aSource interactive: true! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'nice 8/28/2010 22:40'!hashInteger: aPositiveInteger seed: seedInteger	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in the production of random numbers"	| buffer dstIndex |	"Initialize totalA through totalE to their seed values."	totalA := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -128) bitAnd: 16rFFFFFFFF).	totalB := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -96) bitAnd: 16rFFFFFFFF).	totalC := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -64) bitAnd: 16rFFFFFFFF).	totalD := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -32) bitAnd: 16rFFFFFFFF).	totalE := ThirtyTwoBitRegister		fromInteger: (seedInteger bitAnd: 16rFFFFFFFF).	self initializeTotalsArray.	"pad integer with zeros"	buffer := ByteArray new: 64.	dstIndex := 0.	aPositiveInteger digitLength to: 1 by: -1 do: [:i |		buffer at: (dstIndex := dstIndex + 1) put: (aPositiveInteger digitAt: i)].	"process that one block"	self processBuffer: buffer.	^ self finalHash! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:43'!expandedBlock: aByteArray	"Convert the given 64 byte buffer into 80 32-bit registers and answer the result." 	| out src v |	out := Array new: 80.	src := 1.	1 to: 16 do: [:i |		out at: i put: (ThirtyTwoBitRegister fromByteArray: aByteArray at: src).		src := src + 4].	17 to: 80 do: [:i |		v := (out at: i - 3) copy.		v	bitXor: (out at: i - 8);			bitXor: (out at: i - 14);			bitXor: (out at: i - 16);			leftRotateBy: 1.		out at: i put: v].	^ out! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:39'!initializeTotals	"Initialize totalA through totalE to their seed values."	"total registers for use when primitives are absent"	totalA := ThirtyTwoBitRegister fromInteger: 16r67452301.	totalB := ThirtyTwoBitRegister fromInteger: 16rEFCDAB89.	totalC := ThirtyTwoBitRegister fromInteger: 16r98BADCFE.	totalD := ThirtyTwoBitRegister fromInteger: 16r10325476.	totalE := ThirtyTwoBitRegister fromInteger: 16rC3D2E1F0.	self initializeTotalsArray.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:28'!processBuffer: aByteArray	"Process given 64-byte buffer, accumulating the results in totalA through totalE."	| a b c d e w tmp |	self primHasSecureHashPrimitive		ifTrue: [^ self processBufferUsingPrimitives: aByteArray]		ifFalse: [totals := nil].	"initialize registers a through e from the current totals" 	a := totalA copy.	b := totalB copy.	c := totalC copy.	d := totalD copy.	e := totalE copy.	"expand and process the buffer"	w := self expandedBlock: aByteArray.	1 to: 80 do: [:i |		tmp := (a copy leftRotateBy: 5)			+= (self hashFunction: i of: b with: c with: d);			+= e;			+= (w at: i);			+= (self constantForStep: i).		e := d.		d := c.		c := b leftRotateBy: 30.		b := a.		a := tmp].	"add a through e into total accumulators"	totalA += a.	totalB += b.	totalC += c.	totalD += d.	totalE += e.! !!SecureHashAlgorithm class methodsFor: 'class initialization' stamp: 'nice 8/28/2010 22:39'!initialize	"SecureHashAlgorithm initialize"	"For the curious, here's where these constants come from:	  #(2 3 5 10) collect: [:x | ((x sqrt / 4.0) * (2.0 raisedTo: 32)) truncated hex]"	K1 := ThirtyTwoBitRegister fromInteger: 16r5A827999.	K2 := ThirtyTwoBitRegister fromInteger: 16r6ED9EBA1.	K3 := ThirtyTwoBitRegister fromInteger: 16r8F1BBCDC.	K4 := ThirtyTwoBitRegister fromInteger: 16rCA62C1D6.! !!SecurityManager methodsFor: 'security operations' stamp: 'nice 5/8/2011 12:08'!positionToSecureContentsOf: aStream	| bytes trusted part1 part2 sig hash dsa okay pos |	aStream binary.	pos := aStream position.	bytes := aStream next: 4.	bytes = 'SPRJ' asByteArray ifFalse:[		"was not signed"		aStream position: pos.		^false].	part1 := (aStream nextInto: (LargePositiveInteger basicNew: 20)) normalize.	part2 := (aStream nextInto: (LargePositiveInteger basicNew: 20)) normalize.	sig := Array with: part1 with: part2.	hash := SecureHashAlgorithm new hashStream: aStream.	dsa := DigitalSignatureAlgorithm new.	trusted := self trustedKeys.	okay := trusted anySatisfy: [:key| dsa verifySignature: sig ofMessageHash: hash publicKey: key].	aStream position: pos+44.	^okay! !!SecurityManager methodsFor: 'private' stamp: 'mir 11/10/2003 16:14'!printStateOn: stream	"Print the current state of myself onto stream.	Used to gather information in the debug log."	stream		nextPutAll: 'SecurityManager state:'; cr;		nextPutAll: 'Restricted: '; nextPutAll: self isInRestrictedMode asString; cr;		nextPutAll: 'FileAccess: '; nextPutAll: self hasFileAccess asString; cr;		nextPutAll: 'SocketAccess: '; nextPutAll: self hasSocketAccess asString; cr;		nextPutAll: 'Working Dir '; nextPutAll: FileDirectory default pathName asString; cr;		nextPutAll: 'Trusted Dir '; nextPutAll: self secureUserDirectory asString; cr;		nextPutAll: 'Untrusted Dir '; nextPutAll: self untrustedUserDirectory asString; cr;		cr! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'jmv 3/2/2010 11:23'!startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean	"Overridden to return value returned by manageMarker.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"	| index |	index := super startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.	(selections isNil or: [(index between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: index! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 12:03'!fromArray: anArray	"Construct a menu from anArray.  The elements of anArray must be either:	*  A pair of the form: <label> <selector>or	*  The 'dash' (or 'minus sign') symbol	Refer to the example at the bottom of the method"	| labelList lines selections anIndex |	labelList := OrderedCollection new.	lines := OrderedCollection new.	selections := OrderedCollection new.	anIndex := 0.	anArray do:		[:anElement |			anElement size = 1				ifTrue:					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].					lines add: anIndex]				ifFalse:					[anElement size = 2 ifFalse: [self error: 'badly-formed menu constructor'].					anIndex := anIndex + 1.					labelList add: anElement first.					selections add: anElement second]].	^ self labelList: labelList lines: lines selections: selections"(SelectionMenu fromArray:	#(	('first label'		moja)		('second label'	mbili)		-		('third label' 	tatu)		-		('fourth label'	nne)		('fifth label'	tano))) startUp"! !!SelectionMorph methodsFor: 'testing' stamp: 'nk 9/4/2004 17:38'!isSelectionMorph	^true! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'nice 8/19/2010 14:08'!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	| tokens |	contents := aString.	classList := #().  classListIndex := 0.	selectorIndex := 0.	tokens := contents asString findTokens: ' .'.	selectorList := Cursor wait showWhile: [		tokens size = 1 			ifTrue: [(Symbol selectorsContaining: contents asString) asArray				sort: [:x :y | x asLowercase <= y asLowercase]]			ifFalse: [self quickList]].	"find selectors from a single example of data"	self changed: #messageList.	self changed: #classList.	^ true! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'ul 12/6/2011 15:41'!quickList	"Compute the selectors for the single example of receiver and args, in the very top pane" 	| data result resultArray dataStrings mf dataObjects aa statements |	data := contents asString withBlanksTrimmed.	mf := MethodFinder new.	data := mf cleanInputs: data.	"remove common mistakes"	dataObjects := Compiler evaluate: '{', data, '}'. "#( data1 data2 result )"	statements := (Compiler new parse: 'zort ' , data in: Object notifying: nil)				body statements select: [:each | (each isKindOf: ReturnNode) not]. 	dataStrings := statements collect:				[:node | String streamContents:					[:strm | (node isMessage) ifTrue: [strm nextPut: $(].					node shortPrintOn: strm.					(node isMessage) ifTrue: [strm nextPut: $)].]].	dataObjects size < 2 ifTrue: [self inform: 'If you are giving an example of receiver, \args, and result, please put periods between the parts.\Otherwise just type one selector fragment' withCRs. ^#()]. 	dataObjects := Array with: dataObjects allButLast with: dataObjects last. "#( (data1  data2) result )" 	result := mf load: dataObjects; findMessage.	(result first beginsWith: 'no single method') ifFalse: [		aa := self testObjects: dataObjects strings: dataStrings.		dataObjects := aa second.  dataStrings := aa third].	resultArray := self listFromResult: result. 	resultArray isEmpty ifTrue: [self inform: result first].	dataStrings size = (dataObjects first size + 1) ifTrue:		[resultArray := resultArray collect: [:expression | | newExp |		newExp := expression.		dataObjects first withIndexDo: [:lit :i |			newExp := newExp copyReplaceAll: 'data', i printString							with: (dataStrings at: i)].		newExp, ' --> ', dataStrings last]]. 	^ resultArray! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCode: stack args: nArgs encoder: encoder	self emitCode: stack		args: nArgs		encoder: encoder		super: false! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:47'!emitCode: stack args: nArgs encoder: encoder super: supered	stack pop: nArgs.	^supered		ifTrue:			[encoder genSendSuper: index numArgs: nArgs]		ifFalse:			[encoder				genSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:15'!sizeCode: encoder args: nArgs super: supered	self reserve: encoder.	^supered		ifTrue:			[code < Send "i.e. its a special selector" ifTrue:				[code := self code: (index := encoder sharableLitIndex: key) type: 5].			 encoder sizeSendSuper: index numArgs: nArgs]		ifFalse:			[self flag: #yuck. "special selector sends cause this problem"			 encoder				sizeSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitSelectorNode: self! !!Semaphore methodsFor: 'communication' stamp: 'ul 12/8/2010 04:30'!waitIfLocked: aBlock	"Use a signal if available, otherwise evaluate aBlock"	excessSignals == 0 ifTrue: [ ^aBlock value ].	excessSignals := excessSignals - 1! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ul 11/7/2010 05:29'!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	^self critical: [ mutuallyExcludedBlock ifCurtailed: terminationBlock ]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ul 11/7/2010 15:00'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	hasError := false.	blockValue := self critical:[		mutuallyExcludedBlock ifError: [ :msg :rcvr |			hasError := true.			errMsg := msg.			errRcvr := rcvr		].	].	hasError ifTrue:[ ^errorBlock value: errMsg value: errRcvr].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ul 12/8/2010 03:16'!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, then evaluate 	alternativeBlock and return."	"See the comment of #critical: for the explanation how this pattern works	before changing the code."	| caught |	caught := false.	^[		"We're using #== here instead of #=, because it won't introduce a		suspension point, while #= may do that."		excessSignals == 0			ifTrue: [ alternativeBlock value ]			ifFalse: [				excessSignals := excessSignals - 1.				caught := true.				mutuallyExcludedBlock value ] ]		ensure: [ caught ifTrue: [ self signal ] ]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ul 11/15/2010 10:06'!after: target ifAbsent: exceptionBlock	"Answer the element after target.  Answer the result of evaluation	the exceptionBlock if target is not in the receiver, or if there are 	no elements after it."	| index |	index := self indexOf: target.	^ (index = 0 or: [index = self size])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index + 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ul 11/15/2010 10:06'!before: target ifAbsent: exceptionBlock	"Answer the receiver's element immediately before target. Answer	the result of evaluating the exceptionBlock if target is not an element	of the receiver, or if there are no elements before it."	| index |	index := self indexOf: target.	^ (index = 0 or: [index = 1])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index - 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ul 9/12/2010 04:34'!indexOf: anElement startingAt: start	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer 0."	^self indexOf: anElement startingAt: start ifAbsent: 0! !!SequenceableCollection methodsFor: 'accessing' stamp: 'nice 10/2/2011 19:10'!size	^self subclassResponsibility! !!SequenceableCollection methodsFor: 'converting' stamp: 'ul 3/15/2011 14:47'!reverse	"The ANSI standard (5.7.8.26) requires this method to return a copy of the receiver. If you want to reverse the collection in place, then use #reverseInPlace."		^self reversed! !!SequenceableCollection methodsFor: 'converting' stamp: 'ul 4/11/2011 03:07'!reverseInPlace	"Reverse this collection in place."		| start end |	start := 1.	end := self size.	[ start < end ] whileTrue: [		| temp |		temp := self at: start.		self			at: start put: (self at: end);			at: end put: temp.		start := start + 1.		end := end - 1 ]! !!SequenceableCollection methodsFor: 'converting' stamp: 'ul 3/15/2011 14:42'!reversed	"Answer a copy of the receiver with element order reversed."	"Example: 'frog' reversed"	| n result src |	n := self size.	result := self species ofSize: n.	src := n + 1.	1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].	^ result! !!SequenceableCollection methodsFor: 'copying' stamp: 'eem 2/10/2009 11:44'!copyUpThrough: anElement 	"Answer all elements up to and including anObject. If there	is no such object, answer a copy of the receiver."	^self first: (self indexOf: anElement ifAbsent: [^ self copy])! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/17/2010 12:15'!findBinary: aBlock do: actionBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If found, evaluate actionBlock with the found element as argument	If no matching element is found, evaluate exceptionBlock,	with the 'bounding' elements (or nil) as optional arguments.	Examples:		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 11 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 12 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 0.5 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 25 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ',{a. b} printString) ]	"	^self		findBinaryIndex: aBlock		do: [ :foundIndex | actionBlock value: (self at: foundIndex) ]		ifNone: [ :prevIndex :nextIndex |			exceptionBlock				cull: (prevIndex > 0 ifTrue: [ self at: prevIndex ])				cull: (nextIndex <= self size ifTrue: [ self at: nextIndex ]) ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 5/10/2010 14:03'!findBinaryIndex: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ]	"	^self findBinaryIndex: aBlock do: [ :found | found ] ifNone: [ self errorNotFound: aBlock]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/17/2010 12:15'!findBinaryIndex: aBlock do: actionBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If found, evaluate actionBlock with the index as argument	If no matching element is found, evaluate exceptionBlock,	with the indexes of the 'bounding' elements as optional	arguments. 	Warning: Might give invalid indexes, see	examples below.	Examples:		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 11 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString)]		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 12 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23) d			findBinaryIndex: [ :arg | 0.5 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 25 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ',{a. b} printString) ]	"	| index low high |	low := 1.	high := self size.	[		index := high + low // 2.		low > high ] whileFalse: [			| test |			test := aBlock value: (self at: index).			test = 0 				ifTrue: [ ^actionBlock value: index ]				ifFalse: [ test > 0					ifTrue: [ low := index + 1 ]					ifFalse: [ high := index - 1 ] ] ].	^exceptionBlock cull: high cull: low! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/17/2010 12:13'!findBinaryIndex: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock,	with the indexes of the 'bounding' elements as optional	arguments.	Warning: Might give invalid indexes."	^self findBinaryIndex: aBlock do: [ :found | found ] ifNone: exceptionBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 5/10/2010 14:05'!findBinary: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ]	"	^self findBinary: aBlock do: [ :found | found ] ifNone: [ self errorNotFound: aBlock ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/17/2010 12:13'!findBinary: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock,	with the 'bounding' elements (or nil) as optional arguments."		^self findBinary: aBlock do: [ :found | found ] ifNone: exceptionBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 9/10/2011 15:21'!findNearbyBinaryIndex: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, answer the closest index we could find,	answering 0 if the element should preceed all items in the collection,	and size + 1 if the element should follow all items in the collection."		^self		findBinaryIndex: aBlock		ifNone: [ :lower :upper |			lower = self size				ifTrue: [ upper ]				ifFalse: [ lower ] ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 3/1/2011 08:14'!overlappingPairsCollect: aBlock 	"Answer the result of evaluating aBlock with all of the overlapping pairs of my elements."	| retval |	retval := self species ofSize: self size - 1.	1 to: self size - 1		do: [:i | retval at: i put: (aBlock value: (self at: i) value: (self at: i + 1)) ].	^retval! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 8/4/2011 02:33'!polynomialEval: thisX	"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power."	"  #(1 2 3) polynomialEval: 2   "   "is 3*X^2 + 2*X + 1 with X = 2"	| index sum |	sum := self at: (index := self size).	[ (index := index - 1) >= 1 ] whileTrue: [		sum := sum * thisX + (self at: index) ].	^sum! !!SequenceableCollection methodsFor: 'testing' stamp: 'ul 4/1/2011 04:03'!beginsWith: sequence	"Answer true if the receiver starts with the argument collection."		| sequenceSize |	((sequenceSize := sequence size) = 0 or: [ self size < sequence size ]) ifTrue: [ ^false ].	1 to: sequenceSize do: [ :index |		(sequence at: index) = (self at: index) ifFalse: [ ^false ] ].	^true! !!SequenceableCollection methodsFor: 'testing' stamp: 'ul 4/1/2011 04:42'!endsWith: sequence	"Answer true if the receiver ends with the argument collection."		| sequenceSize offset |	((sequenceSize := sequence size) = 0 or: [ (offset := self size - sequence size) < 0 ]) ifTrue: [ ^false ].	1 to: sequenceSize do: [ :index |		(sequence at: index) = (self at: index + offset) ifFalse: [ ^false ] ].	^true! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'ul 7/25/2011 01:30'!changeOfChangesInSlopes: slopes 	"A message to knots of a spline. Returns an array with the 4rd 	cubic coeff."	"The last nth item is correct iff this is a closed cubic. 	Presumably that is the only time we care. 	We always return the same sized array as self."	| n changes |	n := self size.	n = slopes size		ifFalse: [^ self error: 'vertices and slopes differ in number'].	changes := Array new: n.	1 to: n do: [ :i | 		changes at: i put: (self at: i)			- (self atWrap: i + 1) * 2			+ (slopes at: i)			+ (slopes atWrap: i + 1) ].	^ changes! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'ul 7/25/2011 11:24'!closedCubicSlopes	"Sent to knots returns the slopes of a closed cubic spline.	From the same set of java sources as naturalCubic. This is a squeak  	transliteration of the java code."	"from java code NatCubicClosed extends NatCubic  	solves for the set of equations for all knots: 	b1+4*b2+b3=3*(a3-a1)	where a1 is (knots atWrap: index + 1) etc.	and the b's are the slopes .		by decomposing the matrix into upper triangular and lower matrices  	and then back sustitution. See Spath 'Spline Algorithms for Curves  	and Surfaces' pp 19--21. The D[i] are the derivatives at the knots.  	"		| v w x y z n1  D F G H |	n1 := self size.	n1 < 3		ifTrue: [self error: 'Less than 3 points makes a poor curve'].	v := Array new: n1.	w := Array new: n1.	y := Array new: n1.		D := Array new: n1.	x := self.	z := 1.0 / 4.0.	v at: 2 put: z.	w at: 2 put: z.	y at: 1 put: z * 3.0 * ((x at: 2)				- (x at: n1)).	H := 4.0.	F := 3 * ((x at: 1)					- (x at: n1 - 1)).	G := 1.	2 to: n1 - 1		do: [:k | 			z := 1.0 / (4.0							- (v at: k)).			v at: k + 1 put: z.			w at: k + 1 put: z negated					* (w at: k).			y at: k put: z * (3.0 * ((x at: k + 1)							- (x at: k - 1))						- (y at: k - 1)).			H := H - (G						* (w at: k)).			F := F - (G						* (y at: k - 1)).			G := (v at: k) negated * G].	H := H - (G + 1 * ((v at: n1)						+ (w at: n1))).	y at: n1 put: F - (G + 1				* (y at: n1 - 1)).	D at: n1 put: (y at: n1)			/ H.	D at: n1 - 1 put: (y at: n1 - 1)			- ((v at: n1)					+ (w at: n1)					* (D at: n1)).	n1 - 2 to: 1 by: -1 do: [ :k | 		D at: k put: 			(y at: k)					- ((v at: k + 1)							* (D at: k + 1)) - ((w at: k + 1)						* (D at: n1))].	^ D .! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'ul 7/25/2011 01:29'!cubicPointPolynomialAt: vIndex	"From curve information assemble a 4-array of points representing the coefficents for curve segment between to points. Beginning point is first point in array endpoint is the pointSum of the array. Meant to be sent to newcurves idea of curve coefficents." 		| result |	result := Cubic new: 4.	1 to: 4 do: [ :i | 		result at: i put: ((self at: i) at: vIndex) @ ((self at: 4 + i) at: vIndex) ].	^result! !!SequenceableCollection methodsFor: '*Balloon' stamp: 'NS 5/30/2001 20:56'!asPointArray	"Answer an PointArray whose elements are the elements of the receiver, in 	the same order."	| pointArray |	pointArray := PointArray new: self size.	1 to: self size do:[:i| pointArray at: i put: (self at: i)].	^pointArray! !!SequenceableCollectionTest methodsFor: 'tests - accessing' stamp: 'dc 3/5/2007 15:57'!testReplaceFromToWithStartingAt	| string |	string := 'abcd' copy.	string replaceFrom: 1 to: 3 with: 'lmnop' startingAt: 1.	self assert: string = 'lmnd'.		string := 'abcd' copy.	string replaceFrom: 1 to: 3 with: 'lmnop' startingAt: 2.	self assert: string = 'mnod'.		string := 'abcd' copy.	string replaceFrom: 2 to: 3 with: 'lmnop' startingAt: 1.	self assert: string = 'almd'.! !!SequenceableCollectionTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:21'!testAfterIfAbsent	| col |	col := #(2 3 4).	self assert: ((col after: 4 ifAbsent: ['block']) = 'block').	self assert: ((col after: 5 ifAbsent: ['block']) = 'block').	self assert: ((col after: 2 ifAbsent: ['block']) = 3).! !!SequenceableCollectionTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:22'!testBeforeIfAbsent	| col |	col := #(2 3 4).		self assert: ((col before: 2 ifAbsent: ['block']) = 'block').	self assert: ((col before: 5 ifAbsent: ['block']) = 'block').	self assert: ((col before: 3 ifAbsent: ['block']) = 2).! !!SequenceableCollectionTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:22'!testBeginsWith	"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants."	| la prefix oc |	la := #(1 2 3 4 5 6).	oc := OrderedCollection new.	oc add: 1; add: 2; add: 3.	self assert: (la beginsWith: #(1)).	self assert: (la beginsWith: #(1 2)).	self assert: (la beginsWith: #(1 2 3)).	self assert: (la beginsWith: oc).	self deny: (la beginsWith: #()).	self deny: (la beginsWith: '').	self deny: (la beginsWith: OrderedCollection new).		self assert: (oc beginsWith: #(1 2)).		prefix := OrderedCollection new.	self deny: (oc beginsWith: prefix).	prefix add: 1.	self assert: (oc beginsWith: prefix).	prefix add: 2.	self assert: (oc beginsWith: prefix).	prefix add: 3.	self assert: (oc beginsWith: prefix).	prefix add: 4.	self deny: (oc beginsWith: prefix).! !!SequenceableCollectionTest methodsFor: 'tests - testing' stamp: 'ar 2/1/2010 19:14'!testBeginsWithAnyOf	"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants."	| la oc |	la := #(1 2 3 4 5 6).	oc := OrderedCollection new.	oc add: 1; add: 2; add: 3.	self assert: (la beginsWithAnyOf: #((17) (1) (42))).	self assert: (la beginsWithAnyOf: #((17) (1 2) (42))).	self assert: (la beginsWithAnyOf: #((17) (1 2 3) (42))).	self deny: (la beginsWithAnyOf: #()).	self deny: (la beginsWithAnyOf: #(())).	self deny: (la beginsWithAnyOf: #((42))).! !!SequenceableCollectionTest methodsFor: 'tests - testing' stamp: 'sd 6/5/2005 09:22'!testEndsWith	"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants."	| la oc suffix |	la := #(1 2 3 4 5 6).	oc := OrderedCollection new.	oc add: 4; add: 5; add: 6.		self assert: (la endsWith: #(6)).	self assert: (la endsWith: #(5 6)).	self assert: (la endsWith: #(4 5 6)).	self assert: (la endsWith: oc).	self deny: (la endsWith: #()).	self deny: (la endsWith: '').		suffix := OrderedCollection new.	suffix add: 6.	self assert: (oc endsWith: suffix).	suffix addFirst: 5.	self assert: (oc endsWith: suffix).	suffix addFirst: 4.	self assert: (oc endsWith: suffix).	suffix addFirst: 3.	self deny: (oc endsWith: suffix).! !!SequenceableCollectionTest methodsFor: 'tests - testing' stamp: 'ar 2/1/2010 19:13'!testEndsWithAnyOf	"We can't test SequenceableCollection directly. However, we can test a sampling of its descendants."	| la oc |	la := #(6 5 4 3 2 1).	oc := OrderedCollection new.	oc add: 3; add: 2; add: 1.	self assert: (la endsWithAnyOf: #((17) (1) (42))).	self assert: (la endsWithAnyOf: #((17) (2 1) (42))).	self assert: (la endsWithAnyOf: #((17) (3 2 1) (42))).	self deny: (la endsWithAnyOf: #()).	self deny: (la endsWithAnyOf: #(())).	self deny: (la endsWithAnyOf: #((42))).! !!SequentialSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:12'!postCopy	"Copy my component sounds."	super postCopy.	self copySounds! !!SequentialSound methodsFor: 'copying' stamp: 'ul 8/2/2011 20:10'!transformSounds: tfmBlock	"Private!! Support for copying. Copy my component sounds."	sounds := sounds collect: tfmBlock! !!SerialPort methodsFor: 'open/close' stamp: 'ml 3/8/2011 19:40'!openPort: portId 	"Open the given serial port, using the settings specified by my	instance variables."	| p |	self close.	p := portId isString		ifTrue: [self				primOpenPortByName: portId				baudRate: baudRate				stopBitsType: stopBitsType				parityType: parityType				dataBits: dataBits				inFlowControlType: inputFlowControlType				outFlowControlType: outputFlowControlType				xOnByte: xOnByte				xOffByte: xOffByte]		ifFalse: [self				primOpenPort: portId				baudRate: baudRate				stopBitsType: stopBitsType				parityType: parityType				dataBits: dataBits				inFlowControlType: inputFlowControlType				outFlowControlType: outputFlowControlType				xOnByte: xOnByte				xOffByte: xOffByte].	^p ifNotNil: [		port := portId.		self]! !!ServerDirectory methodsFor: 'copying' stamp: 'nice 10/1/2010 23:22'!postCopy	super postCopy.	self urlObject: urlObject copy! !!ServerDirectory class methodsFor: 'available servers' stamp: 'ul 8/2/2011 20:10'!removeServerNamed: nameString ifAbsent: aBlock	self servers removeKey: nameString ifAbsent: aBlock! !!ServerDirectory class methodsFor: 'available servers' stamp: 'ul 8/2/2011 20:10'!serverNamed: nameString ifAbsent: aBlock	^self servers at: nameString asString ifAbsent: aBlock! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'nice 6/11/2010 21:58'!parseEToyUserListFrom: urlString	| url userString userList |	urlString ifNil:[^nil].	url := urlString asUrl.	userString := ["Note: We need to prevent going through the plugin API 	when retrieving a local (file) URL, since the plugin API	(correctly) rejects file:// downloads."		Cursor wait showWhile:[			(url hasRemoteContents) ifTrue:[				"Go through the browser (if present)"				(HTTPClient httpGet: url asString) contents.			] ifFalse:[				"Go grab it directly"				url retrieveContents contents.			].		].	] on: Error do:[nil].	userString ifNil:[^nil].	userList := userString lines collect: [:each| each withBlanksTrimmed].	userList := userList reject:[:any| any isEmpty].	(userList first = '##user list##') ifFalse:[^nil].	userList := userList copyFrom: 2 to: userList size.	^userList! !!ServiceAction methodsFor: 'printing' stamp: 'cmm 3/15/2011 15:00'!printOn: aStream 	super printOn: aStream.	aStream		 space ;		 nextPutAll: id asString! !!ServiceGui class methodsFor: 'hooks' stamp: 'cmm 3/13/2011 17:21'!browser: aBrowser messageListMenu: aMenu 	^ (self new		for: aBrowser		id: #browserMethodMenu) inlineInMenu: aMenu! !!ServiceShortcuts class methodsFor: 'as yet unclassified' stamp: 'cmm 3/12/2011 18:10'!setPreferences	| mm |	mm := self map copy.	(0 to: 9)		do: [:i | #('ctrl-' 'cmd-' 'ctrl-cmd-' )				do: [:str | 					| short | 					short := (str , i asString) asSymbol.					self insertPrefShortcut: short]].	#(#up #down #left #right )		do: [:s | 			self insertPrefShortcut: ('ctrl-cmd-' , s) asSymbol.].	mm		keysAndValuesDo: [:k :v | ServicePreferences setPreference: k toValue: v].	((Array new: 3) at: 1 put: ((Array new: 3) at: 1 put: #inlineServicesInMenu;			 at: 2 put: true;			 at: 3 put: 'Inline services within squeak menus';			 yourself);		 at: 2 put: ((Array new: 3) at: 1 put: #useOnlyServicesInMenu;			 at: 2 put: false;			 at: 3 put: 'Use only services and not regular menu items';			 yourself);		 at: 3 put: ((Array new: 3) at: 1 put: #useServicesInBrowserButtonBar;			 at: 2 put: true;			 at: 3 put: 'Use a service-based button bar';			 yourself);		 yourself)		do: [:tr | ServicePreferences				addPreference: tr first				categories: #('-- settings --' )				default: tr second				balloonHelp: tr third]! !!Set methodsFor: 'testing' stamp: 'ul 2/12/2011 01:05'!includes: anObject 		(array at: (self scanFor: anObject)) ifNil: [ ^false ] ifNotNil: [ ^true ]! !!Set commentStamp: 'nice 8/26/2010 22:14' prior: 0!I represent a set of objects without duplicates.  I can hold anything that responds to#hash and #=, except for nil.  My instances will automatically grow, if necessary.Note that I rely on #=, not #==.  If you want a set using #==, use IdentitySet.Instance structure:  array	An array whose non-nil elements are the elements of the set,		and whose nil elements are empty slots.  There is always at least one nil.		In fact I try to keep my "load" at 75% or less so that hashing will work well.  tally	The number of elements in the set.  The array size is always greater than this.The core operation is #scanFor:, which either finds the position where anobject is stored in array, if it is present, or finds a suitable position holding nil, ifits argument is not present in array.I can include an UndefinedObject (nil) thanks to a special implementation using a wrapper (see message #asSetElement and class SetElement).Indeed, a nil entry in the storage array means vacuity, it cannot mean I contain nil.!!SetElement commentStamp: 'nice 8/26/2010 22:21' prior: 0!A SetElement is a special wrapper used to handle addition of some special elements into Set.This is necessary mainly for storing an UndefinedObject in a Set, since nil is used in Set algorithm to designate free slots in internal storage.Instance Variables	enclosedElement:		<Object>enclosedElement	- the real element we wish to put into the set!!SharedPool class methodsFor: '*ShoutCore' stamp: 'tween 9/13/2004 10:10'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!SharedQueue methodsFor: 'accessing' stamp: 'ul 12/8/2010 04:45'!flushAllSuchThat: aBlock	"Remove from the queue all objects that satisfy aBlock."		accessProtect critical: [		| newReadPos |		newReadPos := writePosition.		writePosition - 1 to: readPosition by: -1 do: [ :i |			| value |			value := contentsArray at: i.			contentsArray at: i put: nil.			((aBlock value: value) and: [ (readSynch waitIfLocked: [ nil ]) notNil ]) ifFalse: [				newReadPos := newReadPos - 1.				contentsArray at: newReadPos put: value ] ].		readPosition := newReadPos ]! !!SharedQueue methodsFor: 'accessing' stamp: 'ul 12/8/2010 04:31'!nextOrNil	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, answer <nil>."	readSynch waitIfLocked: [ ^nil ].	^accessProtect		critical: [			| value |			readPosition = writePosition					ifTrue: 						[self error: 'Error in SharedQueue synchronization'.						 value := nil]					ifFalse: 						[value := contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition := readPosition + 1].			value ]! !!SharedQueue methodsFor: 'accessing' stamp: 'ul 12/8/2010 04:44'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no object has been sent, answer <nil> and leave me intact.	NOTA BENE:  aBlock MUST NOT contain a non-local return (^)."	^accessProtect critical: [		| value readPos |		value := nil.		readPos := readPosition.		[ readPos < writePosition and: [ value isNil ] ] whileTrue: [			value := contentsArray at: readPos.			readPos := readPos + 1.			(aBlock value: value)				ifFalse: [ value := nil ]				ifTrue: [					readSynch waitIfLocked: [ ^nil ]. "We found the value, but someone else booked it."					readPosition to: readPos - 1 do: [ :j | contentsArray at: j put: nil ].					readPosition := readPos ] ].		value ]."===q := SharedQueue new.1 to: 10 do: [ :i | q nextPut: i].c := OrderedCollection new.[	v := q nextOrNilSuchThat: [ :e | e odd].	v notNil] whileTrue: [	c add: {v. q size}].{c. q} explore==="! !!SharedQueue methodsFor: 'accessing' stamp: 'ul 12/8/2010 04:37'!peek	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, return nil"	^readSynch		critical: [			accessProtect critical: [				readPosition >= writePosition ifFalse: [					contentsArray at: readPosition ] ] ]		ifLocked: [ nil ]! !!SharedQueue methodsFor: 'private' stamp: 'ul 10/19/2010 04:53'!makeRoomAtEnd	| contentsSize newContentsArray |	contentsSize := writePosition - readPosition.	newContentsArray := contentsSize * 2 > contentsArray size		ifTrue: [ contentsArray class new: contentsArray size * 2 ]		ifFalse: [			(contentsArray size > 10 and: [ contentsSize * 4 <= contentsArray size ])				ifTrue: [ contentsArray class new: (contentsSize * 2 max: 10) ]				ifFalse: [ contentsArray ] ].	newContentsArray		replaceFrom: 1		to: contentsSize		with: contentsArray		startingAt: readPosition.	contentsArray == newContentsArray 		ifFalse: [ contentsArray := newContentsArray ]		ifTrue: [ contentsArray from: contentsSize + 1 to: contentsArray size put: nil ].	readPosition := 1.	writePosition := contentsSize + 1! !!SharedQueue methodsFor: 'private' stamp: 'ar 10/4/2006 12:43'!printOn: aStream	super printOn: aStream.	"Print a guesstimate of the size of the queue without aquiring the lock properly"	aStream nextPut: $(.	aStream print: writePosition - readPosition.	aStream nextPut: $).! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ul 10/15/2010 08:24'!next	^monitor critical: [		monitor waitWhile: [ items isEmpty ].		items removeFirst ]! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ul 10/15/2010 08:23'!nextPut: item	monitor critical: [		items addLast: item.		monitor signal.  ].	^item! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ul 10/15/2010 08:23'!removeAll	monitor critical: [		items removeAll ].! !!ShiftJISTextConverter methodsFor: 'conversion' stamp: 'ul 5/22/2011 22:08'!nextPut: aCharacter toStream: aStream	| charCode leadingChar aChar |	aStream isBinary ifTrue: [^aCharacter storeBinaryOn: aStream].	aChar := aCharacter.	charCode := aCharacter charCode.	aChar isTraditionalDomestic ifFalse: [			(16rFF61 <= charCode and: [charCode <= 16rFF9F]) ifTrue: [			^aStream basicNextPut: (self sjisKatakanaFor: charCode) ].		aChar := (JISX0208 charFromUnicode: charCode) ifNil: [ 			^aCharacter "an error or nil may be better" ].		charCode := aChar charCode ].	(leadingChar := aChar leadingChar) = 0 ifTrue: [		charCode < 256 ifTrue: [			(latin1Encodings at: charCode + 1)				ifNil: [ aStream basicNextPut: aChar ]				ifNotNil: [ :encodedString | aStream basicNextPutAll: encodedString ].			^aChar ].		^aStream basicNextPut: aChar ].	leadingChar = self leadingChar ifTrue: [		| upper lower | 		upper := charCode // 94 + 33.		lower := charCode \\ 94 + 33.		upper \\ 2 = 1 ifTrue: [			upper := upper + 1 / 2 + 112.			lower := lower + 31		] ifFalse: [			upper := upper / 2 + 112.			lower := lower + 125		].		upper >= 160 ifTrue: [upper := upper + 64].		lower >= 127 ifTrue: [lower := lower + 1].		aStream 			basicNextPut: (Character value: upper);			basicNextPut: (Character value: lower) ].	^aChar! !!SimpleButtonMorph commentStamp: 'ul 7/22/2010 04:30' prior: 0!I am labeled, rectangular morph which allows the user to click me. I can be configured to send my "target" the message "actionSelector" with "arguments" when I am clicked. I may have a label, implemented as a StringMorph.Example:	SimpleButtonMorph new		target: Beeper;		label: 'Beep!!';		actionSelector: #beep; 		openInWorldStructure:instance var 	Type		Description target 			Object 		The Object to notify upon a click actionSelector 	Symbol 		The message to send to Target (#messageName) arguments 		Array 		Arguments to send with #actionSelection (optional) actWhen 		Symbol 		When to take action: may be #buttonUp (default), #buttonDown,								#whilePressed, or #startDrag oldColor 		Color 		Used to restore color after click Another example: a button which quits the image without saving it.	SimpleButtonMorph new		target: Smalltalk;		label: 'quit';		actionSelector: #snapshot:andQuit:;		arguments: (Array with: false with: true); 		openInWorld!!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'mtf 2/20/2011 20:42'!mouseDown: evt	| aMorph selectors |	aMorph := self itemFromPoint: evt position.	(aMorph notNil and:[aMorph inToggleArea: (aMorph point: evt position from: self)])		ifTrue:[^self toggleExpandedState: aMorph event: evt]. 	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	aMorph ifNil:[^super mouseDown: evt].	aMorph highlightForMouseDown.	selectors := Array 		with: #click:		with: nil		with: nil		with: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil]).	evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: HandMorph dragThreshold "pixels".! !!SimpleHierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'ul 11/15/2010 12:03'!arrowKey: aChar	"Handle a keyboard navigation character. Answer true if handled, false if not."	| keyEvent |	keyEvent := aChar asciiValue.     keyEvent = 31 ifTrue:["down"		self setSelectionIndex: self getSelectionIndex+1.		^true].     keyEvent = 30 ifTrue:["up"		self setSelectionIndex: (self getSelectionIndex-1 max: 1).		^true].     keyEvent = 1  ifTrue: ["home"		self setSelectionIndex: 1.		^true].     keyEvent = 4  ifTrue: ["end"		self setSelectionIndex: scroller submorphs size.		^true].      keyEvent = 11 ifTrue: ["page up"		self setSelectionIndex: (self getSelectionIndex - self numSelectionsInView max: 1).		^true].     keyEvent = 12  ifTrue: ["page down"		self setSelectionIndex: self getSelectionIndex + self numSelectionsInView.		^true].	keyEvent = 29 ifTrue:["right"		selectedMorph ifNotNil:[			(selectedMorph canExpand and:[selectedMorph isExpanded not])				ifTrue:[self toggleExpandedState: selectedMorph]				ifFalse:[self setSelectionIndex: self getSelectionIndex+1].		].		^true].	keyEvent = 28 ifTrue:["left"		selectedMorph ifNotNil:[			(selectedMorph isExpanded)				ifTrue:[self toggleExpandedState: selectedMorph]				ifFalse:[self setSelectionIndex: (self getSelectionIndex-1 max: 1)].		].		^true].	^false! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'ar 8/6/2009 20:24'!inputPortNumFromUser	"Prompt the user for a MIDI input port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort inputPortNumFromUser"	| portCount dir portList |	portCount := self primPortCount.	portCount = 0 ifTrue: [^ nil].	portList := OrderedCollection new.	0 to: portCount - 1 do:[:i |		dir := self primPortDirectionalityOf: i.		(dir = 1) | (dir = 3) ifTrue:[portList add: i]].	^UIManager default		chooseFrom: (portList collect:[:i| self portDescription: i])		values: portList		title: 'MIDI port for input:' translated! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'TN 5/31/2005 00:54'!portDescription: portNum	"Answer a string indicating the directionality of the given MIDI port."	"(0 to: SimpleMIDIPort primPortCount - 1) collect:		[:i | SimpleMIDIPort portDescription: i]"	| portName dir |	portName := (self primPortNameOf: portNum) convertFromSystemString.	dir := self primPortDirectionalityOf: portNum.	dir = 1 ifTrue: [^ portName, ' (in)'].	dir = 2 ifTrue: [^ portName, ' (out)'].	dir = 3 ifTrue: [^ portName, ' (in/out)'].	^ self error: 'unknown MIDI port directionality'! !!SimpleServiceEntry methodsFor: 'printing' stamp: 'jmv 3/2/2010 17:15'!printOn: aStream	aStream nextPutAll: self class name; nextPutAll: ': ('.	self provider		ifNotNil: [ aStream nextPutAll: provider printString].	aStream nextPutAll: ' --- '. 	self selector		ifNotNil: [ aStream nextPutAll: selector asString].	aStream nextPut: $)! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ul 11/15/2010 12:03'!setRotations: num	"Tell the palette what number of rotations (or background) to show.  "	| key |	key := 'ItTurns'.	"default and value for num > 1"	num = 1 ifTrue: [key := 'JustAsIs'].	num = 18 ifTrue: [key := 'ItTurns'].	num = 99 ifTrue: [key := 'ToAndFro'].	num == #Background ifTrue: [key := 'Background'].	num == #Repeated ifTrue: [key := 'Repeated'].	palette setRotations: (palette contentsAtKey: key).! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:09'!erasePixelsOfColor: aColor 	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	| newBounds |	originalForm		mapColor: aColor		to: Color transparent.	newBounds := originalForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (originalForm copy: newBounds)! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:19'!erasePixelsUsing: evt 	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: nil		hand: evt hand.	self rememberedColor "color to erase"		ifNil: [ ^ self ]		ifNotNilDo:			[ : chosenColor | self erasePixelsOfColor: chosenColor ]! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:15'!recolorPixelsOfColor: originalColor with: newColor	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| d newForm map |	d := originalForm depth.	newForm := Form extent: originalForm extent depth: d.	map := (Color cachedColormapFrom: d to: d) copy.	map at: (originalColor indexInMap: map) put: (newColor pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:18'!recolorPixelsUsing: evt 	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| originalColor newColor |	self inform: 'choose the color you want to replace' translated.	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: nil		hand: evt hand.	"color to replace"	originalColor := self rememberedColor ifNil: [ ^ self ].	self inform: 'now choose the color you want to replace it with' translated.	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: originalColor		hand: evt hand.	"new color"	newColor := self rememberedColor ifNil: [ ^ self ].	self		recolorPixelsOfColor: originalColor		with: newColor! !!SmallInteger methodsFor: 'arithmetic' stamp: 'ul 11/15/2010 10:12'!quo: aNumber 	"Primitive. Divide the receiver by the argument and answer with the 	result. Round the result down towards zero to make it a whole integer. 	Fail if the argument is 0 or is not a SmallInteger. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 13>	aNumber = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	(aNumber isMemberOf: SmallInteger)		ifFalse: [^ super quo: aNumber].	(aNumber = -1 and: [self = self class minVal])		ifTrue: ["result is aLargeInteger" ^ self negated].	self primitiveFailed! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'nice 4/12/2011 08:58'!byteReversed	"Answer the receiver with bits reversed in a byte.	The receiver must be between 0 and 255.	The constant has been obtained by this snippet:	(0 to: 255) collect: [:e |		| r |		r := ((e bitAnd: 2r11110000) bitShift: -4) + ((e bitAnd: 2r00001111) bitShift: 4).		r := ((r bitAnd: 2r11001100) bitShift: -2) + ((r bitAnd: 2r00110011) bitShift: 2).		((r bitAnd: 2r10101010) bitShift: -1) + ((r bitAnd: 2r01010101) bitShift: 1).] as: ByteArray"		^#[0 128 64 192 32 160 96 224 16 144 80 208 48 176 112 240 8 136 72 200 40 168 104 232 24 152 88 216 56 184 120 248 4 132 68 196 36 164 100 228 20 148 84 212 52 180 116 244 12 140 76 204 44 172 108 236 28 156 92 220 60 188 124 252 2 130 66 194 34 162 98 226 18 146 82 210 50 178 114 242 10 138 74 202 42 170 106 234 26 154 90 218 58 186 122 250 6 134 70 198 38 166 102 230 22 150 86 214 54 182 118 246 14 142 78 206 46 174 110 238 30 158 94 222 62 190 126 254 1 129 65 193 33 161 97 225 17 145 81 209 49 177 113 241 9 137 73 201 41 169 105 233 25 153 89 217 57 185 121 249 5 133 69 197 37 165 101 229 21 149 85 213 53 181 117 245 13 141 77 205 45 173 109 237 29 157 93 221 61 189 125 253 3 131 67 195 35 163 99 227 19 147 83 211 51 179 115 243 11 139 75 203 43 171 107 235 27 155 91 219 59 187 123 251 7 135 71 199 39 167 103 231 23 151 87 215 55 183 119 247 15 143 79 207 47 175 111 239 31 159 95 223 63 191 127 255] at: 1 + self! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'ul 7/18/2011 17:27'!lowBit	" Answer the index of the low order one bit.		2r00101000 lowBit       (Answers: 4)		2r-00101000 lowBit      (Answers: 4)	  First we skip bits in groups of 8, then do a lookup in a table.	  While not optimal, this is a good tradeoff; long	  integer #lowBit always invokes us with bytes."	| n result lastByte |	n := self.	n = 0 ifTrue: [ ^ 0 ].	result := 0.	[(lastByte := n bitAnd: 16rFF) = 0]		whileTrue: [			result := result + 8.			n := n bitShift: -8 ].	^result + (LowBitPerByteTable at: lastByte)! !!SmallInteger methodsFor: 'printing' stamp: 'ul 12/8/2010 03:59'!printOn: stream base: base 	"Append a representation of this number in base b on aStream."	self printOn: stream base: base length: 0 padded: false! !!SmallInteger methodsFor: 'printing' stamp: 'ul 11/30/2010 01:38'!printOn: stream base: base length: minimumLength padded: padWithZeroes	| n numberOfDigits totalLength divisor |	self < 0		ifTrue: [			n := self negated.			totalLength := 1 ]		ifFalse: [			n := self.			totalLength := 0 ].	numberOfDigits := n numberOfDigitsInBase: base.	totalLength := totalLength + numberOfDigits.	padWithZeroes ifFalse: [		[ totalLength < minimumLength ] whileTrue: [			stream space.			totalLength := totalLength + 1 ] ].	n = self ifFalse: [ stream nextPut: $- ].	padWithZeroes ifTrue: [		[ totalLength < minimumLength ] whileTrue: [			stream nextPut: $0.			totalLength := totalLength + 1 ] ].	divisor := (base raisedToInteger: numberOfDigits - 1).	[ divisor > 0 ] whileTrue: [		| digit |		digit := n // divisor.		stream nextPut: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: digit + 1).		n := n - (digit * divisor).		divisor := divisor // base ]! !!SmallInteger methodsFor: 'printing' stamp: 'ul 12/8/2010 04:00'!printOn: aStream base: b nDigits: n 	"Append a representation of this number in base b on aStream using nDigits.	self must be positive."	self printOn: aStream base: b length: n padded: true! !!SmallInteger methodsFor: 'private' stamp: 'nice 9/24/2011 22:52'!highBitOfByte	"The high bits table can be obtained with:	(1 to: 8) inject: #[0] into: [:highBits :rank | highBits , (highBits collect: [:e | rank])]."	^ #[0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8] at: self + 1! !!SmallInteger methodsFor: 'private' stamp: 'nice 9/24/2011 22:52'!highBitOfPositiveReceiver	| shifted bitNo |	"Answer the index of the high order bit of the receiver, or zero if the 	receiver is zero. Receiver has to be positive!!"	shifted := self.	bitNo := 0.	[shifted < 65536]		whileFalse: 			[shifted := shifted bitShift: -16.			bitNo := bitNo + 16].	shifted < 256		ifFalse: 			[shifted := shifted bitShift: -8.			bitNo := bitNo + 8].	^bitNo + shifted highBitOfByte! !!SmallInteger methodsFor: 'mathematical functions' stamp: 'jmv 10/13/2011 21:41'!sqrt	self negative ifTrue: [		^ DomainError signal: 'sqrt undefined for number less than zero.' ].	^super sqrt! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 21:37'!handleEmphasisExtra: index with: aKeyboardEvent	"Handle an extra emphasis menu item"	| action attribute thisSel |	action := {		[attribute := TextDoIt new.		thisSel := attribute analyze: self selection asString].		[attribute := TextPrintIt new.		thisSel := attribute analyze: self selection asString].		[attribute := TextLink new.		thisSel := attribute analyze: self selection asString with: 'Comment'].		[attribute := TextLink new.		thisSel := attribute analyze: self selection asString with: 'Definition'].		[attribute := TextLink new.		thisSel := attribute analyze: self selection asString with: 'Hierarchy'].		[attribute := TextLink new.		thisSel := attribute analyze: self selection asString].		[attribute := TextURL new.		thisSel := attribute analyze: self selection asString].		["Edit hidden info"		thisSel := self hiddenInfo.	"includes selection"		attribute := TextEmphasis normal].		["Copy hidden info"		self copyHiddenInfo.		^true].	"no other action"	} at: index.	action value.	thisSel ifNil: [^true].	"Could not figure out what to link to"	attribute ifNotNil: [		thisSel ifEmpty:[ | oldAttributes |			"only change emphasisHere while typing"			oldAttributes := paragraph text attributesAt: self pointIndex.			emphasisHere := Text addAttribute: attribute toArray: oldAttributes.		] ifNotEmpty: [			self replaceSelectionWith: (thisSel asText addAttribute: attribute).		]	].	^true! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'yo 6/29/2011 14:01'!buttonForIt	^ self doItButtonFromSelection ifNotNilDo: [:e | e openInHand]! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'yo 6/29/2011 14:03'!doItButtonFromSelection	| button string cm |	self lineSelectAndEmptyCheck: [^ nil].	button := SimpleButtonMorph new.	string := self selection.	(model respondsTo: #doItReceiver) 		ifTrue: [			button setProperty: #rcvr toValue: model doItReceiver.			button setProperty: #ctxt toValue: model doItContext].	cm := (button valueOfProperty: #rcvr) class compilerClass new 			compiledMethodFor: string readStream			in: (button valueOfProperty: #ctxt)			to: (button valueOfProperty: #rcvr)			notifying: nil			ifFail: [^ nil]			logged: false.	button setProperty: #cm toValue: cm.	button target: [:b |		[(b valueOfProperty: #cm) valueWithReceiver: (b valueOfProperty: #rcvr) arguments: 			((b valueOfProperty: #ctxt) ifNotNil: [{(b valueOfProperty: #ctxt) }] ifNil: [#()])]		on: OutOfScopeNotification 		do: [ :ex | ex resume: true]];		actionSelector: #value:;		arguments: {button}.	button label: string.	^ button.! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:59'!tallySelection	"Treat the current selection as an expression; evaluate it and return the time took for this evaluation"	| result rcvr ctxt valueAsString v |	self lineSelectAndEmptyCheck: [^ self].	(model respondsTo: #doItReceiver) 		ifTrue: [ rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [ | cm |		cm := rcvr class evaluatorClass new 			compiledMethodFor: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [morph flash. ^ self]			logged: false.		Time millisecondsToRun: 			[v := cm valueWithReceiver: rcvr arguments: #() ].	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	"We do not want to have large result displayed"	valueAsString := v printString.	(valueAsString size > 30) ifTrue: [valueAsString := (valueAsString copyFrom: 1 to: 30), '...'].	PopUpMenu 		inform: 'Time to compile and execute: ', result printString, 'ms res: ', valueAsString.! !!SmalltalkEditor methodsFor: 'private' stamp: 'cmm 4/4/2010 20:41'!methodArgument: anInteger 	^ (ReadStream on: self text asString) nextLine		ifNil: [ String empty ]		ifNotNilDo:			[ : line | 			line substrings				at: 2 * anInteger				ifAbsent: [ String empty ] ]! !!SmalltalkEditor methodsFor: 'private' stamp: 'nice 8/3/2011 20:47'!typeMethodArgument: aKeyboardEvent 	"Replace the current text selection with the name of the method argument represented by the keyCode."	| keyCode |	keyCode := ('1234' 		indexOf: aKeyboardEvent keyCharacter		ifAbsent: [1]).	self  addString: (self methodArgument: keyCode).	^ false! !!SmalltalkEditor methodsFor: 'parenblinking' stamp: 'Richo 10/6/2011 15:59'!blinkPrevParen: aCharacter	"Same as super, but tries to follow the Smalltalk syntax."	| openDelimiter closeDelimiter level string here inside |	string := paragraph text string.	here := pointBlock stringIndex.	openDelimiter := aCharacter.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	inside := nil. "Tricky."	(here > 1 and: [ (string at: here - 1) = $$ ]) ifTrue: [ ^self ]. "Just a character literal."	[ level > 0 and: [ here > 1 ] ] whileTrue: [		| hereChar |		hereChar := string at: (here := here - 1).		inside "Are we inside a comment or string literal?"			ifNotNil: [ "Yes."				hereChar = inside ifTrue: [					(here > 1 and: [ (string at: here - 1) ~= inside ])						ifTrue: [ inside := nil ]						ifFalse: [ here := here - 1 ] ] ]			ifNil: [				(here > 1 and: [ (string at: here - 1) = $$ ]) "Just a character literal."					ifTrue: [ here := here - 1 ]					ifFalse: [						hereChar							caseOf: {								[ closeDelimiter ] -> [									(level := level - 1) = 0 ifTrue: [										^self blinkParenAt: here ] ].								[ openDelimiter ] -> [  level := level + 1 ].								[ $" ] -> [ inside := $" ].								[ $' ] -> [ inside := $' ] }							otherwise: [] ] ] ]! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ul 6/17/2011 12:29'!appendChangesTo: sourcesName	"Condense changes to the end of the given sources file.	If the file is the same as Smalltalk sourcesName, then just append	the changes. If the file is different, then copy the sources file and	append the changes afterwards."	"Smalltalk appendChangesTo: 'test123.sources'"	"To verify correctness of the operation run the following code:	[	| sourceMap |		sourceMap := Dictionary new.		(CompiledMethod allInstances select:[:cm| cm isInstalled]) do:[:cm|			sourceMap at: cm methodReference put: 				(cm getSourceFor: cm selector in: cm methodClass)].		Smalltalk allClassesAndTraitsDo:[:aClass|			sourceMap at: aClass put: aClass comment].		Smalltalk appendChangesTo: 'verify.sources'.		(CompiledMethod allInstances select:[:cm| cm isInstalled]) do:[:cm|			self assert: (sourceMap at: cm methodReference) =				(cm getSourceFor: cm selector in: cm methodClass)].		Smalltalk allClassesAndTraitsDo:[:aClass|			self assert: (sourceMap at: aClass) = aClass comment].	]"	| fullName sourcesFile |	fullName := FileDirectory default fullNameFor: sourcesName.	(fullName endsWith: '.sources') ifFalse:[self error: 'New name must end with .sources'].	fullName = Smalltalk sourcesName ifFalse:[		"Copy sources file; change file name accordingly"		FileStream forceNewFileNamed: fullName do:[:newFile| | bufSize |			bufSize := 16r10000.			sourcesFile := (SourceFiles at: 1) readOnlyCopy.			sourcesFile position: 0.			'Copying sources...'				displayProgressFrom: 0 to: sourcesFile size during:[:bar|					[sourcesFile atEnd] whileFalse:[						bar value: sourcesFile position.						newFile nextPutAll: (sourcesFile next: bufSize)]].			newFile position = sourcesFile size ifFalse:[self error: 'File copy failed'].		].		self setMacFileInfoOn: fullName.		"Change to the new sources file and reopen"		self closeSourceFiles.		SourceFileVersionString := (FileDirectory localNameFor: fullName) 			allButLast: '.sources' size.		self openSourceFiles.	].	"We've copied the old to the new sources file; reopen the sources file read/write"	sourcesFile := SourceFiles at: 1.	sourcesFile close; open: sourcesFile fullName forWrite: true. "should be openReadWrite"	sourcesFile setToEnd; timeStamp. "remember when we did this"	"Copy method sources from changes to sources"	CompiledMethod allInstances do:[:method|		(method isInstalled and:[method fileIndex = 2]) ifTrue:[			| class selector category preamble changeList index chgRec string source |			class := method methodClass.			selector := method selector.			source := class sourceCodeAt: selector.			category := class organization categoryOfElement: selector.			preamble := class name, ' methodsFor: ', category asString printString,							' stamp: ', method timeStamp printString.			"Find the last version in the sources file; link up the prior: version"			changeList := ChangeSet scanVersionsOf: method 				class: class meta: class isMeta category: category  selector: selector.			index := changeList findLast:[:any| any fileIndex = 1].			index > 0 ifTrue:[				chgRec := changeList at: index.				preamble := preamble, ' prior: ', (SourceFiles 					sourcePointerFromFileIndex: chgRec fileIndex 					andPosition: chgRec position) printString].			"append to sources file"			sourcesFile setToEnd; cr; nextPut: $!!; nextChunkPut: preamble; cr.			string := RemoteString newString: source onFileNumber: 1 toFile: sourcesFile.			sourcesFile nextChunkPut: ' '.			method setSourcePosition: string position inFile: 1		].	] displayingProgress: 'Moving changes...'.	"Copy class comments from changes to sources"	self  allClassesAndTraitsDo: [:classOrTrait | 		classOrTrait moveClassCommentTo: sourcesFile fileIndex: 1.	].	"We've moved everything; reopen the source files"	self closeSourceFiles; openSourceFiles.	"Finally, run condenseChanges -- they *should* be empty 	but it's better to be safe than sorry"	self condenseChanges.! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ar 6/16/2010 18:26'!cleanUp: aggressive except: exclusions	"Clean up. When aggressive is true, this will destroy projects, change sets, etc.	Leave out any classes specifically listed in exclusions."	"Smalltalk cleanUp: true except: {Project. ChangeSet}"	^self cleanUp: aggressive except: exclusions confirming: aggressive! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ar 6/16/2010 18:26'!cleanUp: aggressive except: exclusions confirming: aBool	"Clean up. When aggressive is true, this will destroy projects, change sets, etc.	Leave out any classes specifically listed in exclusions."	"Smalltalk cleanUp: true except: {Project. ChangeSet}"	| classes |	aBool ifTrue:[		"Give the user a chance to bail"		(self confirm: 'Cleanup will destroy projects, change sets and more.Are you sure you want to proceed?') ifFalse:[^self].	].	"Find all classes implementing #cleanUp or cleanUp:"	classes := Smalltalk allClasses select:[:aClass| 		(aClass class includesSelector: #cleanUp) 			or:[aClass class includesSelector: #cleanUp:]	].	"Leave out the classes in the exclusion set"	classes := classes reject:[:aClass| exclusions includes: aClass].	"Arrange classes in superclass order, superclasses before subclasses.	This will ensure that specific cleanup (like MethodDictionary compaction)	will run after generic superclass cleanup (HashedCollection rehashing).	Otherwise generic superclass cleanup might undo specific one (in this	case rehashing will undo a good bit of MD compaction)."	classes := ChangeSet superclassOrder: classes.	"Run the cleanup code"	classes 		do:[:aClass| aClass cleanUp: aggressive]		displayingProgress:[:aClass| 'Cleaning up in ', aClass name].! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ul 6/17/2011 12:29'!compressSources		"Copy all the source file to a compressed file. Usually preceded by Smalltalk condenseSources."	"The new file will be created in the default directory, and the code in openSources	will try to open it if it is there, otherwise it will look for normal sources."	"Smalltalk compressSources"	| f cfName cf |	f := SourceFiles first readOnlyCopy binary.	"binary to preserve utf8 encoding"	(f localName endsWith: 'sources')		ifTrue: [cfName := (f localName allButLast: 7) , 'stc']		ifFalse: [self error: 'Hey, I thought the sources name ended with ''.sources''.'].	cf := (CompressedSourceStream on: (FileStream newFileNamed: cfName))				segmentSize: 65536 maxSize: f size.	"Copy the sources"'Compressing Sources File...'	displayProgressFrom: 0 to: f size	during:		[:bar | f position: 0.		[f atEnd] whileFalse:			[cf nextPutAll: (f next: 65536).			bar value: f position]].	cf close.	self setMacFileInfoOn: cfName.	self inform: 'You now have a compressed sources file!!Squeak will use it the next time you start.'! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ul 6/17/2011 12:29'!condenseChanges	"Move all the changes onto a compacted sources file."	"Smalltalk condenseChanges"	| f oldChanges |	f := FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.	'Condensing Changes File...'		displayProgressFrom: 0		to: self classNames size + self traitNames size		during: [:bar | | count | 			count := 0.			self				allClassesAndTraitsDo: [:classOrTrait | 					bar value: (count := count + 1).					classOrTrait moveChangesTo: f.					classOrTrait putClassCommentToCondensedChangesFile: f.					classOrTrait classSide moveChangesTo: f]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges := SourceFiles at: 2.	oldChanges close.	FileDirectory default deleteFileNamed: oldChanges name , '.old';		 rename: oldChanges name toBe: oldChanges name , '.old';		 rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles		at: 2		put: (FileStream oldFileNamed: oldChanges name)! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ul 6/17/2011 12:29'!condenseSources	"Move all the changes onto a compacted sources file."	"Smalltalk condenseSources"	| newSourcesFile defaultDirectory newVersion currentVersion |	Utilities fixUpProblemsWithAllCategory.	"The above removes any concrete, spurious '-- all --' categories, which mess up the process."	defaultDirectory := FileDirectory default.	currentVersion := SmalltalkImage current sourceFileVersionString.	newVersion := UIManager default 		request: 'Please designate the version\for the new source code file...' withCRs		initialAnswer: currentVersion.	newVersion ifEmpty: [ ^ self ].	newVersion = currentVersion ifTrue: [ ^ self error: 'The new source file must not be the same as the old.' ].	SmalltalkImage current sourceFileVersionString: newVersion.	"Write all sources with fileIndex 1"	newSourcesFile := defaultDirectory newFileNamed: (defaultDirectory localNameFor: SmalltalkImage current sourcesName).	newSourcesFile ifNil: [ ^ self error: 'Couldn''t create source code file in\' withCRs,  defaultDirectory name].	newSourcesFile		header;		timeStamp.	'Condensing Sources File...' 		displayProgressFrom: 0		to: self classNames size + self traitNames size		during: 			[ :bar | 			| count |			count := 0.			Smalltalk allClassesAndTraitsDo: 				[ :classOrTrait | 				bar value: (count := count + 1).				classOrTrait 					fileOutOn: newSourcesFile					moveSource: true					toFile: 1 ] ].	newSourcesFile		trailer;		close.			"Make a new empty changes file"	SmalltalkImage current closeSourceFiles.	defaultDirectory 		rename: SmalltalkImage current changesName		toBe: SmalltalkImage current changesName , '.old'.	(FileStream newFileNamed: SmalltalkImage current changesName)		header;		timeStamp;		close.	SmalltalkImage current lastQuitLogPosition: 0.	self setMacFileInfoOn: SmalltalkImage current changesName.	self setMacFileInfoOn: newSourcesFile name.	SmalltalkImage current openSourceFiles.	self inform: 'Source files have been rewritten to\' withCRs, newSourcesFile name, '\Check that all is well,\and then save/quit.' withCRs! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ul 6/17/2011 12:18'!forgetDoIts			self deprecated: 'This method does not have to be sent anymore!!'! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ul 3/24/2011 08:29'!removeObsoleteClassesFromCompactClassesArray	self compactClassesArray doWithIndex: [ :each :index |		(each notNil and: [			each isObsolete and: [			each instanceCount = 0 ] ]) ifTrue: [				Smalltalk compactClassesArray at: index put: nil ] ].! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'mtf 12/16/2010 11:23'!primVmFileName	"Answer the absolute file name of the the Smalltalk virtual machine"	^ self getSystemAttribute: 0! !!SmalltalkImage methodsFor: 'modules' stamp: 'ul 6/17/2011 12:43'!listBuiltinModules	"SmalltalkImage current listBuiltinModules"	"Return a list of all builtin modules (e.g., plugins). Builtin plugins are those that are 	compiled with the VM directly, as opposed to plugins residing in an external shared library. 	The list will include all builtin plugins regardless of whether they are currently loaded 	or not. Note that the list returned is not sorted!!"	| modules index name |	modules := WriteStream on: (Array new: 20).	index := 1.	[		name := self listBuiltinModule: index.		name ifNil:[^modules contents].		modules nextPut: name.		index := index + 1 ] repeat! !!SmalltalkImage methodsFor: 'modules' stamp: 'ul 6/17/2011 12:43'!listLoadedModules	"SmalltalkImage current listLoadedModules"	"Return a list of all currently loaded modules (e.g., plugins). Loaded modules are those that currently in use (e.g., active). The list returned will contain all currently active modules regardless of whether they're builtin (that is compiled with the VM) or external (e.g., residing in some external shared library). Note that the returned list is not sorted!!"	| modules index name |	modules := WriteStream on: (Array new: 20).	index := 1.	[		name := self listLoadedModule: index.		name ifNil:[^modules contents].		modules nextPut: name.		index := index + 1 ] repeat! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'dtl 9/10/2011 15:00'!okayToSave	| wasCog isCog |	[wasCog := self imageFormatVersionFromFile allMask: 1]		on: Error do: [:ignore | "probably save-as to non-existing file" ^ true ].	isCog := Smalltalk isRunningCog.	^(isCog not or: [wasCog]) or: [		self confirm: 'Images saved under Cog cannot be opened on an interpreter again!!Really save?']! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'eem 8/31/2010 10:38'!processShutDownList: quitting	"Send #shutDown to each class that needs to wrap up before a snapshot.	 Also void the endianness chace;  this can't safely be done on start-up because	 Smalltalk is too late in the start-up sequence."	EndianCache := nil.	self send: #shutDown: toClassesNamedIn: ShutDownList with: quitting! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'HenrikSperreJohansen 1/21/2011 19:44'!setPlatformPreferences	"Set some platform specific preferences on system startup"	| platform specs |	Preferences automaticPlatformSettings ifFalse:[^self].	SoundPlayer soundQuickStart: SoundPlayer defaultQuickStartForPlatform.	SoundPlayer stopSoundWhenDone: SoundPlayer defaultStopSoundForPlatform.	platform := self platformName.	specs := 	#().	platform = 'Win32' ifTrue:[		specs := #()].	platform = 'Mac OS' ifTrue:[		specs := #()].	specs do:[:tuple|		Preferences setPreference: tuple first toValue: (tuple last == true).	].! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'bf 4/18/2011 13:55'!snapshot: save andQuit: quit	(save and: [self okayToSave not]) ifTrue: [^self].	^self snapshot: save andQuit: quit embedded: false! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'nice 5/6/2011 14:34'!aboutThisSystem 	"Identify software version"	^self globals		at: #SystemReporter		ifPresent: [:sys | sys open]		ifAbsent: [self inform: self systemInformationString withCRs]! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'laza 12/14/2011 10:38'!event: anEvent	"Hook for SystemChangeNotifier"	anEvent isDoIt ifTrue: [^self logChange: anEvent item].	(anEvent itemKind = SystemChangeNotifier categoryKind) ifTrue: [		anEvent isAdded			ifTrue: [^self logChange: 'SystemOrganization addCategory: ', anEvent item storeString].		anEvent isRemoved			ifTrue: [^self logChange: 'SystemOrganization removeSystemCategory: ', anEvent item storeString].		anEvent isRenamed			ifTrue: [^self logChange: 'SystemOrganization renameCategory: ', anEvent oldName storeString, ' toBe: ', anEvent newName storeString].	].	(anEvent itemKind = SystemChangeNotifier classKind) ifTrue: [		anEvent item acceptsLoggingOfCompilation ifFalse: [^self].		anEvent isAdded ifTrue: [			self logChange: anEvent item definition.		].		anEvent isModified			ifTrue: [^self logChange: anEvent item definition].		anEvent isRemoved			ifTrue: [^self logChange: 'Smalltalk removeClassNamed: ' , anEvent item name storeString].		anEvent isRenamed			ifTrue: [^self logChange: 'Smalltalk renameClassNamed: ', anEvent oldName storeString, ' as: ', anEvent newName storeString].		anEvent isRecategorized			ifTrue: [^self logChange: 'SystemOrganization classify: ', anEvent item name storeString, ' under: ', anEvent itemCategory storeString].	].	(anEvent itemKind = SystemChangeNotifier protocolKind) ifTrue: [		anEvent isAdded			ifTrue: [^self logChange: anEvent itemClass name , ' organization addCategory: ' , anEvent itemProtocol storeString].		anEvent isRemoved			ifTrue: [^self logChange: anEvent itemClass name , ' organization removeCategory: ' , anEvent itemProtocol storeString].		anEvent isRenamed			ifTrue: [^self logChange: anEvent itemClass name , ' organization renameCategory: ' , anEvent oldName storeString, ' toBe: ', anEvent newName storeString].	].	(anEvent itemKind = SystemChangeNotifier methodKind) ifTrue: [		anEvent itemClass acceptsLoggingOfCompilation ifFalse: [^self].		anEvent isRemoved			ifTrue: [^self logChange: anEvent itemClass name , ' removeSelector: ' , anEvent itemSelector storeString].		anEvent isRecategorized			ifTrue: [				^self logChange: anEvent itemClass name , ' organization classify: ', anEvent item selector storeString, ' under: ', anEvent itemProtocol storeString.		].	].! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'bf 4/18/2011 14:02'!saveAs: newName	"Save the image  under that new name."	newName ifNil:[^ self].	self okayToSave ifFalse: [^self].	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'bf 4/18/2011 14:02'!saveAsNewVersion	"Save the image/changes using the next available version number."	"SmalltalkImage current saveAsNewVersion"		| newName changesName aName anIndex |	self okayToSave ifFalse: [^self].	aName := FileDirectory baseNameFor: (FileDirectory default localNameFor: self imageName).	anIndex := aName lastIndexOf: FileDirectory dot asCharacter ifAbsent: [nil].	(anIndex notNil and: [(aName copyFrom: anIndex + 1 to: aName size) isAllDigits])		ifTrue:			[aName := aName copyFrom: 1 to: anIndex - 1].	newName := FileDirectory default nextNameFor: aName extension: FileDirectory imageSuffix.	changesName := self fullNameForChangesNamed: newName.	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"	(FileDirectory default fileOrDirectoryExists: changesName)		ifTrue:			[^ self inform:'There is already .changes file of the desired name,', newName, 'curiously already present, even though there isno corresponding .image file.   Please remedymanually and then repeat your request.'].	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !!SmalltalkImage methodsFor: 'vm parameters' stamp: 'HenrikSperreJohansen 4/20/2011 01:24'!maxExternalSemaphores	"The size of table where external semaphores are registered. Only in Cog"	self isRunningCog ifFalse: [^nil].	^self vmParameterAt: 49! !!SmalltalkImage methodsFor: 'vm parameters' stamp: 'HenrikSperreJohansen 4/20/2011 01:27'!maxExternalSemaphores: aSize	"Changes the size of table where external semaphores are registered. 	The size can only grow, and will always be the next power of two larger than the parameter.		Setting this at any time other than start-up can potentially lose requests.	 i.e. during the realloc new storage is allocated, t	he old contents are copied and then pointers are switched. 	 Requests occurring during copying won't be seen if they occur to indices already copied. 	The intended use is to set the table to some adequate maximum at start-up"		self isRunningCog ifFalse: [^0].	"The vm-header field is a short, maximum 64k entries. Well, on most platforms anyways "	(aSize < 0 or: [aSize > 16rFFFF]) ifTrue: [^DomainError signalFrom: 0 to: 16rFFFF].	^self vmParameterAt: 49 put: aSize! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'ar 6/14/2010 22:05'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		SmalltalkImage current vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := self getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	upTime := Time millisecondClockValue.	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	^ str contents! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'nice 6/11/2010 21:28'!vmStatisticsShortString	"Convenience item for access to recent statistics only"	"StringHolderView open: (StringHolder new contents: SmalltalkImage current vmStatisticsShortString)		label: 'VM Recent Statistics'"	^ (ReadStream on: self vmStatisticsReportString) upToAll: 'Since'; nextLine; upToEnd! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ul 6/17/2011 12:29'!abandonSources	"Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	 replaced by a string of all arg and temp names, followed by its	 length. These names can then be used to inform the decompiler."	"wod 11/3/1998: zap the organization before rather than after	 condensing changes."	"eem 7/1/2009 13:59 update for the closure schematic temp names regime"	| oldMethods newMethods bTotal bCount |	(self confirm: 'This method will preserve most temp names(up to about 15k characters of temporaries)while allowing the sources file to be discarded.-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, choose Yes.If you have any doubts, you may choose Noto back out with no harm done.')			== true		ifFalse: [^ self inform: 'Okay - no harm done'].	oldMethods := OrderedCollection new: CompiledMethod instanceCount.	newMethods := OrderedCollection new: CompiledMethod instanceCount.	bTotal := 0.	bCount := 0.	self systemNavigation allBehaviorsDo: [:b | bTotal := bTotal + 1].	'Saving temp names for better decompilation...'		displayProgressFrom: 0		to: bTotal		during:			[:bar |			self systemNavigation allBehaviorsDo:				[:cl |  "for test: (Array with: Arc with: Arc class) do:"				bar value: (bCount := bCount + 1).				cl selectorsAndMethodsDo:					[:selector :m |					| oldCodeString methodNode |					m fileIndex > 0 ifTrue:						[oldCodeString := cl sourceCodeAt: selector.						methodNode := cl newCompiler											parse: oldCodeString											in: cl											notifying: nil.						oldMethods addLast: m.						newMethods addLast: (m copyWithTempsFromMethodNode: methodNode)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	self systemNavigation allBehaviorsDo: [:b | b zapOrganization].	self condenseChanges.	Preferences disable: #warnIfNoSourcesFile! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ul 6/17/2011 12:29'!abandonTempNames	"Replaces every method by a copy with no source pointer or	encoded temp names."	"Smalltalk abandonTempNames"	| continue oldMethods newMethods n |	continue := self confirm: '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning all source code, hit Yes.If you have any doubts, hit No,to back out with no harm done.'.	continue		ifFalse: [^ self inform: 'Okay - no harm done'].	self garbageCollect.	oldMethods := OrderedCollection new.	newMethods := OrderedCollection new.	n := 0.	'Removing temp names to save space...'		displayProgressFrom: 0		to: CompiledMethod instanceCount "This is just a rough guess."		during: [:bar | self systemNavigation			allBehaviorsDo: [:cl | cl methodsDo: [:m | 				bar value: (n := n + 1).				oldMethods addLast: m.				newMethods					addLast: (m copyWithTrailerBytes: CompiledMethodTrailer empty)]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	SmalltalkImage current closeSourceFiles.	self flag: #shouldUseAEnsureBlockToBeSureThatTheFileIsClosed.	"sd: 17 April 2003"	Preferences disable: #warnIfNoChangesFile.	Preferences disable: #warnIfNoSourcesFile! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ul 2/12/2011 00:35'!cleanUpUndoCommands		self deprecated: 'This method was superseded by Command class >> #cleanUp'.	globals at: #Command ifPresent: [ :command | command cleanUp ]! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ul 9/18/2011 15:27'!presumedSentMessages   | sent |"Smalltalk presumedSentMessages"	"The following should be preserved for doIts, etc"	sent := IdentitySet new.	#(compactSymbolTable rebuildAllProjects		browseAllSelect:  lastRemoval		scrollBarValue: vScrollBarValue: scrollBarMenuButtonPressed: 		withSelectionFrom:  to: removeClassNamed:		dragon: hilberts: mandala: web test3 factorial tinyBenchmarks benchFib		newDepth: restoreAfter: zapAllMethods obsoleteClasses		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher unusedClasses) do:		[:sel | sent add: sel].	"The following may be sent by perform: in dispatchOnChar..."	(Smalltalk at: #ParagraphEditor) ifNotNilDo: [:paragraphEditor |		(paragraphEditor classPool at: #CmdActions) asSet do:			[:sel | sent add: sel].		(paragraphEditor classPool at: #ShiftCmdActions) asSet do:			[:sel | sent add: sel]].	^ sent! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ul 9/18/2011 15:27'!removeAllUnSentMessages	"Smalltalk removeAllUnSentMessages"	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 	Smalltalk removeAllUnSentMessages > 0] whileTrue."	"Remove all implementations of unsent messages."	| sels n |	sels := self systemNavigation allUnSentMessages.	"The following should be preserved for doIts, etc"	"needed even after #majorShrink is pulled"	#(#compactSymbolTable #rebuildAllProjects #browseAllSelect:  #lastRemoval #scrollBarValue: vScrollBarValue: #scrollBarMenuButtonPressed: #withSelectionFrom: #to: #removeClassNamed: #dragon: #hilberts: #mandala: #web #test3 #factorial #tinyBenchmarks #benchFib #newDepth: #restoreAfter: #zapAllMethods #obsoleteClasses #removeAllUnSentMessages #abandonSources #removeUnreferencedKeys #reclaimDependents #zapOrganization #condenseChanges #browseObsoleteReferences #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: #methodsFor:stamp: #methodsFor:stamp:prior: #instanceVariableNames: #startTimerInterruptWatcher #unusedClasses )		do: [:sel | sels				remove: sel				ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(Smalltalk at: #ParagraphEditor) ifNotNilDo: [:paragraphEditor |		(paragraphEditor classPool at: #CmdActions) asSet			do: [:sel | sels					remove: sel					ifAbsent: []].		(paragraphEditor classPool at: #ShiftCmdActions) asSet			do: [:sel | sels					remove: sel					ifAbsent: []]].	sels size = 0		ifTrue: [^ 0].	n := 0.	self systemNavigation		allBehaviorsDo: [:x | n := n + 1].	'Removing ' , sels size printString , ' messages . . .'		displayProgressFrom: 0		to: n		during: [:bar | 			n := 0.			self systemNavigation				allBehaviorsDo: [:class | 					bar value: (n := n + 1).					sels						do: [:sel | class basicRemoveSelector: sel]]].	^ sels size! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ul 6/17/2011 12:17'!unloadAllKnownPackages	"Unload all packages we know how to unload and reload"	"Prepare unloading"	Smalltalk zapMVCprojects.	Flaps disableGlobalFlaps: false.	StandardScriptingSystem removeUnreferencedPlayers.	Project removeAllButCurrent.	#('Morphic-UserObjects' 'EToy-UserObjects' 'Morphic-Imported' )		do: [:each | SystemOrganization removeSystemCategory: each].	Smalltalk at: #ServiceRegistry ifPresent:[:aClass|		SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: aClass.	].	World removeAllMorphs.	"Go unloading"	#(	'ReleaseBuilder' 'ScriptLoader'		'311Deprecated' '39Deprecated'		'Universes' 'SMLoader' 'SMBase' 'Installer-Core'		'VersionNumberTests' 'VersionNumber'		'Services-Base' 'PreferenceBrowser' 'Nebraska'		'ToolBuilder-MVC' 'ST80'		'CollectionsTests' 'GraphicsTests' 'KernelTests'  'MorphicTests' 		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'TraitsTests'		'SystemChangeNotification-Tests' 'FlexibleVocabularies' 		'EToys' 'Protocols' 'XML-Parser' 'Tests' 'SUnitGUI'		'Help-Squeak' 'HelpSystem' 'SystemReporter'	) do: [:pkgName| 			(MCPackage named: pkgName) unload.			MCMcmUpdater disableUpdatesOfPackage: pkgName.			].	"Traits use custom unload"	Smalltalk at: #Trait ifPresent:[:aClass| aClass unloadTraits].	"Post-unload cleanup"	MCWorkingCopy flushObsoletePackageInfos.	SystemOrganization removeSystemCategory: 'UserObjects'.	Presenter defaultPresenterClass: nil.	World dumpPresenter.	ScheduledControllers := nil.	Preferences removePreference: #allowEtoyUserCustomEvents.	SystemOrganization removeEmptyCategories.	ChangeSet removeChangeSetsNamedSuchThat:[:cs | (cs == ChangeSet current) not].	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Behavior flushObsoleteSubclasses.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk flushClassNameCache.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	DebuggerMethodMap voidMapCache.	DataStream initialize.	AppRegistry removeObsolete.	FileServices removeObsolete.	Preferences removeObsolete.	TheWorldMenu removeObsolete.	Smalltalk garbageCollect.	Symbol compactSymbolTable.	TheWorldMainDockingBar updateInstances.	MorphicProject defaultFill: (Color gray: 0.9).	World color: (Color gray: 0.9).! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ar 9/6/2010 11:34'!unloadFonts	"Smalltalk unloadFonts"	"Unloads all fonts except the style specified initially."	| fontName fontSize textStyle |	"Three good choices here:		* Atlanta 11: Absolutely minimal font.		* Accuny 10: A few extra sizes over Atlanta.		* Bitmap DejaVu Sans 9: Nicest fonts but relatively large.	"	fontName := #'Bitmap DejaVu Sans'.	fontSize := 9.	"Nuke everything other than the desired text style"	textStyle := TextStyle named: fontName.	TextStyle defaultFamilyNames do:[:styleName| 		TextConstants at: styleName put: textStyle	].	TextStyle actualTextStyles keys do:[:styleName| 		TextConstants removeKey: styleName	].	TextConstants at: fontName put: textStyle.	"Use it everywhere"	Preferences setDefaultFonts: {		{#setSystemFontTo:.		fontName.	fontSize}.		{#setListFontTo:.			fontName.	fontSize}.		{#setFlapsFontTo:.			fontName.	fontSize}.		{#setEToysFontTo:.			fontName.	fontSize}.		{#setEToysTitleFontTo:	.	fontName.	fontSize}.		{#setPaintBoxButtonFontTo:. fontName.	fontSize}.		{#setMenuFontTo:.			fontName.	fontSize}.		{#setWindowTitleFontTo:.	fontName.	fontSize}.		{#setBalloonHelpFontTo:.	fontName.	fontSize}.		{#setCodeFontTo:.			fontName.	fontSize}.		{#setButtonFontTo:.		fontName.	fontSize}.	}.	"Clean out afterwards"	Smalltalk at: #TextEditor ifPresent:[:aClass| aClass initialize].	Smalltalk at: #SmalltalkEditor ifPresent:[:aClass| aClass initialize].	Smalltalk at: #SystemProgressMorph ifPresent:[:aClass| aClass reset].	Smalltalk at: #TTCFont ifPresent:[:aClass| aClass registry removeAll].	Smalltalk at: #Flaps ifPresent:[:aClass | aClass disableGlobalFlaps: false].	Smalltalk at: #TTFontDescription ifPresent:[:aClass| aClass clearDefault].	Smalltalk at: #TTFontDescription ifPresent:[:aClass| aClass clearDescriptions].! !!SmalltalkImage methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:13'!allClasses  	"Return all the class defined in the system"	^globals allClasses! !!SmalltalkImage methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:13'!allClassesAndTraits	"Return all the classes and traits defined in the system"	^globals allClassesAndTraits! !!SmalltalkImage methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:13'!allClassesAndTraitsDo: aBlock	"Evaluate the argument, aBlock, for each class and trait in the system."	globals allClassesAndTraitsDo: aBlock! !!SmalltalkImage methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:13'!allClassesDo: aBlock	"Evaluate the argument, aBlock, for each class in the system."	globals allClassesDo: aBlock! !!SmalltalkImage methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:14'!allTraits	"Return all traits defined in the system"	^globals allTraits! !!SmalltalkImage methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:14'!allTraitsDo: aBlock	"Evaluate the argument, aBlock, for each trait in the system."	globals allTraitsDo: aBlock! !!SmalltalkImage methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:05'!classNames	"Answer a collection of all class names in the system."	^globals classNames! !!SmalltalkImage methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:05'!traitNames	"Answer a SortedCollection of all traits (not including class-traits) names."	^globals traitNames! !!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ul 4/28/2010 11:38'!keyAtValue: value	"Answer the key that is the external name for the argument, value. If	there is none, answer nil."	self deprecated: 'Use Smalltalk globals'.	^globals keyAtValue: value! !!SmalltalkImage methodsFor: 'memory space' stamp: 'ul 6/17/2011 12:43'!useUpMemory	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemory"	| lst |	lst := nil.	[ lst := Link nextLink: lst ] repeat! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'nice 9/25/2010 15:13'!endianness	^EndianCache ifNil: [EndianCache := self calcEndianness]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:44'!flagInterpretedMethods: aBoolean	"The Cog VM can be instructed to set the flag bit of CompiledMethods that	 it executes but will only interpret.  This can be used e.g. to profile startup.	 See CompiledMethod>>#flag & CompiledMethod>>#clearFlag.  	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 2) + (aBoolean ifTrue: [2] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:43'!isRunningCog	"Returns true if we're running on a Cog VM (JIT or StackInterpreter)	 (vmParameterAt: 42 is the number of stack pages)"	^[(self vmParameterAt: 42) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:41'!isRunningCogit	"Returns true if we're running on the Cog JIT	 (vmParameterAt: 46 is the size of the machine code zone)"	^[(self vmParameterAt: 46) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:23'!processHasThreadIdInstVar: aBoolean	"The threaded VM needs to know if the 4th inst var of Process	 is threadId which it uses to control process-to-thread binding.	 This flag persists across snapshots, stored in the image header."	aBoolean ifTrue: [self assert: (Process instVarNames at: 4) ='threadId'].	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 1) + (aBoolean ifTrue: [1] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:51'!processPreemptionYields	"Answer whether the VM causes a process to yield on process preemption,	 i.e. to put a preempted process at the back of its run queue.  If the parameter	 is unavailable (non-Cog VMs) or bit 2 (4) is 0 then preemption yields."	^(([self vmParameterAt: 48]			on: Error			do: [:ex| ^true]) allMask: 4) not! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:26'!processPreemptionYields: aBoolean	"The Cog VM can be instructed not to yield on process preemption,	 i.e. not to put a preempted process at the back of its run queue.  By	 default preempting a process causes it to yield (Blue Book semantics)	 which can have unfortunate effects.	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 4) + (aBoolean ifTrue: [0] ifFalse: [4])! !!SmalltalkImage methodsFor: 'special objects' stamp: 'ul 9/28/2011 14:08'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"	newArray at: 41 put: nil. "Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Weak reference finalization"	newArray at: 56 put: (self at: #WeakFinalizationList ifAbsent: []).	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray becomeForward: newArray	! !!SmalltalkImage methodsFor: 'accessing' stamp: 'ul 4/18/2010 22:22'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	^globals at: key ifPresentAndInMemory: aBlock! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'jrd 6/10/2009 12:54'!dumpException: ex	self 		logSqueakError: ex description 		inContext: ex signalerContext .! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'mtf 4/27/2011 15:07'!dumpException: ex to: aFilename	self 		logError: ex description 		inContext: ex signalerContext		to: aFilename! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'mtf 7/1/2009 13:02'!logSqueakError: errMsg inContext: aContext 	"Log the error message and a stack trace to the usual file."	^self logError: errMsg inContext: aContext to: self squeakErrorFileName! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'mtf 12/20/2010 16:23'!squeakErrorFileName	"Answer the file name used to dump error reports"	^ Preferences debugLogTimestamp		ifTrue: ['SqueakDebug-' , Time totalSeconds printString , '.log']		ifFalse: ['SqueakDebug.log'].! !!SmalltalkImage methodsFor: 'command line' stamp: 'mtf 12/16/2010 11:22'!vmFileName	"Answer the absolute file name of the the Smalltalk virtual machine"	"Smalltalk vmFileName"	^ (FilePath pathName: (self primVmFileName) isEncoded: true) asSqueakPathName.! !!SmalltalkImage methodsFor: 'private' stamp: 'laza 10/14/2011 09:01'!getSystemAttribute: attributeID 	"Optional. Answer the string for the system attribute with the given 	integer ID. Answer nil if the given attribute is not defined on this 	platform. On platforms that support invoking programs from command 	lines (e.g., Unix), this mechanism can be used to pass command line 	arguments to programs written in Squeak.	By convention, the first command line argument that is not a VM	configuration option is considered a 'document' to be filed in. Such a	document can add methods and classes, can contain a serialized object,	can include code to be executed, or any combination of these.	Currently defined attributes include: 	-1000	1000th command line argument that specify VM options	...	-1		first command line argument that specify VM options	0		the full path name for currently executing VM			(or, on some platforms, just the path name of the VM's directory) 	1		full path name of this image (better use primImageName instead)	2		a Squeak document to open, if any 	3		first command line argument for Squeak programs	...	1000	1000th command line argument for Squeak programs	1001	this platform's operating system 'Mac OS', 'Win32', 'unix', ...	1002	operating system version	1003	this platform's processor type	1004	vm version	1005	window system name	1006	vm build id	1007	Interpreter class (Cog VM only)	1008	Cogit class (Cog VM only)	1009	Platform source version (Cog VM only?)	1201	max filename length (Mac OS only)	1202	file last error (Mac OS only)	10001	hardware details (Win32 only)	10002	operating system details (Win32 only)	10003	graphics hardware details (Win32 only)	"	<primitive: 149>	^ nil! !!SmalltalkImage methodsFor: 'license' stamp: 'cmm 1/11/2011 18:58'!license	"This method contains the text of the license agreement for Squeak."	^ 'Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2011 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Portions of Squeak are covered by the following licenseCopyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.'! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:45'!image	"Answer the object to query about the current object memory and execution environment."		^self! !!SmalltalkImage methodsFor: 'image' stamp: 'bf 4/18/2011 12:49'!imageFormatVersion	"Answer an integer identifying the type of image in memory. The image version number may	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements	of the image (e.g. block closure support required). This invokes an optional primitive	that may not be available on all virtual machines."	"Smalltalk image imageFormatVersion"	<primitive: 'primitiveImageFormatVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveImageFormatVersion' translated.	^''! !!SmalltalkImage methodsFor: 'image' stamp: 'bf 4/18/2011 13:34'!imageFormatVersionFromFile	"Answer an integer identifying the type of image on file. The image version number may	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements	of the image (e.g. block closure support required)"	"Smalltalk image imageFormatVersionFromFile"	| format |	format := self imageFormatVersionFromFileAsIs.	^format <= 16r00FFFFFF		ifTrue: [  "same endianness as VM"			format ]		ifFalse: [ "convert endianness"			((format bitAnd: 16rFF000000) >> 24)			+ ((format bitAnd: 16r00FF0000) >> 8)			+ ((format bitAnd: 16r0000FF00) << 8)			+ ((format bitAnd: 16r000000FF) << 16)]! !!SmalltalkImage methodsFor: 'image' stamp: 'bf 7/11/2011 10:54'!imageFormatVersionFromFileAsIs	"Answer an integer identifying the type of image on file. The image version number may	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements	of the image (e.g. block closure support required). If the image file has a different	endianness than the VM, the format version will appear byte-swapped."	"Smalltalk image imageFormatVersionFromFileAsIs"	^(FileStream readOnlyFileNamed: Smalltalk imageName do: [ :file | file binary; next: 4 ])		unsignedLongAt: 1 bigEndian: Smalltalk isBigEndian! !!SmalltalkImage methodsFor: 'image' stamp: 'md 5/16/2006 12:34'!version	"Answer the version of this release."	^SystemVersion current version! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 1/4/2010 21:40'!wordSize	"Answer the size in bytes of an object pointer or word in the object memory.	The value does not change for a given image, but may be modified by a SystemTracer	when converting the image to another format. The value is cached in WordSize to	avoid the performance overhead of repeatedly consulting the VM."	"Smalltalk wordSize"	^ WordSize ifNil: [WordSize := [SmalltalkImage current vmParameterAt: 40] on: Error do: [4]]! !!SmalltalkImage methodsFor: 'vm' stamp: 'laza 2/8/2011 11:41'!cogitClass	^self getSystemAttribute: 1008! !!SmalltalkImage methodsFor: 'vm' stamp: 'laza 2/8/2011 11:41'!interpreterClass	^self getSystemAttribute: 1007! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:38'!interpreterSourceVersion	"Answer a string corresponding to the version of the interpreter source.	This represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator, as distinct	from the external platform source code, typically written in C and managed	separately for each platform. An optional primitive is invoked that may not	be available on all virtual machines."	"Smalltalk vm interpreterSourceVersion"	<primitive: 'primitiveInterpreterSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveInterpreterSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'eem 9/23/2011 11:39'!platformSourceVersion	"Answer a string corresponding to the version of the external platform source	code, typically written in C and managed separately for each platform. This	invokes an optional primitive that may not be available on all virtual machines."	"Smalltalk vm platformSourceVersion"	<primitive: 'primitivePlatformSourceVersion'>	(self getSystemAttribute: 1009) ifNotNil:		[:platformSourceVersion| ^platformSourceVersion].	self notify: 'This virtual machine supports neither the optional primitive #primitivePlatformSourceVersion nor the optional system attribute 1009' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!versionLabel	"Answer a string corresponding to the version of virtual machine. This	represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator,  in	addition to the external platform source code, typically written in C and	managed separately for each platform.		This invokes an optional primitive that may not be available on all virtual	machines. See also vmVersion, which answers a string identifying the image	from which virtual machine sources were generated."	"Smalltalk vm versionLabel"	<primitive: 'primitiveVMVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveVMVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:15'!vm	"Answer the object to query about virtual machine."		^self! !!SmalltalkImage methodsFor: '*ShoutCore' stamp: 'ul 9/19/2010 22:19'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a key that begins with aString, false otherwise"		^globals hasBindingThatBeginsWith: aString! !!SmalltalkImage class methodsFor: 'class initialization' stamp: 'ul 6/17/2011 12:17'!cleanUp	"Flush caches"	Smalltalk flushClassNameCache.	Undeclared removeUnreferencedKeys.	Smalltalk removeObsoleteClassesFromCompactClassesArray! !!SmalltalkImage class methodsFor: 'class initialization' stamp: 'eem 8/31/2010 10:37'!startUp	SystemChangeNotifier uniqueInstance notify: Smalltalk ofAllSystemChangesUsing: #event:! !!SmartRefStream methodsFor: 'read write' stamp: 'ul 6/17/2011 12:32'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall := anObject.		'Please wait while objects are counted' 			displayProgressFrom: 0 to: 10			during: [:bar | info := self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file'			displayProgressFrom: 0 to: objCount*4	"estimate"			during: [:bar |				objCount := 0.				progressBar := bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		byteStream padToEndWith: $ .	"really want to truncate file, but can't"		topCall := progressBar := nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount := objCount + 1)]].		"return the argument - added by kwl"	^ anObject! !!SmartRefStream methodsFor: 'read write' stamp: 'ul 6/17/2011 12:32'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall == nil 		ifTrue:			[topCall := anObject.			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted'				displayProgressFrom: 0 to: 10				during: [:bar |					info := self instVarInfo: anObject].			self uniClasesDo: [:cls | cls error: 'Class defn not written out.  Proceed?'].			'Writing an object file'				displayProgressFrom: 0 to: objCount*4	"estimate"				during: [:bar |					objCount := 0.					progressBar := bar.					super nextPut: info.					super nextPut: anObject.	"<- the real writing"					"Class inst vars not written here!!"].			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall := progressBar := nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount := objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'ul 11/16/2010 04:41'!restoreClassInstVars	"Install the values of the class instance variables of UniClasses(i.e. scripts slotInfo).  classInstVars is ((#Player25 scripts slotInfo)...).  Thank you Mark Wai for the bug fix."	| normal trans classPlayer |	self flag: #bobconv.		classPlayer := Smalltalk at: #Player ifAbsent:[^self].	self moreObjects ifFalse: [^ self]. 	"are no UniClasses with class inst vars"	classInstVars := super next.	"Array of arrays"	normal := Object class instSize.	"might give trouble if Player class superclass changes size"	(structures at: #Player ifAbsent: [#()]) = #(0 'dependents' 'costume') ifTrue:		[trans := 1].	"now (0 costume costumes).  Do the conversion of Player class			inst vars in Update 509."	classInstVars do: [:list | | aName newCls rList newName start |		aName := (list at: 1) asSymbol.		rList := list.		newName := renamed at: aName ifAbsent: [aName].		newCls := Smalltalk at: newName				ifAbsent: [self error: 'UniClass definition missing'].		("old conversion" trans = 1 and: [newCls inheritsFrom: classPlayer]) ifTrue: [			"remove costumeDictionary from Player class inst vars"			rList := rList asOrderedCollection.			rList removeAt: 4].	"costumeDictionary's value"		start := list second = 'Update to read classPool' ifTrue: [4] ifFalse: [2].		newCls class instSize = (normal + (rList size) - start + 1) ifFalse:			[self error: 'UniClass superclass class has changed size'].			"Need to install a conversion method mechanism"		start = 4 ifTrue: [newCls instVarAt: normal - 1 "classPool" put: (list at: 3)].		start to: rList size do: [:ii |			newCls instVarAt: normal + ii - start + 1 put: (rList at: ii)]].! !!Socket methodsFor: 'accessing' stamp: 'ul 11/25/2010 21:21'!localAddress	self isWaitingForConnection ifFalse: [		self			waitForConnectionFor: Socket standardTimeout			ifTimedOut: [ ^ByteArray new: 4 ] ].	^self primSocketLocalAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'mtf 10/18/2011 18:51'!localAddressPortString	^ self localAddressString, ':', self localPort printString! !!Socket methodsFor: 'accessing' stamp: 'mtf 10/18/2011 18:50'!localAddressString	^ NetNameResolver stringFromAddress: self localAddress! !!Socket methodsFor: 'accessing' stamp: 'ul 11/25/2010 21:21'!localPort	self isWaitingForConnection ifFalse: [		self			waitForConnectionFor: Socket standardTimeout			ifTimedOut: [ ^0] ].	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'ul 4/20/2011 02:00'!primitiveOnlySupportsOneSemaphore		self deprecated: 'All sockets have 3 semaphores.'.	^false! !!Socket methodsFor: 'accessing' stamp: 'ul 4/20/2011 01:54'!readSemaphore		^readSemaphore! !!Socket methodsFor: 'accessing' stamp: 'mtf 10/18/2011 18:51'!remoteAddressPortString	^ self remoteAddressString, ':', self remotePort printString! !!Socket methodsFor: 'accessing' stamp: 'mtf 10/18/2011 18:50'!remoteAddressString	^ NetNameResolver stringFromAddress: self remoteAddress! !!Socket methodsFor: 'accessing' stamp: 'ul 4/20/2011 01:56'!writeSemaphore		^writeSemaphore! !!Socket methodsFor: 'datagrams' stamp: 'ul 4/20/2011 01:55'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	[		datagram := self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]] repeat! !!Socket methodsFor: 'datagrams' stamp: 'ul 4/20/2011 01:53'!sendData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	^self sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber! !!Socket methodsFor: 'initialize-destroy' stamp: 'ul 4/20/2011 01:56'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle := self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle		ifNotNil: [ self register ]		ifNil: [  "socket creation failed"			Smalltalk unregisterExternalObject: semaphore.			Smalltalk unregisterExternalObject: readSemaphore.			Smalltalk unregisterExternalObject: writeSemaphore.			readSemaphore := writeSemaphore := semaphore := nil ]! !!Socket methodsFor: 'initialize-destroy' stamp: 'ul 11/25/2010 21:00'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle ifNotNil: [		self isValid ifTrue: [ self primSocketDestroy: socketHandle ].		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		socketHandle := nil.		readSemaphore := writeSemaphore := semaphore := nil.		self unregister ]! !!Socket methodsFor: 'initialize-destroy' stamp: 'ul 4/20/2011 01:56'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle :=		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle 		ifNotNil: [ self register ]		ifNil: [  "socket creation failed"			Smalltalk unregisterExternalObject: semaphore.			Smalltalk unregisterExternalObject: readSemaphore.			Smalltalk unregisterExternalObject: writeSemaphore.			readSemaphore := writeSemaphore := semaphore := nil ]! !!Socket methodsFor: 'other' stamp: 'nice 1/19/2011 22:31'!getOption: aName 	"Get options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is an status number (0 ok, -1 read only option)	element two is the resulting of the requested option"	(socketHandle == nil or: [self isValid not])		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before getting an option'].	^self primSocket: socketHandle getOption: aName"| foo options |Socket initializeNetwork.foo := Socket newTCP.foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.foo waitForConnectionUntil: (Socket standardDeadline).options := {'SO_DEBUG'. 'SO_REUSEADDR'. 'SO_REUSEPORT'. 'SO_DONTROUTE'.'SO_BROADCAST'. 'SO_SNDBUF'. 'SO_RCVBUF'. 'SO_KEEPALIVE'.'SO_OOBINLINE'. 'SO_PRIORITY'. 'SO_LINGER'. 'SO_RCVLOWAT'.'SO_SNDLOWAT'. 'IP_TTL'. 'IP_HDRINCL'. 'IP_RCVOPTS'.'IP_RCVDSTADDR'. 'IP_MULTICAST_IF'. 'IP_MULTICAST_TTL'.'IP_MULTICAST_LOOP'. 'UDP_CHECKSUM'. 'TCP_MAXSEG'.'TCP_NODELAY'. 'TCP_ABORT_THRESHOLD'. 'TCP_CONN_NOTIFY_THRESHOLD'. 'TCP_CONN_ABORT_THRESHOLD'. 'TCP_NOTIFY_THRESHOLD'.'TCP_URGENT_PTR_TYPE'}.1 to: options size do: [:i | | fum |	fum :=foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr].foo := Socket newUDP.foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.foo waitForConnectionUntil: (Socket standardDeadline).1 to: options size do: [:i | | fum |	fum :=foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr]."! !!Socket methodsFor: 'other' stamp: 'nice 10/14/2010 20:37'!setOption: aName value: aValue 	| value |	"setup options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is the error number	element two is the resulting of the negotiated value.	See getOption for list of keys"	(socketHandle == nil or: [self isValid not])		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before setting an option'].	value := aValue asString.	aValue == true ifTrue: [value := '1'].	aValue == false ifTrue: [value := '0'].	^ self primSocket: socketHandle setOption: aName value: value! !!Socket methodsFor: 'primitives' stamp: 'ul 4/20/2011 01:55'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"		<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ul 4/20/2011 01:56'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'mtf 3/14/2011 20:13'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'mtf 3/14/2011 19:59'!primitiveFailed: selector	SocketPrimitiveFailed signal: selector asString, ' failed'! !!Socket methodsFor: 'receiving' stamp: 'ul 11/15/2010 12:04'!receiveDataInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.  The answer may be zero (indicating that no data was 	available before the socket closed)."	| bytesRead closed |	bytesRead := 0.	closed := false.	[closed not and: [bytesRead = 0]]		whileTrue: [			self waitForDataIfClosed: [closed := true].			bytesRead := self primSocket: socketHandle				receiveDataInto: aStringOrByteArray				startingAt: aNumber				count: aStringOrByteArray size-aNumber+1].	^bytesRead! !!Socket methodsFor: 'receiving' stamp: 'ul 11/15/2010 12:04'!receiveDataSignallingClosedInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data until something is read or the socket is closed, upon which	we signal."	| bytesRead |	bytesRead := 0.	[bytesRead = 0]		whileTrue: [			self waitForData.			bytesRead := self primSocket: socketHandle				receiveDataInto: aStringOrByteArray				startingAt: aNumber				count: aStringOrByteArray size-aNumber+1].	^bytesRead! !!Socket methodsFor: 'sending' stamp: 'mtf 3/5/2011 17:54'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count	^ self sendSomeData: aStringOrByteArray startIndex: startIndex count: count for: Socket standardTimeout! !!Socket methodsFor: 'sending' stamp: 'fbs 2/18/2011 08:58'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count for: aTimeoutInSeconds	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	| bytesSent |	(self waitForSendDoneFor: aTimeoutInSeconds)		ifTrue: [			bytesSent := self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: startIndex				count: count]		ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].	^ bytesSent! !!Socket methodsFor: 'waiting' stamp: 'dc 10/21/2008 08:19'!waitForAcceptFor: timeout	"Wait and accept an incoming connection. Return nil if it falis"	self waitForConnectionFor: timeout ifTimedOut: [^ nil].	^ self isConnected		ifTrue:[self accept]		! !!Socket methodsFor: 'waiting' stamp: 'nice 4/28/2009 21:26'!waitForConnectionFor: timeout ifTimedOut: timeoutBlock	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| startTime msecsDelta msecsEllapsed status |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	status := self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [(msecsEllapsed := Time millisecondsSince: startTime) < msecsDelta]]		whileTrue: [			semaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed.			status := self primSocketConnectionStatus: socketHandle].	status = Connected ifFalse: [^timeoutBlock value].	^ true! !!Socket methodsFor: 'waiting' stamp: 'nice 4/29/2009 21:25'!waitForDataFor: timeout ifClosed: closedBlock ifTimedOut: timedOutBlock	"Wait for the given nr of seconds for data to arrive."		| startTime msecsDelta |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	[(Time millisecondsSince: startTime) < msecsDelta] whileTrue: [		(self primSocketReceiveDataAvailable: socketHandle)			ifTrue: [^self].		self isConnected			ifFalse: [^closedBlock value].		self readSemaphore waitTimeoutMSecs: 			(msecsDelta - (Time millisecondsSince: startTime) max: 0).	].	(self primSocketReceiveDataAvailable: socketHandle)		ifFalse: [			self isConnected				ifTrue: [^timedOutBlock value]				ifFalse: [^closedBlock value]].! !!Socket methodsFor: 'waiting' stamp: 'ul 12/5/2011 01:54'!waitForDataIfClosed: closedBlock	"Wait indefinitely for data to arrive.  This method will block until	data is available or the socket is closed."	[		(self primSocketReceiveDataAvailable: socketHandle)			ifTrue: [^self].		self isConnected			ifFalse: [^closedBlock value].		"This 500 ms waiting is a workaround for a VM bug which causes sockets waiting for data forever randomly, because the semaphore doesn't get signaled. Revert to ""self readSemaphore wait"" when the bug is fixed."		self readSemaphore waitTimeoutMSecs: 500 ] repeat! !!Socket methodsFor: 'waiting' stamp: 'nice 4/28/2009 21:20'!waitForDisconnectionFor: timeout	"Wait for the given nr of seconds for the connection to be broken.	Return true if it is broken by the deadline, false if not.	The client should know the connection is really going to be closed	(e.g., because he has called 'close' to send a close request to the other end)	before calling this method."	| startTime msecsDelta status |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	status := self primSocketConnectionStatus: socketHandle.	[((status == Connected) or: [(status == ThisEndClosed)]) and:	 [(Time millisecondsSince: startTime) < msecsDelta]] whileTrue: [		self discardReceivedData.		self readSemaphore waitTimeoutMSecs: 			(msecsDelta - (Time millisecondsSince: startTime) max: 0).		status := self primSocketConnectionStatus: socketHandle].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'Pmm 11/20/2010 23:47'!waitForSendDoneFor: timeout	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| startTime msecsDelta msecsEllapsed sendDone |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	[(sendDone := self primSocketSendDone: socketHandle) not and: [ self isConnected			"Connection end and final data can happen fast, so test in this order"		and: [(msecsEllapsed := Time millisecondsSince: startTime) < msecsDelta]]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed].	^ sendDone! !!Socket commentStamp: 'gk 12/13/2005 00:43' prior: 0!A Socket represents a network connection point. Current sockets are designed to support the TCP/IP and UDP protocols. Sockets are the lowest level of networking object in Squeak and are not normally used directly. SocketStream is a higher level object wrapping a Socket in a stream like protocol.ProtocolClient and subclasses are in turn wrappers around a SocketStream to provide support for specific network protocols such as POP, NNTP, HTTP, and FTP.!!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24'!register: anObject		^self registry add: anObject! !!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24'!registry	^Registry ifNil: [ Registry := WeakRegistry new ]! !!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24'!unregister: anObject		^self registry remove: anObject ifAbsent: nil! !!Socket class methodsFor: 'utilities' stamp: 'ul 11/25/2010 21:16'!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	self deprecated: 'Using this method may result in clock rollover related bug. Don''t use it.'. 	^ Time millisecondClockValue + (secs * 1000) truncated! !!Socket class methodsFor: 'utilities' stamp: 'ul 11/25/2010 21:09'!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort := 7.  "7 = echo port, 13 = time port, 19 = character generator port"	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr ifNil: [ ^self inform: 'Could not find an address for ', hostName ].	sock := Socket new.	sock connectNonBlockingTo: serverAddr port: tcpPort.	[sock waitForConnectionFor: 10]		on: ConnectionTimedOut		do: [:ex |			(self confirm: 'Continue to wait for connection to ', hostName, '?')				ifTrue: [ex retry]				ifFalse: [					sock destroy.					^ self]].	sock sendData: 'echo!!'.	startTime := Time millisecondClockValue.	[sock waitForDataFor: 15]		on: ConnectionTimedOut		do: [:ex | (self confirm: 'Packet sent but no echo yet; keep waiting?')			ifTrue: [ex retry]].	echoTime := Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!Socket class methodsFor: 'utilities' stamp: 'ul 11/25/2010 21:34'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.org' timeOutSecs: 15"	| serverAddr sockets startTime timeoutMsecs done result unconnectedCount connectedCount waitingCount |	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr ifNil: [ 			self inform: 'Could not find an address for ' , hostName.			^ #() ].	sockets := portList		collect: [ :portNum | 			| sock |			sock := Socket new.			[ sock connectTo: serverAddr port: portNum ] 				on: ConnectionTimedOut				do: [ ].			sock ].	startTime := Time millisecondClockValue.	timeoutMsecs := (1000 * timeOutSecs) truncated.	done := false.	[ done ]		whileFalse: [ 			unconnectedCount := 0.			connectedCount := 0.			waitingCount := 0.			sockets				do: [ :s | 					s isUnconnectedOrInvalid						ifTrue: [ unconnectedCount := unconnectedCount + 1 ]						ifFalse: [ 							s isConnected								ifTrue: [ connectedCount := connectedCount + 1 ].							s isWaitingForConnection								ifTrue: [ waitingCount := waitingCount + 1 ] ] ].			waitingCount = 0				ifTrue: [ done := true ].			connectedCount = sockets size				ifTrue: [ done := true ].			(Time millisecondsSince: startTime) >= timeoutMsecs				ifTrue: [ done := true ] ].	result := (sockets select: [ :s | s isConnected ]) collect: [ :s | self nameForWellKnownTCPPort: s remotePort ].	sockets do: [ :s | s destroy ].	^ result! !!SocketStream methodsFor: 'control' stamp: 'cmm 1/28/2011 15:15'!flush	"If the other end is connected and we have something	to send, then we send it and reset the outBuffer."	(outNextToWrite > 1 and: [ socket isOtherEndClosed not ]) ifTrue:		[ [ self			sendData: outBuffer			count: outNextToWrite - 1 ]			on: ConnectionTimedOut			do: [ : ex | shouldSignal ifTrue: [ ex pass ] ].		outNextToWrite := 1 ]! !!SocketStream methodsFor: 'control' stamp: 'gk 4/14/2005 09:49'!receiveData: nBytes	"Keep reading the socket until we have nBytes	in the inBuffer or we reach the end. This method	does not return data, but can be used to make sure	data has been read into the buffer from the Socket	before actually reading it from the FastSocketStream.	Mainly used internally. We could also adjust the buffer	to the expected amount of data and avoiding several	incremental grow operations.	NOTE: This method doesn't honor timeouts if shouldSignal	is false!! And frankly, I am not sure how to handle that	case or if I care - I think we should always signal."	[self atEnd not and: [nBytes > self inBufferSize]]		whileTrue: [self receiveData]! !!SocketStream methodsFor: 'initialize-release' stamp: 'ar 7/24/2010 15:13'!destroy	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."	socket ifNotNil:[socket destroy]! !!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:50'!next: anInteger into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self beSignalingWhile:[self receiveData: anInteger]] 		on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount < anInteger 		ifTrue:[aCollection copyFrom: 1 to:  startIndex + amount-1]		ifFalse:[aCollection]! !!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:52'!readInto: aCollection startingAt: startIndex count: anInteger	"Read n objects into the given collection starting at startIndex. 	Return number of elements that have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self beSignalingWhile:[self receiveData: anInteger]]		on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount! !!SocketStream methodsFor: 'stream in' stamp: 'ul 12/5/2011 01:46'!upTo: aCharacterOrByte	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of anObject in the receiver. If anObject is not in the collection, answer the entire rest of the receiver."	^self upTo: aCharacterOrByte limit: nil! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/22/2010 13:27'!upTo: aCharacterOrByte limit: nBytes	"Return data up to, but not including given character or byte. If the character is not in the stream, or not found within nBytes answer the available contents of the stream"	| target index result searchedSoFar |	"Deal with ascii vs. binary"	self isBinary 		ifTrue:[target := aCharacterOrByte asInteger] 		ifFalse:[target := aCharacterOrByte asCharacter].	"Look in the current inBuffer first"	index := inBuffer indexOf: target startingAt: lastRead + 1 ifAbsent:[0].	(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: 1.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	"We only get recentlyRead = 0 in the case of a non-signaling socket close."	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset."		index := inBuffer indexOf: target						startingAt: (lastRead + searchedSoFar + 1)						ifAbsent:[0].		(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: 1.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:48'!upToAll: aStringOrByteArray	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upToAll: aStringOrByteArray limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/22/2010 13:32'!upToAll: aStringOrByteArray limit: nBytes	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aStringOrByteArray. If aCollection is not in the stream, or not found within nBytes answer the available contents of the stream"	| index sz result searchedSoFar target |	"Deal with ascii vs. binary"	self isBinary		ifTrue:[target := aStringOrByteArray asByteArray]		ifFalse:[target := aStringOrByteArray asString].	sz := target size.	"Look in the current inBuffer first"	index := inBuffer indexOfSubCollection: target						startingAt: lastRead - sz + 2.	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: sz.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset and 		backs up sz - 1 so that we can catch any borderline hits."		index := inBuffer indexOfSubCollection: target						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: sz.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:49'!upToEnd	"Answer all data coming in on the socket until the socket	is closed by the other end, or we get a timeout.	This means this method catches ConnectionClosed by itself."	[[self atEnd] whileFalse: [self beSignalingWhile:[self receiveData]]]		on: ConnectionClosed		do: [:ex | "swallow it"]. 	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream out' stamp: 'cmm 1/28/2011 15:15'!nextPutAllFlush: aCollection 	"Put a String or a ByteArray onto the stream.	You can use this if you have very large data - it avoids	copying into the buffer (and avoids buffer growing)	and also flushes any other pending data first."	| toPut |	toPut := binary		ifTrue: [ aCollection asByteArray ]		ifFalse: [ aCollection asString ].	self flush.	"first flush pending stuff, then directly send"	socket isOtherEndClosed ifFalse:		[ [ self			sendData: toPut			count: toPut size ]			on: ConnectionTimedOut			do: [ : ex | shouldSignal ifTrue: [ ex pass ] ] ]! !!SocketStream methodsFor: 'testing' stamp: 'ar 11/23/2010 00:04'!isDataAvailable	"Answer if more data can be read. It the inbuffer is empty, we read more data.	Note: It is important not to rely on 'socket dataAvailable' here since this will	not work for subclasses such as SecureSocketStream (which can contain	undecrypted contents that has been read from the socket)." 	self isInBufferEmpty ifFalse: [^true].	^self receiveAvailableData < inNextToWrite! !!SocketStream methodsFor: 'private' stamp: 'ar 11/22/2010 23:48'!beSignalingWhile: aBlock	"Temporarily turn a non-signaling SocketStream into a signaling one.	Required for some of operations that will catch ConnectionClosed in 	order to find out that an operation completed"	| signaling |	signaling := shouldSignal.	shouldSignal := true.	^aBlock ensure:[shouldSignal := signaling]! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07'!receiveAvailableData	"Receive available data (as much as fits in the inBuffer) but not waiting for more to arrive. Return the position in the buffer where the new data starts, regardless if anything was read, see #adjustInBuffer."		recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.	^self adjustInBuffer: recentlyRead! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:15'!receiveData	self waitForData.	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50'!receiveDataIfAvailable	"Deprecated. Use #receiveAvailableData instead"	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07'!receiveDataInto: buffer startingAt: index.	"Read data from the underlying socket. This method may be overridden by subclasses wanting to control incoming traffic for other purposes like encryption or statistics."	^socket  receiveAvailableDataInto: buffer startingAt: index.! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50'!sendData: buffer count: n	"Sends outgoing data directly on the underlying socket."	^socket sendData: buffer count: n! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:09'!signalClosed	self shouldSignal ifFalse: [^ self]. 	ConnectionClosed signal: 'Connection closed while waiting for data.'! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:10'!signalTimeout	self shouldSignal ifFalse: [^ self]. 	ConnectionTimedOut signal: 'Data receive timed out.'! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:16'!waitForData	"Wait for data. If shouldTimeout, we will time out if nothing arrives, otherwise we wait indefinitely"	self shouldTimeout		ifTrue: [socket waitForDataFor: self timeout			ifClosed: [self signalClosed]			ifTimedOut: [self signalTimeout]]		ifFalse: [socket waitForDataIfClosed: [self signalClosed]]! !!SocketStream class methodsFor: 'instance creation' stamp: 'kph 9/23/2008 00:31'!openConnectionToHost: hostIP port: portNumber	^ self openConnectionToHost: hostIP port: portNumber timeout: Socket standardTimeout! !!SocketStream class methodsFor: 'instance creation' stamp: 'kph 9/23/2008 00:30'!openConnectionToHost: hostIP port: portNumber timeout: timeout	| socket |	socket := Socket new.	socket connectTo: hostIP port: portNumber waitForConnectionFor: timeout.	^self on: socket! !!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 18:10'!setUp	| listener clientSocket serverSocket |	listener := Socket newTCP.	[listener listenOn: 0 backlogSize: 4.	clientSocket := Socket newTCP.	clientSocket connectTo: #[127 0 0 1] port: listener localPort.	clientSocket waitForConnectionFor: 1.	self assert: clientSocket isConnected.	serverSocket := listener waitForAcceptFor: 1.	self assert: serverSocket isConnected.	] ensure:[listener destroy].	clientStream := SocketStream on: clientSocket.	serverStream := SocketStream on: serverSocket.! !!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 17:59'!tearDown	clientStream ifNotNil:[clientStream destroy].	serverStream ifNotNil:[serverStream destroy].! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testNextIntoClose	"Ensure that #next:into: will function properly when the connection is closed"	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream next: 100 into: (String new: 100) startingAt: 1) 		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testNextIntoCloseNonSignaling	"Ensure that #next:into: will function properly when the connection is closed"	serverStream shouldSignal: false.	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream next: 100 into: (String new: 100) startingAt: 1)		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpTo	"Tests correct behavior of #upTo:"	clientStream nextPutAll:'A line of text', String cr, 'with more text'; flush.	self assert: (serverStream upTo: Character cr) = 'A line of text'.	[(Delay forSeconds: 1) wait.	clientStream nextPutAll: String cr; flush] fork.	self assert: (serverStream upTo: Character cr) = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToAfterCloseNonSignaling	"Tests correct behavior of #upToAll"	| resp |	clientStream nextPutAll: 'A line of text'.	clientStream close.	serverStream shouldSignal: false.	self shouldnt: [resp := serverStream upTo: Character cr] raise: ConnectionClosed.	self assert: resp = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToAfterCloseSignaling	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text'.	clientStream close.	self should: [serverStream upTo: Character cr] raise: ConnectionClosed.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:29'!testUpToAll	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text', String crlf, 'with more text'; flush.	self assert: (serverStream upToAll: String crlf) = 'A line of text'.	[(Delay forSeconds: 1) wait.	clientStream nextPutAll: String crlf; flush] fork.	self assert: (serverStream upToAll: String crlf) = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:02'!testUpToAllAfterCloseNonSignaling	"Tests correct behavior of #upToAll"	| resp |	clientStream nextPutAll: 'A line of text'.	clientStream close.	serverStream shouldSignal: false.	self shouldnt: [resp := serverStream upToAll: String crlf] raise: ConnectionClosed.	self assert: resp = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:26'!testUpToAllAfterCloseSignaling	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text'.	clientStream close.	self should: [serverStream upToAll: String crlf] raise: ConnectionClosed.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/22/2010 13:28'!testUpToAllAsciiVsBinary	"Tests correct behavior of #upToAll"	serverStream ascii.	clientStream nextPutAll:'A line of text', String crlf, 'with more text'; flush.	self assert: (serverStream upToAll: #[13 10]) = 'A line of text'.	serverStream binary.	clientStream nextPutAll: String crlf; flush.	self assert: (serverStream upToAll: String crlf) asString = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:48'!testUpToAllLimit	"Tests correct behavior of #upToAll:limit:"	clientStream nextPutAll:'A line of text'; flush.	self assert: (serverStream upToAll: String crlf limit: 5) = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:11'!testUpToAllTimeout	"Tests correct behavior of #upToAll"	clientStream nextPutAll: 'A line of text'.	serverStream timeout: 1.	self should: [serverStream upToAll: String crlf] raise: ConnectionTimedOut.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/22/2010 13:28'!testUpToAsciiVsBinary	"Tests correct behavior of #upTo:"	serverStream ascii.	clientStream nextPutAll:'A line of text', String cr, 'with more text'; flush.	self assert: (serverStream upTo: 13) = 'A line of text'.	serverStream binary.	clientStream nextPutAll: String cr; flush.	self assert: (serverStream upTo: Character cr) asString = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testUpToEndClose	"Ensure that #upToEnd will function properly when the connection is closed"	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream upToEnd) 		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testUpToEndCloseNonSignaling	"Ensure that #upToEnd will function properly when the connection is closed"	serverStream shouldSignal: false.	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream upToEnd)		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:49'!testUpToMax	"Tests correct behavior of #upToAll:max:"	clientStream nextPutAll:'A line of text'; flush.	self assert: (serverStream upTo: Character cr limit: 5) = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToTimeout	"Tests correct behavior of #upToAll"	clientStream nextPutAll: 'A line of text'.	serverStream timeout: 1.	self should: [serverStream upTo: Character cr] raise: ConnectionTimedOut.! !!SocketTest methodsFor: 'setup' stamp: 'ar 11/26/2010 10:14'!listenerAddress	^NetNameResolver localHostAddress! !!SocketTest methodsFor: 'setup' stamp: 'ar 11/26/2010 10:13'!listenerPort	^42324! !!SocketTest methodsFor: 'setup' stamp: 'ar 11/26/2010 10:24'!setUp	listenerSocket := Socket newTCP listenOn: self listenerPort backlogSize: 4 interface: self listenerAddress.! !!SocketTest methodsFor: 'setup' stamp: 'ar 11/26/2010 10:24'!tearDown	listenerSocket ifNotNil:[listenerSocket destroy].	clientSocket ifNotNil:[clientSocket destroy].	serverSocket ifNotNil:[serverSocket destroy].! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:17'!testClientConnect	"Tests a client socket connection"	clientSocket := Socket newTCP.	clientSocket connectTo: self listenerAddress port: self listenerPort.	clientSocket waitForConnectionFor: 2.	self assert: clientSocket isConnected.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 11:08'!testDataReceive	"Test data transfer and related methods"	self testDataSending.	"It can take a tad for the status change to be visible"	(Delay forMilliseconds: 200) wait.	self assert: serverSocket dataAvailable.	self assert: (serverSocket receiveData = 'Hello World').	self deny: (serverSocket dataAvailable).! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 11:06'!testDataSending	"Test data transfer and related methods"	self testServerAccept.	clientSocket sendData: 'Hello World'.	clientSocket waitForSendDoneFor: 2.	self assert: clientSocket sendDone.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testLocalAddress	"Tests the various localAddress values for sockets"	self testServerAccept.	self assert: listenerSocket localAddress = self listenerAddress.	self assert: clientSocket localAddress = self listenerAddress.	self assert: serverSocket localAddress = self listenerAddress.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testLocalPort	"Tests the various localPort values for sockets"	self testServerAccept.	self assert: listenerSocket localPort = self listenerPort.	self assert: clientSocket localPort > 0.	self assert: serverSocket localPort > 0.! !!SocketTest methodsFor: 'tests' stamp: 'ar 9/4/2011 15:45'!testReceiveTimeout	"Test data transfer and related methods"	self testServerAccept.	self assert: (serverSocket receiveDataTimeout: 1) isEmpty.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testRemoteAddress	"Tests the various remoteAddress values for sockets"	self testServerAccept.	self assert: listenerSocket remoteAddress = #[0 0 0 0].	self assert: clientSocket remoteAddress = self listenerAddress.	self assert: serverSocket remoteAddress = self listenerAddress.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testRemotePort	"Tests the various remoteAddress values for sockets"	self testServerAccept.	self assert: listenerSocket remotePort = 0.	self assert: clientSocket remotePort = self listenerPort.	self assert: serverSocket remotePort > 0.! !!SocketTest methodsFor: 'tests' stamp: 'ar 9/4/2011 15:45'!testSendTimeout	"Test data transfer and related methods"	| buffer |	self testServerAccept.	buffer := ByteArray new: 1000.	[serverSocket sendDone] whileTrue:[		serverSocket sendSomeData: buffer.	].	self should:[serverSocket sendSomeData: buffer startIndex: 1 count: buffer size for: 1]		raise: ConnectionTimedOut.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testServerAccept	"Tests a server-side accept"	self testClientConnect.	serverSocket := listenerSocket waitForAcceptFor: 2.	self assert: (serverSocket notNil).	self assert: (serverSocket isConnected).! !!SocketTest methodsFor: 'tests' stamp: 'ar 9/4/2011 15:52'!testSocketReuse	"Test for SO_REUSEADDR/SO_REUSEPORT"	| address port udp1 send1 udp2 recv2 sendProc recvProc received |	address := #[255 255 255 255]. "broadcast"	port := 31259.	[		udp1 := Socket newUDP.		udp1 setOption: 'SO_REUSEADDR' value: 1.		udp1 setOption: 'SO_REUSEPORT' value: 1.		udp1 setPort: port.		udp1 setOption: 'SO_BROADCAST' value: 1.		send1 := UUID new.		udp2 := Socket newUDP.		udp2 setOption: 'SO_REUSEADDR' value: 1.		udp2 setOption: 'SO_REUSEPORT' value: 1.		udp2 setPort: port.		udp2 setOption: 'SO_BROADCAST' value: 1.		recv2 := UUID new.		received := 0.		recvProc := [			[received < 16] whileTrue:[				received := received + (udp2 receiveDataInto: recv2 startingAt: received + 1).			]		] fork.		sendProc := [			udp1 setPeer: address port: port.			udp1 sendData: send1 count: 16.		] fork.		(Delay forMilliseconds: 200) wait.		self should: [recvProc isTerminated].		self should: [sendProc isTerminated].		self should: [send1 = recv2].	] ensure:[		udp1 destroy.		udp2 destroy.	].! !!SocketTest methodsFor: 'tests' stamp: 'ar 9/4/2011 15:50'!testUDP	"Test udp recv() and send() functionality"	serverSocket := Socket newUDP.	serverSocket setPort: 54321.	clientSocket := Socket newUDP.	clientSocket setPeer: NetNameResolver localHostAddress port: serverSocket port.	clientSocket sendData: 'Hello World'.	(Delay forMilliseconds: 200) wait.	self assert: (serverSocket dataAvailable).	self assert: (serverSocket receiveData = 'Hello World').! !!SocksSocket methodsFor: 'connection open/close' stamp: 'ul 11/25/2010 21:19'!connectTo: hostAddress port: port	self initializeNetwork.	self shouldUseSocks		ifFalse: [^super connectTo: hostAddress port: port].	super connectTo: socksIP port: socksPort.	self waitForConnectionFor: Socket standardTimeout.	dstIP := hostAddress.	dstPort := port.	vers = 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!SocksSocket methodsFor: 'connection open/close' stamp: 'ul 11/25/2010 21:19'!connectToHostNamed: hostName port: port	super connectTo: socksIP port: socksPort.	self waitForConnectionFor: Socket standardTimeout.	dstName := hostName.	dstPort := port.	vers = 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!SocksSocket methodsFor: 'socks5' stamp: 'ul 11/15/2010 12:05'!socks5MethodSelection	"The client connects to the server, and sends a version   identifier/method selection message.	The server selects from one of the methods given in METHODS, and   sends a METHOD selection message."	| requestString response |	requestString := WriteStream on: ByteArray new.	requestString		nextPut: 5;		nextPut: 1;		nextPut: 0.	self sendData: requestString contents.	response := self waitForReply: 2 for: self defaultTimeOutDuration.	(response at: 2) = 16rFF		ifTrue: [self socksError: 'No acceptable methods.']		ifFalse: [method := response at: 2]! !!SortedCollection methodsFor: 'converting' stamp: 'ul 3/15/2011 15:03'!reverseInPlace	"Change this colleciton into its reversed.	Do not make a copy like reversed do, but change self in place."		| newFirstIndex |	newFirstIndex := 1 + array size - lastIndex.	lastIndex := 1 + array size - firstIndex.	firstIndex := newFirstIndex.	array := array reversed.	sortBlock := sortBlock		ifNil: [ [ :a :b | b <= a ] ]		ifNotNil: [ [ :a :b | sortBlock value: b value: a ] ]! !!SortedCollection methodsFor: 'private' stamp: 'ul 6/8/2011 23:18'!reSort	firstIndex < lastIndex ifTrue: [ 		array quickSortFrom: firstIndex to: lastIndex by: sortBlock ]! !!SorterTokenMorph methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 12:05'!fitContents	submorphs size = 1 ifTrue: [self bounds: (submorphs first bounds insetBy: (-1 @ -1))]! !!SoundPlayer class methodsFor: 'player process' stamp: 'ul 6/17/2011 12:44'!oldStylePlayLoop	"This version of the play loop is used if the VM does not yet support sound primitives that signal a semaphore when a sound buffer becomes available."	| bytesPerSlice count |	bytesPerSlice := Stereo ifTrue: [4] ifFalse: [2].	[		[(count := self primSoundAvailableBytes // bytesPerSlice) > 100]			whileFalse: [(Delay forMilliseconds: 1) wait].		count := count min: Buffer stereoSampleCount.		PlayerSemaphore critical: [			ActiveSounds := ActiveSounds select: [:snd | snd samplesRemaining > 0].			ActiveSounds do: [:snd |				snd ~~ SoundJustStarted ifTrue: [					snd playSampleCount: count into: Buffer startingAt: 1]].			ReverbState == nil ifFalse: [				ReverbState applyReverbTo: Buffer startingAt: 1 count: count].			self primSoundPlaySamples: count from: Buffer startingAt: 1.			Buffer primFill: 0.			SoundJustStarted := nil]] repeat! !!SoundPlayer class methodsFor: 'player process' stamp: 'bf 7/11/2011 11:12'!playLoop	"The sound player process loop."	| bytesPerSlice count willStop mayStop |	mayStop := self stopSoundWhenDone.	bytesPerSlice := Stereo ifTrue: [4] ifFalse: [2].	[		[(count := self primSoundAvailableBytes // bytesPerSlice) > 100]			whileFalse: [ReadyForBuffer wait].		count := count min: Buffer stereoSampleCount.		PlayerSemaphore critical: [			ActiveSounds := ActiveSounds select: [:snd | snd samplesRemaining > 0].			ActiveSounds do: [:snd |				snd ~~ SoundJustStarted ifTrue: [					snd playSampleCount: count into: Buffer startingAt: 1]].			ReverbState == nil ifFalse: [				ReverbState applyReverbTo: Buffer startingAt: 1 count: count].			self primSoundPlaySamples: count from: Buffer startingAt: 1.			willStop := mayStop and:[						(ActiveSounds size = 0) and:[							self isAllSilence: Buffer size: count]].			LastBuffer ifNotNil:[				LastBuffer replaceFrom: 1 to: LastBuffer size with: Buffer startingAt: 1.			].			willStop				ifTrue:[self shutDown. PlayerProcess := nil]				ifFalse:[Buffer primFill: 0].			SoundJustStarted := nil].		willStop ifTrue:[^self] ] repeat! !!SoundPlayer class methodsFor: 'playing' stamp: 'HenrikSperreJohansen 1/21/2011 19:18'!canStartPlayer	"Some platforms do no support simultaneous record and play. If this is one of those platforms, return false if there is a running SoundRecorder."	^SoundRecorder canRecordWhilePlaying 		or: [	SoundRecorder anyActive not] 	! !!SoundPlayer class methodsFor: 'playing' stamp: 'HenrikSperreJohansen 1/21/2011 18:56'!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	SoundService soundEnabled ifFalse: [^ self].	doQuickStart := quickStart.	self soundQuickStart ifFalse: [doQuickStart := false].	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		^self startUpWithSound: aSound].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart := false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 19:04'!defaultQuickStartForPlatform	^ Smalltalk os platformName = 'Mac OS'.! !!SoundPlayer class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 19:43'!defaultStopSoundForPlatform	^(Smalltalk os platformName = 'Mac OS') not! !!SoundPlayer class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 19:05'!soundQuickStart		<preference: 'Quickstart Sounds'		category: 'media'		description: 'If true, attempt to start playing sounds using option "quick start"'		type: #Boolean>		^SoundsShouldStartQuick ifNil: [self defaultQuickStartForPlatform]! !!SoundPlayer class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 18:56'!soundQuickStart: aBoolean		SoundsShouldStartQuick := aBoolean! !!SoundPlayer class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 19:44'!stopSoundWhenDone		<preference: 'Stop sounds when done'		category: 'media'		description: 'If true, the sound player is shut down after playing finished'		type: #Boolean>		^SoundsStopWhenDone ifNil: [self defaultStopSoundForPlatform]! !!SoundPlayer class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 19:43'!stopSoundWhenDone: aBoolean			SoundsStopWhenDone := aBoolean! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'sw 11/24/2003 14:54'!handlerForMouseDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event"	^ ((self findA: UpdatingStringMorph) bounds containsPoint: anEvent cursorPoint)		ifTrue:			[self]		ifFalse:			[super handlerForMouseDown: anEvent]! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'yo 2/11/2005 16:12'!setLiteral: aLiteral	super  setLiteral: aLiteral.	(self findA: UpdatingStringMorph) useSymbolFormat; lock! !!SoundReadoutTile methodsFor: 'private' stamp: 'yo 2/11/2005 16:13'!updateLiteralLabel	"Update the wording emblazoned on the tile, if needed"	super updateLiteralLabel.	(self findA: UpdatingStringMorph) useSymbolFormat; lock! !!SoundRecorder methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 11:05'!initialize	"SoundRecorder new"	super initialize.	stereo := false.	samplingRate := 11025.	recordLevel := 0.5.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'sw 6/10/2003 12:34'!hasRecordedSound	"Answer whether the receiver currently has any recorded sound"	^ self recordedSound notNil! !!SoundRecorder methodsFor: 'recording controls' stamp: 'HenrikSperreJohansen 1/21/2011 19:17'!pause	"Go into pause mode. The record level continues to be updated, but no sound is recorded."	paused := true.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer.				self allocateBuffer].	soundPlaying ifNotNil: [		soundPlaying pause.		soundPlaying := nil].	"Note: there can be problems if canRecordWhilePlaying is true. Recorders which only pause will inhibit other recorders from recording. I chose to make #stopPlaying unconditional in a subclass. The same might be appropriate here at the expense of making recorders resumable"	CanRecordWhilePlaying ifFalse: [self stopRecording].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'HenrikSperreJohansen 1/21/2011 19:17'!resumeRecording	"Continue recording from the point at which it was last paused."	self flag: #bob.	"Note: If canRecordWhilePlaying is true, then recordings may never get started (at least by this method). One possibility, used in a subclass, is to make the #startPlaying unconditional. Another would be to use #startPlaying instead of #resumePlaying in appropriate cases"	CanRecordWhilePlaying ifFalse: [self startRecording].	paused := false.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'HenrikSperreJohansen 1/21/2011 19:17'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel := 0.5].  "lazy initialization"	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused := true.	meteringBuffer := SoundBuffer newMonoSampleCount: 1024.	meterLevel := 0.	self allocateBuffer.	bufferAvailableSema := Semaphore new.	semaIndex := Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: samplingRate asInteger		stereo: stereo		semaIndex: semaIndex.	RecorderActive := true.	samplingRate := self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess := [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'sw 3/3/2004 19:49'!verifyExistenceOfRecordedSound	"If the receiver has a recorded sound, answer true; if not, put up an informer and answer false"	^ self recordedSound		ifNotNil:			[true]		ifNil:			[self inform: 'please record a sound first' translated.			false]! !!SoundRecorder methodsFor: 'private' stamp: 'ul 6/17/2011 12:47'!recordLoop	"Record process loop that records samples."	| n sampleCount linuxWorkaroundBlock |	n := 0.	linuxWorkaroundBlock := Smalltalk os platformName = 'unix'		ifTrue: [ [ (Delay forMilliseconds: 20) wait ] ]		ifFalse: [ nil ].	[		n = 0 ifTrue: [bufferAvailableSema wait].		paused			ifTrue: [				n := self primRecordSamplesInto: meteringBuffer startingAt: 1.				self meterFrom: 1 count: n in: meteringBuffer]			ifFalse: [				n := self primRecordSamplesInto: currentBuffer startingAt: nextIndex.				self meterFrom: nextIndex count: n in: currentBuffer.				nextIndex := nextIndex + n.				stereo					ifTrue: [sampleCount := currentBuffer stereoSampleCount]					ifFalse: [sampleCount := currentBuffer monoSampleCount].				nextIndex > sampleCount					ifTrue: [						self emitBuffer: currentBuffer.						self allocateBuffer]].		"workaround for OSS emulation on top on ALSA (on Linux environments)"		linuxWorkaroundBlock ifNotNil: [ linuxWorkaroundBlock value ] ] repeat! !!SoundRecorder class methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 1/21/2011 19:25'!canRecordWhilePlaying	"Return true if this platform supports simultaneous sound recording and playback."	<preference: 'Record while playing'		category: 'media'		description: 'If true, recording and playing sounds concurrently is permitted (platform dependent)'		type: #Boolean>	^CanRecordWhilePlaying ifNil: [false].	! !!SoundRecorder class methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 1/21/2011 19:15'!canRecordWhilePlaying: aBoolean	CanRecordWhilePlaying := aBoolean! !!SoundRecorder class methodsFor: 'class initialization' stamp: 'HenrikSperreJohansen 1/21/2011 19:13'!initialize	"SoundRecorder initialize"	"Details: Some computers cannot record and playback sound at the same time. If CanRecordWhilePlaying is false, then the SoundRecorder alternates between recording and playing. If it is true, sounds can be playing during recording."	CanRecordWhilePlaying := false.! !!SoundService commentStamp: 'gk 2/24/2004 23:14' prior: 0!This is the AppRegistry class for the sound system.A sound system offers a small protocol for playing sounds and making beeps and works like a facade towards the rest of Squeak. A sound system is registered in this registry and can be accessed by "SoundService default". This way we decouple the sound system from the rest of Squeak and make it pluggable. It also is a perfect spot to check for the Preference class>>soundsEnabled.!!SoundService class methodsFor: 'preferences' stamp: 'bf 7/11/2011 11:10'!soundEnabled	<preference: 'Enable sound'		category: 'media'		description: 'If false, all sound playing is disabled'		type: #Boolean>	^SoundEnabled ifNil: [true]! !!SoundService class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 18:33'!soundEnabled: aBoolean	SoundEnabled := aBoolean! !!SoundService class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 18:40'!soundEnablingString	^ self soundEnabled		ifFalse:			['turn sound on' translated]		ifTrue:			['turn sound off' translated]! !!SoundService class methodsFor: 'preferences' stamp: 'HenrikSperreJohansen 1/21/2011 18:36'!toggleSoundEnabled	self soundEnabled: self soundEnabled not! !!SoundTile methodsFor: 'mouse handling' stamp: 'sw 11/24/2003 14:44'!handlerForMouseDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event"	^ ((self findA: UpdatingStringMorph) bounds containsPoint: anEvent cursorPoint)		ifTrue:			[self]		ifFalse:			[super handlerForMouseDown: anEvent]! !!SourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'ul 3/16/2011 23:44'!fileIndexAndPositionFromSourcePointer: sourcePointer do: aBlock	^aBlock		value: (self fileIndexFromSourcePointer: sourcePointer)		value: (self filePositionFromSourcePointer: sourcePointer)! !!SpaceTally methodsFor: 'fileOut' stamp: 'ul 6/17/2011 12:30'!printSpaceAnalysis: threshold on: fileName	"SpaceTally new printSpaceAnalysis: 1000 on: 'STspace.text1'"	"sd-This method should be rewrote to be more coherent within the rest of the class 	ie using preAllocate and spaceForInstanceOf:"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f totalCodeSpace totalInstCount totalInstSpace n totalPercent |	Smalltalk garbageCollect.	totalCodeSpace := totalInstCount := totalInstSpace := n := 0.	results := OrderedCollection new: Smalltalk classNames size.'Taking statistics...'	displayProgressFrom: 0	to: Smalltalk classNames size	during: [:bar |	Smalltalk allClassesDo:		[:cl | | instSpace eltSize instCount codeSpace | codeSpace := cl spaceUsed.		bar value: (n := n+1).		Smalltalk garbageCollectMost.		instCount := cl instanceCount.		instSpace := (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize := cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace := instSpace + (x basicSize*eltSize)]]			ifFalse: [instSpace := instSpace + (cl instSize*instCount*4)].		results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).		totalCodeSpace := totalCodeSpace + codeSpace.		totalInstCount := totalInstCount + instCount.		totalInstSpace := totalInstSpace + instSpace]].	totalPercent := 0.0.	f := FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		results := (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])				asSortedCollection: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].	results do:		[:s | | percent | f nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).		percent := s spaceForInstances*100.0/totalInstSpace roundTo: 0.1.		totalPercent := totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ );		nextPutAll: ((totalPercent roundTo: 0.1) printString padded: #left to: 8 with: $ ).	f close! !!SpaceTally methodsFor: 'fileOut' stamp: 'nice 6/11/2010 21:28'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f := FileStream readOnlyFileNamed: fileName1.	coll1 := OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: f nextLine].	f close.	f := FileStream readOnlyFileNamed: fileName2.	coll2 := OrderedCollection new.	[f atEnd] whileFalse:		[item := f nextLine.		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SpaceTallyItem methodsFor: 'printing' stamp: 'jmv 3/2/2010 16:34'!printOn: aStream	analyzedClassName		ifNotNil: [ aStream nextPutAll: analyzedClassName asString]. 	aStream nextPutAll: ' ('.	codeSize		ifNotNil: [ aStream nextPutAll: 'code size: ' ;  nextPutAll: codeSize asString]. 	instanceCount		ifNotNil: [ aStream nextPutAll: ' instance count: ' ;  nextPutAll: instanceCount asString]. 	spaceForInstances		ifNotNil: [ aStream nextPutAll: ' space for instances: ' ;  nextPutAll: spaceForInstances asString]. 	aStream nextPut: $).	! !!SparseLargeArray methodsFor: 'private' stamp: 'eem 11/5/2008 10:36'!analyzeSpaceSaving	| elems tablesTotal nonNilTables lastPage lastChunkSize |	elems := 0.	tablesTotal := self basicSize.	nonNilTables := 0.	lastPage := self basicAt: self basicSize.	(lastChunkSize := size \\ chunkSize) = 0 ifTrue:		[lastChunkSize := chunkSize].	1 to: self basicSize do:		[:i | | page |		(page := self basicAt: i) ifNotNil:			[nonNilTables := nonNilTables + 1.			 1 to: (page == lastPage ifTrue: [lastChunkSize] ifFalse: [chunkSize]) do:				[:j|				(page at: j) ~= defaultValue ifTrue:					[elems := elems + 1]]]].	^String streamContents:		[:strm |		strm nextPutAll: 'total: '; print: size.		strm nextPutAll: ' elements: '; print: elems.		strm nextPutAll: ' tables: '; print: tablesTotal.		strm nextPutAll: ' non-nil: '; print: nonNilTables]! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/1/2008 14:00'!atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	1 to: self basicSize do:		[:i|		self basicAt: i put: nil].	defaultValue := anObject! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/1/2008 12:53'!noCheckAt: index	^(self basicAt: index - base // chunkSize + 1)		ifNil: [defaultValue]		ifNotNil: [:chunk| chunk at: index - base \\ chunkSize + 1]! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/2/2008 11:57'!noCheckAt: index put: value	| chunkIndex chunk lastChunkSize |	chunkIndex := index - base // chunkSize + 1.	(chunk := self basicAt: chunkIndex) ifNil:		[value = defaultValue ifTrue:			[^value].		chunk := arrayClass					new: ((chunkIndex == self basicSize						   and: [(lastChunkSize := size \\ chunkSize) > 0])							ifTrue: [lastChunkSize]							ifFalse: [chunkSize])					withAll: defaultValue.		self basicAt: chunkIndex put: chunk].	^chunk at: index - base \\ chunkSize + 1 put: value! !!SparseLargeArray methodsFor: 'initialization' stamp: 'eem 11/1/2008 12:16'!initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d	chunkSize := aChunkSize.	size := aSize.	base := b.	defaultValue := d.	arrayClass := aClass! !!SparseLargeArray commentStamp: '<historical>' prior: 0!A version of SparseLargeTable that does not populate its bins until a value other than the default is stored.!!SparseXTable methodsFor: 'accessing' stamp: 'nice 7/10/2010 23:49'!tableFor: code	| div |	div := code // 65536.	^xTables at: div ifAbsentPut:		[Array new: 65536 withAll: 0].! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/24/2010 02:51'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [					sourceStream skip: -1.					^ self expected: 'an integer greater than 1 as valid radix'].			self peekSignIsMinus				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !!SqNumberParserTest methodsFor: 'tests - Float' stamp: 'StephaneDucasse 3/25/2011 18:47'!testFloatGradualUnderflow	"Gradual underflow are tricky.	This is a non regression test for http://bugs.squeak.org/view.php?id=6976"	| float trueFraction str |		"as a preamble, use a base 16 representation to avoid round off error and check that number parsing is correct"	trueFraction := 16r2D2593D58B4FC4 / (16 raisedTo: 256+13).	"Parse the number in base 16 if possible - it is impossible if lowercase letter are allowed digits due to exponent letter ambiguity."	float := self areLowercaseDigitsAllowed		ifFalse: [SqNumberParser parse: '16r2.D2593D58B4FC4e-256']		ifTrue: [trueFraction asFloat]..	self assert: float asTrueFraction = trueFraction.	self assert: float = trueFraction asFloat.	"now print in base 10"	str := (String new: 32) writeStream.	float absPrintExactlyOn: str base: 10.		"verify if SqNumberParser can read it back"	self assert: (SqNumberParser parse: str contents) = float. ! !!SqNumberParserTest methodsFor: 'tests - Integer' stamp: 'ul 11/16/2010 04:56'!testIntegerReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := SqNumberParser parse: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := SqNumberParser parse: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: '.s could be confused with a ScaledDecimal' = s! !!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:11'!bookName 	^'Squeak'! !!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:30'!icon	(self name = #SqueakHelp) ifTrue: [^HelpIcons iconNamed: #squeakIcon].	^nil! !!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 10/1/2010 00:53'!pages	^#(SqueakProjectHelp SqueakToolsHelp SqueakTutorials)! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:16'!bookName 	^'License'! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'mha 5/2/2010 17:26'!pages	^#(licenseChange officialLicense)! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'hjh 4/29/2010 16:48'!licenseChange	^HelpTopic 		title: 'License has changed with 4.0'		contents: 'On 23 September 1996, Apple Computer Inc. released Squeak V1.1 under the "Squeak License" (SqL).On May 8, 2006 Apple agreed to relicense original Squeak V1.1 under the Apple Public Source License.On October 12, 2006 Apple granted permission to relicense under Apache license 2.0.In 2006, VPRI began to collect "Distribution Agreements" for all contributors to Squeak since V1.1 up to V3.8, asking them to relicense their contributions, which were originally licensed under SqL, to the MIT license. This was a great effort on behalf of many and VPRI has 100s of signed documents agreeing to this.Do you want to contribute source to Squeak?All new contributions since 4.0 must be under the MIT license. When you make your code available, please state explicitly in some form such as the description on a web site or email announcement that your contribution is under the MIT license. (It doesn''t have to be exclusive; you can release it under difference licenses at the same time.)Have you contributed source to Squeak? If you believe you have, but have not sent in an agreement to allow your submission(s) to be licensed under the MIT license then please see http://netjam.org/squeak/contributors. There you can find a list of known contributors and a PDF of the agreement with instructions. The snail mail address is found in the agreement PDF file.Also there are a few people for which we are lacking full contact information. If you think you can help please also visit the link above and see if you can identify any of the unknown developer initials or any of the developers for whom we do not have a current email address.' ! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'cmm 1/11/2011 19:22'!officialLicense	^HelpTopic 		title: 'Official License - 4.0'		contents: 'Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2011 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Portions of Squeak are covered by the following licenseCopyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.'! !!SqueakPage methodsFor: 'saving' stamp: 'ul 9/28/2011 14:08'!purge	"Replace my morph with a tombstone, if I am not in a world that is being shown."	(self prePurge) ifNotNil: [		contentsMorph becomeForward: (MorphObjectOut new xxxSetUrl: url page: self)].		"Simple, isn't it!!"! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'ul 6/17/2011 12:47'!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[		Smalltalk garbageCollect.		unreferenced := PageCache keys asSet.		URLMorph allSubInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		MorphObjectOut allInstancesDo: [:ticklish |			unreferenced remove: ticklish url ifAbsent: []].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]] repeat! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 10/1/2010 00:59'!bookName 	^'The Project'! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:15'!pages	^#(introduction )! !!SqueakProjectHelp class methodsFor: 'pages' stamp: 'tbn 3/5/2010 22:01'!introduction	^HelpTopic		title: 'Welcome'		icon: (HelpIcons iconNamed: #squeakIcon)		contents:'WELCOMESqueak is a modern, open source, full-featured implementation of the powerful Smalltalk programming language and environment. Squeak is highly-portable - even its virtual machine is written entirely in Smalltalk making it easy to debug, analyze, and change. Squeak is the vehicle for a wide range of projects from multimedia applications, educational platforms to commercial web application development.'! !!SqueakToolsHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:08'!basicDevelopmentTools	^HelpTopic 		title: 'Basic Development Tools'		contents: 'Smalltalk environments have some of the best user interfaces for programmers ever devised. Those who have programmed in Lisp under Emacs have some idea, but Smalltalk is even better.		You should learn these basic tools thoroughly:- Workspace- Transcript- Browser- Inspector- File List- Change Sorter- Debugger- Method Finder		'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 22:59'!bookName 	^'Tools'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:08'!pages	^#(basicDevelopmentTools)! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:14'!bookName	^'Transcript'! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:16'!pages	^# (transcript)! !!SqueakToolsTranscriptHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:16'!transcript	^HelpTopic 		title: 'The Transcript window'		contents: 'The Transcript window is often used for logging or printing results from text only code. To open the Transcript use TheWorldMenu and choose ''open...''. Then choose ''Transcript''.You can also type   Transcript openin a Workspace and doIt.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:06'!bookName 	^'Workspace'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:11'!pages	^#(workspace openWorkspace saveWorkspace)! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'sd 5/12/2010 23:01'!openWorkspace	^HelpTopic 		title: 'Open a Workspace'		contents: 'You can open a Workspace window in any of the following ways:		- Keyboard Shortcut: while pointing at an empty part of the Squeak window, press alt-k (in Windows) or cmd-k (on a Mac)- World Menu: select "Workspace"- Tools Flap: click on the Tools Flap. When it comes out, drag the Workspace icon out.- Doit: select inside the following quote and doit: "Workspace open"'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:13'!saveWorkspace	^HelpTopic 		title: 'Saving Workspace to a File'		contents: 'You can save the text content of a Workspace to a file by choosing the workspace menu (from within the workspace), then ''more...'', then ''save contents to file...''.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'sd 5/12/2010 22:48'!workspace	^HelpTopic 		title: 'What is a Workspace'		contents: 'A Workspace is a window used as a scratchpad area where fragments of Smalltalk code can be entered, stored, edited, and evaluated.'! !!SqueakTutorials class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:33'!bookName 	^'Tutorials'! !!SqueakTutorials class methodsFor: 'accessing' stamp: 'tbn 10/1/2010 00:55'!pages	^#(introduction)! !!SqueakTutorials class methodsFor: 'pages' stamp: 'tbn 10/1/2010 00:56'!introduction	"This method was automatically generated. Edit it using:"	"SqueakTutorials edit: #introduction"	^HelpTopic		title: 'Introduction'		contents: 'Here you will some short tutorials on how to use Squeak for daily tasks. Feel free to add your own.!!' readStream nextChunkText! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:34'!bookName 	^'XML'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:35'!pages	^# (dataRetrieval)! !!SqueakTutorialsOnXML class methodsFor: 'pages' stamp: 'it 5/4/2010 20:12'!dataRetrieval	^HelpTopic 		title: 'Retrieving XML data'		contents: 'Retrieving data from XML documents is simple and easy in Squeak Smalltalk. This tutorial demonstrates the fundamentals with a straightforward approach where code can be tested right away either here or in a Workspace window. The beauty of Squeak Smalltalk resides in the possibility to evaluate, inspect, print and debug code anywhere and this window is no different. This tutorial demonstrates how to...	* retrieve an XML document from the World Wide Web	* instantiate an XML document class	* inspect and understand the content of an XML document	* retrieve and display values from specific XML tagsRetrieve an XML document from the World Wide WebThere are many manners to retrieve data from the World Wide Web in Squeak Smalltalk. HTTPClient is among them and allows to download files in all simplicity. Select the following code snippet and inspect it (press alt-i). An Inspect window will open with the document loaded in memory. The result is a MIMEDocument object.	HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.TIP: Select HTTPClient and browse it (press alt-b) to open a System Browser window on its class. HTTPClient does not have instance methods but it has class methods. Click on class to see class methods.Instantiate an XML DocumentAn instance of MIMEDocument will not allow to retrieve XML data in a comprehensive manner because it does not understand the nature of XML. For this reason, it is necessary to parse the content of MIMEDocument using XMLDOMParser. XMLDOMParser>>parseDocumentFrom: requires a stream as a parameter and ReadStream will be used for this purpose. The following code snippet instantiates an XMLDocument using the content of the downloaded file.	| doc |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).Inspect and understand the content of an XML documentXML is a flexible document format and it is necessary to understand how each given XML file is structured in order to properly search, retrieve and manipulate data. Inspecting values is critical in a dynamic programming language and environment, such as Squeak Smalltalk. Select the previous code snippet and inspect it (press alt-i).Unfortunately, the Inspect window does not reveal a lot about the XML structure of the downloaded file. Select the previous code snippet once again and explore it (press alt and the capital letter i). An Explorer window will open with a tree outline on the instance of XMLDocument.The Inspect and Explorer windows tell a lot about an XMLDocument. The sections are instance variables and their values are displayed aside. In the Explorer window, unfold elementsAndContents. Unfold other sections as deemed necessary to understand the XML format and the data available.The gibberish coding is about to become clear. Open a Browser window from the world menu and right click in the first pane, select find class (press alt-f) and type XMLDocument to search for its class, or select the class name and browse it (press alt-b). However, it is suggested to read more about XMLParser and XMLParserTest first. Retrieve and display values from specific XML tagsThe downloaded XML file contains a list of items which are denoted by the tag name "item". The Explorer window revealed the content of interest is located at the array index 1 of the elementsAndContents, which can be accessed through XMLDocument>>root.TIP: Some XML documents have additional components contained within its file, such as XMLPI (XML Processing Instructions). For this reason, the root may lead to this rather than the data which will be indexed at 2 or more. It is necessary to use XMLNodeWithElements>>elements, e.g. (xml elements at: 2), in order to access subsequent data.The following code snippet will display items in a Transcript window. Open a Transcript window using the world menu before selecting and executing the code. Select the code snippet and execute it (press alt-d).	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript show: (e asString); cr.		].An XML item looks like this:	<item>	<title>HelpSystem-Core-tbn.46.mcz</title>	<link>http://source.squeak.org/trunk.html</link>	<description>throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)</description>	<pubDate>Sun, 02 May 2010 20:23:49 +0000</pubDate>	<author>Torsten Bergmann &lt;Torsten.Bergmann@astares.de&gt;</author>	<category>The Trunk</category>	<enclosure length="27288" type="application/x-monticello" url="http://source.squeak.org/trunk/HelpSystem-Core-tbn.46.mcz"/> 	<guid isPermaLink="false"/> </item>The following code snippet uses information learned, retrieves each comment and displays them in a Transcript window. Notice an author can have a nil value and is handled accordingly.	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript 			show: ''Date: '', ((e firstTagNamed: #pubDate) contentString); cr;			show: ''Title: '', ((e firstTagNamed: #title) contentString); cr;			show: ''Author: '', 				(((e firstTagNamed: #author) notNil)					ifTrue: [(e firstTagNamed: #author) contentString]					ifFalse: ['''']); cr;			show: ''Description: '', ((e firstTagNamed: #description) contentString); cr; cr.			].An item will now look like:	Date: Sun, 02 May 2010 20:23:49 +0000	Title: HelpSystem-Core-tbn.46.mcz	Author: Torsten Bergmann <Torsten.Bergmann@astares.de>	Description: throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)'! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 12:05'!insertCardOfBackground	"Prompt the user for choice of a background, and insert a new card of that background"	| bgs aBackground |	(bgs := self backgrounds) size = 1 ifTrue:		[self inform: 'At this time, there IS only one kind ofbackground in this stack, so that''swhat you''ll get' translated.		^ self insertCard].	aBackground := UIManager default		chooseFrom: (bgs collect: [:bg | bg externalName])		values: bgs.	aBackground ifNotNil:		[self insertCardOfBackground: aBackground]! !!StackMorph methodsFor: 'page controls' stamp: 'sw 6/6/2003 13:59'!addPageControlMorph: aMorph	"Add the given morph as a page-control, at the appropriate place"	aMorph setProperty: #pageControl toValue: true.	self addPane: aMorph paneType: #pageControl! !!StackMorph methodsFor: 'submorphs-accessing' stamp: 'sw 6/5/2003 04:02'!naturalPaneOrder	^ #(header pageControl retrieve search index content)! !!StandardFileStream methodsFor: 'open/close' stamp: 'eem 7/4/2010 12:00'!openOnHandle: aFileID name: streamName forWrite: writeMode	"Initialize the file with the given handle. If writeMode is true then	 allow writing, otherwise put the file in read-only mode.	 N.B. Do _not_ register the stream.  We do not want it to be	 closed implicitly (e.g. on GC).  There may be multiple instances	 accessing the same stream.  The stream is not a file."	fileID := aFileID.	name := streamName.	rwmode := writeMode.	buffer1 := String new: 1.	self enableReadBuffering! !!StandardFileStream methodsFor: 'primitives' stamp: 'ul 11/10/2011 12:51'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>	(FileWriteError fileName: name)		signal: (self closed			ifTrue: [ 'File ', name, ' is closed' ]			ifFalse: [ 'File ', name, ' write failed' ])! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/15/2011 13:28'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil."		| next |	next := self basicNext ifNil: [ ^nil ].	collection ifNotNil: [		"#basicNext ensures that this is enough"		position := position - 1.		^next ].	self skip: -1.	^next! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 9/20/2010 05:10'!upTo: delimiter	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOf: delimiter startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					collection 						ifNil: [ self skip: pos - bytesRead ]						ifNotNil: [							position := pos.							readLimit := bytesRead ].					false "Found the delimiter." ] ] whileTrue ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 9/20/2010 05:01'!upToAnyOf: delimiters do: aBlock	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					| result |					result := collection copyFrom: position + 1 to: (position := pos) - 1 .					aBlock value: (collection at: position).					^result ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOfAnyOf: delimiters startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					collection 						ifNil: [ self skip: pos - bytesRead ]						ifNotNil: [							position := pos.							readLimit := bytesRead ].					false "Found the delimiter." ] ] whileTrue.		bytesRead = 0 ifFalse: [			aBlock value: (buffer at: pos) ] ]! !!StandardFileStream methodsFor: '*Compression' stamp: 'ul 6/17/2011 12:30'!compressFile	"Write a new file that has the data in me compressed in GZip format."	| zipped buffer |	self readOnly; binary.	zipped := self directory newFileNamed: (self name, FileDirectory dot, 'gz').	zipped binary; setFileTypeToObject.		"Type and Creator not to be text, so can be enclosed in an email"	zipped := GZipWriteStream on: zipped.	buffer := ByteArray new: 50000.	'Compressing ', self fullName 		displayProgressFrom: 0 to: self size		during: [:bar |			[self atEnd] whileFalse: [				bar value: self position.				zipped nextPutAll: (self nextInto: buffer)].			zipped close.			self close].	^zipped! !!StandardFileStream methodsFor: '*Tools-FileList' stamp: 'ul 11/23/2010 10:58'!dirAndFileName	"A temporary solution for supporting project loading via drag and drop."	^{ self directory. self localName }! !!StandardFileStream methodsFor: 'printing' stamp: 'mtf 12/27/2010 15:55'!<< aCollection	aCollection putOn: self! !!StandardFileStream commentStamp: 'ul 12/6/2009 05:13' prior: 0!Provides a simple, platform-independent, interface to a file system. The instance variable rwmode, inherited from class PositionableStream, here is used to hold a Boolean -- true means opened for read-write, false means opened for read-only.  2/12/96 swI implement a simple read buffering scheme with the variables defined in PositionableStream (which are unused in me otherwise) in the following way:	collection	<ByteString> or <ByteArray>	This is the buffer.	position	<Integer>	The relative position in the buffer. Greater or equal to zero.	readLimit	<Integer>	The number of bytes buffered. Greater or equal to zero.Read buffering is enabled with #enableReadBuffering, disabled with #disableReadBuffering and it is enabled by default. The buffer is filled when a read attempt of an unbuffered absolute position is requested, or when a negative repositioning is made (with #position: with an argument < than the current absolute position) to an absolute position which is not buffered. In the first case, the buffer is positioned to the given absolute position. In the latter case the repositioning is made to the requested absolute position minus fourth of the buffer size. This means that further small negative repositionings won't result in buffer flushing. This is really useful when filing in code.The read buffer is flushed (#flushReadBuffer) whenever a write attempt is made.The buffer state is valid if and only if collection is not nil and position < readLimit.!!StandardFileStream class methodsFor: 'error handling' stamp: 'mtf 1/20/2011 14:14'!fileDoesNotExistUserHandling: fullFileName ifDebug: debugBlock	| selection newName |	selection := UIManager default chooseFrom: {		'create a new file' translated.		'choose another name' translated.		'debug' translated.		'cancel' translated	} title: (FileDirectory localNameFor: fullFileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: fullFileName forWrite: true].	selection = 2 ifTrue:		[ newName := UIManager default request: 'Enter a new file name'						initialAnswer:  fullFileName.		^ self oldFileNamed:			(self fullName: newName)].	selection = 3 ifTrue: [^ debugBlock value].	self halt! !!StandardFileStream class methodsFor: 'error handling' stamp: 'mtf 1/20/2011 14:12'!fileExistsUserHandling: fullFileName ifDebug: debugBlock	| dir localName choice newName newFullFileName |	dir := FileDirectory forFileName: fullFileName.	localName := FileDirectory localNameFor: fullFileName.	choice := (UIManager default 		chooseFrom: #('overwrite that file' 'append (risky!!!!)' 'choose another name' 'debug' 'cancel')		title: localName, ' already exists.').	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fullFileName forWrite: true].	choice = 2 ifTrue: [		^ (self new open: fullFileName forWrite: true) setToEnd].	choice = 3 ifTrue: [		newName := UIManager default request: 'Enter a new file name' initialAnswer: fullFileName.		newFullFileName := self fullName: newName.		^ self newFileNamed: newFullFileName].	choice = 4 ifTrue: [^ debugBlock value].	self error: 'Please close this to abort file opening'! !!StandardFileStream class methodsFor: 'error handling' stamp: 'mtf 1/20/2011 14:13'!readOnlyFileDoesNotExistUserHandling: fullFileName ifDebug: debugBlock	| dir files choices selection newName fileName |	dir := FileDirectory forFileName: fullFileName.	files := dir fileNames.	fileName := FileDirectory localNameFor: fullFileName.	choices := fileName correctAgainst: files.	choices add: 'Choose another name'.	choices add: 'Debug'.	choices add: 'Cancel'.	selection := UIManager default chooseFrom: choices lines: (Array with: 5)		title: (FileDirectory localNameFor: fullFileName), 'does not exist.'.	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].	selection < (choices size - 1) ifTrue: [		newName := (dir pathName , FileDirectory slash , (choices at: selection))].	selection = (choices size - 2) ifTrue: [		newName := UIManager default 							request: 'Enter a new file name' 							initialAnswer: fileName].	selection = (choices size - 1) ifTrue: [^ debugBlock value].	newName = '' ifFalse: [^ self readOnlyFileNamed: (self fullName: newName)].	^ self error: 'Could not open a file'! !!StandardFileStream class methodsFor: 'file creation' stamp: 'nice 8/27/2010 21:45'!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened 	for writing on that file. If the file already exists, delete it without 	asking before creating the new file."	| dir localName fullName f |	fullName := self fullName: fileName.	(self isAFileNamed: fullName)		ifFalse: 			[f := self new open: fullName forWrite: true.			^ f				ifNil: ["Failed to open the file"					(FileDoesNotExistException fileName: fullName) signal]].	dir := FileDirectory forFileName: fullName.	localName := FileDirectory localNameFor: fullName.	dir		deleteFileNamed: localName		ifAbsent: [(CannotDeleteFileException new			messageText: 'Could not delete the old version of file ' , fullName) signal].	f := self new open: fullName forWrite: true.	^ f		ifNil: ["Failed to open the file"			(FileDoesNotExistException fileName: fullName) signal]! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jmv 3/2/2010 16:35'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| fullName f |	fullName := self fullName: fileName.	f := self new open: fullName forWrite: false.	^ f		ifNil: ["File does not exist..."			((FileDoesNotExistException fileName: fullName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!StandardFileStream class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24'!register: anObject		^self registry add: anObject! !!StandardFileStream class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24'!registry		^Registry ifNil: [ Registry := WeakRegistry new ]! !!StandardFileStream class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:25'!unregister: anObject		^self registry remove: anObject ifAbsent: nil! !!StandardScriptingSystem methodsFor: '*Etoys-utilities' stamp: 'ul 6/17/2011 12:17'!cleanupsForRelease	"Miscellaneous space cleanups to do before a release."	"EToySystem cleanupsForRelease"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph initialize.	"forces Prototype to let go of extra things it might hold"	Smalltalk globals removeKey: #AA ifAbsent: [].	Smalltalk globals removeKey: #BB ifAbsent: [].	Smalltalk globals removeKey: #CC ifAbsent: [].	Smalltalk globals removeKey: #DD ifAbsent: [].	Smalltalk globals removeKey: #Temp ifAbsent: [].	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk removeEmptyMessageCategories.	Symbol rehash! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'ul 11/15/2010 12:05'!testChangesFileAddressRange	"Test file position to source pointer address translation for the changes file"		| sf a |	sf := StandardSourceFileArray new.	(0 to: 16r1FFFFFF by: 811) do: [:e | | a2 i p |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i = 2.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 2 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r2000000 and: 16r2FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r4000000 and: 16r4FFFFFF)]! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'ul 11/15/2010 12:05'!testSourcesFileAddressRange	"Test file position to source pointer address translation for the sources file"		| sf a |	sf := StandardSourceFileArray new.	(0 to: 16r1FFFFFF by: 811) do: [:e | | a2 p i |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i = 1.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 1 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r1000000 and: 16r1FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r3000000 and: 16r3FFFFFF)]! !!StandardSystemController methodsFor: 'borders' stamp: 'nice 12/29/2010 15:01'!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp := sensor cursorPoint.	((view labelDisplayBox insetBy: (0 @ 2 corner: 0 @ -2)) containsPoint: cp)		ifTrue: [^ false].	(i := view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box := view windowBox]		ifFalse: [box := (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController methodsFor: 'menu messages' stamp: 'ul 9/28/2011 14:09'!toggleTwoTone	(view isMemberOf: StandardSystemView) ifTrue:		[^ view becomeForward: (view as: ColorSystemView)].	(view isMemberOf: ColorSystemView) ifTrue:		[^ view becomeForward: (view as: StandardSystemView)].! !!StandardSystemFontsTest methodsFor: 'testing' stamp: 'ul 11/25/2010 23:38'!testRestoreDefaultFonts	Preferences restoreFontsAfter: [		Preferences restoreDefaultFonts.		self assert: #standardDefaultTextFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardListFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardFlapFont familyName: 'Accushi' pointSize: 12.		self assert: #standardEToysFont familyName: 'BitstreamVeraSans' pointSize: 9.		self assert: #standardMenuFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #windowTitleFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardBalloonHelpFont familyName: 'Bitmap DejaVu Sans' pointSize: 7.		self assert: #standardCodeFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardButtonFont familyName: 'Bitmap DejaVu Sans' pointSize: 7]! !!StandardSystemView methodsFor: 'label access' stamp: 'nice 12/29/2010 15:01'!closeBoxFrame	^ Rectangle origin: (self labelDisplayBox leftCenter + (10 @ -5)) extent: (11 @ 11)! !!StandardSystemView methodsFor: 'label access' stamp: 'nice 12/29/2010 15:01'!growBoxFrame	^ Rectangle origin: (self labelDisplayBox rightCenter + (-22 @ -5)) extent: (11 @ 11)! !!StandardToolSet class methodsFor: 'completion' stamp: 'damiencassou 7/29/2009 16:12'!codeCompletionAround: aBlock textMorph: aTextMorph keyStroke: evt	^ aBlock value! !!StandardViewer methodsFor: 'initialization' stamp: 'ar 4/23/2010 16:53'!initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo	"Initialize the receiver to be a look inside the given Player.  The categoryInfo, if present, describes which categories should be present in it, in which order"	scriptedPlayer := aPlayer.	self listDirection: #topToBottom;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1.	self color: self standardViewerColor.	self addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean.	categoryInfo isEmptyOrNil		ifFalse:  "Reincarnating an pre-existing list"			[categoryInfo do:				[:aCat | self addCategoryViewerFor: aCat]]		ifTrue:  "starting fresh"			[self addSearchPane. 			self addCategoryViewer.			self addCategoryViewer.			(scriptedPlayer isPlayerLike and: [scriptedPlayer costume isMemberOf: KedamaMorph]) ifTrue: [self addCategoryViewer].		].! !!StandardViewer methodsFor: 'user interface' stamp: 'nice 5/6/2011 00:26'!hasDismissButton	submorphs isEmptyOrNil ifTrue: [^ false].	^submorphs first allMorphs anySatisfy:		[:possible |  (possible isKindOf: SimpleButtonMorph) and: [possible actionSelector == #dismiss]]! !!Stream methodsFor: 'printing' stamp: 'ajh 7/31/2001 20:34'!printOn: stream	super printOn: stream.	stream space.	self contents printOn: stream.! !!Stream methodsFor: 'testing' stamp: 'mir 11/10/2003 18:22'!isTypeHTTP	^false! !!Stream methodsFor: 'accessing - multibyte support' stamp: 'yo 8/30/2002 17:13'!basicNext	^ self next.! !!Stream methodsFor: 'accessing - multibyte support' stamp: 'ul 4/11/2011 02:58'!basicNext: anInteger 	^self next: anInteger! !!Stream methodsFor: 'accessing - multibyte support' stamp: 'ul 1/31/2011 01:37'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^self next: anInteger putAll: aCollection startingAt: startIndex! !!Stream methodsFor: 'accessing - multibyte support' stamp: 'yo 8/30/2002 17:13'!basicNextPut: anObject 	^ self nextPut: anObject! !!Stream methodsFor: 'accessing - multibyte support' stamp: 'yo 8/30/2002 17:13'!basicNextPutAll: aCollection 	^ self nextPutAll: aCollection.! !!StreamingMonoSound methodsFor: 'converting' stamp: 'ul 6/17/2011 12:30'!storeSunAudioOn: aBinaryStream compressionType: compressionName	"Store myself on the given stream as a monophonic sound compressed with the given type of compression. The sampling rate is reduced to 22050 samples/second if it is higher."	| fmt inBufSize samplesPerFrame outCodec compressed outSamplingRate audioWriter |	self pause; reset.  "stop playing and return to beginning"	fmt := SunAudioFileWriter formatCodeForCompressionType: compressionName.	inBufSize := 64000.	samplesPerFrame := 1.	outCodec := SunAudioFileWriter codecForFormatCode: fmt.	outCodec ifNotNil: [		samplesPerFrame := outCodec samplesPerFrame.		inBufSize := inBufSize roundUpTo: (2 * samplesPerFrame).		compressed := ByteArray new:			(inBufSize // samplesPerFrame) * outCodec bytesPerEncodedFrame].	outSamplingRate := streamSamplingRate.	streamSamplingRate > 22050 ifTrue: [		streamSamplingRate = 44100 ifFalse: [self error: 'unexpected MP3 sampling rate'].		outSamplingRate := 22050].	"write audio header"	audioWriter := SunAudioFileWriter onStream: aBinaryStream.	audioWriter writeHeaderSamplingRate: outSamplingRate format: fmt.	"convert and write sound data"	'Storing audio...' 		displayProgressFrom: 0 to: totalSamples during: [:bar | | outBuf counts inBuf samplesRemaining byteCount |			samplesRemaining := totalSamples.			[samplesRemaining > 0] whileTrue: [				bar value: totalSamples - samplesRemaining.				self loadBuffersForSampleCount: (inBufSize min: samplesRemaining).				inBuf := mixer sounds first samples.				outSamplingRate < streamSamplingRate					ifTrue: [outBuf := inBuf downSampledLowPassFiltering: true]					ifFalse: [outBuf := inBuf].				outCodec					ifNil: [audioWriter appendSamples: outBuf]					ifNotNil: [						counts := outCodec							encodeFrames: (outBuf size // samplesPerFrame)							from: outBuf at: 1							into: compressed at: 1.						byteCount := counts last.						byteCount = compressed size							ifTrue: [audioWriter appendBytes: compressed]							ifFalse: [audioWriter appendBytes: (compressed copyFrom: 1 to: byteCount)]].				samplesRemaining := samplesRemaining - inBuf monoSampleCount]].	"update audio header"	audioWriter updateHeaderDataSize.! !!StrikeFont methodsFor: 'accessing' stamp: 'bf 2/26/2007 12:39'!derivativeFonts	derivativeFonts ifNil: [^#()].	^derivativeFonts copyWithout: nil! !!StrikeFont methodsFor: 'accessing' stamp: 'ul 2/14/2011 03:49'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| code |	code := aCharacter charCode.	(self characterToGlyphMap notNil and: [ 		characterToGlyphMap size > code ]) ifTrue: [			code := characterToGlyphMap at: code + 1 ].	((code < minAscii or: [maxAscii < code]) 		or: [(xTable at: code + 1) < 0])			ifTrue: [^ self fallbackFont widthOf: aCharacter].	^ (xTable at: code + 2) - (xTable at: code + 1)! !!StrikeFont methodsFor: 'displaying' stamp: 'nice 12/29/2010 15:12'!displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| leftX rightX glyphInfo char destY form gfont destX destPt |	destX := aPoint x.	glyphInfo := Array new: 5.	startIndex to: stopIndex do:[:charIndex|		char := aString at: charIndex.		(self hasGlyphOf: char) ifTrue: [			self glyphInfoOf: char into: glyphInfo.			form := glyphInfo at: 1.			leftX := glyphInfo at: 2.			rightX := glyphInfo at: 3.			destY := glyphInfo at: 4.			gfont := glyphInfo at: 5.			(gfont == aBitBlt lastFont) ifFalse: [gfont installOn: aBitBlt].			destY := baselineY - destY. 			aBitBlt displayGlyph: form at: destX @ destY left: leftX right: rightX font: self.			destX := destX + (rightX - leftX + kernDelta).		] ifFalse:[			destPt := self fallbackFont displayString: aString on: aBitBlt from: charIndex to: charIndex at: destX @ aPoint y kern: kernDelta from: self baselineY: baselineY.			destPt x = destX ifTrue:[				"In some situations BitBlt doesn't return the advance width from the primitive.				Work around the situation"				destX := destX + (self widthOfString: aString from: charIndex to: charIndex) + kernDelta.			] ifFalse:[destX := destPt x].		].	].	^destX @ aPoint y! !!StrikeFont methodsFor: 'file in/out' stamp: 'nice 6/11/2010 21:29'!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f lastAscii charLine width ascii charForm line missingForm tempGlyphs iRect p rectLine left tokens right |	f := FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	"NOTE: if font has been scaled (and in any case),	the REAL bitmap dimensions come after the header."	self restOfLine: 'Extent information for entire font' from: f.	"Parse the following line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	tokens := f nextLine  findTokens: ' '.	iRect := Rectangle left: (tokens at: 5) asNumber right: (tokens at: 8) asNumber				top: (tokens at: 14) asNumber bottom: (tokens at: 11) asNumber.	ascent := iRect top.	descent := iRect bottom negated.		tempGlyphs := Form extent: (maxWidth*257) @ self height.	xTable := (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii := -1.	[charLine := self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[p := f position.		rectLine := f nextLine.		(rectLine beginsWith: 'Image rectange: left = ')			ifTrue: [tokens := rectLine findTokens: ' '.					left := (tokens at: 5) asNumber. right := (tokens at: 8) asNumber]			ifFalse: [left := right := 0. f position: p].		width:= (self restOfLine: 'Width (final pen position) = ' from: f) asNumber - left					max: (right-left+1).		(charLine beginsWith: 'Missing character') ifTrue: [ascii := 256].		('x''*' match: charLine) ifTrue:			[ascii := Number readFrom: (charLine copyFrom: 3 to: 4) asUppercase base: 16].		charForm := Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line := f nextLine.				4 to: (width + 3 min: line size + iRect left - left) do:					[:x | (line at: x - iRect left + left) = $*						ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm := charForm deepCopy]				ifFalse:				[minAscii := minAscii min: ascii.				maxAscii := maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii := ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs := Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable := xTable copyFrom: 1 to: maxAscii+3.	characterToGlyphMap := nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'nice 6/11/2010 21:29'!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line := file nextLine.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size! !!StrikeFont methodsFor: 'make arrows' stamp: 'sps 10/15/2003 17:06'!makeAssignArrow"Replace the underline character with an arrow for this font"	| arrowForm arrowCanvas arrowY arrowLeft arrowRight arrowHeadLength |	arrowForm := (self characterFormAt: $_) copy.	arrowCanvas := arrowForm getCanvas.	arrowCanvas fillColor: Color white.	arrowY := arrowForm height // 2.	arrowLeft := 0. 	arrowRight := arrowForm width - 2.	arrowHeadLength := (arrowRight - arrowLeft) * 2 // 5.	"Draw the lines"	arrowCanvas line: (arrowLeft@arrowY) to: (arrowRight@arrowY) color: Color black.	arrowCanvas 		line: (arrowLeft@arrowY) 		to: ((arrowLeft + arrowHeadLength)@(arrowY - arrowHeadLength)) 		color: Color black.	arrowCanvas 		line: (arrowLeft@arrowY) 		to: ((arrowLeft + arrowHeadLength)@(arrowY + arrowHeadLength)) 		color: Color black.	"Replace the glyph"	self characterFormAt: $_ put: arrowForm.! !!StrikeFont methodsFor: '*nebraska-file in/out' stamp: 'ul 5/16/2011 01:11'!encodedForRemoteCanvas	^String streamContents: [ :stream |		stream			nextPutAll: self familyName;			space;			nextPutAll: self name;			space;			print: self height;			space;			print: self emphasis ]! !!StrikeFont commentStamp: '<historical>' prior: 0!I represent a compact encoding of a set of Forms corresponding to characters in the ASCII character set. All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths. The xTable variable gives the left-x coordinates of the subforms corresponding to the glyphs. Characters are mapped to glyphs by using the characterToGyphMap.Subclasses can have non-trivial mapping rules as well as different representations for glyphs sizes (e.g., not using an xTable). If so, these classes should return nil when queried for xTable and/or the characterToGlyphMap. This will cause the CharacterScanner primitive to fail and query the font for the width of a character (so that a more programatical approach can be implemented).For display, fonts need to implement two messages:	#installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColorThis method installs the receiver (a font) on the given DisplayContext (which may be an instance of BitBlt or Canvas (or any of it's subclasses). The font should take the appropriate action to initialize the display context so that further display operations can be optimized.	#displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDeltaThis method is called for each subsequent run of characters in aString which is to be displayed with the (previously installed) settings.!!StrikeFont class methodsFor: 'accessing' stamp: 'ar 9/6/2010 11:33'!defaultSized: aNumber	| fonts f |	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	fonts := (TextConstants at: #Accuny ifAbsent:[TextStyle default]) fontArray.	f := fonts first.	1 to: fonts size do: [:i |		aNumber > (fonts at: i) height ifTrue: [f := fonts at: i].	].	^f! !!StrikeFont class methodsFor: 'examples' stamp: 'nice 8/19/2010 16:35'!readStrikeFont2Family: familyName fromDirectory: aDirectory	"StrikeFont readStrikeFont2Family: 'Lucida' fromDirectory: FileDirectory default"	"This utility reads all available .sf2 StrikeFont files for a given family from  	the current directory. It returns an Array, sorted by size, suitable for handing 	to TextStyle newFontArray: ."	"For this utility to work as is, the .sf2 files must be named 'familyNN.sf2'."	| fileNames strikeFonts |	fileNames := aDirectory fileNamesMatching: familyName , '##.sf2'.	strikeFonts := fileNames collect: [:fname | StrikeFont new readFromStrike2: fname].	strikeFonts do: [ :font | font reset ].	^strikeFonts asArray sort: [:a :b | a height < b height]."TextConstants at: #Lucida put: (TextStyle fontArray: (StrikeFont 	readStrikeFont2Family: 'Lucida'))."! !!StrikeFontSet methodsFor: 'displaying' stamp: 'nice 10/2/2010 00:32'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont baselineY: baselineY	| destPoint leftX rightX glyphInfo g tag char destY rIndex |	destPoint := aPoint.	rIndex := startIndex.	tag := (aString at: rIndex) leadingChar.	glyphInfo := Array new: 5.	[rIndex <= stopIndex] whileTrue: [		char := aString at: rIndex.		((fromFont hasGlyphOf: char) or: [char leadingChar ~= tag]) ifTrue: [^destPoint].		self glyphInfoOf: char into: glyphInfo.		g := glyphInfo first.		leftX := glyphInfo second.		rightX := glyphInfo third.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		destY := baselineY - glyphInfo fourth. 		aBitBlt			sourceForm: g;			destX: destPoint x;			destY: destY;			sourceOrigin: leftX @ 0;			width: rightX - leftX;			height: self height;			copyBits.		destPoint := destPoint x + (rightX - leftX + kernDelta) @ destPoint y.		rIndex := rIndex + 1.	].	^destPoint.! !!StrikeFontSet methodsFor: 'copying' stamp: 'nice 10/2/2010 00:31'!postCopy	super postCopy.	self reset.	fontArray := fontArray copy! !!StrikeFontSet methodsFor: '*nebraska-file in/out' stamp: 'ul 5/16/2011 01:11'!encodedForRemoteCanvas	^String streamContents: [ :stream |		stream			nextPutAll: self familyName;			space;			print: self pointSize;			space;			print: self emphasis ]! !!String methodsFor: 'accessing' stamp: 'ul 9/14/2009 02:59'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."	| index c1 c2 |	matchTable == nil ifTrue: [		key size = 0 ifTrue: [^ 0].		start to: body size - key size + 1 do:			[:startIndex |			index := 1.				[(body at: startIndex+index-1)					= (key at: index)]					whileTrue:					[index = key size ifTrue: [^ startIndex].					index := index+1]].		^ 0	].	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.		[c1 := body at: startIndex+index-1.		c2 := key at: index.		((c1 leadingChar = 0 and: [ c1 asciiValue < matchTable size ]) 			ifTrue: [ matchTable at: c1 asciiValue + 1 ]			ifFalse: [ c1 asciiValue + 1 ]) = 			((c2 leadingChar = 0 and: [ c2 asciiValue < matchTable size ])				ifTrue: [ matchTable at: c2 asciiValue + 1 ]				ifFalse: [c2 asciiValue + 1 ]) ]			whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!lastSpacePosition	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i) isSeparator) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!String methodsFor: 'accessing' stamp: 'nice 6/11/2010 21:44'!lines	"Answer an array of lines composing this receiver without the line ending delimiters."	^Array new: (self size // 60 max: 16) streamContents: [:lines |		self linesDo: [:aLine | lines nextPut: aLine]]! !!String methodsFor: 'accessing' stamp: 'eem 9/29/2011 12:40'!numArgs 	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons excess start ix |	self size = 0 ifTrue: [^ -1].	firstChar := self at: 1.	(firstChar isLetter or: [firstChar = $:]) ifTrue:		["Fast reject if any chars are non-alphanumeric		NOTE: fast only for Byte things - Broken for Wide"		Scanner prefAllowUnderscoreSelectors ifFalse:			[self class isBytes				ifTrue: [(self findSubstring: '~' in: self startingAt: 1 matchTable: Tokenish) > 0 ifTrue: [^ -1]]				ifFalse: [2 to: self size do: [:i | (self at: i) tokenish ifFalse: [^ -1]]]].		"Fast colon count"		numColons := 0.  start := 1.		[(ix := self indexOf: $: startingAt: start) > 0]			whileTrue:				[numColons := numColons + 1.				start := ix + 1].		numColons = 0 ifTrue: [^ 0].		firstChar = $:			ifTrue: [excess := 2 "Has an initial keyword, as #:if:then:else:"]			ifFalse: [excess := 0].		self last = $:			ifTrue: [^ numColons - excess]			ifFalse: [^ numColons - excess - 1 "Has a final keywords as #nextPut::andCR"]].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!String methodsFor: 'comparing' stamp: 'ul 1/15/2011 11:48'!match: text	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	^ self startingAt: 1 match: text startingAt: 1"	'*'			match: 'zort' true	'*baz'		match: 'mobaz' true	'*baz'		match: 'mobazo' false	'*baz*'		match: 'mobazo' true	'*baz*'		match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'		match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' true	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true	'*foo*zort'	match: 'afoodezortorfoo3zort' true"! !!String methodsFor: 'comparing' stamp: 'ul 1/15/2011 13:54'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."		| anyMatch matchStart matchEnd i matchStr j ii jj |	i := keyStart.	j := textStart.		"Process consecutive *s and #s at the beginning."	anyMatch := false.	[ i <= self size and: [		(self at: i)			caseOf: {				[ $* ] -> [ 					anyMatch := true.					i := i + 1.					true ].				[ $# ] -> [					i := i + 1.					j := j + 1.					true ] }			otherwise: [ false ] ] ] whileTrue.	i > self size ifTrue: [		^j - 1 = text size or: [ "We reached the end by matching the character with a #."			anyMatch and: [ j <= text size ] "Or there was a * before the end." ] ].	matchStart := i.	"Now determine the match string"	matchEnd := self size.	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue: [ matchEnd := ii-1 ].	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue: [ matchEnd := matchEnd min: ii-1 ].	matchStr := self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj := text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j := j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asDateAndTime	"Convert from UTC format" 	^ DateAndTime fromString: self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asDuration	"convert from [nnnd]hh:mm:ss[.nanos] format. [] implies optional elements"	^ Duration fromString: self! !!String methodsFor: 'converting' stamp: 'ul 11/15/2010 10:07'!asIdentifier: shouldBeCapitalized	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"	| aString firstChar firstLetterPosition |	aString := self select: [:el | el isAlphaNumeric].	firstLetterPosition := aString findFirst: [:ch | ch isLetter].	aString := firstLetterPosition = 0		ifFalse:			[aString copyFrom: firstLetterPosition to: aString size]		ifTrue:			['a', aString].	firstChar := shouldBeCapitalized ifTrue: [aString first asUppercase] ifFalse: [aString first asLowercase].	^ firstChar asString, (aString copyFrom: 2 to: aString size)"'234Fred987' asIdentifier: false'235Fred987' asIdentifier: true'' asIdentifier: true'()87234' asIdentifier: false'())z>=PPve889  U >' asIdentifier: false"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asTimeStamp	"Convert from obsolete TimeStamp format"	^ TimeStamp fromString: self! !!String methodsFor: 'converting' stamp: 'ul 11/15/2010 10:07'!initialIntegerOrNil	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	(self size = 0 or: [self first isDigit not]) ifTrue: [^ nil].	firstNonDigit := (self findFirst: [:m | m isDigit not]).	firstNonDigit = 0 ifTrue: [firstNonDigit := self size + 1].	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"'234Whoopie' initialIntegerOrNil'wimpy' initialIntegerOrNil'234' initialIntegerOrNil'2N' initialIntegerOrNil'2' initialIntegerOrNil'  89Ten ' initialIntegerOrNil'78 92' initialIntegerOrNil"! !!String methodsFor: 'converting' stamp: 'ul 11/15/2010 10:07'!sansPeriodSuffix	"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "	| likely |	likely := self copyUpTo: $..	^ likely size = 0		ifTrue:	[self]		ifFalse:	[likely]! !!String methodsFor: 'converting' stamp: 'md 5/26/2005 13:35'!string	^self! !!String methodsFor: 'converting' stamp: 'ul 8/9/2011 13:31'!unescapePercents	"decode %xx form.  This is the opposite of #encodeForHTTP. Assume UTF-8 encoding by default."		| unescaped |	unescaped := self unescapePercentsRaw.	^[ unescaped utf8ToSqueak ]		on: Error		do: [ unescaped ]! !!String methodsFor: 'converting' stamp: 'ul 8/9/2011 13:28'!unescapePercentsRaw	"decode string including %XX form"		| unescaped char asciiVal specialChars oldPos pos |	unescaped := ReadWriteStream on: String new.	specialChars := '+%' asCharacterSet.	oldPos := 1.	[pos := self indexOfAnyOf: specialChars startingAt: oldPos.	pos > 0]		whileTrue: [unescaped				nextPutAll: (self copyFrom: oldPos to: pos - 1).			char := self at: pos.			(char = $%					and: [pos + 2 <= self size])				ifTrue: [asciiVal := (self at: pos + 1) asUppercase digitValue * 16 + (self at: pos + 2) asUppercase digitValue.					asciiVal > 255						ifTrue: [^ self].					unescaped						nextPut: (Character value: asciiVal).					pos := pos + 3.					pos <= self size						ifFalse: [char := nil].					oldPos := pos]				ifFalse: [char = $+						ifTrue: [unescaped nextPut: Character space]						ifFalse: [unescaped nextPut: char].					oldPos := pos + 1]].	oldPos <= self size		ifTrue: [unescaped				nextPutAll: (self copyFrom: oldPos to: self size)].	^unescaped contents! !!String methodsFor: 'converting' stamp: 'ul 8/9/2011 13:29'!unescapePercentsWithTextConverter: aTextConverter	"decode string including %XX form"	| unescaped |	unescaped := self unescapePercentsRaw.	^[ unescaped convertFromWithConverter: aTextConverter ]		on: Error		do: ["the contents may be squeak-encoded"			unescaped ]! !!String methodsFor: 'converting' stamp: 'ul 8/9/2011 13:30'!unescapePercentsWithTextEncoding: encodingName 	"decode string including %XX form"		| converter |	converter := (TextConverter newForEncoding: encodingName)		ifNil: [ TextConverter newForEncoding: nil ].	^self unescapePercentsWithTextConverter: converter! !!String methodsFor: 'converting' stamp: 'nice 3/25/2011 22:55'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end |				| pastEnd lineStart |				pastEnd := endWithoutDelimiters + 1.				"eliminate spaces at beginning of line"				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [pastEnd]) min: pastEnd.				[| lineStop lineEnd spacePosition |				lineEnd := lineStop  := lineStart + aNumber min: pastEnd..				spacePosition := lineStart.				[spacePosition < lineStop] whileTrue: [					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [pastEnd].					spacePosition <= lineStop ifTrue: [lineEnd := spacePosition].				].				"split before space or before lineStop if no space"				stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).				"eliminate spaces at beginning of next line"				lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd ifAbsent: [pastEnd].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: pastEnd to: end) ] ]! !!String methodsFor: 'formatting' stamp: 'ul 2/10/2011 22:52'!expandMacrosWithArguments: anArray 		^self class new: self size streamContents: [ :output |		| lastIndex nextIndex characterSet |		lastIndex := 1.		[ (nextIndex := self indexOfAnyOf: CSMacroCharacters startingAt: lastIndex) = 0 ] whileFalse: [			nextIndex = lastIndex ifFalse: [				output next: nextIndex - lastIndex putAll: self startingAt: lastIndex ].			(self at: nextIndex) == $% 				ifTrue: [ output nextPut: (self at: (nextIndex := nextIndex + 1)) ]				ifFalse: [ 					| nextCharacter argumentIndex |					nextCharacter := (self at: (nextIndex := nextIndex + 1)) asUppercase.					nextCharacter == $N ifTrue: [ output cr ].					nextCharacter == $T ifTrue: [ output tab ].					(nextCharacter between: $0 and: $9) ifTrue: [						argumentIndex := nextCharacter digitValue.						[ (nextIndex := nextIndex + 1) <= self size and: [							(nextCharacter := self at: nextIndex) between: $0 and: $9 ] ] whileTrue: [								argumentIndex := argumentIndex * 10 + nextCharacter digitValue ].						nextCharacter := nextCharacter asUppercase ].					nextCharacter == $P ifTrue: [ output print: (anArray at: argumentIndex) ].					nextCharacter == $S ifTrue: [ output nextPutAll: (anArray at: argumentIndex) ].					nextCharacter == $? ifTrue: [ 						| trueEnd falseEnd |						trueEnd := self indexOf: $: startingAt: nextIndex + 1.						falseEnd := self indexOf: $> startingAt: trueEnd + 1.						(anArray at: argumentIndex)							ifTrue: [ output next: trueEnd - nextIndex - 1 putAll: self startingAt: nextIndex + 1 ]							ifFalse: [ output next: falseEnd - trueEnd - 1 putAll: self startingAt: trueEnd + 1 ].						nextIndex := falseEnd - 1 ].					(self at: (nextIndex := nextIndex + 1)) == $> ifFalse: [						self error: '> expected' ] ].			lastIndex := nextIndex + 1 ].		lastIndex <= self size ifTrue: [			output next: self size - lastIndex + 1 putAll: self startingAt: lastIndex ] ]! !!String methodsFor: 'internet' stamp: 'ul 11/15/2010 10:07'!utf8ToIso	"Only UTF-8 characters that maps to 8-bit ISO-8559-1 values are converted. Others raises an error"	| s i c v c2 v2 |	s := WriteStream on: (String new: self size).		i := 1.	[i <= self size] whileTrue: [		c := self at: i. i:=i+1.		v := c asciiValue.		(v > 128)			ifFalse: [ s nextPut: c ]			ifTrue: [((v bitAnd: 252) = 192)				ifFalse: [self error: 'illegal UTF-8 ISO character']				ifTrue: [					(i > self size) ifTrue: [ self error: 'illegal end-of-string, expected 2nd byte of UTF-8'].					c2 := self at: i. i:=i+1.					v2 := c2 asciiValue.					((v2 bitAnd: 192) = 128) ifFalse: [self error: 'illegal 2nd UTF-8 char']. 					s nextPut: ((v2 bitAnd: 63) bitOr: ((v << 6) bitAnd: 192)) asCharacter]]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'ul 11/22/2010 13:20'!withInternetLineEndings	"change line endings from CR's and LF's to CRLF's.  This is probably in prepration for sending a string over the Internet"		^self withLineEndings: String crlf! !!String methodsFor: 'internet' stamp: 'ul 11/22/2010 13:19'!withLineEndings: lineEndingString	| stream |	stream := nil.	self lineIndicesDo: [ :start :endWithoutDelimiters :end |		(stream isNil and: [ endWithoutDelimiters ~= end ]) ifTrue: [			(self copyFrom: endWithoutDelimiters + 1 to: end) = lineEndingString ifFalse: [				stream := WriteStream with: self copy.				stream position: start - 1 ] ].		stream ifNotNil: [			stream next: endWithoutDelimiters - start + 1 putAll: self startingAt: start.			endWithoutDelimiters = end ifFalse: [				stream nextPutAll: lineEndingString ] ] ].	^stream		ifNil: [ self ]		ifNotNil: [ 			stream position = self size				ifTrue: [ stream originalContents ]				ifFalse: [ stream contents ] ]! !!String methodsFor: 'internet' stamp: 'ul 11/23/2010 08:19'!withSqueakLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single CR."	(self includes: Character lf) ifFalse: [ ^self ].	(self includes: Character cr) ifFalse: [		^self translateWith: String crLfExchangeTable ].	^self withLineEndings: String cr! !!String methodsFor: 'internet' stamp: 'ul 11/23/2010 08:20'!withUnixLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single LF."	(self includes: Character cr) ifFalse: [ ^self ].	(self includes: Character lf) ifFalse: [		^self translateWith: String crLfExchangeTable ].	^self withLineEndings: String lf! !!String methodsFor: 'internet' stamp: 'ul 11/7/2010 06:46'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote := self first.	(quote = self last and: [ quote = $' or: [ quote = $" ] ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'testing' stamp: 'ul 4/1/2011 04:04'!beginsWith: sequence	"Answer true if the receiver starts with the argument collection. The comparison is case-sensitive. Overridden for better performance."	| sequenceSize |	sequence isString ifFalse: [ ^super beginsWith: sequence ].	((sequenceSize := sequence size) = 0 or: [ self size < sequence size ]) ifTrue: [ ^false ].	1 to: sequenceSize do: [ :index |		(sequence basicAt: index) = (self basicAt: index) ifFalse: [ ^false ] ].	^true! !!String methodsFor: 'testing' stamp: 'ul 4/1/2011 04:45'!endsWith: suffix	"Answer true if the receiver ends with the argument collection. The comparison is case-sensitive. Overridden for better performance."		| offset |	(offset := self size - suffix size) < 0 ifTrue: [ ^false ].	^(self findString: suffix startingAt: offset + 1) ~= 0! !!String methodsFor: 'testing' stamp: 'sw 10/20/2004 17:51'!endsWithAColon 	"Answer whether the final character of the receiver is a colon"	^ self size > 0 and: [self last == $:]"#fred: endsWithAColon'fred' endsWithAColon"! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!endsWithAnyOf: aCollection	aCollection do:[:suffix|		(self endsWith: suffix) ifTrue:[^true].	].	^false! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!endsWithDigit	"Answer whether the receiver's final character represents a digit.  3/11/96 sw"	^ self size > 0 and: [self last isDigit]! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!includesSubString: subString	^ (self findString: subString startingAt: 1) > 0! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!includesSubstring: aString caseSensitive: caseSensitive		^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0! !!String methodsFor: 'testing' stamp: 'ul 2/11/2011 18:16'!isAsciiString	^self allSatisfy: [ :each | each asciiValue <= 127 ]! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!startsWithDigit	"Answer whether the receiver's first character represents a digit"	^ self size > 0 and: [self first isDigit]! !!String methodsFor: '*monticello' stamp: 'cmm 8/14/2011 14:04'!withLoadedPackageVersions	"Everywhere the receiver contains a package version in the format:  PackageName-author.123 for which a version of that package is loaded in the image, answer a new String with each of those package versions changed to reflect the currently loaded version."	| string |	string := self.	MCWorkingCopy allManagers do:		[ : eachWorkingCopy | | start packageName |		start := 1.		packageName := eachWorkingCopy packageName.		[ start := string			findString: packageName			startingAt: start.		start > 0 and: [ string size > (start + packageName size + 4) ] ] whileTrue:			[ | dot end versionName |			dot := string				indexOf: $.				startingAt: (end := start + packageName size)				ifAbsent: [ 0 ].			dot > 0 ifTrue:				[ end := (dot + 1 to: string size)					detect: [ : n | (string at: n) isDigit not ]					ifNone: [ 0 ].				(end > (dot + 1) and:					[ (dot + 1 to: end - 1) allSatisfy:						[ : n | (string at: n) isDigit ] ])					ifTrue:						[ versionName := string							copyFrom: start							to: end - 1.						versionName asMCVersionName packageName = packageName ifTrue:							[ string := string								copyReplaceTokens: versionName								with: eachWorkingCopy ancestors first name ] ]					ifFalse: [ end := start + packageName size ] ].			start := end ] ].	^ string! !!String methodsFor: '*versionnumber' stamp: 'yo 11/3/2004 19:24'!asVersion	"Answer a VersionNumber"	^VersionNumber fromString: self! !!String methodsFor: '*sound-synthesis' stamp: 'wiz 4/28/2010 16:01'!asSound	"Return a sound. Either from the sound library via SampleSound or	else the Beeper default"	^ SampledSound		soundNamed: self		ifAbsent: [Beeper default]! !!String methodsFor: '*network-uuid' stamp: 'mw 1/30/2004 11:53'!asAlphaNumeric: totalSize extraChars: additionallyAllowed mergeUID: minimalSizeOfRandomPart	"Generates a String with unique identifier ( UID ) qualities, the difference to a	 UUID is that its beginning is derived from the receiver, so that it has a meaning	 for a human reader.	 Answers a String of totalSize, which consists of 3 parts	 1.part: the beginning of the receiver only consisting of		a-z, A-Z, 0-9 and extraChars in Collection additionallyAllowed ( which can be nil )	 2.part: a single _	 3.part: a ( random ) UID of size >= minimalSizeOfRandomPart consisting of		a-z, A-Z, 0-9	 Starting letters are capitalized. 	 TotalSize must be at least 1.	 Exactly 1 occurrence of $_ is guaranteed ( unless additionallyAllowed includes $_ ).	 The random part has even for small sizes good UID qualitites for many practical purposes.	 If only lower- or uppercase letters are demanded, simply convert the answer with	 say #asLowercase. The probability of a duplicate will rise only moderately ( see below ).	 Example: 		size of random part = 10		in n generated UIDs the chance p of having non-unique UIDs is			n = 10000 ->  p < 1e-10		if answer is reduced to lowerCase: p < 1.4 e-8			n = 100000 -> p < 1e-8		at the bottom is a snippet for your own calculations  		Note: the calculated propabilites are theoretical,			for the actually used random generator they may be much worse"	| stream out sizeOfFirstPart index ascii ch skip array random |	totalSize > minimalSizeOfRandomPart 		ifFalse: [ self errorOutOfBounds ].	stream := ReadStream on: self.	out := WriteStream on: ( String new: totalSize ).	index := 0.	skip := true.	sizeOfFirstPart := totalSize - minimalSizeOfRandomPart - 1.	[ stream atEnd or: [ index >= sizeOfFirstPart ]]	whileFalse: [		((( ascii := ( ch := stream next ) asciiValue ) >= 65 and: [ ascii <= 90 ]) or: [			( ascii >= 97 and: [ ascii <= 122 ]) or: [			 			ch isDigit or: [			additionallyAllowed notNil and: [ additionallyAllowed includes: ch ]]]])		ifTrue: [			skip				ifTrue: [ out nextPut: ch asUppercase ]				ifFalse: [ out nextPut: ch ].			index := index + 1.			skip := false ]		ifFalse: [ skip := true ]].	out nextPut: $_.	array := Array new: 62.	1 to: 26 do: [ :i |		array at: i put: ( i + 64 ) asCharacter.		array at: i + 26 put: ( i + 96 ) asCharacter ].	53 to: 62 do: [ :i |		array at: i put: ( i - 5 ) asCharacter ].	random := UUIDGenerator default randomGenerator. 	totalSize - index - 1 timesRepeat: [		out nextPut: ( array atRandom: random )].	^out contents	"	calculation of probability p for failure of uniqueness in n UIDs		Note: if answer will be converted to upper or lower case replace 62 with 36	| n i p all |	all := 62 raisedTo: sizeOfRandomPart.	i := 1.	p := 0.0 .	n := 10000.	[ i <= n ]	whileTrue: [		p := p + (( i - 1 ) / all ).		i := i + 1 ].	p   	approximation formula: n squared / ( 62.0 raisedTo: sizeOfRandomPart ) / 2 	" 	"'Crop SketchMorphs and Grab Screen Rect to JPG' 			asAlphaNumeric: 31 extraChars: nil mergeUID: 10  	 			'CropSketchMorphsAndG_iOw94jquN6'	 'Monticello' 			asAlphaNumeric: 31 extraChars: nil mergeUID: 10    				'Monticello_kp6aV2l0IZK9uBULGOeG' 	 'version-', ( '1.1.2' replaceAll: $. with: $- )			asAlphaNumeric: 31 extraChars: #( $- ) mergeUID: 10    				'Version-1-1-2_kuz2tMg2xX9iRLDVR'"		! !!String methodsFor: '*network-url' stamp: 'yo 11/3/2004 19:24'!asUrl	"convert to a Url"	"'http://www.cc.gatech.edu/' asUrl"	"msw://chaos.resnet.gatech.edu:9000/' asUrl"	^Url absoluteFromText: self! !!String methodsFor: '*network-url' stamp: 'yo 11/3/2004 19:24'!asUrlRelativeTo: aUrl	^aUrl newFromRelativeText: self! !!String methodsFor: '*network-url' stamp: 'ar 9/4/2010 11:23'!urlEncoded	"Encode the receiver, which is assumed to be URL, properly.	This method is specific to URLs in such that it will parse	the url and perform a semantically correct substitution, for example:	'http://squeak.org/name with space?and=value' encodeForHTTP.	=> 'http%3A%2F%2Fsqueak.org%2Fname%20with%20space%3Fand%3Dvalue'			'http://squeak.org/name with space?and=value' urlEncoded.	=> 'http://squeak.org/name%20with%20space?and=value"	^self asUrl asString! !!String methodsFor: '*Compression' stamp: 'yo 11/3/2004 19:24'!unzipped	| magic1 magic2 |	magic1 := (self at: 1) asInteger.	magic2 := (self at: 2) asInteger.	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].	^(GZipReadStream on: self) upToEnd! !!String methodsFor: '*Compression' stamp: 'dgd 11/26/2005 21:19'!zipped	| stream gzstream |	stream := RWBinaryOrTextStream on: String new.	gzstream := GZipWriteStream on: stream.	gzstream nextPutAll: self.	gzstream close.	stream reset.	^ stream contents.! !!String methodsFor: '*toolbuilder-kernel' stamp: 'yo 11/3/2004 19:24'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	^ProgressInitiationException 		display: self		at: aPoint 		from: minVal 		to: maxVal 		during: workBlock! !!String methodsFor: '*toolbuilder-kernel' stamp: 'cmm 6/14/2011 22:21'!displayProgressFrom: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressFrom: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]]."	^ self		displayProgressAt: nil		from: minVal		to: maxVal		during: workBlock! !!String commentStamp: '<historical>' prior: 0!A String is an indexed collection of Characters. Class String provides the abstract super class for ByteString (that represents an array of 8-bit Characters) and WideString (that represents an array of  32-bit characters).  In the similar manner of LargeInteger and SmallInteger, those subclasses are chosen accordingly for a string; namely as long as the system can figure out so, the String is used to represent the given string.Strings support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!!String class methodsFor: 'initialization' stamp: 'ul 2/10/2011 04:00'!initialize   "self initialize"	| order |	AsciiOrder := (0 to: 255) as: ByteArray.	CaseInsensitiveOrder := AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder := ByteArray new: 256 withAll: 255.	order := -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order := order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order := order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish := String withAll: (Character allByteCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders := CharacterSet crlf. 	"separators and non-separators"	CSSeparators := CharacterSet separators.	CSNonSeparators := CSSeparators complement.		"% and < for #expandMacros*"	CSMacroCharacters := CharacterSet newFrom: '%<'.		"a table for exchanging cr with lf and vica versa"	CrLfExchangeTable := Character allByteCharacters collect: [ :each |		each			caseOf: {				[ Character cr ] -> [ Character lf ].				[ Character lf ] -> [ Character cr ] }			otherwise: [ each ] ]! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:08'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	order == nil ifTrue: [		len1 := string1 size.		len2 := string2 size.		1 to: (len1 min: len2) do:[:i |			c1 := string1 basicAt: i.			c2 := string2 basicAt: i.			c1 = c2 ifFalse: [c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].		].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:[:i |		c1 := string1 basicAt: i.		c2 := string2 basicAt: i.		c1 < 256 ifTrue: [c1 := order at: c1 + 1].		c2 < 256 ifTrue: [c2 := order at: c2 + 1].		c1 = c2 ifFalse:[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].	].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:07'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := aString basicAt: i.		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:06'!indexOfAscii: anInteger inString: aString startingAt: start	"Trivial, non-primitive version"	start to: aString size do: [ :index |		(aString basicAt: index) = anInteger ifTrue: [ ^index ] ].	^0! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:02'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	stringSize := aString size.	hash := speciesHash bitAnd: 16r0FFFFFFF.	1 to: stringSize do: [ :pos |		hash := hash + (aString basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash // 16384) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF ].	^hash.! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:09'!translate: aString from: start  to: stop  table: table	"Trivial, non-primitive version"	start to: stop do: [ :i |		| char |		(char := aString basicAt: i) < 256 ifTrue: [			aString at: i put: (table at: char+1) ] ].! !!String class methodsFor: 'accessing' stamp: 'ul 11/23/2010 08:17'!crLfExchangeTable	^CrLfExchangeTable! !!StringHolder methodsFor: '*Tools' stamp: 'fbs 5/5/2011 10:35'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	^ (myClass := self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: self selectedMessageName]! !!StringHolder methodsFor: '*Tools' stamp: 'cmm 5/2/2011 09:56'!classListKey: aChar from: view 	"Respond to a Command key.  I am a model with a list of classes and a 	code pane, and I also have a listView that has a list of methods.  The 	view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findMethod].	aChar == $r ifTrue: [^ self browseVariableReferences].	aChar == $a ifTrue: [^ self browseVariableAssignments].	aChar == $h ifTrue: [^ self spawnHierarchy].	aChar == $x ifTrue: [^ self removeClass].	^ self messageListKey: aChar from: view! !!StringHolder methodsFor: '*Tools' stamp: 'cmm 9/20/2010 13:59'!copyReference	"Copy the selected selector to the clipboard"	self selectedMessageName ifNotNilDo:		[ : selector | Clipboard clipboardText:			(self selectedClassOrMetaClass				ifNil: [ selector asString ]				ifNotNilDo: [ : cls | (cls >> selector) reference ]) ]! !!StringHolder methodsFor: '*Tools' stamp: 'nice 3/14/2010 19:43'!fileOutAllMessages	"Put a description of the all the message list on a file."	FileStream		writeSourceCodeFrom:			(String new: 16000 streamContents: [:str |				self messageList do: [:e |					e actualClass printMethodChunk: e methodSymbol withPreamble: true					on: str moveSource: false toFile: 0]])		baseName: (self messageListSelectorTitle replaceAll: Character space with: $_) isSt: true useHtml: false! !!StringHolder methodsFor: '*Tools' stamp: 'nice 3/14/2010 19:43'!fileOutMessage	"Put a description of the selected message on a file.	If no message is selected, put a description of ALL the message list."	self selectedMessageName		ifNil:			[self fileOutAllMessages]		ifNotNil:			[Cursor write showWhile:				[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]]! !!StringHolder methodsFor: '*Tools' stamp: 'nice 3/14/2010 19:33'!messageList	^Array new! !!StringHolder methodsFor: '*Tools' stamp: 'ul 11/15/2010 12:05'!messageListSelectorTitle	| selector aString aStamp aSize |	(selector := self selectedMessageName)		ifNil:			[aSize := self messageList size.			^ (aSize = 0 ifTrue: ['no'] ifFalse: [aSize printString]), ' message', (aSize = 1 ifTrue: [''] ifFalse: ['s'])]		ifNotNil:			[Preferences timeStampsInMenuTitles				ifFalse:	[^ nil].			aString := selector truncateWithElipsisTo: 28.			^ (aStamp := self timeStamp) size > 0				ifTrue:					[aString, String cr, aStamp]				ifFalse:					[aString]]! !!StringHolder methodsFor: '*Tools' stamp: 'eem 9/7/2010 12:04'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method |	(selector := self selectedMessageName) ifNil: [^ self].	method := (self selectedClassOrMetaClass ifNil: [^aBlock value: selector])				compiledMethodAt: selector				ifAbsent: [].	method isNil ifTrue: [^aBlock value: selector].	^self withSelectorAndMessagesIn: method evaluate: aBlock! !!StringHolder methodsFor: '*Tools' stamp: 'cmm 4/26/2011 16:45'!systemCatListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findClass].	aChar == $x ifTrue: [^ self removeSystemCategory].	aChar == $b ifTrue: [^ self recent].	^ self classListKey: aChar from: view! !!StringHolder methodsFor: '*Tools' stamp: 'ul 8/2/2011 20:10'!withSelectorAndMessagesIn: aCompiledMethod evaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selectorOrNil litGetter messages |	selectorOrNil := aCompiledMethod selector.	messages := Preferences thoroughSenders					ifTrue:						[litGetter := [:set :l|										(l isSymbol and: [l size > 0 and: [l first isLowercase]]) ifTrue:											[set add: l].										l isArray ifTrue:											[l inject: set into: litGetter copy].										set].						aCompiledMethod allLiterals						, (aCompiledMethod pragmas collect: [:pragma| pragma keyword])							inject: aCompiledMethod messages into: litGetter copy]					ifFalse: [aCompiledMethod messages].	(messages isEmpty	"if no messages, use only selector"	or: [messages size = 1 and: [messages includes: selectorOrNil]]) ifTrue:		[^selectorOrNil ifNotNil: [aBlock value: selectorOrNil]].  "If only one item, there is no choice"	self systemNavigation 		showMenuOf: messages		withFirstItem: selectorOrNil		ifChosenDo: aBlock! !!StringHolder methodsFor: '*Tools-traits' stamp: 'cmm 5/2/2011 09:55'!browseVariableAssignments	| cls |	cls := self selectedClassOrMetaClass.	(cls notNil and: [ cls isTrait not ]) ifTrue: [ self systemNavigation browseVariableAssignments: cls ]! !!StringHolder methodsFor: '*Tools-traits' stamp: 'cmm 5/2/2011 09:45'!browseVariableReferences	| cls |	cls := self selectedClassOrMetaClass.	(cls notNil and: [cls isTrait not])		ifTrue: [self systemNavigation browseVariableReferences: cls]! !!StringHolder class methodsFor: 'instance creation' stamp: 'fbs 4/28/2010 18:53'!open	^ (Smalltalk at: #Workspace ifAbsent:[self]) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!StringHolder class methodsFor: 'instance creation' stamp: 'dtl 5/15/2011 20:46'!openLabel: aString	^self new openLabel: aString! !!StringHolder class methodsFor: 'yellow button menu' stamp: 'yo 6/23/2011 00:16'!yellowButtonMenuItems	"Returns the standard yellow button menu items"	^{			{'set font... (k)' translated.				#offerFontMenu}.			{'set style... (K)' translated.				#changeStyle}.			{'set alignment... (u)' translated.		#chooseAlignment}.			#-.			{'make project link (P)' translated.	#makeProjectLink}.			#-.			{'find...(f)' translated.					#find}.			{'find again (g)' translated.				#findAgain}.			{'set search string (h)' translated.		#setSearchString}.			#-.			{'do again (j)' translated.				#again}.			{'undo (z)' translated.					#undo}.			#-.			{'copy (c)' translated.					#copySelection}.			{'cut (x)' translated.						#cut}.			{'paste (v)' translated.					#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			     		{'print it (p)' translated.		#printIt}.		     		{'inspect it (i)' translated.		#inspectIt}.		     		{'explore it (I)' translated.		#exploreIt}.		     		{'debug it' translated.			#debugIt}.		     		{'button for it' translated.			#buttonForIt}.		     		{'tally it' translated.			#tallyIt}.			#-.			{'accept (s)' translated.					#accept}.			{'cancel (l)' translated.					#cancel}.			#-.			{'show bytecodes' translated.			#showBytecodes}.			#-.			{'copy html' translated.					#copyHtml}.			#-.			{'more...' translated.					#shiftedTextPaneMenuRequest}.		}! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:53'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [displayContents text]! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:55'!unacceptedEditState: stateOrNil	(hasUnacceptedEdits := stateOrNil notNil) ifTrue:		[self editString: stateOrNil]! !!StringMorph methodsFor: 'accessing' stamp: 'cao 2/28/2011 18:17'!contents: newContents 	| scanner |	contents := newContents isText				ifTrue: [scanner := StringMorphAttributeScanner new initializeFromStringMorph: self.					(newContents attributesAt: 1 forStyle: self font textStyle)						do: [:attr | attr emphasizeScanner: scanner].					emphasis := scanner emphasis.					font := scanner font.					color := scanner textColor.					newContents string]				ifFalse: [contents = newContents						ifTrue: [^ self].					"no substantive change"					newContents].	self fitContents! !!StringMorph methodsFor: 'connectors-layout' stamp: 'nk 4/29/2004 22:49'!minHeight"answer the receiver's minHeight"	^ super minHeight max: self fontToUse height! !!StringMorph methodsFor: 'menu' stamp: 'ul 8/23/2010 00:49'!changeFont		| chooser originalFont |	originalFont := self fontToUse.	self openModal: (		Cursor wait showWhile: [			| window |			window := UIManager default 				chooseFont: 'Choose a Font' 				for: self 				setSelector: #font: 				getSelector: originalFont.			"We have to save the model here, because it will be gone when the window is closed."			chooser := window model. 			window ]).	originalFont = self fontToUse ifFalse: [		"Ensure that we restore the original font in case it was changed, but Cancel was clicked."		self font: (chooser result ifNil: [ originalFont ]) ]! !!StringMorphEditor methodsFor: 'display' stamp: 'sw 4/20/2003 15:46'!initialize	"Initialize the receiver.  Give it a white background"	super initialize.	self backgroundColor: Color white.	self color: Color red! !!StringSocket methodsFor: 'private-IO' stamp: 'nice 3/31/2011 01:18'!purgeOutputQueue	bytesInOutputQueue := 0.	[outputQueue nextOrNil == nil] whileFalse.! !!StringTest methodsFor: 'tests - accessing' stamp: 'nice 10/5/2009 03:44'!testFindLastOccurenceOfStringStartingAt	self assert: ('Smalltalk' findLastOccurrenceOfString: 'al' startingAt: 2) = 7.	self assert: ('aaa' findLastOccurrenceOfString: 'aa' startingAt: 1) = 2.	self assert: ('Smalltalk' asWideString findLastOccurrenceOfString: 'al' startingAt: 2) = 7.	self assert: ('Smalltalk' asWideString findLastOccurrenceOfString: 'al' asWideString startingAt: 2) = 7.	self assert: (('Smalltalk' copyWith: 835 asCharacter) findLastOccurrenceOfString: 'al' asWideString startingAt: 2) = 7.! !!StringTest methodsFor: 'tests - converting' stamp: 'nice 11/17/2009 11:16'!testEncodeForHTTP	self assert: 'aa aa  aa aa' encodeForHTTP = 'aa%20aa%20%C3%A9%C3%A9%20aa%20aa'! !!StringTest methodsFor: 'tests - converting' stamp: 'KR 06/24/2005 11:21'!testPercentEncodingJa	| leading hiraA hiraO hiraAO encodedHiraA encodedHiraO encodedHiraAO |    "Make Japanese String from unicode. see http://www.unicode.org/charts/PDF/U3040.pdf"     leading := JapaneseEnvironment leadingChar.	hiraA := (Character leadingChar: leading code: 16r3042) asString.  "HIRAGANA LETTER A"	hiraO := (Character leadingChar: leading code: 16r304A) asString.  "HIRAGANA LETTER O"	hiraAO := hiraA, hiraO.	"Percent Encoded Japanese String"	encodedHiraA := hiraA encodeForHTTP.	self assert: encodedHiraA = '%E3%81%82'.	encodedHiraO := hiraO encodeForHTTP.	self assert: encodedHiraO = '%E3%81%8A'.	encodedHiraAO := hiraAO encodeForHTTP.	self assert: encodedHiraAO =  '%E3%81%82%E3%81%8A'.     "without percent encoded string"	self assert: '' unescapePercents = ''.	self assert: 'abc' unescapePercents = 'abc'.	"latin1 character"	self assert: hiraAO unescapePercents = hiraAO.  "multibyte character"	"encoded latin1 string"	self assert: '%61' unescapePercents = 'a'.	self assert: '%61%62%63' unescapePercents = 'abc'.	"encoded multibyte string"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: encodedHiraA unescapePercents = hiraA.		self assert: encodedHiraAO unescapePercents = hiraAO].	"mixed string"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: (encodedHiraAO,'a') unescapePercents = (hiraAO, 'a').		self assert: ('a', encodedHiraA) unescapePercents = ('a', hiraA).		self assert: ('a', encodedHiraA, 'b')  unescapePercents = ('a', hiraA, 'b').		self assert: ('a', encodedHiraA, 'b', encodedHiraO) unescapePercents = ('a', hiraA, 'b', hiraO).		self assert: (encodedHiraA, encodedHiraO, 'b', encodedHiraA) unescapePercents = (hiraA, hiraO, 'b', hiraA)].	"for Seaside"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: (encodedHiraA, '+', encodedHiraO) unescapePercents = (hiraA, ' ', hiraO)].! !!StringTest methodsFor: 'tests - converting' stamp: 'ul 9/11/2011 16:57'!testSubStrings	#("receiver (argument expectedResult argument expectedResult ...) ..."		'' ('' () ($a) () 'a' () 'ab' () 'aaa' ())		'a' ('' ('a') ($a) () 'a' () 'ab' () 'aaa' () ($b) ('a') 'b' ('a') 'bc' ('a'))		'aa' ('' ('aa') ($a) () 'a' () 'ab' () 'aaa' () ($b) ('aa') 'b' ('aa') 'bc' ('aa'))		'ab' ('' ('ab') ($a) ('b') 'a' ('b') 'ab' () 'aaa' ('b') ($b) ('a') 'b' ('a') 'bc' ('a'))		'ababa' ('' ('ababa') ($a) ('b' 'b') 'a' ('b' 'b') 'ab' () 'aaa' ('b' 'b') ($b) ('a' 'a' 'a') 'b' ('a' 'a' 'a') 'bc' ('a' 'a' 'a'))		'abbccba' ('' ('abbccba') ($a) ('bbccb') 'a' ('bbccb') 'ab' ('cc') 'aaa' ('bbccb') ($b) ('a' 'cc' 'a') 'b' ('a' 'cc' 'a') 'bc' ('a' 'a')))		pairsDo: [ :receiver :argumentsAndExpectedResults |			argumentsAndExpectedResults pairsDo: [ :argument :expectedResult |				self assert: expectedResult equals: (					receiver subStrings: argument) ] ]! !!StringTest methodsFor: 'tests - converting' stamp: 'ul 10/13/2009 00:55'!testWithBlanksTrimmed	| s |	self assert: ' abc  d   ' withBlanksTrimmed = 'abc  d'.	self assert: 'abc  d   ' withBlanksTrimmed = 'abc  d'.	self assert: ' abc  d' withBlanksTrimmed = 'abc  d'.	self assert: (((0 to: 255) collect: [ :each | each asCharacter ] thenSelect: [ :each | each isSeparator ]) as: String) withBlanksTrimmed = ''.	s := 'abcd'.	self assert: s withBlanksTrimmed = s.	self assert: s withBlanksTrimmed ~~ s.! !!StringTest methodsFor: 'tests - converting' stamp: 'nice 3/25/2011 22:49'!testWithNoLineLongerThan	"self run: #testWithNoLineLongerThan"	self assert: ('Hello World' withNoLineLongerThan: 5) = ('Hello', String cr, 'World').	self shouldnt: [String crlf withNoLineLongerThan: 5] raise: Error.	self shouldnt: [('Hello', String cr, String cr,'World') withNoLineLongerThan: 5] raise: Error.	self assert: ('Sample text to line break at some point' withNoLineLongerThan:  28)		= ('Sample text to line break at', String cr, 'some point').	self assert: ('Sample text', String cr, 'to line break', String cr, 'at some point' withNoLineLongerThan:  28)		= ('Sample text', String cr, 'to line break', String cr, 'at some point').! !!StringTest methodsFor: 'tests - comparing' stamp: 'lr 7/7/2006 11:32'!testComparing	self assert: 'foo' < 'foo:'.	self assert: 'foo' < 'fooBar'.	self assert: 'foo' <= 'foo:'.	self assert: 'foo' <= 'fooBar'.	self assert: 'foo:' > 'foo'.	self assert: 'fooBar' > 'foo'.	self assert: 'foo:' >= 'foo'.	self assert: 'fooBar' >= 'foo'! !!StringTest methodsFor: 'tests - comparing' stamp: 'nice 1/18/2010 14:54'!testEquality	self assert: 'abc' = 'abc' asWideString.	self assert: 'abc' asWideString = 'abc'.	self assert: (#[ 97 0 0 0 ] asString ~= 'a000' asWideString).	self assert: ('a000' asWideString ~= #[ 97 0 0 0 ] asString).	self assert: ('abc' sameAs: 'aBc' asWideString).	self assert: ('aBc' asWideString sameAs: 'abc').	self assert: (#[ 97 0 0 0 ] asString 						sameAs: 'Abcd' asWideString) not.	self assert: ('a000' asWideString sameAs: 					#[ 97 0 0 0 ] asString) not.! !!StringTest methodsFor: 'tests - comparing' stamp: 'ul 1/15/2011 13:30'!testMatch	#('**' 'f**'  'f**o' 'f*' '*f*' 'f#*' 'f##' '*oo' '#oo' '*o*' '#o#' '#o*' '*o#' 'fo*' 'fo#' '*foo*' '###' '*#'  'f*#' 'f*#o')		do: [ :each | self assert: (each match: 'foo') ].	#('bar' 'foo#' '#foo' '*foo#' '#foo*' '*bar*') do: [ :each |		self deny: (each match: 'foo') ]! !!StringTest methodsFor: 'tests - formatting' stamp: 'ul 2/10/2011 22:53'!testExpandMacrosWithArguments	| patterns |	patterns := {		"Input - Expected output"		#('' '').		#('foo' 'foo').		{ '<N>'. String cr }.		{ '<T>'. String tab }.		{ '<n>'. String cr }.		{ '<t>'. String tab }.		#('%>' '>').		#('%<' '<').		#('%%' '%').		#('%a' 'a').		#('%A' 'A').		#('<1S>' 'foo').		#('<1s>' 'foo').		#('<10S>' '10').		#('<10s>' '10').		#('<2P>' '1').		#('<3p>' 'true').		#('<10P>' '''10''').		#('<11p>' '11').		#('<3?ab:cde>' 'ab').		#('<4?ab:cde>' 'cde') }.	"Test all possible 3 long sequences of the above patterns. Since the patterns include	the empty string, all 1 and 2 long sequences will be tested too."	patterns do: [ :first |		patterns do: [ :second |			patterns do: [ :third |				| result |				result := first first, second first, third first expandMacrosWithArguments: #('foo' 1 true false 5 6 7 8 9 '10' 11).				self assert: first second, second second, third second equals: result ] ] ].	"Test some malformed inputs too."	#('%' '<' '<N' '<T' '<1T' '<>' '<N><' '<1st' '<A' '<1Phello>' '<1?abcd>' '<?a:b>') do: [ :each |		self should: [ each expandMacrosWithArguments: #() ] raise: Error ]! !!StringTest methodsFor: 'tests - formatting' stamp: 'ul 10/13/2009 01:23'!testFormat	{ 		[ '\{ \} \\ foo {1} bar {2}' format: { 12. 'string' } ] -> '{ } \ foo 12 bar string'.		[ '\{ \} \\ foo {2} bar {1}' format: { 'string'. 12 } ] -> '{ } \ foo 12 bar string'.		[ '\{1}' format: {} ] -> '{1}'.		[ '\{1}{1}' format: { $a } ] -> '{1}a'.	} do: [ :each |		self assert: each key value = each value ]! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 9/11/2011 16:54'!testFindTokens	#("receiver (argument expectedResult argument expectedResult ...) ..."		'' ('' () $a () 'a' () 'ab' () 'aaa' ())		'a' ('' ('a') $a () 'a' () 'ab' () 'aaa' () $b ('a') 'b' ('a') 'bc' ('a'))		'aa' ('' ('aa') $a () 'a' () 'ab' () 'aaa' () $b ('aa') 'b' ('aa') 'bc' ('aa'))		'ab' ('' ('ab') $a ('b') 'a' ('b') 'ab' () 'aaa' ('b') $b ('a') 'b' ('a') 'bc' ('a'))		'ababa' ('' ('ababa') $a ('b' 'b') 'a' ('b' 'b') 'ab' () 'aaa' ('b' 'b') $b ('a' 'a' 'a') 'b' ('a' 'a' 'a') 'bc' ('a' 'a' 'a'))		'abbccba' ('' ('abbccba') $a ('bbccb') 'a' ('bbccb') 'ab' ('cc') 'aaa' ('bbccb') $b ('a' 'cc' 'a') 'b' ('a' 'cc' 'a') 'bc' ('a' 'a')))		pairsDo: [ :receiver :argumentsAndExpectedResults |			argumentsAndExpectedResults pairsDo: [ :argument :expectedResult |				self assert: expectedResult asOrderedCollection equals: (					receiver findTokens: argument) ] ]! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:05'!testFindTokensEscapedBy01	| tokens |	string := 'this, is, "a, test"'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 3! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'fbs 2/13/2006 22:20'!testFindTokensEscapedBy02	| tokens |	string := ''.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens isEmpty! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:05'!testFindTokensEscapedBy03	| tokens |	string := 'this, is, a, test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 4! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:05'!testFindTokensEscapedBy04	| tokens |	string := 'this, is, a"," test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy05	| tokens |	string := 'this, /is, a"," test/'.	tokens := string findTokens: ',#' escapedBy: '"/'.	self assert: tokens size = 2.	self assert: tokens first = 'this'.	self assert: tokens second = ' is, a"," test'.! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy06	| tokens |	string := 'this, is, "a, test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy07	| tokens |	string := 'a:b::c'.	tokens := string findTokens: ':' escapedBy: '"'.	self assert: tokens size = 4.	self assert: tokens first = 'a'.	self assert: tokens second = 'b'.	self assert: tokens third = ''.	self assert: tokens fourth = 'c'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy08	| tokens |	string := 'this, is, ##a, test'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size = 4.	self assert: tokens third = ' a'.	self assert: tokens fourth = ' test'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy09	| tokens |	string := 'this, is, ###a, test#'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size = 3.	self assert: tokens third = ' #a, test'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy10	| tokens |	string := 'this, is, ###a, test'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size = 3.	self assert: tokens third = ' #a, test'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy11	| tokens |	string := 'this, is, """a, test"'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 3.	self assert: tokens third = ' "a, test'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy12	| tokens |	string := 'one, two# three; four. five'.	tokens := string findTokens: ',#;.' escapedBy: '"'.	self assert: tokens size = 5.	self assert: tokens third = ' three'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy13	| tokens |	string := 'one, two# three; four. five'.	tokens := string findTokens: ',#;.' escapedBy: nil.	self assert: tokens size = 5.	self assert: tokens third = ' three'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy14	| tokens |	string := 'one, "two# three"; &four. five&'.	tokens := string findTokens: ',#;.' escapedBy: '"&'.	self assert: tokens size = 3.	self assert: tokens second = ' two# three'.	self assert: tokens third = ' four. five'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy15	| tokens |	string := 'one, "two# three"; &four. five&'.	tokens := string findTokens: nil escapedBy: '"&'.	self assert: tokens size = 1.	self assert: tokens first = 'one, two# three; four. five'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy16	| tokens |	string := 'one, "two# three"; &four. five&'.	tokens := string findTokens: nil escapedBy: nil.	self assert: tokens size = 1.	self assert: tokens first = string! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy21	| tokens |	string := 'this, is, "a, test"'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 3! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy22	| tokens |	string := ''.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 0! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy23	| tokens |	string := 'this, is, a, test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 4! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy24	| tokens |	string := 'this, is, a"," test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'fbs 2/13/2006 22:19'!testFindTokensEscapedBy25	| tokens |	string := 'this, /is, a"," test/'.	tokens := string findTokens: $, escapedBy: $/.	self assert: tokens size = 2.	self assert: tokens first = 'this'.	self assert: tokens second = ' is, a"," test'.! !!StringTest methodsFor: 'tests - tokenizing' stamp: 'ul 11/15/2010 12:06'!testFindTokensEscapedBy26	| tokens |	string := 'this, is, "a, test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'tests - lines' stamp: 'nice 11/16/2009 13:22'!testLineCorrespondingToIndex	| sampleCRString sampleLFString sampleCRLFString anIndex |	sampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.	sampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.	sampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.		anIndex := sampleCRString indexOf: $h.	self assert: (sampleCRString lineCorrespondingToIndex: anIndex) = 'the'.	anIndex := sampleLFString indexOf: $h.	self assert: (sampleLFString lineCorrespondingToIndex: anIndex) = 'the'.	anIndex := sampleCRLFString indexOf: $h.	self assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) = 'the'.		anIndex := sampleCRString indexOf: $B.	self assert: (sampleCRString lineCorrespondingToIndex: anIndex) = 'Bear'.	anIndex := sampleLFString indexOf: $B.	self assert: (sampleLFString lineCorrespondingToIndex: anIndex) = 'Bear'.	anIndex := sampleCRLFString indexOf: $B.	self assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) = 'Bear'.		anIndex := sampleCRString indexOf: $d.	self assert: (sampleCRString lineCorrespondingToIndex: anIndex) = 'Fred'.	anIndex := sampleLFString indexOf: $d.	self assert: (sampleLFString lineCorrespondingToIndex: anIndex) = 'Fred'.	anIndex := sampleCRLFString indexOf: $d.	self assert: (sampleCRLFString lineCorrespondingToIndex: anIndex) = 'Fred'.! !!StringTest methodsFor: 'tests - lines' stamp: 'nice 11/16/2009 13:13'!testLineCount	| sampleCRString sampleLFString sampleCRLFString |	sampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.	sampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.	sampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.		self assert: sampleCRString lineCount = 3.	self assert: sampleLFString lineCount = 3.	self assert: sampleCRLFString lineCount = 3.! !!StringTest methodsFor: 'tests - lines' stamp: 'nice 11/16/2009 13:14'!testLineNumber	| sampleCRString sampleLFString sampleCRLFString |	sampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.	sampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.	sampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.		self assert: (sampleCRString lineNumber: 2) = 'the'.	self assert: (sampleLFString lineNumber: 2) = 'the'.	self assert: (sampleCRLFString lineNumber: 2) = 'the'.! !!StringTest methodsFor: 'tests - lines' stamp: 'nice 11/16/2009 13:19'!testLinesDo	| sampleCRString sampleLFString sampleCRLFString lines |	sampleCRString := 'Fred', String cr , 'the' , String cr , 'Bear'.	sampleLFString := 'Fred', String lf , 'the' , String lf , 'Bear'.	sampleCRLFString := 'Fred', String crlf , 'the' , String crlf , 'Bear'.		lines := OrderedCollection new.	sampleCRString linesDo: [:aLine |		self deny: (aLine includes: Character cr).		self deny: (aLine includes: Character lf).		lines add: aLine].	self assert: lines asArray = #('Fred' 'the' 'Bear').		lines := OrderedCollection new.	sampleLFString linesDo: [:aLine |		self deny: (aLine includes: Character cr).		self deny: (aLine includes: Character lf).		lines add: aLine].	self assert: lines asArray = #('Fred' 'the' 'Bear').	lines := OrderedCollection new.	sampleCRLFString linesDo: [:aLine |		self deny: (aLine includes: Character cr).		self deny: (aLine includes: Character lf).		lines add: aLine].	self assert: lines asArray = #('Fred' 'the' 'Bear').! !!StringTest methodsFor: 'tests - lines' stamp: 'nice 11/16/2009 22:26'!testWthNoLineLongerThan	| phrases |	phrases := {		'Fred the bear went down to the brook to read his book in silence'.		'Fred the bear went down' , String cr , ' to the brook to ' , String cr , 'read his book in silence'.		'Fred the bear went down' , String lf , '  to the brook to ' , String lf , 'read his book in silence'.		'Fred the bear went down' , String crlf , '  to the brook to ' , String crlf , 'read his book in silence'.		}.	#(5 7 9) do: [:length |		phrases do: [:phrase |			| split |			split := phrase withNoLineLongerThan: length.			self				assert: (split copyWithoutAll: CharacterSet separators) = (phrase copyWithoutAll: CharacterSet separators)				description: 'no information should be lost'.			split linesDo: [:line |				self assert: line size <= length description: 'lines should not be longer than prescribed'].			phrase lineCount = 1 ifTrue: [| lastLineSize |				lastLineSize := length.				split linesDo: [:line |					line isEmpty ifFalse: [| firstWordSize |						firstWordSize := line indexOfAnyOf: CharacterSet separators startingAt: 1 ifAbsent: [line size + 1].						self assert: (lastLineSize + firstWordSize) > length description: 'split was too short'.						lastLineSize := line size]]]]]! !!StringTest methodsFor: 'tests - instance creation' stamp: 'dc 3/21/2007 11:22'!testSpace	"self debug: #testSpace"		string := String new.	self assert: string size = 0. "instead of #isEmpty to be consistent with the following test"		string := String space.	self assert: string size = 1.	self assert: string = ' '! !!StringTest methodsFor: 'tests - internet' stamp: 'ul 11/23/2009 14:39'!testWithInternetLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String crlf).		'abc', String lf -> ('abc', String crlf).		'abc', String crlf -> ('abc', String crlf).		String cr, 'abc' -> (String crlf, 'abc').		String lf, 'abc' -> (String crlf, 'abc').		String crlf, 'abc' -> (String crlf, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String crlf, String crlf, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String crlf, String crlf, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String crlf, String crlf, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String crlf, 'abc', String crlf, String crlf, 'abc', String crlf).	} do: [ :each |		self assert: each key withInternetLineEndings = each value ]! !!StringTest methodsFor: 'tests - internet' stamp: 'nice 1/18/2010 23:33'!testWithSqueakLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String cr).		'abc', String lf -> ('abc', String cr).		'abc', String crlf -> ('abc', String cr).		String cr, 'abc' -> (String cr, 'abc').		String lf, 'abc' -> (String cr, 'abc').		String crlf, 'abc' -> (String cr, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String cr, String cr, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String cr, String cr, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String cr, String cr, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String cr, 'abc', String cr, String cr, 'abc', String cr).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String cr, 'abc', String cr, String cr, 'abc', String cr).	} do: [ :each |		self assert: each key withSqueakLineEndings = each value ]! !!StringTest methodsFor: 'tests - internet' stamp: 'nice 1/18/2010 23:35'!testWithUnixLineEndings	{		'abc' -> 'abc'.		'abc', String cr -> ('abc', String lf).		'abc', String lf -> ('abc', String lf).		'abc', String crlf -> ('abc', String lf).		String cr, 'abc' -> (String lf, 'abc').		String lf, 'abc' -> (String lf, 'abc').		String crlf, 'abc' -> (String lf, 'abc').		'abc', String cr, String cr, 'abc' -> ('abc', String lf, String lf, 'abc').		'abc', String lf, String lf, 'abc' -> ('abc', String lf, String lf, 'abc').		'abc', String crlf, String crlf, 'abc' -> ('abc', String lf, String lf, 'abc').		String cr, 'abc', String cr, String crlf, 'abc', String lf -> (String lf, 'abc', String lf, String lf, 'abc', String lf).		String lf, 'abc', String lf, String crlf, 'abc', String cr -> (String lf, 'abc', String lf, String lf, 'abc', String lf).	} do: [ :each |		self assert: each key withUnixLineEndings = each value ]! !!StringTest methodsFor: 'tests - internet' stamp: 'ul 11/16/2010 06:29'!testWithoutQuoting	#(		'"foo"' 'foo'		'''foo''' 'foo'		'"foo''' '"foo'''		'''foo"' '''foo"'		'"foo' '"foo'		'foo"' 'foo"'		'foo' 'foo') pairsDo: [ :before :after |			self assert: before withoutQuoting = after ]! !!SubClassForBehaviorTest methodsFor: 'accessing' stamp: 'nice 5/7/2011 13:58'!iv2: anyObject	iv2 := anyObject printString! !!SubClassForBehaviorTest methodsFor: 'accessing' stamp: 'nice 5/7/2011 13:58'!resetIV1	iv1 := nil! !!SubClassForBehaviorTest class methodsFor: 'accessing' stamp: 'nice 5/7/2011 14:14'!install	civ1 := true! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:42'!testSummingColors	"self run: #testSummingColors"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	}.	cases do: [ :each |		self assert: ((Array with: each) sum = each) 	].! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:42'!testSummingToTen	"self run: #testSummingToTen"	| cases |	cases :={ 		{ 1 . 2 . 3 . 4 }.		{ 2.0 . 2.0 . 2.0 . 2.0 . 2.0  }.		{ 2/5 . 5/2 . 5/2 . 3/5 . 4 } 	} .	cases do: [ :each |		self assert: (each  sum = 10 )	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:43'!testSummingToWhite	"self run: #testSummingToWhite"	| cases |	cases := { 		{ Color black . Color white }.		{ Color red . Color green. Color blue }.		{ Color gray . Color gray }.		{ Color cyan. Color magenta. Color yellow }.		{ Color cyan. Color magenta.  }.		{  Color magenta. Color yellow }.		{ Color cyan.  Color yellow }.		{ Color cyan. Color red }.		{ Color green .Color magenta.  }.		{ Color blue. Color yellow }.	} .	cases do: [ :each |		self assert: (each  sum = Color white) 	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:44'!testSummingWithBlack	"self run: #testSummingWithBlack"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	}.	cases do: [ :each |		self assert: ((Array with: each with: Color black) sum = each) 	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:45'!testSummingWithWhite	"self run: #testSummingWithWhite"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	} .	cases do: [ :each |		self assert: ((Array with: Color white with: each ) sum = Color white) 	] .! !!Symbol methodsFor: 'testing' stamp: 'ul 11/15/2010 10:07'!isInfix	"Answer whether the receiver is an infix message selector."	^ self precedence = 2! !!Symbol methodsFor: 'testing' stamp: 'ul 11/15/2010 10:07'!isKeyword	"Answer whether the receiver is a message keyword."	^ self precedence = 3! !!Symbol methodsFor: 'testing' stamp: 'ul 11/15/2010 10:07'!isUnary	"Answer whether the receiver is an unary message selector."	^ self precedence = 1! !!Symbol methodsFor: 'evaluating' stamp: 'ul 11/2/2010 18:23'!cull: anObject 	^anObject perform: self! !!Symbol class methodsFor: 'access' stamp: 'ul 11/15/2010 10:07'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	(aString first isLetter or: [aString first isDigit]) ifFalse:		[			aString size = 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'eem 5/22/2008 12:56'!selectorsMatching: aStringPattern	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.	 Does return symbols that begin with a capital letter."	| selectorList |	selectorList := OrderedCollection new.	aStringPattern isEmpty ifTrue: [^selectorList].	self allSymbolTablesDo:		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"		[:each | each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]	"Symbol selectorsMatching: 'parse:*'"! !!Symbol class methodsFor: 'class initialization' stamp: 'ul 9/12/2010 03:25'!allSymbolTablesDo: aBlock after: aSymbol	(NewSymbols includes: aSymbol) 		ifTrue: [			NewSymbols do: aBlock after: aSymbol.			SymbolTable do: aBlock after: aSymbol ]		ifFalse: [			SymbolTable do: aBlock after: aSymbol.			NewSymbols do: aBlock after: aSymbol ]	! !!Symbol class methodsFor: 'class initialization' stamp: 'ul 4/13/2010 00:00'!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols with 25% free space."	| oldSize |	Smalltalk garbageCollect.	oldSize := SymbolTable capacity.	SymbolTable compact.	^(oldSize - SymbolTable capacity) printString, ' slot(s) reclaimed'! !!SyntaxError methodsFor: 'accessing' stamp: 'sd 11/20/2005 21:27'!category: aSymbol	"Record the message category of method being compiled. This is used when the user corrects the error and accepts."	category := aSymbol.! !!SyntaxError methodsFor: 'accessing' stamp: 'nice 2/23/2011 21:50'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class := aClass.	debugger := aDebugger.	selector := aClass newParser parseSelector: aString.	types := Scanner classPool at: #TypeTable.	"dictionary"	printables := '!!@#$%&*-_=+<>{}?/\,`~`' asSet.	badChar := aString detect: [:aChar | (types at: aChar asciiValue ifAbsent: [#xLetter]) == #xBinary and: [			(printables includes: aChar) not]] ifNone: [nil].	contents := badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString].	category ifNil: [category := aClass organization categoryOfElement: selector].	category ifNil: [category := ClassOrganizer default].	doitFlag := flag! !!SyntaxError methodsFor: 'initialize-release' stamp: 'laza 1/26/2011 13:31'!release	| p |	(debugger isNil or: [		(p := debugger interruptedProcess) isNil or: [			p isTerminated]]) ifTrue: [^self].	p terminate! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'nice 12/29/2010 16:51'!standardInset	parseNode class == BlockNode ifTrue: [^ 5 @ 1].		"allow pointing beside a line so can replace it"	^ self alansTest1 ifTrue: [1] ifFalse: [-1]! !!SyntaxMorph methodsFor: 'drawing' stamp: 'nice 12/29/2010 16:52'!drawOn: aCanvas	super drawOn: aCanvas.	self isBlockNode ifFalse: [^self].	self alansTest1 ifTrue: [^self].	self immediatelyBelowTheMethodNode ifTrue: [		aCanvas fillRectangle: (self topLeft + (0 @ -1) extent: self width @ 1) color: Color gray	] ifFalse: [		aCanvas fillRectangle: (self topLeft + (1 @ 1) extent: 2 @ (self height-2)) color: Color gray.		aCanvas fillRectangle: (self topLeft + (1 @ 1) extent: 4 @ 1) color: Color gray.		aCanvas fillRectangle: (self bottomLeft + (1 @ -1) extent: 4 @ 1) color: Color gray	].! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'nice 5/8/2011 12:22'!structureMatchWith: aMorph	| meNoun itNoun |	"Return true if the node types would allow aMorph to replace me.  This tests the gross structure of the method only."	meNoun := self isNoun.	itNoun := aMorph isNoun.	"Consider these nouns to be equal:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	meNoun & itNoun ifTrue: [^ true].	meNoun & aMorph isBlockNode ifTrue: [^ true].	"If I am a BlockNode, and it is a TempVariableNode, add it into list"	"If I am a BlockNode, and it is a noun, add it as a new line"	self isBlockNode ifTrue:		[itNoun ifTrue: [^ true].		(aMorph nodeClassIs: ReturnNode) ifTrue:			[^ self submorphs				noneSatisfy: [:mm | (mm isSyntaxMorph) and: [mm nodeClassIs: ReturnNode]]].	"none already in this block"				"If I am a BlockNode, and it is a ReturnNode, add to end"		(aMorph nodeClassIs: CommentNode) ifTrue: [^ true]].	(self isMethodNode) ifTrue: [^ false].	"Later add args and keywords"		"Later allow comments to be dropped in"		"Add MethodTemps by dropping into the main block"	(self nodeClassIs: ReturnNode) & (aMorph parseNode class == MessageNode) 		ifTrue: [^ true].		"Command replace Return"	(self nodeClassIs: MessageNode) & (aMorph parseNode class == ReturnNode) ifTrue: [		(owner submorphs select: [:ss | ss isSyntaxMorph]) last == self			ifTrue: [^ true]].	"Return replace last command"	(aMorph nodeClassIs: AssignmentNode) ifTrue: [		itNoun ifFalse: ["create a new assignment"			^ self isAVariable & self isDeclaration not]].	"only assign to a variable"	"If nodes are of equal class, replace me with new one."	(self nodeClassIs: aMorph parseNode class) ifTrue: [		(self nodeClassIs: MessageNode) 				ifFalse: [^ true]	"normal match"				ifTrue: [^ self receiverNode == aMorph receiverNode]].	"both nil"	^ false "otherwise reject"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'fbs 12/22/2010 07:25'!replaceKeyWord: evt menuItem: stringMorph	"Replace my entire message (which may be multi-part) with the one specified.  Preserve all argument tiles, either in the new message or in the world outside the scriptor.  I am a SelectorNode or KeyWordNode."	| menu new news newSel mm newTree newRec newArgs top oldArgNodes share ctrY |	(menu := stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new := stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news := String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: {' 5'. Character space.}) do: [:part | strm nextPutAll: part]].	newSel := stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel := news].	mm := MessageSend receiver: 5 selector: newSel 			arguments: ((Array new: newSel numArgs) atAllPut: 5).	newTree := mm asTilesIn: Object globalNames: false.	newRec := newTree receiverNode.	newArgs := newTree argumentNodes.	ctrY := self fullBoundsInWorld center y.	top := self messageNode.	newRec owner replaceSubmorph: newRec by: top receiverNode.	oldArgNodes := top argumentNodes.	share := newArgs size min: oldArgNodes size.	(newArgs first: share) with: (oldArgNodes first: share) do: [:newNode :oldNode | 		newNode owner replaceSubmorph: newNode by: oldNode].	"later get nodes for objects of the right type for new extra args"	top owner replaceSubmorph: top by: newTree.	"Deposit extra args in the World"	(oldArgNodes copyFrom: share+1 to: oldArgNodes size) do: [:leftOver |		(leftOver parseNode class == LiteralNode and: [leftOver decompile asString = '5']) 			ifFalse: [newTree pasteUpMorph addMorphFront: leftOver.				leftOver position: newTree enclosingPane fullBoundsInWorld right - 20 @ ctrY.				ctrY := ctrY + 26]			ifTrue: [leftOver delete]].	newTree acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'fbs 12/22/2010 07:25'!replaceSel: evt menuItem: stringMorph	"I rep a SelectorNode.  Replace my selector with new one that was just chosen from a menu"	| menu new old newSel ms oa na case news |	(menu := stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new := stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news := String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: {' 5'. Character space.}) do: [:part | strm nextPutAll: part]].	newSel := stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel := news].	old := (ms := self findA: StringMorph) valueOfProperty: #syntacticallyCorrectContents.	old ifNil: [old := (self findA: StringMorph) contents].	oa := old numArgs.  na := newSel numArgs.  case := 5.	(oa = 1) & (na = 1) ifTrue: [case := 1]. 	(oa = 0) & (na = 0) ifTrue: [case := 2].	(oa = 1) & (na  = 0) ifTrue: [case := 3].	(oa = 0) & (na  = 1) ifTrue: [case := 4].	case <= 4 ifTrue: ["replace the selector"		ms contents: news.	"not multi-part"		ms setProperty: #syntacticallyCorrectContents toValue: newSel].	case = 3 ifTrue: [owner tossOutArg: 1].	case = 4 ifTrue: [self addArg: 1].	"more cases here.  Rebuild the entire MessageNode"		self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'nice 12/29/2010 16:52'!selectorMenuAsk: listOfLists	"I represent a SelectorNode to be replaced by one of the selectors in one of the category lists.  Each list has pre-built StringMorphs in it."	| menu |	listOfLists isEmpty ifTrue: [^ nil].	listOfLists first addFirst: (self aSimpleStringMorphWith: '( Cancel )').	listOfLists first first color: Color red.	menu := RectangleMorph new.	menu listDirection: #leftToRight; layoutInset: 3; cellInset: 1 @ 0.	menu layoutPolicy: TableLayout new; hResizing: #shrinkWrap; 		vResizing: #shrinkWrap; color: (Color r: 0.767 g: 1.0 b: 0.767);		useRoundedCorners; cellPositioning: #topLeft.	listOfLists do: [:ll | | col |		col := Morph new.	 	col listDirection: #topToBottom; layoutInset: 0; cellInset: 0 @ 0.		col layoutPolicy: TableLayout new; hResizing: #shrinkWrap.		col color: Color transparent; vResizing: #shrinkWrap.		menu addMorphBack: col.		ll do: [:ss | 			col addMorphBack: ss.			ss on: #mouseUp send: #replaceKeyWord:menuItem: to: self]		].	self world addMorph: menu.	menu setConstrainedPosition: (owner localPointToGlobal: self topRight) + (10 @ -30) 			hangOut: false.! !!SyntaxMorph methodsFor: 'type checking' stamp: 'nice 3/31/2011 01:18'!receiverOrArgTypeAbove	"Return the type for me according to the message that encloses me."	| enclosing sub list |	(self nodeClassIs: BlockNode) ifTrue: [^#command].	enclosing := owner.	sub := self.		[enclosing isSyntaxMorph ifFalse: [^#unknown].	(enclosing nodeClassIs: MessageNode) 		ifTrue: 			[list := enclosing submorphs 						select: [:ss | ss isSyntaxMorph and: [ss parseNode notNil]].			list size = 1 				ifFalse: 					[^(list indexOf: sub) = 1 						ifTrue: [enclosing receiverTypeFor: enclosing selector]						ifFalse: [enclosing argTypeFor: enclosing selector]]].	(enclosing nodeClassIs: BlockNode) ifTrue: [^#command].	sub := enclosing.	enclosing := enclosing owner] repeat! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'nice 12/29/2010 16:51'!standardInset	^ self alansTest1 ifTrue: [1] ifFalse: [-1 @ -1]! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'ul 6/17/2011 12:31'!testAll	| systNav total count|"SyntaxMorph testAll"	systNav := self systemNavigation.	count := total := 0.	systNav allBehaviorsDo: [ :aClass | total := total + 1].'Testing all behaviors'	displayProgressFrom: 0 to: total	during: [ :bar |		systNav allBehaviorsDo: [ :aClass |			bar value: (count := count + 1).			aClass methodsDo: [ :m |				| source tree |				source := m getSourceFromFile.				tree := Compiler new 					parse: source 					in: aClass 					notifying: nil.				tree asMorphicSyntaxUsing: SyntaxMorph.			].		].	].! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'ul 6/17/2011 12:31'!testAllMethodsOver: methodSize 	"MessageTally spyOn: [SyntaxMorph testAllMethodsOver: 600]"	"Add up the total layout area for syntax morphs representing all  	methods over the given size. This is a stress-test for SyntaxMorph  	layout. A small value for the total area is also a figure of merit in the  	presentation of Squeak source code in general."	"Results:  	#(69 600 180820874 103700) 11/4  	70% build morphs, 12% get source, 9% layout, 8% parse, 1% roundoff  	Folded wide receivers, don't center keywords any more.  	#(68 600 160033784 127727) 11/9  	76% build morphs, 8% get source, 8% layout, 8% parse, 0% roundoff  	Folded more messages, dropped extra vertical spacing in blocks.  	#(68 600 109141704 137308) 11/10  	79% build morphs, 6% get source, 8% layout, 7% parse  	Folded more messages, dropped extra horizontal spacing.  	#(68 600 106912968 132171) 11/10  	80% build morphs, ??% get source, 11% layout, 7% parse  	Unfolded keyword messages that will fit on one line.  	#(68 600 96497372 132153) 11/10  	81% build morphs, ??% get source, 8% layout, 8% parse  	After alignment rewrite...  	#(74 600 101082316 244799) 11/12  	76% build morphs, 4% get source, 15% layout, 5% parse  	After alignment rewrite...  	#(74 600 101250620 204972) 11/15  	74% build morphs, 6% get source, 13% layout, 7% parse  	"	| biggies stats area |	biggies := self systemNavigation 				allMethodsSelect: [:cm | cm size > methodSize].	stats := OrderedCollection new.	'Laying out all ' , biggies size printString , ' methods over ' , methodSize printString , ' bytes...'		displayProgressFrom: 1		to: biggies size		during: [:bar | biggies				withIndexDo: [:methodRef :i | | time | 					bar value: i.					Utilities						setClassAndSelectorFrom: methodRef						in: [:aClass :aSelector | | source | 							source := (aClass compiledMethodAt: aSelector) getSourceFromFile.							time := Time										millisecondsToRun: [ | tree morph |											tree := Compiler new														parse: source														in: aClass														notifying: nil.											morph := tree asMorphicSyntaxUsing: SyntaxMorph.											area := morph fullBounds area]].					stats add: {methodRef. area. time}]].	^ {{			biggies size.			methodSize.			stats detectSum: [:a | a second].			stats detectSum: [:a | a third]		}.		stats asArray sort: [:x :y | x third >= y third]}! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 10:30'!change: changeBlock verify: verifyBlock	self prepare: [] change: changeBlock verify: verifyBlock! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 12/8/2011 14:06'!expectedFailures	^#(		#testCategoryModified		#testClassReorganized		#testProtocolModified	)! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 12/14/2011 09:52'!prepare: prepareBlock change: changeBlock verify: verifyBlock	"All tests follow this pattern. Beware that prepareBlock (and verifyBlock) will be evalutated twice."		"Setup the testcourt"	prepareBlock value.		"Embrace the changeBlock so that any change to our testcourt	will be recorded in our temporary changes file"	self useTemporaryChangesFile.	changeBlock value.	"Check if the changes we made worked as expected. We need to do	this before we switch back to the standard changes file"	"We raise an Error if this fails, because then the testcase is broken"	[verifyBlock value]		on: TestFailure		do: [self error: 'The verifyBlock needs to validate the changes made in the changeBlock'].	self useStandardChangesFile.	"Remove the testcourt completely"	self removeTestcourt.	"Setup the testcourt once again"	prepareBlock value.	"Replay the changes from the temporary changes file"	self replayChanges.	"See if we got the same changes as we did before using the changeBlock"	verifyBlock value.! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 15:05'!testCategoryAdded	| aClassCategory |	aClassCategory := self genericClassCategory.	self		change: [			SystemOrganization addCategory: aClassCategory.		]		verify: [			self assert: (SystemOrganization categories includes: aClassCategory).		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/3/2011 07:59'!testCategoryAddedBefore	| aClassCategory |	aClassCategory := self genericClassCategory.	self		change: [			SystemOrganization addCategory: aClassCategory before: nil.		]		verify: [			self assert: (SystemOrganization categories includes: aClassCategory).		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 15:03'!testCategoryRemoved	| aClassCategory |	aClassCategory := self genericClassCategory.	self		prepare: [			SystemOrganization addCategory: aClassCategory.		]		change: [			SystemOrganization removeCategory: aClassCategory.		]		verify: [			self deny: (SystemOrganization categories includes: aClassCategory).		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 15:01'!testCategoryRenamed	| aNewClassCategory anOldClassCategory |	anOldClassCategory := self genericClassCategory.	aNewClassCategory := self genericClassCategory.	self		prepare: [			SystemOrganization addCategory: anOldClassCategory.		]		change: [			SystemOrganization renameCategory: anOldClassCategory toBe: aNewClassCategory		]		verify: [			self assert: (SystemOrganization categories includes: aNewClassCategory).			self deny: (SystemOrganization categories includes: anOldClassCategory).		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 15:06'!testClassAdded	| aClassName |	aClassName := self genericClassName.	self		change: [			self createClass: aClassName.		]		verify: [			self assert: (Smalltalk keys includes: aClassName).		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 12:00'!testClassCommented	| aClass aClassName aComment |	aClassName := self genericClassName.	self		prepare: [			aClass := self createClass: aClassName.		]		change: [			aComment := self randomString.			aClass classComment: aComment.		]		verify: [			self assert: aClass organization classComment string = aComment.		].! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 12:37'!testClassModified	| aClass aClassName aInstVarName |	aClassName := self genericClassName.	self		prepare: [			aClass := self createClass: aClassName.		]		change: [			aInstVarName := self genericInstVarName.			aClass addInstVarName: aInstVarName.		]		verify: [			self assert: (aClass instVarNames includes: aInstVarName).		].! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/8/2011 14:26'!testClassRecategorized	| aClassName aNewClassCategory |	aClassName := self genericClassName.	aNewClassCategory := self genericClassCategory.	self		prepare: [			self createClass: aClassName.			SystemOrganization addCategory: aNewClassCategory.		]		change: [			SystemOrganization classify: aClassName under: aNewClassCategory.		]		verify: [			self assert: (SystemOrganization categoryOfElement: aClassName) = aNewClassCategory.		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 14:57'!testClassRemoved	| aClass aClassName |	aClassName := self genericClassName.	self		prepare: [			aClass := self createClass: aClassName.		]		change: [			aClass removeFromSystem.		]		verify: [			self deny: (Smalltalk keys includes: aClassName).		].! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 15:01'!testClassRenamed	| aClass aNewClassName anOldClassName |	anOldClassName := self genericClassName.	aNewClassName := self genericClassName.	self		prepare: [			aClass := self createClass: anOldClassName.		]		change: [			aClass rename: aNewClassName.		]		verify: [			self assert: (Smalltalk keys includes: aNewClassName).			self deny: (Smalltalk keys includes: anOldClassName).		].! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 14:53'!testExpressionDoIt	| aClassName |	aClassName := self genericClassName..	self		prepare: [			self createClass: aClassName.		]		change: [			Compiler evaluate: '(Smalltalk at: ', aClassName storeString, ') removeFromSystem'.		]		verify: [			self deny: (Smalltalk keys includes: aClassName).		].! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 13:53'!testMethodAdded	| aClassName aClass aSelector |	aClassName := self genericClassName.	self		prepare: [			aClass := self createClass: aClassName.		]		change: [			aSelector := self genericSelector.			aClass compile: aSelector.		]		verify: [			self assert: (aClass methodDict keys includes: aSelector).		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 14:11'!testMethodModified	| aClassName aClass aSelector aMethodSource |	aClassName := self genericClassName.	aSelector := self genericSelector.	self		prepare: [			aClass := self createClass: aClassName.			aClass compile: aSelector, ' ', self randomString storeString.		]		change: [			aMethodSource := aSelector, ' ', self randomString storeString.			aClass compile: aMethodSource.		]		verify: [			self assert: (aClass sourceCodeAt: aSelector) string = aMethodSource.		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 14:24'!testMethodRecategorized	| aClassName aClass aNewProtocol aSelector anOldProtocol |	aClassName := self genericClassName.	aSelector := self genericSelector.	anOldProtocol := self genericProtocol.	self		prepare: [			aClass := self createClass: aClassName.			aClass compile: aSelector classified: anOldProtocol.		]		change: [			aNewProtocol := self genericProtocol.			aClass organization classify: aSelector under: aNewProtocol.		]		verify: [			self assert: (aClass organization categoryOfElement: aSelector) = aNewProtocol		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 13:59'!testMethodRemoved	| aClassName aClass aSelector |	aClassName := self genericClassName.	aSelector := self genericSelector.	self		prepare: [			aClass := self createClass: aClassName.			aClass compile: aSelector.		]		change: [			aClass removeSelector: aSelector.		]		verify: [			self deny: (aClass methodDict keys includes: aSelector).		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 14:30'!testProtocolAdded	| aClassName aClass aProtocol |	aClassName := self genericClassName.	aProtocol := self genericProtocol.	self		prepare: [			aClass := self createClass: aClassName.		]		change: [			aClass organization addCategory: aProtocol.		]		verify: [			self assert: (aClass organization categories includes: aProtocol)		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 16:39'!testProtocolDefault	| aClassName aClass aSelector |	aClassName := self genericClassName.	self		prepare: [			aClass := self createClass: aClassName.		]		change: [			aSelector := self genericSelector.			aClass compile: aSelector.		]		verify: [			self assert: (aClass organization categoryOfElement: aSelector) = aClass organization class default.		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 14:33'!testProtocolRemoved	| aClassName aClass aProtocol |	aClassName := self genericClassName.	aProtocol := self genericProtocol.	self		prepare: [			aClass := self createClass: aClassName.			aClass organization addCategory: aProtocol.		]		change: [			aClass organization removeCategory: aProtocol.		]		verify: [			self deny: (aClass organization categories includes: aProtocol)		]! !!SystemChangeFileTest methodsFor: 'testing' stamp: 'laza 11/2/2011 14:41'!testProtocolRenamed	| aClassName aClass anOldProtocol aNewProtocol |	aClassName := self genericClassName.	anOldProtocol := self genericProtocol.	self		prepare: [			aClass := self createClass: aClassName.			aClass organization addCategory: anOldProtocol.		]		change: [			aNewProtocol := self genericProtocol.			aClass organization renameCategory: anOldProtocol toBe: aNewProtocol.		]		verify: [			self deny: (aClass organization categories includes: anOldProtocol).			self assert: (aClass organization categories includes: aNewProtocol).		]! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 13:39'!createClass: name	^Object		subclass: name		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self genericClassCategory! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/21/2011 15:43'!genericChangesName	^self prefixChangesName, self randomString, '.changes'! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 12:09'!genericClassCategory	^(self prefixClassCategory, self randomString capitalized) asSymbol! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 12:11'!genericClassName	^(self prefixClassName, self randomString capitalized) asSymbol! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 12:39'!genericInstVarName	^(self prefixInstVarName, self randomString capitalized) asSymbol! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 14:23'!genericProtocol	^(self prefixProtocol, self randomString) asSymbol! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 13:55'!genericSelector	^(self prefixSelector, self randomString capitalized) asSymbol! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/21/2011 15:43'!prefixChangesName	^self prefixGeneral! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 12:08'!prefixClassCategory	^self prefixGeneral, 'Category-'! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 12:10'!prefixClassName	^self prefixGeneral, 'Class'! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 12:30'!prefixGeneral	^self class name select: [:each | each isUppercase]! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 12:39'!prefixInstVarName	^self prefixGeneral asLowercase, 'InstVar'! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 14:22'!prefixProtocol	^self prefixGeneral asLowercase, ' protocol '! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 13:54'!prefixSelector	^self prefixGeneral asLowercase, 'Selector'! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/1/2011 18:58'!randomString	^Character alphabet shuffled! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 12:29'!removeTestcourt	SystemOrganization categories do: [:each |		(each beginsWith: self prefixClassCategory) ifTrue: [			SystemOrganization removeSystemCategory: each.		].	].		! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 15:10'!replayChanges	| file |	file := FileStream fileNamed: (self directory fullNameFor: self tempChangesName).	Transcript show: file contents; cr.	file fileIn.! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/1/2011 21:26'!useStandardChangesFile	Smalltalk		closeSourceFiles;		openSourceFiles! !!SystemChangeFileTest methodsFor: 'private' stamp: 'laza 11/2/2011 10:17'!useTemporaryChangesFile	Smalltalk closeSourceFiles.	tempChangesFile := self directory forceNewFileNamed: self tempChangesName.	SourceFiles at: 2 put: tempChangesFile! !!SystemChangeFileTest methodsFor: 'accessing' stamp: 'laza 9/28/2011 07:22'!directory	"Where we want to place the temporary changes file"	^FileDirectory default! !!SystemChangeFileTest methodsFor: 'accessing' stamp: 'laza 11/21/2011 15:44'!tempChangesName	^tempChangesName ifNil: [tempChangesName := self genericChangesName]! !!SystemChangeFileTest methodsFor: 'running' stamp: 'laza 11/1/2011 21:28'!tearDown	self useStandardChangesFile.	tempChangesFile := tempChangesFile ifNotNil: [tempChangesFile close].	(self directory fileExists: self tempChangesName)		ifTrue: [self directory deleteFileNamed: self tempChangesName].	self removeTestcourt.! !!SystemChangeFileTest methodsFor: 'as yet unclassified' stamp: 'laza 11/8/2011 13:52'!testCategoryModified	self assert: false description: 'When does that happen?'! !!SystemChangeFileTest methodsFor: 'as yet unclassified' stamp: 'laza 11/8/2011 13:52'!testClassReorganized	self assert: false description: 'When does that happen?'! !!SystemChangeFileTest methodsFor: 'as yet unclassified' stamp: 'laza 11/8/2011 13:52'!testProtocolModified	self assert: false description: 'When does that happen?'! !!SystemChangeNotifier methodsFor: 'public' stamp: 'ul 8/2/2011 20:11'!doSilently: aBlock	"Perform the block, and ensure that no system notification are broadcasted while doing so."	| result |	silenceLevel := silenceLevel + 1.	result := aBlock ensure: [silenceLevel > 0 ifTrue: [silenceLevel := silenceLevel - 1]].	^ result.! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'laza 11/3/2011 00:36'!protocolAdded: aProtocol inClass: aClass 	self trigger: (		AddedEvent protocol: aProtocol class: aClass	)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'laza 11/3/2011 00:35'!protocolRemoved: aProtocol inClass: aClass 	self trigger: (		RemovedEvent protocol: aProtocol class: aClass	)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'laza 11/3/2011 00:19'!protocolRenamedFrom: anOldProtocol to: aNewProtocol inClass: aClass 	self trigger: (		(RenamedEvent protocol: anOldProtocol class: aClass)			oldName: anOldProtocol;			newName: aNewProtocol	)! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'ar 9/5/2010 21:57'!selector: selector recategorizedFrom: oldCategory to: newCategory inClass: aClass	self trigger: (RecategorizedEvent 				selector: selector				method: (aClass compiledMethodAt: selector ifAbsent: [nil])				protocol: newCategory				class: aClass				oldProtocol: oldCategory)! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:07'!allClassesAndTraits	"Return all the classes and traits defined in the Smalltalk SystemDictionary"	^Array streamContents: [ :stream |		self allClassesAndTraitsDo: [ :each | stream nextPut: each ] ]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:13'!allClassesAndTraitsDo: aBlock		self		allClassesDo: aBlock;		allTraitsDo: aBlock! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:02'!allClassesDo: aBlock	"Evaluate the argument, aBlock, for each class in the system."	self classNames do: [ :name |		aBlock value: (self at: name) ]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:03'!allTraitsDo: aBlock	"Evaluate the argument, aBlock, for each trait in the system."	self traitNames do: [ :name |		aBlock value: (self at: name) ]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 2/20/2011 07:08'!classAndTraitNames	"Answer a sorted collection of all class and trait (not including class-traits) names. The performance of this algorithm is O(n) if the classNames are already cached, otherwise O(n*log(n)) where n is self size."	| classNames traitNames result temporary |	classNames := self classNames.	traitNames := self traitNames ifEmpty: [ ^classNames ].	temporary := Array new: classNames size + traitNames size.	result := temporary shallowCopy.	temporary		replaceFrom: 1		to: classNames size		with: classNames		startingAt: 1;		replaceFrom: classNames size + 1		to: temporary size		with: traitNames		startingAt: 1;		mergeFirst: 1		middle: classNames size		last: temporary size		into: result		by: nil.	^result! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 10/8/2010 21:22'!classNames	"Answer a sorted collection of all class names. Use the return value of #fillCaches to avoid concurrency issues."		^cachedClassNames ifNil: [ self fillCaches at: 1 ]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'fbs 1/9/2011 16:56'!classOrTraitNamed: aString 	"aString is either a class or trait name or a class or trait name followed by ' class' or 'classTrait' respectively.	Answer the class or metaclass it names."	| meta baseName |	(aString endsWith: ' class')		ifTrue: [meta := true.				baseName := aString copyFrom: 1 to: aString size - 6]		ifFalse: [			(aString endsWith: ' classTrait')				ifTrue: [					meta := true.					baseName := aString copyFrom: 1 to: aString size - 11]				ifFalse: [					meta := false.					baseName := aString]].	^self at: baseName asSymbol ifPresent:		[ :global | 		global isBehavior ifTrue:			[ meta				ifFalse: [ global ]				ifTrue: [ global classSide ]]]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 10/8/2010 21:33'!fillCaches	"Fill cachedClassNames and cachedNonClassNames. Return an array with the calculated values."	| classNames nonClassNames |	classNames := OrderedCollection new: self size.	nonClassNames := OrderedCollection new.	self keysAndValuesDo: [ :key :value |		value isInMemory ifTrue: [			"The key == value name test below addresses two separate issues:				1) Obsolete classes, where key = #Foo and value name = 'AnObsoleteFoo'				2) Aliases, i.e., Smalltalk at: #OtherName put: aClass"			((value isKindOf: Class) and: [ key == value name ])				ifTrue: [ classNames add: key ]				ifFalse: [ nonClassNames add: key ] ] ].	classNames sort.	cachedNonClassNames := nonClassNames sort.	cachedClassNames := classNames.	^{ classNames. nonClassNames }! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 10/8/2010 21:23'!flushClassNameCache	"Smalltalk flushClassNameCache"	"Force recomputation of the cached list of class names and non-class names."	cachedClassNames := cachedNonClassNames := nil! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 10/8/2010 21:22'!nonClassNames	"Answer a sorted collection of all non-class names. Use the return value of #fillCaches to avoid concurrency issues."		^cachedNonClassNames ifNil: [ self fillCaches at: 2 ]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'laza 12/14/2011 15:46'!renameClass: aClass from: oldName to: newName	"Rename the class, aClass, to have the title newName."	| oldref category |	category := SystemOrganization categoryOfElement: oldName.	self organization classify: newName under: category suppressIfDefault: true.	self organization removeElement: oldName.	oldref := self associationAt: oldName.	self removeKey: oldName.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	Smalltalk renamedClass: aClass from: oldName to: newName.	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 12/8/2010 21:06'!traitNames	"Answer a sorted collection of all traits (not including class-traits) names."	^self nonClassNames select: [ :name |		(name beginsWith: 'AnObsolete') not and: [			self 				at: name 				ifPresent: [ :global | global isInMemory and: [ global isTrait ] ]				ifAbsent: [ false ] ] ]! !!SystemDictionary methodsFor: 'compatibility' stamp: 'ul 4/28/2010 11:45'!hasSpecialSelector: aLiteral ifTrueSetByte: aBlock	self deprecated: 'Use Smalltalk'.	^Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: aBlock! !!SystemDictionary methodsFor: 'removing' stamp: 'eem 5/19/2010 15:35'!removeKey: key ifAbsent: aBlock	"Remove key (and its associated value) from the receiver. If key is not in	the receiver, answer the result of evaluating aBlock. Otherwise, answer	the value externally named by key."	self flushClassNameCache.	^super removeKey: key ifAbsent: aBlock! !!SystemDictionary methodsFor: '*ShoutCore' stamp: 'ul 11/17/2010 05:20'!hasBindingThatBeginsWith: aString	"Use the cached class and non-class names for better performance."	| name searchBlock |	searchBlock := [ :element |		(element beginsWith: aString)			ifTrue: [ 0 ]			ifFalse: [				aString < element					ifTrue: [ -1 ]					ifFalse: [ 1 ] ] ].	name := self classNames 		findBinary: searchBlock		ifNone: [ nil ].	name ifNotNil: [ ^true ].	name := self nonClassNames 		findBinary: searchBlock		ifNone: [ nil ].	^name notNil! !!SystemDictionary commentStamp: 'nice 3/6/2010 21:56' prior: 0!I represent a special dictionary used as global namespace for class names :	Smalltalk globals classNames.and for traits too:	Smalltalk globals traitNames.	and a few other globals:	(Smalltalk globals keys reject: [:k | (Smalltalk globals at: k) isBehavior])			collect: [:k | k -> (Smalltalk globals at: k) class].As the above example let you guess, the global namespace of Smalltalk system is accessed through:	Smalltalk globals.!!SystemDictionaryTest methodsFor: 'testing - classes and traits' stamp: 'fbs 1/9/2011 16:53'!testClassOrTraitNamedReturnsClassForClasses	self assert: Object ==  (Smalltalk globals classOrTraitNamed: 'Object').	self assert: Object ==  (Smalltalk globals classOrTraitNamed: #Object).! !!SystemDictionaryTest methodsFor: 'testing - classes and traits' stamp: 'fbs 1/9/2011 16:53'!testClassOrTraitNamedReturnsNilForGlobals	self assert: nil = (Smalltalk globals classOrTraitNamed: 'Undeclared').	self assert: nil = (Smalltalk globals classOrTraitNamed: #Undeclared).! !!SystemHelp commentStamp: 'tbn 4/30/2010 15:33' prior: 0!This class defines Help for the system in front of you.It defines the default contents when you open a help browser.So "HelpBrowser open" is the same as "HelpBrowser openOn: SystemHelp".!!SystemHelp class methodsFor: 'conversion' stamp: 'tbn 3/8/2010 08:52'!asHelpTopic 	|topic helpOnHelp sortedTopics |	topic := CustomHelp asHelpTopic.	topic sortSubtopicsByTitle.	helpOnHelp := topic subtopics detect: [:t | t key = 'HelpOnHelp'] ifNone: [self error: 'Help for the help system is removed'].	sortedTopics := topic subtopics.	sortedTopics remove: helpOnHelp.	sortedTopics addLast: helpOnHelp.	topic subtopics: sortedTopics.	^topic.! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 3/14/2011 23:35'!browseAllAccessesTo: instVarName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods or any methods of a subclass/superclass that refer to the instance variable name."	"self new browseAllAccessesTo: 'contents' from: Collection."		^ self 		browseMessageList: [ self allAccessesTo: instVarName from: aClass ]		name: 'Accesses to ' , instVarName 		autoSelect: instVarName! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 3/14/2011 20:53'!browseAllCallsOn: aLiteral 	"Create and schedule a message browser on each method that refers to aLiteral."	"self default browseAllCallsOn: #open:label:."	self headingAndAutoselectForLiteral: aLiteral do: [ :label :autoSelect |		self			browseMessageList: [ self allCallsOn: aLiteral ]			name: label			autoSelect: autoSelect]! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 5/9/2011 02:20'!browseAllCallsOn: literal1 and: literal2 	"Create and schedule a message browser on each method that calls on the two Symbols, literal1 and literal2."	"self default browseAllCallsOn: #at: and: #at:put:."	^self 		browseMessageList: [ self allCallsOn: literal1 and: literal2 ]		name: literal1 printString , ' -and- ' , literal2 printString! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 3/14/2011 21:02'!browseAllCallsOn: aLiteral from: aBehavior	"Create and schedule a Message Set browser for all the methods that call on aLiteral within aBehavior."	"self default browseAllCallsOn: #/ from: Number"	^self headingAndAutoselectForLiteral: aLiteral do: [ :label :autoSelect |		self 			browseMessageList: [ self  allCallsOn: aLiteral from: aBehavior ]			name: label, ' from ', aBehavior name			autoSelect: autoSelect ]	! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 3/14/2011 21:02'!browseAllCallsOn: aLiteral localTo: aBehavior	"Create and schedule a message browser on each method in or below the given class that refers to aLiteral."	"self default browseAllCallsOn: #open:label: localTo: CodeHolder"	aBehavior ifNil: [ ^self inform: 'No behavior selected.' ].	self headingAndAutoselectForLiteral: aLiteral do: [ :label :autoSelect |		self			browseMessageList:  [ self allCallsOn: aLiteral from: aBehavior ]			name: label, ' local to ', aBehavior name			autoSelect: autoSelect ]! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 3/14/2011 21:02'!browseAllCallsOn: aLiteral localToPackage: packageNameOrInfo	"Create and schedule a message browser on each method in the given package that refers to aLiteral."	"self default browseAllCallsOn: #open:label: localToPackage: 'Tools'."	self headingAndAutoselectForLiteral: aLiteral do: [ :label :autoSelect |		self			browseMessageList: [ 				self 					allCallsOn: aLiteral					localToPackage: packageNameOrInfo ]			name: label, ' local to package ', (self packageInfoFor: packageNameOrInfo) name			autoSelect: autoSelect ]! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 5/9/2011 02:17'!browseAllCallsOnClass: aBehavior	"Create and schedule a message browser on each method that refers to aClass."	"self default browseAllCallsOnClass: Array"		| behaviorName |	behaviorName := aBehavior theNonMetaClass name.	self		browseMessageList: [ aBehavior allCallsOn ]		name: 'Users of ', behaviorName		autoSelect: behaviorName! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:13'!browseAllImplementorsOf: selector localToPackage: packageNameOrInfo	"Create and schedule a message browser on each method in the given package	that implements the message whose selector is the argument, selector. For example, 	SystemNavigation new browseAllImplementorsOf: #at:put: localToPackage: 'Collections'."	self browseMessageList: (self								allImplementorsOf: selector								localToPackage: packageNameOrInfo) asSortedCollection		name: 'Implementors of ' , selector,				' local to package ', (self packageInfoFor: packageNameOrInfo) name! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 7/16/2011 18:48'!browseAllImplementorsOfList: selectorList title: aTitle 	"Create and schedule a message browser on each method that implements the message whose selector is in the argument selectorList."	"For example, self new browseAllImplementorsOf: #(at:put: size). "		| implementorLists |	implementorLists := selectorList gather: [:each | 		self allImplementorsOf: each ].	implementorLists sort.	^self browseMessageList: implementorLists name: aTitle! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 7/16/2011 18:55'!browseAllSelect: aBlock name: aName autoSelect: autoSelectString 	"Create and schedule a message browser on each method that, when used 	as the block argument to aBlock gives a true result. Do not return an  	#DoIt traces."	"self new browseAllSelect: [:method | method numLiterals > 10] name:  	'Methods with more than 10 literals' autoSelect: 'isDigit'"	^ self		browseMessageList: [ self allMethodsSelect: aBlock ]		name: aName		autoSelect: autoSelectString! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 11/4/2011 09:22'!browseAllStoresInto: varName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."	"self new browseAllStoresInto: 'contents' from: Collection."	^ self		browseMessageList: (self allStoresInto: varName from: aClass)		name: 'Stores into ' , varName		autoSelect: varName! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 3/14/2011 20:52'!browseMessageList: messageListOrBlock name: labelString autoSelect: autoSelectString	"Create and schedule a MessageSet browser on the message list. If messageListOrBlock is a block, then evaluate it to get the message list."	| messageList title |	messageList := messageListOrBlock isBlock		ifTrue: [ Cursor wait showWhile: messageListOrBlock ]		ifFalse: [ messageListOrBlock ].	messageList size = 0 ifTrue: [		^self inform: 'There are no', String cr, labelString ].	title := messageList size > 1		ifFalse: [ labelString ]		ifTrue: [ labelString, ' [', messageList size printString, ']' ].	ToolSet 		browseMessageSet: messageList 		name: title 		autoSelect: autoSelectString! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 7/16/2011 18:49'!browseMethodsWhoseNamesContain: aString	"Launch a tool which shows all methods whose names contain the given string; case-insensitive.	1/16/1996 sw, at the dawn of Squeak: this was the classic implementation that provided the underpinning for the 'method names containing it' (cmd-shift-W) feature that has always been in Squeak -- the feature that later inspired the MethodFinder (aka SelectorBrowser).	sw 7/27/2001:	Switched to showing a MessageNames tool rather than a message-list browser, if in Morphic."	| aList |	Smalltalk isMorphic		ifFalse:			[aList := Symbol selectorsContaining: aString.			aList size > 0 ifTrue:				[self browseAllImplementorsOfList: aList title: 'Methods whose names contain ''', aString, '''']]		ifTrue:			[ToolSet browseMessageNames: aString]	! !!SystemNavigation methodsFor: 'browse' stamp: 'dtl 8/1/2010 10:12'!browseMyChanges	"Browse only the changes (in the changes file) by the current author."	"SystemNavigation default browseMyChanges"	self browseAllSelect: [ :method |       method fileIndex > 1 "only look at changes file"               and: [ method timeStamp beginsWith: Utilities authorInitials ]]! !!SystemNavigation methodsFor: 'browse' stamp: 'ul 7/17/2011 22:33'!browseUncommentedMethodsWithInitials: targetInitials	"Browse uncommented methods whose initials (in the time-stamp, as logged to disk) match the given initials.  Present them in chronological order.  CAUTION: It will take several seconds for this to complete."	"Time millisecondsToRun: [SystemNavigation default browseUncommentedMethodsWithInitials: 'jm']"	self		browseMessageList: [ self allUncommentedMethodsWithInitials: targetInitials ] 		name: 'Uncommented methods with initials ', targetInitials		autoSelect: nil! !!SystemNavigation methodsFor: 'browse' stamp: 'cmm 5/2/2011 09:55'!browseVariableAssignments: aClass 	aClass chooseVarThenDo:		[ : aVar | self			browseAllStoresInto: aVar			from: aClass ]! !!SystemNavigation methodsFor: 'browse' stamp: 'cmm 5/2/2011 09:43'!browseVariableReferences: aClass	aClass chooseVarThenDo:		[ : aVar | (aClass allInstVarNames includes: aVar)			ifTrue:				[ self					browseAllAccessesTo: aVar					from: aClass ]			ifFalse: [ self browseAllCallsOn: aVar ] ]! !!SystemNavigation methodsFor: 'browse' stamp: 'fbs 3/16/2011 22:07'!spawnHierarchyForClass: aClass selector: aSelector	"Create and schedule a new class hierarchy browser on the requested class/selector."	"SystemNavigation default spawnHierarchyForClass: SmallInteger selector: #hash"	(aClass == nil)  ifTrue: [^ self].	^ ToolSet browseHierarchy: aClass selector: aSelector! !!SystemNavigation methodsFor: 'query' stamp: 'eem 11/4/2011 09:20'!allAccessesTo: instVarName from: aClass	"Return a sequence of MethodReferences of all methods of aClass or it's sub/superclass that refer to the instance variable instVarName."		| result |	result := OrderedCollection new.	aClass withAllSubAndSuperclassesDo:		[ :class | 		(class whichSelectorsAccess: instVarName) do:			[ :selector |			result add: (MethodReference class: class selector: selector) ] ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'ul 8/2/2011 20:16'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses and Traits).	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous	behaviors for which the following should be executed:		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].	but what follows is way faster than enumerating all objects."	Class rootsOfTheWorld do:		[:root|		root withAllSubclassesDo:			[:class|			class isMeta ifFalse: "The metaclasses are rooted at Class; don't include them twice."				[aBlock value: class; value: class class]]].	ClassDescription allTraitsDo: aBlock! !!SystemNavigation methodsFor: 'query' stamp: 'ul 5/9/2011 02:37'!allCallsOn: aLiteral 	"Answer a sorted collection of all the methods that call on aLiteral even deeply embedded in literal array."	"self default browseAllCallsOn: #open:label:."		^self		allCallsOn: aLiteral		fromBehaviors: (Generator on: [ :generator |			self allBehaviorsDo: [ :each |				generator yield: each ] ])		sorted: true! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/13/2011 20:33'!allCallsOn: firstLiteral and: secondLiteral	"Answer a sorted collection of all the methods that call on both firstLiteral and secondLiteral."	| firstList secondList |	firstList := self allCallsOn: firstLiteral.	secondList := (self 		allCallsOn: secondLiteral		fromBehaviors: (firstList collect: [ :each | each actualClass ] as: IdentitySet)		sorted: false) asSet.	firstList removeAllSuchThat: [ :each | (secondList includes: each) not ].	^firstList	! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/14/2011 20:58'!allCallsOn: aSymbol from: aBehavior	"Answer a sorted collection of all the methods from aBehavior that call on aSymbol."	^self allCallsOn: aSymbol fromBehaviors: { aBehavior } sorted: true! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/13/2011 20:23'!allCallsOn: aLiteral fromBehaviors: behaviors sorted: sorted	"Answer a collection of all the methods implemented by behaviors that call on aLiteral even deeply embedded in literal array."		| result special thorough byte |	result := OrderedCollection new.	special := Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: [ :b | byte := b ].	"Possibly search for symbols imbedded in literal arrays"	thorough := aLiteral isSymbol and: [ Preferences thoroughSenders ].	behaviors do: [ :behavior |		| list | 		list := behavior whichSelectorsReferTo: aLiteral special: special byte: byte thorough: thorough.		list do: [ :selector |			result add: (MethodReference class: behavior selector: selector) ] ].	sorted ifTrue: [ result sort ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/14/2011 20:50'!allCallsOn: aLiteral localTo: aClass	"Answer a sorted collection of MethodReferences for all the methods that call on aLiteral in, above or below the given class."	^self		allCallsOn: aLiteral		fromBehaviors: (Array streamContents: [ :stream |			aClass theNonMetaClass withAllSuperAndSubclassesDoGently: [ :each |				stream nextPut: each ].			aClass theNonMetaClass class withAllSuperAndSubclassesDoGently: [ :each |				stream nextPut: each ] ])		sorted: true! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/14/2011 20:50'!allCallsOn: aLiteral localToPackage: packageNameOrInfo	"Answer a sorted collection of MethodReferences for all the methods that call on aLiteral in the given package."	^self		allCallsOn: aLiteral		fromBehaviors: (self packageInfoFor: packageNameOrInfo) classesAndMetaClasses		sorted: true! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/18/2011 00:15'!allClassesImplementing: aSelector  	"Answer an collection of all classes that implement the message aSelector."	| result |	result := OrderedCollection new.	self allBehaviorsDo: [ :behavior | 		(behavior includesSelector: aSelector) ifTrue: [			result add: behavior ] ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/23/2011 17:21'!allGlobalRefsWithout: classesAndMessagesPair 	"Answer a set of symbols that may be refs to Global names. In some  	sense we should only need the associations, but this will also catch, eg,  	HTML tag types. This method computes its result in the absence of  	specified classes and messages."	"may be a problem if namespaces are introduced as for the moment  	only Smalltalk is queried. sd 29/4/03"	| globalRefs absentClasses absentSelectors |	globalRefs := IdentitySet new: CompiledMethod instanceCount.	absentClasses := classesAndMessagesPair first.	absentSelectors := classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute		showWhile: [Smalltalk classNames				do: [:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{Smalltalk at: cName. (Smalltalk at: cName) class}])						do: [:cl | (absentSelectors isEmpty								ifTrue: [cl selectors]								ifFalse: [cl selectors copyWithoutAll: absentSelectors])								do: [:sel | "Include all capitalized symbols for good 									measure"									(cl compiledMethodAt: sel) literalsDo: [:m |										((m isSymbol)												and: [m size > 0														and: [m first canBeGlobalVarInitial]])											ifTrue: [globalRefs add: m].										(m isMemberOf: Array)											ifTrue: [m													do: [:x | ((x isSymbol)																and: [x size > 0																		and: [x first canBeGlobalVarInitial]])															ifTrue: [globalRefs add: x]]].										m isVariableBinding											ifTrue: [m key													ifNotNil: [globalRefs add: m key]]]]]]].	^ globalRefs! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 14:47'!allImplementedMessages	"Answer a set of all the messages that are implemented in the system."		^self allImplementedMessagesWithout: #(() ())! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 14:47'!allImplementedMessagesWithout: behaviorsAndSelectorsPair 	"Answer a set of all the selectors that are implemented in the system, computed in the absence of the supplied behaviors and selectors."		| selectors behaviorsToReject |	selectors := IdentitySet new.	behaviorsToReject := behaviorsAndSelectorsPair first asIdentitySet.	Smalltalk allClassesAndTraitsDo: [ :behavior |		(behaviorsToReject includes: behavior name) ifFalse: [			selectors				addAll: behavior selectors;				addAll: behavior classSide selectors ] ].	behaviorsAndSelectorsPair second do: [ :each |		selectors remove: each ].	^selectors! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 14:27'!allImplementorsOf: aSelector 	"Answer a sorted collection of all the methods which are named aSelector."		| result |	result := OrderedCollection new.	self allBehaviorsDo: [ :class |		(class includesSelector: aSelector) ifTrue: [			result add: (MethodReference class: class selector: aSelector) ] ].	^result sort! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 14:29'!allImplementorsOf: aSelector localTo: aClass 	"Answer a sorted collection of all the methods that are named aSelector in, above, or below the given class."		| result |	result := OrderedCollection new.	{ aClass theNonMetaClass. aClass theMetaClass } do: [ :baseClass |		baseClass withAllSuperAndSubclassesDoGently: [ :class | 			(class includesSelector: aSelector) ifTrue: [				result add: (MethodReference class: class selector: aSelector) ] ] ].	^result sort! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 14:30'!allImplementorsOf: aSelector  localToPackage: packageNameOrInfo	"Answer a sorted collection of all the methods named aSelector in the given package."	| result |	result := OrderedCollection new.	(self packageInfoFor: packageNameOrInfo) actualMethodsDo: [ :method |		method selector = aSelector ifTrue: [			result add: method methodReference ] ].	^result sort! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 14:32'!allMethodsNoDoitsSelect: aBlock 	"Like allSelect:, but strip out Doits"		self deprecated: 'Doits are not present in MethodDictionaries anymore. Use #allMethodsSelect:'.	^self allMethodsSelect: aBlock! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 13:57'!allMethodsSelect: aBlock 	"Answer a sorted collection of each method that, when used as the block  	argument to aBlock, gives a true result."		| result |	result := OrderedCollection new.	self allSelectorsAndMethodsDo: [ :behavior :selector :method |		(aBlock value: method) ifTrue: [			result add: (MethodReference class: behavior selector: selector) ] ].	^result sort! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 14:00'!allMethodsSelect: aBlock localToPackage: packageNameOrInfo	"Answer a sorted collection of each method in the given package for which the evaluation of aBlock with the method answers true."	| result |	result := OrderedCollection new.	(self packageInfoFor: packageNameOrInfo) actualMethodsDo: [ :aMethod |		(aBlock value: aMethod) ifTrue: [			result add: aMethod methodReference ] ].	^result sort! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 15:01'!allMethodsWithSourceString: aString matchCase: caseSensitive	"Answer a sorted collection of all the methods that contain, in source code, aString as a substring. Search the class comments also"	| result |	result := OrderedCollection new.	CurrentReadOnlySourceFiles cacheDuring: [		'Searching all source code...'			displayProgressFrom: 0 to: Smalltalk classNames size			during: [ :bar |				| count previousBehavior |				count := 0.				previousBehavior := nil.				self allSelectorsAndMethodsDo: [ :behavior :selector :method |					behavior == previousBehavior ifFalse: [						bar value: (count := count + 1).						previousBehavior := behavior.						(behavior organization classComment asString							includesSubstring: aString							caseSensitive: caseSensitive) ifTrue: [								result add: (MethodReference class: behavior selector: #Comment) ] ].					(method getSource asString						includesSubstring: aString						caseSensitive: caseSensitive) ifTrue: [							result add: (MethodReference class: behavior selector: selector) ] ] ] ].	^result sort! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/12/2011 15:08'!allPrimitiveMethods	"Answer a collection of all the methods that are implemented by primitives."	| result |	result := OrderedCollection new.	self allSelectorsAndMethodsDo: [ :behavior :selector :method |		method primitive ~= 0 ifTrue: [			result add: (String streamContents: [ :stream |				stream					nextPutAll: behavior name;					space;					nextPutAll: selector;					space;					print: method primitive ]) ] ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/12/2011 15:08'!allPrimitiveMethodsInCategories: aList 	"Answer an OrderedCollection of all the methods that are implemented by 	primitives in the given categories. 1/26/96 sw"	"SystemNavigation new allPrimitiveMethodsInCategories:  	#('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh')"	| result categories |	result := OrderedCollection new.	categories := aList collect: [ :each | each asSymbol ].	categories size > 10 ifTrue: [ categories := categories asIdentitySet ].	self allBehaviorsDo: [ :behavior | 		(aList includes: behavior category) ifTrue: [			behavior selectorsAndMethodsDo: [ :selector :method | 				method primitive ~= 0 ifTrue: [					result add: (String streamContents: [ :stream |						stream							nextPutAll: behavior name;							space;							nextPutAll: selector;							space;							print: method primitive ]) ] ] ] ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/23/2011 17:24'!allReferencesToPool: aPool from: aClass	"Answer all the references to variables from aPool"	| list |	list := OrderedCollection new.	aClass withAllSubclassesDo:[:cls|		cls selectorsAndMethodsDo:[:sel :meth|			(meth hasLiteralSuchThat: [:lit| lit isVariableBinding and:[(aPool bindingOf: lit key) notNil]]) ifTrue:				[list add:(MethodReference new setStandardClass: cls methodSymbol: sel)]]].	^list! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 22:35'!allSelect: aBlock 	"Answer a sorted collection of each method that, when used as the block argument to aBlock, gives a true result."	| result |	result := OrderedCollection new.	self allSelectorsAndMethodsDo: [ :behavior :selector :method |		(aBlock value: method) ifTrue: [			result add: behavior name , ' ' , selector ] ].	^result sort! !!SystemNavigation methodsFor: 'query' stamp: 'ul 3/12/2011 14:53'!allSelectorsAndMethodsDo: aBlock 	"Evaluate aBlock for all selectors and methods of all behaviors in this image."		self allBehaviorsDo: [ :behavior |		behavior selectorsAndMethodsDo: [ :selector :method |			aBlock value: behavior value: selector value: method ] ]! !!SystemNavigation methodsFor: 'query' stamp: 'eem 5/23/2011 17:24'!allSentMessagesWithout: classesAndMessagesPair 	"Answer the set of selectors which are sent somewhere in the system,  	computed in the absence of the supplied classes and messages."	| sent absentClasses absentSelectors |	sent := IdentitySet new: CompiledMethod instanceCount.	absentClasses := classesAndMessagesPair first.	absentSelectors := classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute showWhile: [		Smalltalk classNames , Smalltalk traitNames do: [:name |			((absentClasses includes: name)				ifTrue: [{}]				ifFalse: [{Smalltalk at: name. (Smalltalk at: name) classSide}])					do: [:each | (absentSelectors isEmpty						ifTrue: [each selectors]						ifFalse: [each selectors copyWithoutAll: absentSelectors])						do: [:sel | "Include all sels, but not if sent by self"							(each compiledMethodAt: sel) literalsDo: [:m | 									(m isSymbol)										ifTrue: ["might be sent"											m == sel												ifFalse: [sent add: m]].									(m isMemberOf: Array)										ifTrue: ["might be performed"											m												do: [:x | (x isSymbol)														ifTrue: [x == sel																ifFalse: [sent add: x]]]]]]]].			"The following may be sent without being in any literal frame"			1				to: Smalltalk specialSelectorSize				do: [:index | sent						add: (Smalltalk specialSelectorAt: index)]].	Smalltalk presumedSentMessages		do: [:sel | sent add: sel].	^ sent! !!SystemNavigation methodsFor: 'query' stamp: 'eem 11/4/2011 09:21'!allStoresInto: varName from: aClass 	"Answer a sequence of MewthodReferences for all the receiver's methods 	 or any methods of a subclass/superclass that assign to the instance variable name."	"self new allStoresInto: 'contents' from: Collection."	| result |	result := OrderedCollection new.	aClass withAllSubAndSuperclassesDo:		[ : class |		(class whichMethodsStoreInto: varName) do:			[ : eachMethod |			result add: eachMethod methodReference ] ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 22:27'!allUncommentedMethodsWithInitials: targetInitials	"Return a sorted collection with all uncommented methods whose initials (in the	time-stamp, as logged to disk) match the given initials, in chronological order."	^CurrentReadOnlySourceFiles cacheDuring: [		| result |		result := OrderedCollection new.		self allSelectorsAndMethodsDo: [ :behavior :selector :method |			method timeStamp ifNotEmptyDo: [ :timeStamp |				| initials |				initials := timeStamp substrings first.				initials first isDigit ifFalse: [					(initials = targetInitials and: [ 						(behavior firstPrecodeCommentFor: selector) isNil ]) ifTrue: [							result add: (MethodReference								class: behavior								selector: selector ) ] ] ] ].		result ]! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 22:30'!allUnimplementedCalls	"Answer a collection of each message that is sent by an expression in a method but is not implemented by any object in the system."	| result implementedMessages |	implementedMessages := self allImplementedMessages.	result := OrderedCollection new.	self allSelectorsAndMethodsDo: [ :behavior :selector :method |		method messagesDo: [ :each |			(implementedMessages includes: each) ifFalse: [					result add: (String streamContents: [ :stream |						stream							nextPutAll: behavior name;							space;							nextPutAll: selector;							space;							nextPutAll: 'calls: ';							nextPutAll: each ]) ] ] ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 22:31'!allUnimplementedNonPrimitiveCalls	"Answer an collection of each message that is sent by an expression in a method but is not implemented by any object in the system. This list won't include primitive methods."	| result implementedMessages |	implementedMessages := self allImplementedMessages.	result := OrderedCollection new.	self allSelectorsAndMethodsDo: [ :behavior :selector :method |		method primitive = 0 ifTrue: [			method messagesDo: [ :each |				(implementedMessages includes: each) ifFalse: [					result add: (String streamContents: [ :stream |						stream							nextPutAll: behavior name;							space;							nextPutAll: selector;							space;							nextPutAll: 'calls: ';							nextPutAll: each ]) ] ] ] ].	^result! !!SystemNavigation methodsFor: 'query' stamp: 'ul 6/17/2011 12:31'!obsoleteMethodReferences	"SystemNavigation default obsoleteMethodReferences"	"Open a browser on all referenced behaviors that are obsolete"	| obsClasses references |	references := WriteStream on: Array new.	obsClasses := self obsoleteBehaviors.	'Scanning for methods referencing obsolete classes' 		displayProgressFrom: 1		to: obsClasses size		during: 			[:bar | 			obsClasses keysAndValuesDo: 					[:index :each | | obsRefs | 					bar value: index.					obsRefs := Utilities pointersTo: each except: obsClasses.					obsRefs do: 							[:ref | 							"Figure out if it may be a global"							(ref isVariableBinding and: [ref key isString	"or Symbol"]) 								ifTrue: 									[(Utilities pointersTo: ref) do: 											[:meth | 											(meth isKindOf: CompiledMethod) 												ifTrue: [meth methodReference ifNotNil: [:mref | references nextPut: mref]]]]]]].	^references contents! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 13:56'!selectAllMethods: aBlock 	"Answer a SortedCollection of each method that, when used as the block  	argument to aBlock, gives a true result."		self deprecated: 'Use #allMethodsSelect:'.	^self allMethodsSelect: aBlock! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 14:31'!selectAllMethodsNoDoits: aBlock 	"Like allSelect:, but strip out Doits"		self deprecated: 'Doits are not present in MethodDictionaries anymore. Use #allMethodsSelect:'.	^self allMethodsSelect: aBlock! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 15:20'!unimplemented	"Answer an collection of each message that is sent by an expression in a method but is not implemented by any object in the system."	| implemented unimplemented |	implemented := self allImplementedMessages.	unimplemented := IdentityDictionary new.	self allSelectorsAndMethodsDo: [ :behavior :selector :method |		method messagesDo: [ :each |			| entry |			(implemented includes: each) ifFalse: [				entry := unimplemented 					at: each 					ifPresent: [ :oldEntry |						oldEntry copyWith: behavior name, '>', selector ]					ifAbsent: [ 						{ behavior name, '>', selector } ].				unimplemented at: each put: entry ] ] ].	^unimplemented! !!SystemNavigation methodsFor: 'query' stamp: 'ul 7/17/2011 15:13'!unusedBlocks	"Answer all methods that contain a block that is not used (not	 sent a message, returned, passed as an argument, or assigned)."	"SystemNavigation new unusedBlocks"	"SystemNavigation new		browseMessageList: SystemNavigation new unusedBlocks		name: 'unused blocks'"	^self allMethodsSelect:		[:m| | is |		is := InstructionStream on: m.		is scanFor: [:b| b = 143 and: [(m at: is thirdByte * 256 + is fourthByte + is pc + 4) = 135]]]! !!SystemNavigation methodsFor: 'ui' stamp: 'ul 11/15/2010 12:16'!confirmRemovalOf: aSelector on: aClass 	"Determine if it is okay to remove the given selector. Answer 1 if it  	should be removed, 2 if it should be removed followed by a senders  	browse, and 3 if it should not be removed."	| count answer caption allCalls |	allCalls := self allCallsOn: aSelector.	(count := allCalls size) = 0		ifTrue: [^ 1].	"no senders -- let the removal happen without warning"	count = 1		ifTrue: [(allCalls first actualClass == aClass					and: [allCalls first methodSymbol == aSelector])				ifTrue: [^ 1]].	"only sender is itself"	caption := 'This message has ' , count printString , ' sender'.	count > 1		ifTrue: [caption := caption copyWith: $s].	answer := UIManager default 		chooseFrom: #('Remove it'				'Remove, then browse senders'				'Don''t remove, but show me those senders'				'Forget it -- do nothing -- sorry I asked') title: caption.	answer = 3		ifTrue: [self				browseMessageList: allCalls				name: 'Senders of ' , aSelector				autoSelect: aSelector keywords first].	answer = 0		ifTrue: [answer := 3].	"If user didn't answer, treat it as cancel"	^ answer min: 3! !!SystemNavigation methodsFor: 'ui' stamp: 'topa 9/27/2010 11:06'!showMenuOf: selectorCollection withFirstItem: firstItem ifChosenDo: choiceBlock withCaption: aCaption	"Show a sorted menu of the given selectors, preceded by firstItem, and all abbreviated to 40 characters.  Use aCaption as the menu title, if it is not nil.  Evaluate choiceBlock if a message is chosen."	| index menuLabels sortedList |	sortedList := selectorCollection asSortedCollection.	menuLabels := Array streamContents: 		[:strm | strm nextPut: (firstItem contractTo: 40).		sortedList do: [:sel | strm nextPut: (sel contractTo: 40)]].	index := UIManager default chooseFrom: menuLabels lines: #(1).	index = 1 ifTrue: [choiceBlock value: firstItem].	index > 1 ifTrue: [choiceBlock value: (sortedList at: index - 1)]! !!SystemNavigation methodsFor: 'private' stamp: 'cmm 5/1/2011 22:24'!headingAndAutoselectForLiteral: aLiteral do: binaryBlock 	"Evaluate binaryBlock with either Users of ... or Senders of ... plus the auto-select string for the given literal.  aLiteral can be a Symbol, a VariableBinding or an arbitrary object."	| autoSelect |	^ aLiteral isSymbol		ifTrue:			[ binaryBlock				value: 'Senders of ' , aLiteral				value: aLiteral keywords first ]		ifFalse:			[ autoSelect := aLiteral isVariableBinding				ifTrue: [ aLiteral key ]				ifFalse: [ aLiteral printString ].			binaryBlock				value: 'Users of ' , autoSelect				value: autoSelect ]! !!SystemNavigation methodsFor: 'private' stamp: 'eem 8/30/2010 10:34'!packageInfoFor: packageInfoOrString	^packageInfoOrString isString		ifTrue: [PackageInfo named: packageInfoOrString]		ifFalse: [packageInfoOrString]! !!SystemNavigation commentStamp: 'mha 8/26/2010 09:02' prior: 0!I support the navigation of the system. I act as a facade but as I could require some stateor different way of navigating the system all my behavior are on the instance side.For example if you want to look at all methods you have written or changed in the current image doSystemNavigation new browseAllSelect: [ :method |       method fileIndex > 1 "only look at changes file"       and: [ method timeStamp beginsWith: 'your-initials-here' ] ].!!SystemNavigation class methodsFor: 'accessing' stamp: 'ul 3/14/2011 20:53'!default		^Default ifNil: [ Default := self new ]! !!SystemOrganizer methodsFor: 'accessing' stamp: 'laza 12/8/2011 15:06'!addCategory: catString before: nextCategory	SystemChangeNotifier uniqueInstance		doSilently: [super addCategory: catString before: nextCategory];		classCategoryAdded: catString! !!SystemOrganizer methodsFor: 'accessing' stamp: 'laza 12/14/2011 10:25'!classify: element under: newCategory	| oldCategory |	oldCategory := self categoryOfElement: element.	super classify: element under: newCategory.	SystemChangeNotifier uniqueInstance		class: (Smalltalk at: element)		recategorizedFrom: oldCategory		to: newCategory ! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'nice 8/19/2010 16:35'!orderedTraitsIn: category 	"Answer an OrderedCollection containing references to the traits in the 	category whose name is the argument, category (a string). The traits 	are ordered so they can be filed in."	| behaviors traits |	behaviors := (self listAtCategoryNamed: category asSymbol) 			collect: [:title | Smalltalk at: title].	traits := behaviors reject: [:each | each isBehavior].	^traits asArray sort: [:t1 :t2 |		(t2 traitComposition allTraits includes: t1)			or: [(t1 traitComposition allTraits includes: t2) not]]! !!SystemOrganizer class methodsFor: 'class initialization' stamp: 'spd 5/19/2010 15:54'!default	"I have a global instance, SystemOrganization.  In case someone stumbles upon my class, and does not know about the global, it can be accessed from here, too."  ^ SystemOrganization.! !!SystemOrganizerTest methodsFor: 'tests' stamp: 'spd 5/19/2010 15:53'!testAccessGlobalDirectly	"	SystemOrganizerTest run: #testAccessGlobalDirectly	"		self assert: (SystemOrganization isKindOf: SystemOrganizer).					"It really lives in Smalltalk (another global)"	self assert: ((Smalltalk at: #SystemOrganization) == SystemOrganization).! !!SystemOrganizerTest methodsFor: 'tests' stamp: 'spd 5/19/2010 15:53'!testAccessGlobalThroughClass	"	SystemOrganizerTest run: #testAccessGlobalThroughClass	"			"In case someone stumbles upon the SystemOrganizer class, and does not know	about the SystemNavigation global, it can be accessed from there, too."	self assert: (SystemOrganizer default == SystemOrganization).! !!SystemProgressMorph methodsFor: 'private' stamp: 'cmm 5/27/2011 14:20'!freeSlot: number	number > 0 ifFalse: [^self].	lock critical: [| label |		label := labels at: number.		(label isNil or: [label owner isNil]) ifTrue: [^self]. "Has been freed before"		label delete.		(bars at: number) delete.		activeSlots := activeSlots - 1.		activeSlots = 0			ifTrue: [self delete]			ifFalse: [self reposition]]! !!SystemProgressMorph methodsFor: 'private' stamp: 'cmm 6/4/2011 16:58'!label: shortDescription min: minValue max: maxValue	| slot range barSize lastRefresh |"This method is no longer used, but kept for a while longer to ensure no difficulties updating via the trunk."	((range := maxValue - minValue) < 0 or: [(slot := self nextSlotFor: shortDescription) = 0])		ifTrue: [^[:barVal| 0 ]].	range <= 0 ifTrue: [self removeMorph: (bars at: slot)].	self recenter.	self openInWorld.	barSize := -1. "Enforces a inital draw of the morph"	lastRefresh := 0.	^[:barVal | | newBarSize |		barVal isString ifTrue: [			self setLabel: barVal at: slot.			self currentWorld displayWorld].		(barVal isNumber and: [range >= 1 and: [barVal between: minValue and: maxValue]]) ifTrue: [			newBarSize := (barVal - minValue / range * BarWidth) truncated.			newBarSize = barSize ifFalse: [				barSize := newBarSize.				(bars at: slot) barSize: barSize.				Time primMillisecondClock - lastRefresh > 25 ifTrue: [					self currentWorld displayWorld.					lastRefresh := Time primMillisecondClock]]].		slot]! !!SystemProgressMorph methodsFor: 'private' stamp: 'cmm 5/27/2011 14:21'!position: aPoint label: shortDescription min: minValue max: maxValue	| slot range barSize lastRefresh |	requestedPosition := aPoint.	((range := maxValue - minValue) < 0 or: [(slot := self nextSlotFor: shortDescription) = 0])		ifTrue: [^[:barVal| 0 ]].	range <= 0 ifTrue: [self removeMorph: (bars at: slot)].	self reposition.	self openInWorld.	barSize := -1. "Enforces a inital draw of the morph"	lastRefresh := 0.	^[:barVal | | newBarSize |		barVal isString ifTrue: [			self setLabel: barVal at: slot.			self currentWorld displayWorld].		(barVal isNumber and: [range >= 1 and: [barVal between: minValue and: maxValue]]) ifTrue: [			newBarSize := (barVal - minValue / range * BarWidth) truncated.			newBarSize = barSize ifFalse: [				barSize := newBarSize.				(bars at: slot) barSize: barSize.				Time primMillisecondClock - lastRefresh > 25 ifTrue: [					self currentWorld displayWorld.					lastRefresh := Time primMillisecondClock]]].		slot]! !!SystemProgressMorph methodsFor: 'private' stamp: 'cmm 6/4/2011 16:58'!recenter	| position |"This method is no longer used, but kept for a while longer to ensure no difficulties updating via the trunk."	"Put ourself in the center of the display"	self align: self fullBounds center with: Display boundingBox center.	"Check to see if labels are wider than progress bars. In that case do	a centered instead of the default left aligned layout."	position :=	self width > (Inset x * 2 + (self borderWidth * 2) + BarWidth)					ifTrue: [#topCenter]					ifFalse: [#leftCenter].	self cellPositioning: position! !!SystemProgressMorph methodsFor: 'private' stamp: 'cmm 6/4/2011 16:24'!reposition	"Put ourself in the requested position on the display, but ensure completely within the bounds of the display"	| position |	self bounds:		((self fullBounds			align: self fullBounds center			with: (requestedPosition ifNil: [ self fullBounds center ])) translatedToBeWithin: Display boundingBox).	"Check to see if labels are wider than progress bars. In that case do	a centered instead of the default left aligned layout."	position := self width > (Inset x * 2 + (self borderWidth * 2) + BarWidth)		ifTrue: [ #topCenter ]		ifFalse: [ #leftCenter ].	self cellPositioning: position! !!SystemProgressMorph methodsFor: 'labelling' stamp: 'cmm 5/27/2011 14:21'!setLabel: shortDescription at: slot	(labels at: slot) contents: shortDescription.	self reposition! !!SystemProgressMorph commentStamp: '<historical>' prior: 0!An single instance of this morph class is used to display progress while the system is busy, eg. while it receives code updates or does a fileIn. To give the user progress information you don't deal directly with SystemProgressMorph. You keep on using the well established way of progress notification, that has been a long time in the system, is widely used and does not depend on the existence of SystemProgressMorph. For more information on this look at the example in this class or look at the comment of the method displayProgressAt:from:to:during: in class String.SystemProgressMorph is not meant to be used as a component inside other morphs.You can switch back to the old style of progress display by disabling the morphicProgressStyle setting in the morphic section of the preferences.!!SystemProgressMorph class methodsFor: 'examples' stamp: 'ul 6/17/2011 12:31'!example	"SystemProgressMorph example"	'Progress' 		displayProgressFrom: 0 to: 1000		during: [:bar | 0 to: 1000 do: [:i | bar value: i. (Delay forMilliseconds: 2) wait]]! !!SystemProgressMorph class methodsFor: 'examples' stamp: 'ul 6/17/2011 12:31'!exampleChangeLabel	"SystemProgressMorph exampleChangeLabel"	| classes |	classes := Smalltalk allClasses copyFrom: 1 to: 100.	'InitialLabel' 		displayProgressFrom: 0 to: classes size		during: [:bar | 1 to: classes size do: [:i |				bar value: i.				bar value: i printString, '/', classes size printString, ' ', (classes at: i) printString.				(Delay forMilliseconds: 100) wait]]! !!SystemProgressMorph class methodsFor: 'instance creation' stamp: 'laza 12/8/2010 12:16'!close: aBlock	| slot |	slot := aBlock value: SmallInteger maxVal. "This should prevent a redraw"	aBlock receiver freeSlot: slot.	! !!SystemProgressMorph class methodsFor: 'instance creation' stamp: 'cmm 6/4/2011 17:00'!label: shortDescription min: minValue max: maxValue"This method is no longer used, but kept for a while longer to ensure no difficulties updating via the trunk."	^ self 		position: Display center		label: shortDescription		min: minValue		max: maxValue! !!SystemProgressMorph class methodsFor: 'instance creation' stamp: 'cmm 5/27/2011 14:06'!position: aPoint label: shortDescription min: minValue max: maxValue 	UniqueInstance ifNil: [ UniqueInstance := super new ].	^ UniqueInstance		position: aPoint		label: (shortDescription contractTo: 100)		min: minValue asFloat		max: maxValue asFloat! !!SystemReference commentStamp: 'tbn 4/30/2010 15:35' prior: 0!This class defines the full reference help for the system.(contents for the full API Help).Just run "HelpBrowser openOn: SystemReference".!!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:01'!all	"HelpBrowser openOn: self all "		^(ClassAPIHelpBuilder new)		rootToBuildFrom: ProtoObject;		addSubclasses: true;		addMethods: true;		subclassesAsSeparateTopic: false;		build;		topicToBuild 	 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:04'!asHelpTopic 	"HelpBrowser openOn: SystemReference"		^self hierarchyFor: ProtoObject 	 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/11/2010 23:41'!forClass: aClass	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := ClassAPIHelpBuilder buildHelpTopicFrom: aClass.	root addSubtopic: topic.	^root! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:21'!hierarchyFor: aClass	 	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := (ClassAPIHelpBuilder new)					rootToBuildFrom: aClass;					addSubclasses: true;					addMethods: false;					subclassesAsSeparateTopic: false;					build;					topicToBuild.	root addSubtopic: topic.	^root					 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:23'!hierarchyWithMethodsFor: aClass	 	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := (ClassAPIHelpBuilder new)					rootToBuildFrom: aClass;					addSubclasses: true;					addMethods: true;					subclassesAsSeparateTopic: true;					build;					topicToBuild.	root addSubtopic: topic.	^root					 		 ! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:22'!add: category method: aSymbol	^self categoryList add: (self categories add: category -> aSymbol) key! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:19'!categories	^ categories ifNil: [categories := IdentityDictionary new]! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/17/2011 12:22'!categoryAt: anIndex	^ categoriesSelected includes: (self categoryList at: anIndex ifAbsent: [ ^ false ]).! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/17/2011 12:37'!categoryAt: anInteger put: aBoolean	categoriesSelected := categoriesSelected		perform: (aBoolean ifTrue: [ #copyWith: ] ifFalse: [ #copyWithout: ])		with: (self categoryList at: anInteger ifAbsent: [ ^ self ]).	self updateReport! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:16'!categoryList	^ categoryList ifNil: [categoryList := OrderedCollection new]! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:57'!categoryMenu: aMenu	^ aMenu		title: 'Categories';		add: 'Select all' action: #selectAllCategories;		add: 'Select none' action: #selectNoCategories;		addLine;		add: 'Refresh' action: #refresh;		yourself.! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:11'!categorySelected	^ 0! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:12'!categorySelected: anInteger	self changed: #categorySelected.! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/31/2011 20:59'!refresh	tinyBenchmarksResult := testRunner := nil.	self updateReport! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:40'!selectAllCategories	categoriesSelected addAll: categoryList.	self changed: #categorySelected.	self updateReport! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:40'!selectNoCategories	categoriesSelected removeAll.	self changed: #categorySelected.	self updateReport! !!SystemReporter methodsFor: 'building' stamp: 'lr 10/31/2005 15:12'!buildCategoriesWith: aBuilder	^ aBuilder pluggableMultiSelectionListSpec new		model: self;		list: #categoryList;		menu: #categoryMenu:;		getIndex: #categorySelected;		setIndex: #categorySelected:;		getSelectionList: #categoryAt:;		setSelectionList: #categoryAt:put:;		yourself.! !!SystemReporter methodsFor: 'building' stamp: 'laza 1/18/2011 11:46'!buildReportWith: aBuilder	^ aBuilder pluggableTextSpec new		model: self;		menu: #reportMenu:;		getText: #reportText;		yourself.! !!SystemReporter methodsFor: 'building' stamp: 'laza 1/17/2011 12:10'!buildWith: aBuilder	| window |	window := aBuilder pluggableWindowSpec new		model: self; label: self label; extent: self extent;		children: (OrderedCollection new 			add: ((self buildCategoriesWith: aBuilder)				frame: self categoriesFrame;				yourself);			add: ((self buildReportWith: aBuilder)				frame: self reportFrame;				yourself);			yourself);		yourself.	^ aBuilder build: window.! !!SystemReporter methodsFor: 'building' stamp: 'laza 1/17/2011 11:56'!categoriesFrame	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.25 offset: 0;		bottomFraction: 1 offset: 0! !!SystemReporter methodsFor: 'building' stamp: 'laza 1/17/2011 12:14'!reportFrame	^LayoutFrame new		leftFraction: 0.25 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0! !!SystemReporter methodsFor: 'accessing-report' stamp: 'laza 1/18/2011 11:50'!copyReportToClipboard	Clipboard clipboardText: self reportText.	UIManager default inform: 'Copied Report to Clipboard'! !!SystemReporter methodsFor: 'accessing-report' stamp: 'laza 1/18/2011 11:49'!reportMenu: aMenu	^ aMenu		title: 'Report';		add: 'Copy to Clipboard' action: #copyReportToClipboard;		yourself.! !!SystemReporter methodsFor: 'accessing-report' stamp: 'laza 1/18/2011 09:42'!reportText	^ (report isNil or: [categoriesSelected isEmpty])		ifTrue: ['-- Choose any category on the left --']		ifFalse: [report]! !!SystemReporter methodsFor: 'accessing-ui' stamp: 'lr 10/8/2005 18:39'!extent	^ 640 @ 480! !!SystemReporter methodsFor: 'accessing-ui' stamp: 'laza 1/17/2011 11:47'!label	^ 'System Reporter' ! !!SystemReporter methodsFor: 'printing-report' stamp: 'laza 1/18/2011 08:58'!header: aString on: aStream	aStream withAttribute: TextEmphasis bold do: [			aStream nextPutAll: aString; cr.		aString size timesRepeat: [aStream nextPut: $-].		aStream cr]! !!SystemReporter methodsFor: 'initialize-release' stamp: 'laza 2/15/2011 10:08'!initialize	self		add: #Image method: #reportImage;		add: #'Image Parameters' method: #reportImageParameters;		add: #'Image Sources' method: #reportSources;		add: #'Image Preferences' method: #reportPreferences;		add: #'MC Repositories' method: #reportRepositories;		add: #'MC Working Copies' method: #reportWorkingCopies;		add: #'VM General' method: #reportVM;		add: #'VM Options' method: #reportVMOptions;		add: #'VM Modules' method: #reportModules;		add: #'VM Parameters' method: #reportVMParameters;		add: #'VM Stats' method: #reportVMStats.	Smalltalk os platformName = 'Win32' ifTrue: [		self			add: #'VM Configuration' method: #reportWin32VMConfig.		].	self		add: #'OS General' method: #reportOS.	Smalltalk os platformName = 'Win32' ifTrue: [		self			add: #'OS Details' method: #reportWin32OSDetails;			add: #'Hardware Details' method: #reportWin32HardwareDetails;			add: #'GFX Hardware Details' method: #reportWin32GFXDetails.		].	Smalltalk os osVersion = 'linux' ifTrue: [		self			add: #'OS Details' method: #reportLinuxOSDetails	].	self		add: #'Tiny Benchmarks' method: #reportTinyBenchmarks;		add: #'SUnit' method: #reportTestRunner;		add: #'Debug Log' method: #reportDebugLog.	categoriesSelected := Set with: #Image with: #'VM General'.	self updateReport! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 2/1/2011 09:28'!reportDebugLog: aStream	| logFilename logStream contents |	self header: 'Debug Logfile' on: aStream.	logFilename := Smalltalk image squeakErrorFileName.	logStream := nil.	[		[			logStream := FileStream readOnlyFileNamed: logFilename.			aStream nextPutAll: logStream name; cr; cr.			contents := logStream contents.			aStream				nextPutAll: 					((contents isNil or: [contents size = 0])						ifTrue: ['<empty>']						ifFalse: [contents]);				cr		] on: Error do: [:ex |			aStream				nextPutAll: (					ex class = FileDoesNotExistException						ifTrue: [logFilename, ' not found']						ifFalse: [ex description]);				cr		]	] ensure: [		logStream ifNotNil: [logStream close]	]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/30/2011 05:04'!reportImage: aStream	self header: 'Image' on: aStream.	aStream 		nextPutAll: Smalltalk image imageName; cr;		nextPutAll: SystemVersion current version; cr;		nextPutAll: Smalltalk image lastUpdateString; cr;		nextPutAll: Smalltalk image currentChangeSetString; cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 09:51'!reportImageParameters: aStream	self header: 'Image Commandline Parameters' on: aStream.	self enumerate: [:idx | Smalltalk image argumentAt: idx] on: aStream.! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 2/21/2011 23:57'!reportLinuxOSDetails: aStream	self header: 'Operating System Details' on: aStream.	#(		'/etc/issue'		'/etc/lsb-release'		'/proc/version'	) do: [:path|		self writeContentsSafelyFromFile: path on: aStream]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:54'!reportModules: aStream	self header: 'Loaded VM Modules' on: aStream.	SmalltalkImage current listLoadedModules asSortedCollection do: [:each | aStream nextPutAll: each; cr].! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 10:07'!reportOS: aStream	self header: 'Operating System/Hardware' on: aStream.	aStream		nextPutAll: Smalltalk os platformName; space;		nextPutAll: Smalltalk os osVersion; space;		nextPutAll: Smalltalk os platformSubtype; cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 13:51'!reportPreferences: aStream	| booleanPrefs prefs valuePrefs attribute falseTA trueTA |	prefs := Preferences dictionaryOfPreferences.	booleanPrefs := prefs select: [:each | each type = #Boolean].	valuePrefs := prefs select: [:each | each type = #Number or: [each type = #String]].	trueTA := TextColor black.	falseTA := TextColor gray.	booleanPrefs := booleanPrefs asSortedCollection: [:a :b | a name <= b name].  	self header: 'Boolean Preferences' on: aStream.	booleanPrefs do: [:each |		attribute := each preferenceValue ifTrue: [trueTA] ifFalse: [falseTA].		aStream withAttribute: attribute do: [			aStream			nextPutAll: each name;			tab;  			nextPutAll: each preferenceValue printString;			cr]].	aStream cr.	self header: 'Value Preferences' on: aStream.	valuePrefs do: [:each |		aStream			nextPutAll: each name;			tab;  			nextPutAll: each preferenceValue printString;			cr].! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 12:14'!reportRepositories: aStream	self header: 'Monticello Repositories' on: aStream.	MCRepositoryGroup default repositories do: [:each | aStream nextPutAll: each description; cr]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:55'!reportSources: aStream	self header: 'Image Sources' on: aStream.	aStream nextPutAll: SourceFiles class printString; cr.	SourceFiles do: [:each |		each ifNotNil: [aStream nextPutAll: each printString; cr]]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/31/2011 21:16'!reportTestRunner: aStream	testRunner ifNil: [| runAllTests |		runAllTests := UIManager confirm: 'Running all Tests\will take long time' withCRs.		runAllTests			ifTrue: [testRunner := TestRunner new runAll]			ifFalse: [				categoriesSelected remove: #SUnit. 				^self changed: #categorySelected]].	self header: 'SUnit Results' on: aStream.	aStream nextPutAll: testRunner statusText; cr; cr.	self header: 'Failed Tests' on: aStream.	testRunner failedList do: [:each | aStream nextPutAll: each; cr].	aStream cr.	self header: 'Errors' on: aStream.	testRunner errorList do: [:each | aStream nextPutAll: each; cr]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/31/2011 21:13'!reportTinyBenchmarks: aStream	tinyBenchmarksResult ifNil: [		UIManager inform: 'Running the Benchmarks\will take a few seconds' withCRs.		tinyBenchmarksResult := 0 tinyBenchmarks].	self header: 'Tiny Benchmarks' on: aStream.	aStream nextPutAll: tinyBenchmarksResult; cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 2/15/2011 09:55'!reportVM: aStream	self header: 'Virtual Machine' on: aStream.	aStream		nextPutAll: (Smalltalk vm vmFileName); cr;		nextPutAll: (Smalltalk vm vmVersion); cr.	Smalltalk vm buildDate		ifNotNilDo: [:string | aStream nextPutAll: string; cr].	[Smalltalk vm platformSourceVersion		ifNotNilDo: [:v | aStream nextPutAll: 'platform sources revision ', v; cr]]			on: Warning do: ["unsupported primitive"].	[Smalltalk vm interpreterSourceVersion		ifNotNilDo: [:v | aStream nextPutAll: 'VMMaker versionString ', v; cr]]			on: Warning do: ["unsupported primitive"].	[Smalltalk vm interpreterClass		ifNotNilDo: [:string | aStream nextPutAll: string; cr].	Smalltalk vm cogitClass		ifNotNilDo: [:string | aStream nextPutAll: string; cr]	] on: Error do: ["unsupported primitives"]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 09:58'!reportVMOptions: aStream	self header: 'Virtual Machine Commandline Options' on: aStream.	self enumerate: [:idx | Smalltalk vm optionAt: idx] startAt: 1 on: aStream! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 12:43'!reportVMParameters: aStream	| vmParameters |	self header: 'Virtual Machine Parameters' on: aStream.	vmParameters := Smalltalk vm getVMParameters.	#(		1	'end of old-space (0-based, read-only)'		2	'end of young-space (read-only)'		3	'end of memory (read-only)'		4	'allocationCount (read-only)'		5	'allocations between GCs (read-write)'		6	'survivor count tenuring threshold (read-write)'		7	'full GCs since startup (read-only)'		8	'total milliseconds in full GCs since startup (read-only)'		9	'incremental GCs since startup (read-only)'		10	'total milliseconds in incremental GCs since startup (read-only)'		11	'tenures of surving objects since startup (read-only)'		12	'specific to the translating VM'		13  'specific to the translating VM'		14  'specific to the translating VM'		15  'specific to the translating VM'		16  'specific to the translating VM'		17  'specific to the translating VM'		18  'specific to the translating VM'		19  'specific to the translating VM'		20  'specific to the translating VM'		21	'root table size (read-only)'		22	'root table overflows since startup (read-only)'		23	'bytes of extra memory to reserve for VM buffers, plugins, etc.'		24	'memory threshold above which shrinking object memory (rw)'		25	'memory headroom when growing object memory (rw)'		26  'interruptChecksEveryNms - force an ioProcessEvents every N milliseconds, in case the image  is not calling getNextEvent often (rw)'		27	'number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking'		28	'number of times sweep loop iterated  for current IGC/FGC (read-only)'		29	'number of times make forward loop iterated for current IGC/FGC (read-only)'		30	'number of times compact move loop iterated for current IGC/FGC (read-only)'		31	'number of grow memory requests (read-only)'		32	'number of shrink memory requests (read-only)'		33	'number of root table entries used for current IGC/FGC (read-only)'		34	'number of allocations done before current IGC/FGC (read-only)'		35	'number of survivor objects after current IGC/FGC (read-only)'		36  'millisecond clock when current IGC/FGC completed (read-only)'		37  'number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)'		38  'milliseconds taken by current IGC  (read-only)'		39  'Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)'		40  'VM word size - 4 or 8 (read-only)'	) pairsDo: [:idx :desc |		aStream			nextPut: $#;			nextPutAll: idx printString;			tab;			nextPutAll: (vmParameters at: idx) printString;			tab;			nextPutAll: desc;			cr]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 12:30'!reportVMStats: aStream	self header: 'Virtual Machine Statistics' on: aStream.	aStream		nextPutAll: Smalltalk vm vmStatisticsReportString! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 2/15/2011 09:40'!reportWin32GFXDetails: aStream	self header: 'Graphics Hardware Details' on: aStream.	aStream nextPutAll: (SmalltalkImage current getSystemAttribute: 10003)! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 2/15/2011 09:40'!reportWin32HardwareDetails: aStream	self header: 'Hardware Details' on: aStream.	aStream nextPutAll: (SmalltalkImage current getSystemAttribute: 10001)! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 2/15/2011 09:39'!reportWin32OSDetails: aStream	self header: 'Operating System Details' on: aStream.	aStream nextPutAll: (SmalltalkImage current getSystemAttribute: 10002)! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 2/15/2011 10:21'!reportWin32VMConfig: aStream	| exePath iniPath |	self header: 'VM Configuration' on: aStream.	exePath := Smalltalk vm vmFileName.	iniPath := (exePath copyUpToLast: $.), '.ini'.	aStream nextPutAll: iniPath; cr.	self writeContentsSafelyFromFile: iniPath on: aStream.! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 12:08'!reportWorkingCopies: aStream	| list |	self header: 'Monticello Working Copies' on: aStream.	list := MCWorkingCopy allManagers asSortedCollection: [:a :b | a name <= b name]  .	list do: [:each | aStream nextPutAll: each description; cr]! !!SystemReporter methodsFor: 'updating' stamp: 'laza 1/18/2011 11:26'!updateReport	report := Text streamContents: [:stream | 		stream 			withAttribute: (TextFontReference toFont: ((TextStyle named: 'BitstreamVeraSansMono') fontOfSize: 16))			do: [				self categoryList do: [:each |					(categoriesSelected includes: each) ifTrue: [						self perform: ((categories at: each), ':') asSymbol with: stream.						stream cr]]]].	self changed: #reportText! !!SystemReporter methodsFor: 'private' stamp: 'laza 1/28/2011 09:57'!enumerate: aBlock on: aStream	self enumerate: aBlock startAt: 0 on: aStream! !!SystemReporter methodsFor: 'private' stamp: 'laza 1/28/2011 10:25'!enumerate: aBlock startAt: first on: aStream	"Utilitymethod to enumerate Options or Parameters from first to 1000"	| idx value |	idx := first.	[value := aBlock value: idx.	value = nil or: [idx > 1000]] whileFalse: [		aStream			nextPut: $#;			nextPutAll: idx printString;			tab;			nextPutAll: value; cr.		idx := idx + 1	].	idx = first ifTrue: [aStream nextPutAll: 'none'; cr]! !!SystemReporter methodsFor: 'private' stamp: 'laza 2/21/2011 23:57'!writeContentsSafelyFromFile: osPath on: aStream	aStream nextPutAll:		([			(FileStream readOnlyFileNamed: osPath) upToEnd		 ] on: Error do: [:ex| ex return: ex printString])! !!SystemReporter commentStamp: 'laza 1/18/2011 12:04' prior: 0!SystemReporter offers a window where information about the system is gathered. This can be easily copied to the clipboard and be attached to a bug report for better identification of the context the bug occured in.To extend the SystemReporter:	- add a method		reportXYZ: aStream	  to the reporting category	- insert a line		add: #XYZ method: #reportXYZ	  to the initialize method!!SystemReporter class methodsFor: 'instance creation' stamp: 'lr 10/8/2005 18:35'!open	^ ToolBuilder open: self new.! !!SystemVersion methodsFor: 'testing' stamp: 'cmm 4/14/2011 20:59'!isPharo	^ version includesSubString: 'Pharo'! !!SystemVersion methodsFor: 'testing' stamp: 'cmm 4/14/2011 20:59'!isSqueak	^ version includesSubString: 'Squeak'! !!SystemWindow methodsFor: 'events' stamp: 'mtf 2/21/2011 14:21'!handlesMouseDown: evt 	"If I am not the topWindow, then I will only respond to dragging by the title bar.	Any other click will only bring me to the top"	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!SystemWindow methodsFor: 'events' stamp: 'mtf 2/21/2011 16:21'!mouseDown: evt	TopWindow == self ifFalse:		[evt hand releaseKeyboardFocus.		self activate].		"the window was locked, thus we got the event. re-send it now that the window is unlocked again"	evt wasHandled: false.	model windowActiveOnFirstClick		ifTrue: [self processEvent: evt] "re-dispatch to any submorphs"		ifFalse: [label processEvent: evt]. "dispatch to label so dragging works"	evt wasHandled: true.! !!SystemWindow methodsFor: 'events' stamp: 'mtf 2/21/2011 14:21'!startDragFromLabel: evt	"When label events are active, we need to pass dragging to the window explicitely	 The window only recognizes a drag with an offset of more than 3 pixels"		self isSticky ifTrue: [^ self].	self fastFramingOn 		ifTrue: [self doFastFrameDrag: evt cursorPoint]		ifFalse: [evt hand grabMorph: self topRendererOrSelf]! !!SystemWindow methodsFor: 'initialization' stamp: 'ar 6/23/2010 17:13'!addCornerGrips	"When enabled via preference, also add edge grips"	super addCornerGrips.	self class resizeAlongEdges ifTrue:[self addEdgeGrips].! !!SystemWindow methodsFor: 'initialization' stamp: 'cmm 6/21/2011 20:13'!createExpandBox	^ (self createBox: self class expandBoxImage)		actionSelector: #expandBoxHit;		setBalloonText: 'expand this window' translated! !!SystemWindow methodsFor: 'menu' stamp: 'cmm 12/4/2010 15:11'!changeColor	"Change the color of the receiver -- triggered, e.g. from a menu.  This variant allows the recolor triggered from the window's halo recolor handle to have the same result as choosing change-window-color from the window-title menu"	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: self color				setColorSelector: #setWindowColor:) openNear: self fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #setWindowColor: ;				 originalColor: self color ;								putUpFor: self				near: self fullBoundsInWorld ]! !!SystemWindow methodsFor: 'menu' stamp: 'cmm 12/4/2010 15:11'!setWindowColor	"Allow the user to select a new basic color for the window"	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: self paneColorToUse				setColorSelector: #setWindowColor:) openNear: self fullBounds ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #setWindowColor: ;				 originalColor: self paneColorToUse ;								putUpFor: self				near: self fullBounds ]! !!SystemWindow methodsFor: 'menu' stamp: 'ul 11/15/2010 12:06'!takeOutOfWindow	"Take the receiver's pane morph out the window and place it, naked, where once the window was"	| aMorph |	paneMorphs size = 1 ifFalse: [^ Beeper beep].	aMorph := paneMorphs first.	owner addMorphFront: aMorph.	self delete! !!SystemWindow methodsFor: 'open/close' stamp: 'eem 5/23/2008 13:17'!delete	| thisWorld sketchEditor aPaintBox |	self mustNotClose ifTrue: [^self].	model okToClose ifFalse: [^self].	thisWorld := self world.	sketchEditor := self extantSketchEditor.	self isFlexed		ifTrue: [owner delete]		ifFalse: [super delete].	model windowIsClosing; release.	model := nil.	sketchEditor ifNotNil:		[sketchEditor deleteSelfAndSubordinates.		 (thisWorld notNil 		  and: [(aPaintBox := thisWorld paintBoxOrNil) notNil]) ifTrue:			[aPaintBox delete]].			SystemWindow noteTopWindowIn: thisWorld! !!SystemWindow methodsFor: 'open/close' stamp: 'cmm 6/4/2011 15:41'!openAsIsIn: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self.	self activeHand releaseAllFoci! !!SystemWindow methodsFor: 'open/close' stamp: 'cmm 6/4/2011 15:43'!openInWorld: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	self anyOpenWindowLikeMe		ifEmpty: 			[ self 				bounds: (RealEstateAgent initialFrameFor: self world: aWorld) ;				openAsIsIn: aWorld ]		ifNotEmptyDo:			[ : windows | 			windows anyOne				expand ;				activate ; 				postAcceptBrowseFor: self ].	self activeHand releaseAllFoci! !!SystemWindow methodsFor: 'open/close' stamp: 'eem 10/22/2010 12:08'!openInWorld: aWorld extent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	^ self anyOpenWindowLikeMe		ifEmpty:			[ self 				position: (RealEstateAgent initialFrameFor: self initialExtent: extent world: aWorld) topLeft ;				extent: extent.			self openAsIsIn: aWorld ]		ifNotEmptyDo:			[ : windows | 			windows anyOne				expand ;				activate ; 				postAcceptBrowseFor: self ]! !!SystemWindow methodsFor: 'panes' stamp: 'cwp 11/22/2011 21:02'!addMorph: aMorph fullFrame: aLayoutFrame	| left right bottom top windowBorderWidth |	windowBorderWidth := self class borderWidth.	left := aLayoutFrame leftOffset ifNil: [0].	right := aLayoutFrame rightOffset ifNil: [0].	bottom := aLayoutFrame bottomOffset ifNil: [0].	top := aLayoutFrame topOffset ifNil: [0].		aLayoutFrame rightFraction = 1 ifTrue: [aLayoutFrame rightOffset: right - windowBorderWidth].	aLayoutFrame leftFraction = 0		ifTrue: [aLayoutFrame leftOffset: left + windowBorderWidth]		ifFalse: [aLayoutFrame leftOffset: left + ProportionalSplitterMorph splitterWidth].	aLayoutFrame bottomFraction = 1 ifTrue: [aLayoutFrame bottomOffset: bottom - windowBorderWidth].	aLayoutFrame topFraction = 0		ifTrue: [aLayoutFrame topOffset: top + windowBorderWidth]		ifFalse: [aLayoutFrame topOffset: top + ProportionalSplitterMorph splitterWidth].		(aMorph class name = #BrowserCommentTextMorph) ifTrue:		[aLayoutFrame rightOffset: windowBorderWidth negated.		aLayoutFrame leftOffset: windowBorderWidth.		aLayoutFrame bottomOffset: windowBorderWidth negated.		aLayoutFrame topOffset: (windowBorderWidth negated) + 4].		super addMorph: aMorph fullFrame: aLayoutFrame.	paneMorphs := paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	aMorph adoptPaneColor: self paneColor.	aMorph borderWidth: 1; borderColor: Color lightGray; color: Color white.	Preferences scrollBarsOnRight	"reorder panes so flop-out right-side scrollbar is visible"		ifTrue: [self addMorphBack: aMorph].			self addPaneSplitters! !!SystemWindow methodsFor: 'panes' stamp: 'ul 11/15/2010 12:06'!holdsTranscript	"ugh"	| plug |	^ paneMorphs size = 1 and: [((plug := paneMorphs first) isKindOf: PluggableTextMorph) and: [plug model isKindOf: TranscriptStream]]! !!SystemWindow methodsFor: 'panes' stamp: 'ul 8/2/2011 20:11'!paneMorphSatisfying: aBlock	^paneMorphs detect: aBlock ifNone: [ nil ]! !!SystemWindow methodsFor: 'panes' stamp: 'ul 11/15/2010 12:06'!titleAndPaneText	"If the receiver represents a workspace, return an Association between the title and that text, else return nil"	(paneMorphs size ~= 1 or: [(paneMorphs first isKindOf: PluggableTextMorph) not])		ifTrue: [^ nil].	^ labelString -> paneMorphs first text! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'cmm 6/21/2011 20:12'!collapseOrExpand	"Collapse or expand the window, depending on existing state"	| cf |	isCollapsed		ifTrue: 			["Expand -- restore panes to morphics structure"			isCollapsed := false.			self activate.  "Bring to frint first"			Preferences collapseWindowsInPlace				ifTrue: 					[fullFrame := fullFrame align: fullFrame topLeft with: self getBoundsWithFlex topLeft]				ifFalse:					[collapsedFrame := self getBoundsWithFlex].			collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse this window' translated].			self setBoundsWithFlex: fullFrame.			paneMorphs reverseDo: 					[:m |  self addMorph: m unlock.					self world startSteppingSubmorphsOf: m].			self addPaneSplitters]		ifFalse: 			["Collapse -- remove panes from morphics structure"			isCollapsed := true.			fullFrame := self getBoundsWithFlex.			"First save latest fullFrame"			paneMorphs do: [:m | m delete; releaseCachedState].			self removePaneSplitters.			self removeCornerGrips.			model modelSleep.			cf := self getCollapsedFrame.			(collapsedFrame isNil and: [Preferences collapseWindowsInPlace not]) ifTrue:				[collapsedFrame := cf].			self setBoundsWithFlex: cf.			collapseBox ifNotNil: [collapseBox setBalloonText: 'expand this window' translated ].			expandBox ifNotNil: [expandBox setBalloonText: 'expand this window' translated ].			self sendToBack].	self layoutChanged! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'cmm 6/21/2011 20:13'!contractToOriginalSize	self bounds: self unexpandedFrame.	self unexpandedFrame: nil.	expandBox ifNotNil: [expandBox setBalloonText: 'expand this window' translated].! !!SystemWindow commentStamp: '<historical>' prior: 0!SystemWindow is the Morphic equivalent of StandardSystemView -- a labelled container for rectangular views, with iconic facilities for close, collapse/expand, and resizing.The attribute onlyActiveOnTop, if set to true (and any call to activate will set this), determines that only the top member of a collection of such windows on the screen shall be active.  To be not active means that a mouse click in any region will only result in bringing the window to the top and then making it active.!!SystemWindow class methodsFor: 'initializing' stamp: 'cmm 1/10/2011 14:10'!updatePreferences	"Temporary method to update system-wide preferences"	Preferences setPreference: #defaultWindowColor toValue: (Color veryVeryLightGray muchLighter).	(Preferences preferenceAt: #defaultWindowColor) defaultValue: (Color veryVeryLightGray muchLighter).	Preferences setPreference: #menuAppearance3d toValue: true.	(Preferences preferenceAt: #menuAppearance3d) defaultValue: true.	Preferences setPreference: #menuColorFromWorld toValue: false.	(Preferences preferenceAt: #menuColorFromWorld) defaultValue: false.	Preferences setPreference: #roundedMenuCorners toValue: false.	(Preferences preferenceAt: #roundedMenuCorners) defaultValue: false.	Preferences setParameter: #menuColor to: (Color gray: 0.9).	Preferences setParameter: #menuTitleColor to: (Color transparent).	Preferences setParameter: #menuTitleBorderWidth to: 0.	Preferences setParameter: #defaultWorldColor to: (Color gray: 0.25).	Preferences setPreference: #showSplitterHandles toValue: false.	(Preferences preferenceAt: #showSplitterHandles) defaultValue: true.	Preferences setPreference: #showSharedFlaps toValue: false.	(Preferences preferenceAt: #showSharedFlaps) defaultValue: false.	Preferences installBrightWindowColors.	CornerGripMorph drawCornerResizeHandles: false.	FillInTheBlankMorph roundedDialogCorners: true.	LazyListMorph		listSelectionColor: LazyListMorph listSelectionColor;		listSelectionTextColor: Color black.	PluggableButtonMorph roundedButtonCorners: true.	SystemWindow		clickOnLabelToEdit: false;		doubleClickOnLabelToExpand: true;		moveMenuButtonRight: true;		hideExpandButton: false.! !!SystemWindow class methodsFor: 'preferences' stamp: 'ar 6/23/2010 17:12'!resizeAlongEdges	<preference: 'Resize Windows along edges'		category: 'Morphic'		description: 'When true, windows can be resized along their edges as well as the corners'		type: #Boolean>	^ResizeAlongEdges ifNil:[true]! !!SystemWindow class methodsFor: 'preferences' stamp: 'ar 6/23/2010 17:13'!resizeAlongEdges: aBool	"Preference setter"	ResizeAlongEdges := aBool! !!TTCFont methodsFor: 'accessing' stamp: 'nice 8/27/2010 21:06'!emphasis: code	code > 3 ifTrue: [^ self].	code = 0 ifTrue: [^ self].	derivatives ifNil: [^ self].	^ (derivatives at: code) ifNil: [self].! !!TTCFont methodsFor: '*nebraska-file in/out' stamp: 'ul 5/16/2011 01:11'!encodedForRemoteCanvas	^String streamContents: [ :stream |		stream			nextPutAll: self familyName;			space;			print: self pointSize;			space;			print: self emphasis ]! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:18'!initialize"	self initialize"	| tt |	self allSubInstancesDo:[:fnt| fnt flushCache].	GlyphCacheSize := 512.	GlyphCacheData := Array new: GlyphCacheSize.	GlyphCacheIndex := 0.	GlyphCacheReady := true.		tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	FileServices registerFileReader: self.	Smalltalk addToShutDownList: self.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:18'!unload	FileServices unregisterFileReader: self! !!TTCFont class methodsFor: 'other' stamp: 'nice 8/27/2010 21:07'!registry	^ Registry		ifNil: [Registry := IdentityDictionary new]! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'nice 8/27/2010 21:07'!registry	^ Registry		ifNil: [Registry := IdentityDictionary new]! !!TTFileDescription class methodsFor: 'font paths' stamp: 'ul 8/2/2011 20:11'!fontFilesIn: path do: aBlock	"TTFileDescription loadAllFilesIn: 'C:\Windows\Fonts'"	"Load all the TTF files we can find in the given path"	| fd |	fd := FileDirectory on: path.	(fd fileNamesMatching: '*.ttf;*.ttc') do:[:fn|		(self readFontsFrom: fn) do: aBlock ]! !!TTFontReader methodsFor: 'processing' stamp: 'ul 6/17/2011 12:31'!processGlyphDataTable: entry offsets: offsetArray	"Read the actual glyph data from the font.	offsetArray contains the start offsets in the data for each glyph."	| initialOffset |	initialOffset := entry offset.	glyphs := Array new: nGlyphs.	1 to: nGlyphs do:[:i | 		glyphs at: i put: (TTGlyph new glyphIndex: i-1)].	'Reading glyph data' 		displayProgressFrom: 1 		to: nGlyphs 		during:[:bar| | nContours glyphOffset origin corner glyphLength glyph nextOffset |	1 to: nGlyphs do:[:glyphIndex |		bar value: glyphIndex.		glyph := glyphs at: glyphIndex.		glyphOffset := offsetArray at: glyphIndex.		nextOffset := offsetArray at: glyphIndex+1.		glyphLength := nextOffset - glyphOffset.		glyphLength = 0 ifFalse:[			entry offset: initialOffset + glyphOffset.			nContours := entry nextShort.			origin := entry nextShort @ entry nextShort.			corner := entry nextShort @ entry nextShort.			glyph bounds: (origin corner: corner).			nContours >= 0 ifTrue:[				self processSimpleGlyph: glyph contours: nContours from: entry			] ifFalse:[				glyph := self processCompositeGlyph: glyph contours: nContours from: entry.				glyphs at: glyphIndex put: glyph]]]	].! !!TTFontReader class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:38'!initialize	"self initialize"	FileServices registerFileReader: self! !!TTFontReader class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:38'!unload	FileServices unregisterFileReader: self ! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'nice 12/29/2010 15:02'!drawCharactersOn: aCanvas	| glyph origin r offset cy m |	0 to: 255 do: [:i |		glyph := font at: i.		origin := font bounds extent * ((i \\ 16) @ (i // 16)).		r := origin extent: font bounds extent.		offset := r center - glyph bounds center.		cy := glyph bounds center y.		m := MatrixTransform2x3 withOffset: 0@cy.		m := m composedWithLocal: (MatrixTransform2x3 withScale: 1 @ -1).		m := m composedWithLocal: (MatrixTransform2x3 withOffset: 0 @ cy negated).		m := m composedWithGlobal: (MatrixTransform2x3 withOffset: offset).		aCanvas asBalloonCanvas preserveStateDuring: [:balloonCanvas |			balloonCanvas transformBy: m.			balloonCanvas drawGeneralBezierShape: glyph contours					color: color					borderWidth: 0					borderColor: Color black.		].	].! !!TTSampleStringMorph methodsFor: 'private' stamp: 'nice 12/29/2010 15:02'!computeTransform	| cy |	cy := bounds origin y + bounds corner y * 0.5.	transform := MatrixTransform2x3 			transformFromLocal: (ttBounds insetBy: borderWidth negated)			toGlobal: bounds.	transform := transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0 @ cy negated).	transform := transform composedWithGlobal:(MatrixTransform2x3 withScale: 1.0 @ -1.0).	transform := transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0 @ cy).	^transform! !!TabMorph methodsFor: 'as yet unclassified' stamp: 'ul 9/28/2011 14:09'!convertToReferenceMorph	| aMorph |	aMorph := ReferenceMorph new referent: morphToInstall.	aMorph position: self position.	self becomeForward: aMorph.! !!TempVariableNode methodsFor: 'testing' stamp: 'ul 6/10/2011 22:24'!assignmentCheck: encoder at: location	^((self isBlockArg and: [Scanner allowBlockArgumentAssignment not])	    or: [self isMethodArg])			ifTrue: [location]			ifFalse: [-1]! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 8/14/2010 11:02'!isDeclaredAtMethodLevel	"For the explainer."	^scope = 0! !!TempVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitTempVariableNode: self! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 8/18/2011 16:22'!definingScope: scopeBlock "<BlockNode>"	definingScope ifNotNil:		[self error: 'temp has more than one defining scope.  This is probably a parser error'].	definingScope := scopeBlock! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:22'!emitCodeForLoad: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53'!emitCodeForStore: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStoreInto: self stack: stack encoder: encoder].	encoder genStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:54'!emitCodeForStorePop: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStorePopInto: self stack: stack encoder: encoder].	encoder genStorePopTemp: index.	stack pop: 1! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53'!emitCodeForValue: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForValueOf: self stack: stack encoder: encoder].	encoder genPushTemp: index.	stack push: 1! !!TempVariableNode methodsFor: 'code generation' stamp: 'jmv 3/2/2010 16:39'!sizeCodeForLoad: encoder	^remoteNode		ifNil: [0]		ifNotNil: [remoteNode sizeCodeForLoadFor: self encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52'!sizeCodeForStore: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStoreInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52'!sizeCodeForStorePop: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStorePopInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStorePopTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:51'!sizeCodeForValue: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForValueOf: self encoder: encoder].	self reserve: encoder.	^encoder sizePushTemp: index! !!TerseGuideHelp commentStamp: 'dtl 11/26/2010 12:17' prior: 0!TerseGuideHelp contains the Squeak terse guide by Chris Rathman (http://www.angelfire.com/tx4/cus/notes/smalltalk.html), maintained on the swiki at http://wiki.squeak.org/squeak/5699. Copyrights and credit for the original document belong to Chris Rathman.The original document was formatted for printing with a fixed font. Here it is reformatted for display in a help browser, with various updates and corrections to match the current state of the Squeak image. The contents of the help pages may be evaluated as workspace expressions.HelpBrowser openOn: TerseGuideHelp!!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 14:25'!arithmetic	^HelpTopic		title: 'Arithmetic Expressions' 		contents:'"************************************************************************ * Arithmetic expressions:															* ************************************************************************"| x |x := 6 + 3.								"addition"x := 6 - 3.								"subtraction"x := 6 * 3.								"multiplication"x := 1 + 2 * 3.							"evaluation always left to right (1 + 2) * 3"x := 5 / 3.								"division with fractional result"x := 5.0 / 3.0.							"division with float result"x := 5.0 // 3.0.							"integer divide"x := 5.0 \\ 3.0.							"integer remainder"x := -5.									"unary minus"x := 5 sign.								"numeric sign (1, -1 or 0)"x := 5 negated.							"negate receiver"x := 1.2 integerPart.						"integer part of number (1.0)"x := 1.2 fractionPart.					"fractional part of number (0.2)"x := 5 reciprocal.						"reciprocal function"x := 6 * 3.1.								"auto convert to float"x := 5 squared.							"square function"x := 25 sqrt.							"square root"x := 5 raisedTo: 2.						"power function"x := 5 raisedToInteger: 2.				"power function with integer"x := 5 exp.								"exponential"x := -5 abs.								"absolute value"x := 3.99 rounded.						"round"x := 3.99 truncated.						"truncate"x := 3.99 roundTo: 1.					"round to specified decimal places"x := 3.99 truncateTo: 1.					"truncate to specified decimal places"x := 3.99 floor.							"truncate"x := 3.99 ceiling.						"round up"x := 5 factorial.							"factorial"x := -5 quo: 3.							"integer divide rounded toward zero"x := -5 rem: 3.							"integer remainder rounded toward zero"x := 28 gcd: 12.							"greatest common denominator"x := 28 lcm: 12.							"least common multiple"x := 100 ln.								"natural logarithm"x := 100 log.							"base 10 logarithm"x := 100 log: 10	.						"logarithm with specified base"x := 100 floorLog: 10.					"floor of the log"x := 180 degreesToRadians.			"convert degrees to radians"x := 3.14 radiansToDegrees.			"convert radians to degrees"x := 0.7 sin.								"sine"x := 0.7 cos.							"cosine"x := 0.7 tan.								"tangent"x := 0.7 arcSin.							"arcsine"x := 0.7 arcCos.							"arccosine"x := 0.7 arcTan.							"arctangent"x := 10 max: 20.							"get maximum of two numbers"x := 10 min: 20.							"get minimum of two numbers"x := Float pi.							"pi"x := Float e.								"exp constant"x := Float infinity.						"infinity"x := Float nan.							"not-a-number"x := Random new next; yourself. x next.	"random number stream (0.0 to 1.0)"x := 100 atRandom.						"quick random number"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:46'!array	^HelpTopic		title: 'Array' 		contents:'"************************************************************************ * Array:         Fixed length collection												* * ByteArray:     Array limited to byte elements (0-255)								* * WordArray:     Array limited to word elements (0-2^32)							* ************************************************************************"| b x y sum max |x := #(4 3 2 1).									"constant array"x := Array with: 5 with: 4 with: 3 with: 2.			"create array with up to 4 elements"x := Array new: 4.								"allocate an array with specified size"x												"set array elements"   at: 1 put: 5;   at: 2 put: 4;   at: 3 put: 3;   at: 4 put: 2.b := x isEmpty.									"test if array is empty"y := x size.										"array size"y := x at: 4.										"get array element at index"b := x includes: 3.								"test if element is in array"y := x copyFrom: 2 to: 4.						"subarray"y := x indexOf: 3 ifAbsent: [0].					"first position of element within array"y := x occurrencesOf: 3.						"number of times object in collection"x do: [:a | Transcript show: a printString; cr].		"iterate over the array"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum array elements"sum := 0. 1 to: (x size) do: [:a | sum := sum + (x at: a)].	"sum array elements"sum := x inject: 0 into: [:a :c | a + c].				"sum array elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in array"   ifTrue: [a]   ifFalse: [c]].y := x shuffled.									"randomly shuffle collection"y := x asArray.									"convert to array"y := x asByteArray.								"convert to byte array"y := x asWordArray.								"convert to word array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:10'!assignment	^HelpTopic		title: 'Assignment' 		contents:'"************************************************************************ * Assignment:																		* ************************************************************************"| x y z |x _ 4.									"assignment (Squeak) <-"x := 5.									"assignment"x := y := z := 6.							"compound assignment"x := (y := 6) + 1.x := Object new.						"bind to allocated instance of a class"x := 123 class.							"discover the object class"x := Integer superclass.					"discover the superclass of a class"x := Object allInstances.				"get an array of all instances of a class"x := Integer allSuperclasses.			"get all superclasses of a class"x := 1.2 hash.							"hash value for object"y := x copy.								"copy object"y := x shallowCopy.						"copy object (not overridden)"y := x deepCopy.						"copy object and instance vars"y := x veryDeepCopy.					"complete tree copy using a dictionary"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:31'!association	^HelpTopic		title: 'Association' 		contents:'"************************************************************************ * Associations:																		* ************************************************************************"| x y |x := #myVar->''hello''.y := x key.y := x value.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:04'!bag	^HelpTopic		title: 'Bag' 		contents:'"************************************************************************ * Bag:        like OrderedCollection except elements are in no						* *                particular order														* ************************************************************************"| b x y sum max |x := Bag with: 4 with: 3 with: 2 with: 1.			"create collection with up to 4 elements"x := Bag new.									"allocate collection"x add: 4; add: 3; add: 1; add: 2; yourself.			"add element to collection"x add: 3 withOccurrences: 2.					"add multiple copies to collection"y := x addAll: #(7 8 9).							"add multiple elements to collection"y := x removeAll: #(7 8 9).						"remove multiple elements from collection"y := x remove: 4 ifAbsent: [].					"remove element from collection"b := x isEmpty.									"test if empty"y := x size.										"number of elements"b := x includes: 3.								"test if element is in collection"y := x occurrencesOf: 3.						"number of times object in collection"x do: [:a | Transcript show: a printString; cr].		"iterate over the collection"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:34'!bitwise	^HelpTopic		title: 'Bitwise Manipulation' 		contents:'"************************************************************************ * Bitwise Manipulation:																* ************************************************************************"| b x |x := 16rFF bitAnd: 16r0F.			"and bits"x := 16rF0 bitOr: 16r0F.				"or bits"x := 16rFF bitXor: 16r0F.				"xor bits"x := 16rFF bitInvert.					"invert bits"x := 16r0F bitShift: 4.				"left shift"x := 16rF0 bitShift: -4.				"right shift"x := 16r80 bitAt: 8.					"bit at position (0|1)"x := 16r80 highBit.					"position of highest bit set"b := 16rFF allMask: 16r0F.			"test if all bits set in mask set in receiver"b := 16rFF anyMask: 16r0F.			"test if any bits set in mask set in receiver"b := 16rFF noMask: 16r0F.			"test if all bits set in mask clear in receiver"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/28/2010 19:34'!block	^HelpTopic		title: 'Blocks' 		contents:'"************************************************************************ * Blocks:																			* *    - blocks are objects and may be assigned to a variable						* *    - value is last expression evaluated unless explicit return						* *    - blocks may be nested														* *    - specification [ arguments | | localvars | expressions ]							* *    - ^expression terminates block & method (exits all nested blocks)			* *    - blocks intended for long term storage should not contain ^					* ************************************************************************"| x y z fac |x := [ y := 1. z := 2. ]. x value.						"simple block usage"x := [ :argOne :argTwo |   argOne, '' and '' , argTwo.].	"set up block with argument passing"Transcript show: (x value: ''First'' value: ''Second''); cr.	"use block with argument passing"x := [:e | | v | v := 1. e + v] value: 2.					"localvar in a block"fac := [ :n | n > 1 ifTrue:  [n * (fac value: n-1)] ifFalse: [1]].	"closure on block variable"fac value: 5.											"closure variable scoped to its block"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:08'!boolean	^HelpTopic		title: 'Boolean' 		contents:'"************************************************************************ * Booleans:																		* ************************************************************************"| b x y |x := 1. y := 2.b := (x = y).								"equals"b := (x ~= y).							"not equals"b := (x == y).							"identical"b := (x ~~ y).							"not identical"b := (x > y).								"greater than"b := (x < y).								"less than"b := (x >= y).							"greater than or equal"b := (x <= y).							"less than or equal"b := b not.								"boolean not"b := (x < 5) & (y > 1).					"boolean and"b := (x < 5) | (y > 1).					"boolean or"b := (x < 5) and: [y > 1].					"boolean and (short-circuit)"b := (x < 5) or: [y > 1].					"boolean or (short-circuit)"b := (x < 5) eqv: (y > 1).					"test if both true or both false"b := (x < 5) xor: (y > 1).					"test if one true and other false"b := 5 between: 3 and: 12.				"between (inclusive)"b := 123 isKindOf: Number.				"test if object is class or subclass of"b := 123 isMemberOf: SmallInteger.		"test if object is type of class"b := 123 respondsTo: #sqrt.			"test if object responds to message"b := x isNil.								"test if object is nil"b := x isZero.							"test if number is zero"b := x positive.							"test if number is positive"b := x strictlyPositive.					"test if number is greater than zero"b := x negative.							"test if number is negative"b := x even.								"test if number is even"b := x odd.								"test if number is odd"b := x isLiteral.							"test if literal constant"b := x isInteger.							"test if object is integer"b := x isFloat.							"test if object is float"b := x isNumber.						"test if object is number"b := $A isUppercase.					"test if upper case character"b := $A isLowercase.					"test if lower case character"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:17'!character	^HelpTopic		title: 'Character' 		contents:'"************************************************************************ * Character:																		* ************************************************************************"| x y b |x := $A.										"character assignment"y := x isLowercase.							"test if lower case"y := x isUppercase.							"test if upper case"y := x isLetter.								"test if letter"y := x isDigit.								"test if digit"y := x isAlphaNumeric.						"test if alphanumeric"y := x isSeparator.							"test if seperator char"y := x isVowel.								"test if vowel"y := x digitValue.							"convert to numeric digit value"y := x asLowercase.						"convert to lower case"y := x asUppercase.						"convert to upper case"y := x asciiValue.							"convert to numeric ascii value"y := x asString.								"convert to string"b := $A <= $B.								"comparison"y := $A max: $B.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:16'!conditionalStatement	^HelpTopic		title: 'Conditional Statement' 		contents:'"************************************************************************ * Conditional Statements:															* ************************************************************************"| x switch result |x := 11.x > 10 ifTrue: [Transcript show: ''ifTrue''; cr].		"if then"x > 10 ifFalse: [Transcript show: ''ifFalse''; cr].	"if else"x > 10											"if then else"   ifTrue: [Transcript show: ''ifTrue''; cr]   ifFalse: [Transcript show: ''ifFalse''; cr].x > 10											"if else then"   ifFalse: [Transcript show: ''ifFalse''; cr]   ifTrue: [Transcript show: ''ifTrue''; cr].Transcript   show:      (x > 10         ifTrue: [''ifTrue'']         ifFalse: [''ifFalse'']);   cr.Transcript										"nested if then else"   show:      (x > 10         ifTrue: [x > 5            ifTrue: [''A'']            ifFalse: [''B'']]         ifFalse: [''C'']);   cr.switch := Dictionary new.						"switch functionality"switch at: $A put: [Transcript show: ''Case A''; cr].switch at: $B put: [Transcript show: ''Case B''; cr].switch at: $C put: [Transcript show: ''Case C''; cr].result := (switch at: $B) value.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:11'!constants	^HelpTopic		title: 'Constants' 		contents:'"************************************************************************ * Constants:																		* ************************************************************************"| b x |b := true.								"true constant"b := false.								"false constant"x := nil.									"nil object constant"x := 1.									"integer constants"x := 3.14.								"float constants"x := 2e-2.								"fractional constants"x := 16r0F.								"hex constant".x := -1.									"negative constants"x := ''Hello''.								"string constant"x := ''I''''m here''.							"single quote escape"x := $A.									"character constant"x := $ .									"character constant (space)"x := #aSymbol.							"symbol constants"x := #(3 2 1).							"array constants"x := #(''abc'' 2 $a).						"mixing of types allowed"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:57'!conversion	^HelpTopic		title: 'Conversion' 		contents:'"************************************************************************ * Conversion:																		* ************************************************************************"| x |x := 3.99 asInteger.				"convert number to integer (truncates in Squeak)"x := 3.99 asFraction.			"convert number to fraction"x := 3 asFloat.					"convert number to float"x := 65 asCharacter.			"convert integer to character"x := $A asciiValue.				"convert character to integer"x := 3.99 printString.			"convert object to string via printOn:"x := 3.99 storeString.			"convert object to string via storeOn:"x := 15 radix: 16.				"convert to string in given base"x := 15 printStringBase: 16.x := 15 storeStringBase: 16.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 22:19'!date	^HelpTopic		title: 'Date' 		contents:'"************************************************************************ * Date:																				* ************************************************************************"| x y b |x := Date today.								"create date for today"x := Date dateAndTimeNow.					"create date from current time/date"x := Date readFromString: ''01/02/1999''.			"create date from formatted string"x := Date newDay: 12 month: #July year: 1999.	"create date from parts"x := Date fromDays: 36000.						"create date from elapsed days since 1/1/1901"y := Date dayOfWeek: #Monday.				"day of week as int (1-7)"y := Date indexOfMonth: #January.				"month of year as int (1-12)"y := Date daysInMonth: 2 forYear: 1996.			"day of month as int (1-31)"y := Date daysInYear: 1996.						"days in year (365|366)"y := Date nameOfDay: 1.						"weekday name (#Monday,...)"y := Date nameOfMonth: 1.						"month name (#January,...)"y := Date leapYear: 1996.						"1 if leap year; 0 if not leap year"y := x weekday.									"day of week (#Monday,...)"y := x previous: #Monday.						"date for previous day of week"y := x dayOfMonth.								"day of month (1-31)"y := x day.										"day of year (1-366)"y := x firstDayOfMonth.							"day of year for first day of month"y := x monthName.								"month of year (#January,...)"y := x monthIndex.								"month of year (1-12)"y := x daysInMonth.								"days in month (1-31)"y := x year.										"year (19xx)"y := x daysInYear.								"days in year (365|366)"y := x daysLeftInYear.							"days left in year (364|365)"y := x asSeconds.								"seconds elapsed since 1/1/1901"y := x addDays: 10.								"add days to date object"y := x subtractDays: 10.							"subtract days to date object"y := x subtractDate: (Date today).				"subtract date (result in days)"y := x printFormat: #(2 1 3 $/ 1 1).				"print formatted date"b := (x <= Date today).							"comparison"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 13:16'!debugging	^HelpTopic		title: 'Debugging' 		contents:'"************************************************************************ * debugging:																		* ************************************************************************"| a b x |x := Object new.x yourself.								"returns receiver"String browse.							"browse specified class"x inspect.								"open object inspector window"x confirm: ''Is this correct?''.x halt.									"breakpoint to open debugger window"x halt: ''Halt message''.x notify: ''Notify text''.x error: ''Error string''.					"open up error window with title"x shouldNotImplement.					"flag message should not be implemented"x subclassResponsibility.				"flag message as abstract"x errorImproperStore.					"flag an improper store into indexable object"x errorNonIntegerIndex.				"flag only integers should be used as index"x errorSubscriptBounds: 13.			"flag subscript out of bounds"x primitiveFailed.						"system primitive failed"a := ''A1''. b := ''B2''. a become: b.			"switch two objects"Transcript show: a, b; cr.x doesNotUnderstand: (Message selector: #foo).	"flag message is not handled"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:05'!dictionary	^HelpTopic		title: 'Dictionary' 		contents:'"************************************************************************ * Dictionary:																		* * IdentityDictionary:   uses identity test (== rather than =)							* ************************************************************************"| b x y sum max |x := Dictionary new.								"allocate collection"x add: #a->4; add: #b->3; add: #c->1; add: #d->2; yourself.		"add element to collection"x at: #e put: 3.									"set element at index"b := x isEmpty.									"test if empty"y := x size.										"number of elements"y := x at: #a ifAbsent: [].							"retrieve element at index"y := x keyAtValue: 3 ifAbsent: [].					"retrieve key for given value with error block"y := x removeKey: #e ifAbsent: [].				"remove element from collection"b := x includes: 3.								"test if element is in values collection"b := x includesKey: #a.							"test if element is in keys collection"y := x occurrencesOf: 3.						"number of times object in collection"y := x keys.										"set of keys"y := x values.									"bag of values"x do: [:a | Transcript show: a printString; cr].		"iterate over the values collection"x keysDo: [:a | Transcript show: a printString; cr].			"iterate over the keys collection"x associationsDo: [:a | Transcript show: a printString; cr].	"iterate over the associations"x keysAndValuesDo: [:aKey :aValue | Transcript				"iterate over keys and values"   show: aKey printString; space;   show: aValue printString; cr].b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asArray.									"convert to array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"Smalltalk at: #CMRGlobal put: ''CMR entry''.		"put global in Smalltalk Dictionary"x := Smalltalk at: #CMRGlobal.					"read global from Smalltalk Dictionary"Transcript show: (CMRGlobal printString).		"entries are directly accessible by name"Smalltalk keys do: [ :k |							"print out all classes"   ((Smalltalk at: k) isKindOf: Class)      ifFalse: [Transcript show: k printString; cr]].Smalltalk at: #CMRDictionary put: (Dictionary new).	"set up user defined dictionary"CMRDictionary at: #MyVar1 put: ''hello1''.			"put entry in dictionary"CMRDictionary add: #MyVar2->''hello2''.			"add entry to dictionary use key->value combo"CMRDictionary size.		"dictionary size"CMRDictionary keys do: [ :k |					"print out keys in dictionary"   Transcript show: k printString; cr].CMRDictionary values do: [ :k |					"print out values in dictionary"   Transcript show: k printString; cr].CMRDictionary keysAndValuesDo: [:aKey :aValue |	"print out keys and values"   Transcript      show: aKey printString;      space;      show: aValue printString;      cr].CMRDictionary associationsDo: [:aKeyValue |		"another iterator for printing key values"   Transcript show: aKeyValue printString; cr].Smalltalk removeKey: #CMRGlobal ifAbsent: [].		"remove entry from Smalltalk dictionary"Smalltalk removeKey: #CMRDictionary ifAbsent: [].	"remove user dictionary from Smalltalk dictionary"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:37'!dynamic	^HelpTopic		title: 'Dynamic Message Calling/Compiling' 		contents:'"************************************************************************ * Dynamic Message Calling/Compiling:												* ************************************************************************"| receiver message result argument keyword1 keyword2 argument1 argument2 |"unary message"receiver := 5.message := ''factorial'' asSymbol.result := receiver perform: message.result := Compiler evaluate: ((receiver storeString), '' '', message).result := (Message new setSelector: message arguments: #()) sentTo: receiver."binary message"receiver := 1.message := ''+'' asSymbol.argument := 2.result := receiver perform: message withArguments: (Array with: argument).result := Compiler evaluate: ((receiver storeString), '' '', message, '' '', (argument storeString)).result := (Message new setSelector: message arguments: (Array with: argument)) sentTo: receiver."keyword messages"receiver := 12.keyword1 := ''between:'' asSymbol.keyword2 := ''and:'' asSymbol.argument1 := 10.argument2 := 20.result := receiver   perform: (keyword1, keyword2) asSymbol   withArguments: (Array with: argument1 with: argument2).result := Compiler evaluate:   ((receiver storeString), '' '', keyword1, (argument1 storeString) , '' '', keyword2, (argument2 storeString)).result := (Message   new      setSelector: (keyword1, keyword2) asSymbol      arguments: (Array with: argument1 with: argument2))   sentTo: receiver.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:34'!fileStream	^HelpTopic		title: 'File Stream' 		contents:'"************************************************************************ * FileStream:																		* ************************************************************************"| b x ios |ios := FileStream newFileNamed: ''ios.txt''.ios nextPut: $H; cr.ios nextPutAll: ''Hello File''; cr.''Hello File'' printOn: ios.''Hello File'' storeOn: ios.ios close.ios := FileStream oldFileNamed: ''ios.txt''.[(x := ios nextLine) notNil]   whileTrue: [Transcript show: x; cr].ios position: 3.x := ios position.x := ios next.x := ios peek.b := ios atEnd.ios close.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:33'!internalStream	^HelpTopic		title: 'Internal Stream' 		contents:'"************************************************************************ * Internal Stream:																	* ************************************************************************"| b x ios |ios := ReadStream on: ''Hello read stream''.ios := ReadStream on: ''Hello read stream'' from: 1 to: 5.[(x := ios nextLine) notNil]   whileTrue: [Transcript show: x; cr].ios position: 3.ios position.x := ios next.x := ios peek.x := ios contents.b := ios atEnd.ios := ReadWriteStream on: ''Hello read stream''.ios := ReadWriteStream on: ''Hello read stream'' from: 1 to: 5.ios := ReadWriteStream with: ''Hello read stream''.ios := ReadWriteStream with: ''Hello read stream'' from: 1 to: 10.ios position: 0.[(x := ios nextLine) notNil]   whileTrue: [Transcript show: x; cr].ios position: 6.ios position.ios nextPutAll: ''Chris''.x := ios next.x := ios peek.x := ios contents.b := ios atEnd.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:05'!interval	^HelpTopic		title: 'Interval' 		contents:'"************************************************************************ * Interval:																			* ************************************************************************"| b x y sum max |x := Interval from: 5 to: 10.						"create interval object"x := 5 to: 10.x := Interval from: 5 to: 10 by: 2.				"create interval object with specified increment"x := 5 to: 10 by: 2.b := x isEmpty.									"test if empty"y := x size.										"number of elements"x includes: 9.									"test if element is in collection"x do: [:k | Transcript show: k printString; cr].		"iterate over interval"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 7].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := 0. 1 to: (x size) do: [:a | sum := sum + (x at: a)].	"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asArray.									"convert to array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 11:14'!introduction	^HelpTopic		title: 'General' 		contents:'"************************************************************************ * Allowable characters:															* *    - a-z																			* *    - A-Z																			* *    - 0-9																			* *    - .+/\*~<>@%|&?																* *    - blank, tab, cr, ff, lf																* *																					* * Variables:																		* *    - variables must be declared before use										* *    - shared vars must begin with uppercase										* *    - local vars must begin with lowercase											* *    - reserved names: nil, true, false, self, super, and Smalltalk						* *																					* * Variable scope:																	* *    - Global: defined in Dictionary Smalltalk and accessible by all					* *         objects in system															* *    - Special: (reserved) Smalltalk, super, self, true, false, & nil						* *    - Method Temporary: local to a method										* *    - Block Temporary: local to a block												* *    - Pool: variables in a Dictionary object											* *    - Method Parameters: automatic local vars created as a result of 				* *         message call with params													* *    - Block Parameters: automatic local vars created as a result of					* *         value: message call															* *    - Class: shared with all instances of one class & its subclasses				* *    - Class Instance: unique to each instance of a class							* *    - Instance Variables: unique to each instance									* ************************************************************************""Comments are enclosed in quotes""Period (.) is the statement seperator"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 14:28'!iterationStatement	^HelpTopic		title: 'Iteration Statement' 		contents:'"************************************************************************ * Iteration statements:																* ************************************************************************"| x y |x := 4. y := 1.[x > 0] whileTrue: [x := x - 1. y := y * 2].		"while true loop"[x >= 4] whileFalse: [x := x + 1. y := y * 2].	"while false loop"x timesRepeat: [y := y * 2].					"times repear loop (i := 1 to x)"1 to: x do: [:a | y := y * 2].					"for loop"1 to: x by: 2 do: [:a | y := y / 2].				"for loop with specified increment"#(5 4 3) do: [:a | x := x + a].					"iterate over array elements"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 22:31'!metaclass	^HelpTopic		title: 'Class / Metaclass' 		contents:'"************************************************************************ * class/meta-class:																	* ************************************************************************"| b x |x := String name.						"class name"x := String category.					"organization category"x := String comment.					"class comment"x := String kindOfSubclass.				"subclass type - subclass: variableSubclass, etc"x := String definition.					"class definition"x := String instVarNames.				"immediate instance variable names"x := String allInstVarNames.				"accumulated instance variable names"x := String classVarNames.				"immediate class variable names"x := String allClassVarNames.			"accumulated class variable names"x := String sharedPools.					"immediate dictionaries used as shared pools"x := String allSharedPools.				"accumulated dictionaries used as shared pools"x := String selectors.					"message selectors for class"x := String sourceCodeAt: #indexOf:.	"source code for specified method"x := String allInstances.					"collection of all instances of class"x := String superclass.					"immediate superclass"x := String allSuperclasses.				"accumulated superclasses"x := String withAllSuperclasses.			"receiver class and accumulated superclasses"x := String subclasses.					"immediate subclasses"x := String allSubclasses.				"accumulated subclasses"x := String withAllSubclasses.			"receiver class and accumulated subclasses"b := String instSize.						"number of named instance variables"b := String isFixed.						"true if no indexed instance variables"b := String isVariable.					"true if has indexed instance variables"b := String isPointers.					"true if index instance vars contain objects"b := String isBits.						"true if index instance vars contain bytes/words"b := String isBytes.						"true if index instance vars contain bytes"b := String isWords.						"true if index instance vars contain words"Object withAllSubclasses size.			"get total number of class entries"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 14:27'!methodCall	^HelpTopic		title: 'Method Call' 		contents:'"************************************************************************ * Method calls:																		* *    - unary methods are messages with no arguments								* *    - binary methods																* *    - keyword methods are messages with selectors including colons				* *																					* * standard categories/protocols:													* *    - initialize-release    (methods called for new instance)							* *    - accessing             (get/set methods)											* *    - testing               (boolean tests - is)											* *    - comparing             (boolean tests with parameter							* *    - displaying            (gui related methods)										* *    - printing              (methods for printing)										* *    - updating              (receive notification of changes)							* *    - private               (methods private to class)									* *    - instance-creation     (class methods for creating instance)					* ************************************************************************"| x |x := 2 sqrt.									"unary message"x := 2 raisedTo: 10.							"keyword message"x := 194 * 9.								"binary message"Transcript show: (194 * 9) printString; cr.	"combination (chaining)"x := 2 perform: #sqrt.						"indirect method invocation"Transcript									"Cascading - send multiple messages to receiver"   show: ''hello '';   show: ''world'';   cr.x := 3 + 2; * 100.							"result=300. Sends message to same receiver (3)"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 14:00'!misc	^HelpTopic		title: 'Miscellaneous' 		contents:'"************************************************************************ * Misc.																				* ************************************************************************"| x |"Smalltalk condenseChanges."					"compress the change file"x := FillInTheBlank request: ''Prompt Me''.			"prompt user for input"x := UIManager default request: ''Prompt Me''.	"prompt user for input using a flexible UI dispatcher"Utilities openCommandKeyHelp'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:04'!orderedCollection	^HelpTopic		title: 'Ordered Collection' 		contents:'"************************************************************************ * OrderedCollection: acts like an expandable array								* ************************************************************************"| b x y sum max |x := OrderedCollection with: 4 with: 3 with: 2 with: 1.	"create collection with up to 4 elements"x := OrderedCollection new.					"allocate collection"x add: 3; add: 2; add: 1; add: 4; yourself.			"add element to collection"y := x addFirst: 5.								"add element at beginning of collection"y := x removeFirst.								"remove first element in collection"y := x addLast: 6.								"add element at end of collection"y := x removeLast.								"remove last element in collection"y := x addAll: #(7 8 9).							"add multiple elements to collection"y := x removeAll: #(7 8 9).						"remove multiple elements from collection"x at: 2 put: 3.									"set element at index"y := x remove: 5 ifAbsent: [].					"remove element from collection"b := x isEmpty.									"test if empty"y := x size.										"number of elements"y := x at: 2.										"retrieve element at index"y := x first.										"retrieve first element in collection"y := x last.										"retrieve last element in collection"b := x includes: 5.								"test if element is in collection"y := x copyFrom: 2 to: 3.						"subcollection"y := x indexOf: 3 ifAbsent: [0].					"first position of element within collection"y := x occurrencesOf: 3.						"number of times object in collection"x do: [:a | Transcript show: a printString; cr].		"iterate over the collection"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := 0. 1 to: (x size) do: [:a | sum := sum + (x at: a)].	"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x shuffled.									"randomly shuffle collection"y := x asArray.									"convert to array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:37'!pen	^HelpTopic		title: 'Pen' 		contents:'"************************************************************************ * Pen:																				* ************************************************************************"| myPen |Display restoreAfter: [   Display fillWhite.myPen := Pen new.								"get graphic pen"myPen squareNib: 1.myPen color: (Color blue).						"set pen color"myPen home.									"position pen at center of display"myPen up.										"makes nib unable to draw"myPen down.									"enable the nib to draw"myPen north.									"points direction towards top"myPen turn: -180.								"add specified degrees to direction"myPen direction.								"get current angle of pen"myPen go: 50.									"move pen specified number of pixels"myPen location.									"get the pen position"myPen goto: 200@200.							"move to specified point"myPen place: 250@250.						"move to specified point without drawing"myPen print: ''Hello World'' withFont: (TextStyle default fontAt: 1).Display extent.									"get display width@height"Display width.									"get display width"Display height.									"get display height"].'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 22:25'!point	^HelpTopic		title: 'Point' 		contents:'"************************************************************************ * Point:																				* ************************************************************************"| x y |x := 200@100.									"obtain a new point"y := x x.											"x coordinate"y := x y.											"y coordinate"x := 200@100 negated.							"negates x and y"x := (-200@ -100) abs.							"absolute value of x and y"x := (200.5@100.5) rounded.					"round x and y"x := (200.5@100.5) truncated.					"truncate x and y"x := 200@100 + 100.							"add scale to both x and y"x := 200@100 - 100.							"subtract scale from both x and y"x := 200@100 * 2.								"multiply x and y by scale"x := 200@100 / 2.								"divide x and y by scale"x := 200@100 // 2.								"divide x and y by scale"x := 200@100 \\ 3.								"remainder of x and y by scale"x := 200@100 + (50@25).						"add points"x := 200@100 - (50@25).						"subtract points"x := 200@100 * (3@4).							"multiply points"x := 200@100 // (3@4).							"divide points"x := 200@100 max: 50@200.					"max x and y"x := 200@100 min: 50@200.					"min x and y"x := 20@5 dotProduct: 10@2.					"sum of product (x1*x2 + y1*y2)"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:36'!rectangle	^HelpTopic		title: 'Rectangle' 		contents:'"************************************************************************ * Rectangle:																		* ************************************************************************"Rectangle fromUser.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:04'!set	^HelpTopic		title: 'Set' 		contents:'"************************************************************************ * Set:           like Bag except duplicates not allowed								* * IdentitySet:   uses identity test (== rather than =)								* ************************************************************************"| b x y sum max |x := Set with: 4 with: 3 with: 2 with: 1.			"create collection with up to 4 elements"x := Set new.									"allocate collection"x add: 4; add: 3; add: 1; add: 2; yourself.			"add element to collection"y := x addAll: #(7 8 9).							"add multiple elements to collection"y := x removeAll: #(7 8 9).						"remove multiple elements from collection"y := x remove: 4 ifAbsent: [].					"remove element from collection"b := x isEmpty.									"test if empty"y := x size.										"number of elements"x includes: 4.									"test if element is in collection"x do: [:a | Transcript show: a printString; cr].		"iterate over the collection"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asArray.									"convert to array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:04'!sortedCollection	^HelpTopic		title: 'Sorted Collection' 		contents:'"************************************************************************ * SortedCollection:    like OrderedCollection except order of elements			* *                         determined by sorting criteria									* ************************************************************************"| b x y sum max |x := SortedCollection with: 4 with: 3 with: 2 with: 1.	"create collection with up to 4 elements"x := SortedCollection new.							"allocate collection"x := SortedCollection sortBlock: [:a :c | a > c].		"set sort criteria"x add: 3; add: 2; add: 1; add: 4; yourself.				"add element to collection""y := x addFirst: 5."									"add element at beginning of collection"y := x removeFirst.									"remove first element in collection"y := x addLast: 6.									"add element at end of collection"y := x removeLast.									"remove last element in collection"y := x addAll: #(7 8 9).								"add multiple elements to collection"y := x removeAll: #(7 8 9).							"remove multiple elements from collection"y := x remove: 5 ifAbsent: [].						"remove element from collection"b := x isEmpty.										"test if empty"y := x size.											"number of elements"y := x at: 2.											"retrieve element at index"y := x first.											"retrieve first element in collection"y := x last.											"retrieve last element in collection"b := x includes: 4.									"test if element is in collection"y := x copyFrom: 2 to: 3.							"subcollection"y := x indexOf: 3 ifAbsent: [0].						"first position of element within collection"y := x occurrencesOf: 3.							"number of times object in collection"x do: [:a | Transcript show: a printString; cr].			"iterate over the collection"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].			"test if all elements meet condition"y := x select: [:a | a > 2].								"return collection of elements that pass test"y := x reject: [:a | a < 2].								"return collection of elements that fail test"y := x collect: [:a | a + a].							"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].					"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.			"sum elements"sum := 0. 1 to: (x size) do: [:a | sum := sum + (x at: a)].	"sum elements"sum := x inject: 0 into: [:a :c | a + c].					"sum elements"max := x inject: 0 into: [:a :c | (a > c)					"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asArray.										"convert to array"y := x asOrderedCollection.							"convert to ordered collection"y := x asSortedCollection.							"convert to sorted collection"y := x asBag.										"convert to bag collection"y := x asSet.										"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:03'!string	^HelpTopic		title: 'String' 		contents:'"************************************************************************ * String:																			* ************************************************************************"| b x y |x := ''This is a string''.						"string assignment"x := ''String'', ''Concatenation''.				"string concatenation"b := x isEmpty.								"test if string is empty"y := x size.									"string size"y := x at: 2.									"char at location"y := x copyFrom: 2 to: 4.					"substring"y := x indexOf: $a ifAbsent: [0].				"first position of character within string"x := String new: 4.							"allocate string object"x											"set string elements"   at: 1 put: $a;   at: 2 put: $b;   at: 3 put: $c;   at: 4 put: $e.x := String with: $a with: $b with: $c with: $d.	"set up to 4 elements at a time"x do: [:a | Transcript show: a printString; cr].		"iterate over the string"b := x allSatisfy: [:a | (a >= $a) & (a <= $z)].	"test if all elements meet condition"y := x select: [:a | a > $a].					"return all elements that meet condition"y := x asSymbol.							"convert string to symbol"y := x asArray.								"convert string to array"x := ''ABCD'' asByteArray.					"convert string to byte array"y := x asOrderedCollection.					"convert string to ordered collection"y := x asSortedCollection.					"convert string to sorted collection"y := x asBag.								"convert string to bag collection"y := x asSet.								"convert string to set collection"y := x shuffled.								"randomly shuffle string"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:02'!symbol	^HelpTopic		title: 'Symbol' 		contents:'"************************************************************************ * Symbol:																			* ************************************************************************"| b x y |x := #Hello.									"symbol assignment"y := ''String'', ''Concatenation''.				"symbol concatenation (result is string)"b := x isEmpty.								"test if symbol is empty"y := x size.									"string size"y := x at: 2.									"char at location"y := x copyFrom: 2 to: 4.					"substring"y := x indexOf: $e ifAbsent: [0].				"first position of character within string"x do: [:a | Transcript show: a printString; cr].	"iterate over the string"b := x allSatisfy: [:a | (a >= $a) & (a <= $z)].	"test if all elements meet condition"y := x select: [:a | a > $a].					"return all elements that meet condition"y := x asString.								"convert symbol to string"y := x asText.								"convert symbol to text"y := x asArray.								"convert symbol to array"y := x asOrderedCollection.					"convert symbol to ordered collection"y := x asSortedCollection.					"convert symbol to sorted collection"y := x asBag.								"convert symbol to bag collection"y := x asSet.								"convert symbol to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 22:22'!time	^HelpTopic		title: 'Time' 		contents:'"************************************************************************ * Time:																				* ************************************************************************"| x y b |x := Time now.									"create time from current time"x := Time dateAndTimeNow.					"create time from current time/date"x := Time readFromString: ''3:47:26 pm''.			"create time from formatted string"x := Time fromSeconds: (60 * 60 * 4).			"create time from elapsed time from midnight"y := Time millisecondClockValue.				"milliseconds since midnight"y := Time totalSeconds.							"total seconds since 1/1/1901"y := x seconds.									"seconds past minute (0-59)"y := x minutes.									"minutes past hour (0-59)"y := x hours.									"hours past midnight (0-23)"y := x addTime: (Time now).						"add time to time object"y := x subtractTime: (Time now).				"subtract time to time object"y := x asSeconds.								"convert time to seconds"x := Time millisecondsToRun: [					"timing facility"   1 to: 1000 do: [:index | y := 3.14 * index]]."b := (x <= Time now)."							"comparison"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:05'!transcript	^HelpTopic		title: 'Transcript' 		contents:'"************************************************************************ * Transcript:																		* ************************************************************************"Transcript clear.						"clear to transcript window"Transcript show: ''Hello World''.			"output string in transcript window"Transcript nextPutAll: ''Hello World''.		"output string in transcript window"Transcript nextPut: $A.					"output character in transcript window"Transcript space.						"output space character in transcript window"Transcript tab.							"output tab character in transcript window"Transcript cr.							"carriage return / linefeed"''Hello'' printOn: Transcript.				"append print string into the window"''Hello'' storeOn: Transcript.				"append store string into the window"Transcript endEntry.					"flush the output buffer"'! !!TerseGuideHelp class methodsFor: 'accessing' stamp: 'dtl 11/25/2010 10:56'!bookName	^'Terse Guide'! !!TerseGuideHelp class methodsFor: 'accessing' stamp: 'dtl 11/25/2010 13:41'!pages	^ #( introduction transcript assignment constants boolean arithmetic		bitwise conversion block methodCall conditionalStatement		iterationStatement character symbol string array orderedCollection		sortedCollection bag set interval association dictionary internalStream		fileStream date time point rectangle pen dynamic metaclass debugging		misc )! !!TestCase methodsFor: 'accessing' stamp: 'fbs 9/12/2011 20:29'!assert: expected equals: actual description: aString	^ self		assert: (expected = actual)		description: aString , ': ', (self comparingStringBetween: expected and: actual)! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:26'!defaultTimeout	"Answer the default timeout to use for tests in this test case.	The timeout is a value in seconds."	^5 "seconds"! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 13:10'!timeout: seconds	"The timeout for a test should normally be set with a method annotation.	However, for tests that are expected to run in images that do not support	method annotations, the value may be set by setting the value from the	#setUp method (i.e. prior to running the test method)."	timeout := seconds! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 15:26'!timeoutForSetUp	"Answer the timeout to use for setUp"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^self defaultTimeout! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 15:07'!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^timeout ifNil: [self defaultTimeout]! !!TestCase methodsFor: 'running' stamp: 'dtl 6/6/2010 15:10'!runCase	"Run this TestCase. Time out if the test takes too long."	[self timeout: [self setUp]		after: self timeoutForSetUp.	self timeout: [self performTest]		after: self timeoutForTest]		ensure: [self tearDown]! !!TestCase methodsFor: 'running' stamp: 'ar 7/9/2010 11:31'!timeout: aBlock after: seconds	"Evaluate the argument block. Time out if the evaluation is not	complete after the given number of seconds. Handle the situation	that a timeout may occur after a failure (during debug)"	| theProcess delay watchdog |	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := Delay forSeconds: seconds.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: 			(TestFailure new messageText: 'Test timed out') ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	watchdog resume.				"start up the watchdog"	^[aBlock on: TestFailure, Error, Halt do:[:ex|		theProcess := nil.		ex pass.	]] ensure:[							"evaluate the receiver"		theProcess := nil.				"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"	]! !!TestCase commentStamp: '<historical>' prior: 0!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.!!TestCase class methodsFor: 'building suites' stamp: 'spd 10/1/2010 10:26'!buildSuite	| suite |	suite := self suiteClass new.	^ self isAbstract		ifTrue: [			suite name: self name asString.			self allSubclasses				do: [:each | each isAbstract						ifFalse: [each addToSuiteFromSelectors: suite]].			suite]		ifFalse: [self addToSuiteFromSelectors: suite]! !!TestCase class methodsFor: 'building suites' stamp: 'spd 10/1/2010 10:26'!buildSuiteFromMethods: testMethods 	| suite |	suite := (self suiteClass new)				name: self name asString;				yourself.	^self addToSuite: suite fromMethods: testMethods! !!TestDynamicVariable commentStamp: 'mvl 3/13/2007 13:51' prior: 0!TestDynamicVariable is a test class using in ProcessSpecificTest.!!TestLocalVariable commentStamp: 'mvl 3/13/2007 13:52' prior: 0!TestLocalVariable is a test class using in ProcessSpecificTest.!!TestLocalVariable class methodsFor: 'as yet unclassified' stamp: 'mvl 3/13/2007 14:54'!default	"My default value for a new process is 0."		^0! !!TestObjectsAsMethods methodsFor: 'running' stamp: 'al 2/9/2009 20:19'!setUp	SystemChangeNotifier uniqueInstance doSilently: [		self class addSelector: #add:with: withMethod: ObjectsAsMethodsExample new.		self class addSelector: #answer42 withMethod: ObjectsAsMethodsExample new.		self class addSelector: #foo withMethod: AbstractObjectsAsMethod new ]! !!TestObjectsAsMethods methodsFor: 'running' stamp: 'al 2/9/2009 20:19'!tearDown	SystemChangeNotifier uniqueInstance doSilently: [		self class removeSelector: #add:with:.		self class removeSelector: #answer42.		self class removeSelector: #foo ]! !!TestObjectsAsMethods methodsFor: 'testing' stamp: 'al 2/9/2009 19:55'!testAddNumbers	self assert: (self add: 3 with: 4) = 7.	self assert: (self perform: #add:with: withArguments: #(3 4)) = 7.! !!TestObjectsAsMethods methodsFor: 'testing' stamp: 'al 2/9/2009 19:52'!testAnswer42 	self assert: self answer42 = 42! !!TestObjectsAsMethods methodsFor: 'testing' stamp: 'al 2/9/2009 19:52'!testDNU 	self should: [self foo] raise: MessageNotUnderstood! !!TestResource methodsFor: 'accessing' stamp: 'jmv 3/2/2010 16:40'!description	^description ifNil: [ '' ]! !!TestResource methodsFor: 'accessing' stamp: 'jmv 3/2/2010 16:40'!name	^name ifNil: [ self printString]! !!TestResource class methodsFor: 'accessing' stamp: 'nice 8/27/2010 18:02'!current	^ current ifNil: [ current := self new]			! !!TestResource class methodsFor: 'Creation' stamp: 'nice 8/27/2010 18:02'!reset	current ifNotNil: [:oldCurrent |		current := nil.		oldCurrent tearDown]! !!TestRunner methodsFor: 'accessing' stamp: 'cmm 1/11/2011 10:50'!classesSelected	^ classesSelected! !!TestRunner methodsFor: 'accessing-ui' stamp: 'cmm 1/11/2011 10:50'!postAcceptBrowseFor: aModel	"Nothing to do."! !!TestRunner methodsFor: 'accessing-ui' stamp: 'cmm 1/11/2011 10:50'!representsSameBrowseeAs: anotherModel 	^ self class = anotherModel class	and: [ classesSelected = anotherModel classesSelected ]! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:45'!buildWith: aBuilder	| window |	window := aBuilder pluggableWindowSpec new		model: self; label: self label; extent: self extent;		children: (OrderedCollection new 			add: ((self buildCategoriesWith: aBuilder)				frame: self categoriesFrame;				yourself);			add: ((self buildClassesWith: aBuilder)				frame: self classesFrame;				yourself);			add: ((self buildStatusWith: aBuilder)				frame: self statusFrame;				yourself);			add: ((self buildFailureListWith: aBuilder)				frame: self failureListFrame;				yourself);			add: ((self buildErrorListWith: aBuilder)				frame: self errorListFrame;				yourself);			add: ((self buildButtonsWith: aBuilder)				frame: self buttonsFrame;				yourself);			yourself);		yourself.	^ aBuilder build: window.! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:50'!buttonHeight	^Preferences standardButtonFont height + 25! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:45'!buttonsFrame	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 1 offset: self buttonHeight negated;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:48'!categoriesFrame	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.25 offset: 0;		bottomFraction: 1 offset: self buttonHeight negated + 4! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:48'!classesFrame	^LayoutFrame new		leftFraction: 0.25 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.5 offset: 0;		bottomFraction: 1 offset: self buttonHeight negated + 4! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:49'!errorListFrame	^LayoutFrame new		leftFraction: 0.5 offset: 0;		topFraction: 0.5 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: self buttonHeight negated + 4! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:43'!failureListFrame	^LayoutFrame new		leftFraction: 0.5 offset: 0;		topFraction: 0 offset: self statusHeight;		rightFraction: 1 offset: 0;		bottomFraction: 0.5 offset: 0! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:41'!statusFrame	^LayoutFrame new		leftFraction: 0.5 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 0 offset: self statusHeight! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:42'!statusHeight	^Preferences standardCodeFont height * 2 + 5! !!TestSuite methodsFor: 'accessing' stamp: 'nice 8/27/2010 17:59'!resources	^ resources ifNil: [resources := self defaultResources]			! !!TestSuite methodsFor: 'accessing' stamp: 'nice 8/27/2010 17:59'!tests	^ tests ifNil: [tests := OrderedCollection new]			! !!TestSuite methodsFor: 'running' stamp: 'cmm 3/4/2011 13:12'!debug	self tests do:		[ : each | self changed: each.		each debug ]! !!TestSuite methodsFor: 'running' stamp: 'spd 10/1/2010 10:28'!run	| result | 	result := self resultClass new.	self resources do: [ :res |		res isAvailable ifFalse: [^res signalInitializationError]].	[self run: result] ensure: [self resources do: [:each | each reset]].	^result			! !!TestSuite methodsFor: 'private' stamp: 'spd 10/1/2010 10:27'!resultClass	^ TestResult.! !!TestURI methodsFor: 'running file' stamp: 'ar 4/12/2010 21:38'!testDirWithHash	"Tests proper escaping of directories with hash mark"	| uriDir origPath origDir dirURI |	origPath := FileDirectory default pathName, '#123'.	origDir := FileDirectory on: origPath.	self assert: origDir pathName = origPath.	dirURI := origDir uri.	uriDir := FileDirectory uri: dirURI.	self assert: origDir fullName = uriDir fullName.! !!Text methodsFor: 'emphasis' stamp: 'nice 2/23/2011 21:50'!makeSelectorBold	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser i |	string size = 0 ifTrue: [^ self].	i := 0.	[(string at: (i := i + 1)) isSeparator] whileTrue.	(string at: i) = $[ ifTrue: [^ self].  "block, no selector"	[(parser := Compiler newParser) parseSelector: string] on: Error do: [^ self].	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'emphasis' stamp: 'nice 2/23/2011 21:50'!makeSelectorBoldIn: aClass	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser |	string size = 0 ifTrue: [^self].	(parser := aClass newParser) parseSelector: string.	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: '*network-url' stamp: 'ls 7/14/1998 03:17'!asUrl	^self asString asUrl! !!Text methodsFor: '*network-url' stamp: 'ls 7/14/1998 03:20'!asUrlRelativeTo: aUrl	^self asString asUrlRelativeTo: aUrl! !!TextAnchorTest methodsFor: 'initialize-release' stamp: 'cmm 6/12/2010 22:46'!testBeginWithAnAnchor	| text morph model |	text := Text streamContents:		[ : stream | stream			 nextPutAll:			(Text				string: (String value: 1)				attributes: {TextAnchor new anchoredMorph: Morph new. 					TextColor color: Color transparent}) ;			 nextPutAll: ' should be able to begin with an embedded object. ' ].	model := text -> nil.	morph := PluggableTextMorph		on: model		text: #key		accept: nil.	[ morph openInWorld ] ensure: [ morph delete ]! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'ar 5/5/2004 17:15'!menu	^nil! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'cmm 6/13/2010 20:50'!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks := argWantsColumnBreaks.	lines := argLinesCollection.	theTextStyle := argTextStyle.	theText := argText.	theContainer := argContainer.	deltaCharIndex := argDelta.	currCharIndex := startCharIndex := argStart.	stopCharIndex := argStop.	prevLines := argPriorLines.	currentY := argStartY.	maxRightX := theContainer left.	possibleSlide := stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding := false.	prevIndex := 1.	scanner := CompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	defaultLineHeight := scanner canComputeDefaultLineHeight		ifTrue: [ scanner computeDefaultLineHeight ]		ifFalse: [ theTextStyle lineGrid. ].	isFirstLine := true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!TextConverter methodsFor: 'conversion' stamp: 'ul 1/31/2011 02:35'!next: anInteger putAll: aString startingAt: startIndex toStream: aStream	"Handle fast conversion if ByteString"		| lastIndex nextIndex |	aString class == ByteString ifFalse: [		startIndex to: startIndex + anInteger - 1 do: [ :index |			self nextPut: (aString at: index) toStream: aStream ].		^aString ].	aStream isBinary ifTrue: [		aStream basicNext: anInteger putAll: aString startingAt: startIndex.		^aString ].	lastIndex := startIndex.	[ (nextIndex := ByteString 		findFirstInString: aString		inSet: latin1Map		startingAt: lastIndex) = 0 or: [ nextIndex > anInteger ] ] whileFalse: [			aStream				basicNext: nextIndex - lastIndex putAll: aString startingAt: lastIndex;				basicNextPutAll: (latin1Encodings at: (aString byteAt: nextIndex) + 1).			lastIndex := nextIndex + 1 ].	aStream basicNext: anInteger - lastIndex + startIndex putAll: aString startingAt: lastIndex.	^aString! !!TextConverter methodsFor: 'conversion' stamp: 'ul 1/31/2011 01:52'!nextPutAll: aString toStream: aStream	"Handle fast conversion if ByteString"		^self next: aString size putAll: aString startingAt: 1 toStream: aStream! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ul 11/2/2010 18:33'!buildDisplayPatch	| stream |	stream := AttributedTextStream new.	self 		patchSequenceDoIfMatch: [ :string |			self print: string withAttributes: NormalTextAttributes on: stream ]		ifInsert: [ :string |			self print: string withAttributes: InsertTextAttributes on: stream ]		ifRemove: [ :string |			self print: string withAttributes: RemoveTextAttributes on: stream ].	^stream contents! !!TextDiffBuilder methodsFor: 'private' stamp: 'ul 2/8/2011 03:04'!findMatches	"I find the matching pairs of xLines and yLines. First I filter out all lines that can't have a pair, then I find the longest common subsequence of the remaining elements. Finally I mark the matching pairs."	| temp lcs xFilteredLines yFilteredLines xNumbers yNumbers |	"Filter out all lines that can't have a pair."	temp := yLines asSet.	xFilteredLines := xLines select: [ :each |		temp includes: each ].	xFilteredLines size = 0 ifTrue: [ ^self ].	temp := xLines asSet.	yFilteredLines := yLines select: [ :each |		temp includes: each ].	yFilteredLines size = 0 ifTrue: [ ^self ].	"Map all lines to SmallIntegers, because they can be compared faster."	temp := Dictionary new.	xNumbers := xFilteredLines collect: [ :each |		temp at: each ifAbsentPut: [ temp size ] ].	yNumbers := yFilteredLines collect: [ :each |		temp at: each ifAbsentPut: [ temp size ] ].	temp := nil.	"Find the longest common subsequence."	lcs := self lcsFor: xNumbers and: yNumbers.	"Mark the matching pairs."	[ lcs == nil ] whileFalse: [		(xFilteredLines at: (lcs at: 1)) matches: (yFilteredLines at: (lcs at: 2)).		lcs := lcs at: 3 ]! !!TextDiffBuilder methodsFor: 'private' stamp: 'ul 1/10/2011 19:23'!lcsFor: xFilteredLines and: yFilteredLines	"I find one of the longest common subsequences of my the arguments. I assume that none of my arguments are empty. I return nil or an Array which represents a list. The first two elements are the matching line numbers, the last is the next node in the list or nil if there are no more elements. The list containts the longest common subsequence. I'm a modified version of the greedy lcs algorithm from the 6th page of 'An O(ND) Difference Algorithm and Its Variations (1986)' by Eugene W. Myers"	| n m v lcss max |	n := xFilteredLines size.	m := yFilteredLines size.	max := m + n.	v := Array new: 2 * max + 1.	v at: max + 2 put: 0.	lcss := Array new: 2 * max + 1.	0 to: max do: [ :d |		d negated to: d by: 2 do: [ :k |			| index lcs x y |			index := max + k.			(k + d = 0 or: [ k ~= d and: [ (v at: index) < (v at: index + 2) ] ])				ifTrue: [ x := v at: (index := index + 2) ]				ifFalse: [ x := (v at: index) + 1 ].			y := x - k.			lcs := lcss at: index.			[ x < n and: [ y < m and: [ (xFilteredLines at: x + 1) = (yFilteredLines at: y + 1) ] ] ]				whileTrue: [					lcs := { x := x + 1. y := y + 1. lcs } ].			(x >= n and: [ y >= m ]) ifTrue: [ ^lcs ].			v at: max + k + 1 put: x.			lcss at: max + k + 1 put: lcs ] ].	self error! !!TextDiffBuilder methodsFor: 'private' stamp: 'ul 11/4/2010 22:34'!print: aString withAttributes: attributes on: stream	stream		currentAttributes: attributes;		nextPutAll: aString.	(aString notEmpty and: [ 		aString last = Character cr or: [			aString endsWith: String crlf ] ]) 				ifFalse: [ stream cr ]! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 5/30/2011 10:03'!align	"Align text according to the next greater alignment value,	cycling among leftFlush, rightFlush, center, and justified."	self changeAlignment.	self recomputeSelection! !!TextEditor methodsFor: 'menu messages' stamp: 'cmm 6/4/2011 16:01'!browseClassFromIt	"Launch a hierarchy browser for the class indicated by the current selection.  If multiple classes matching the selection exist, let the user choose among them."	| aClass |	self lineSelectAndEmptyCheck: [ ^ self ].	aClass := Utilities		classFromPattern: self selection string withBlanksTrimmed		withCaption: 'choose a class to browse...'.	aClass ifNil: [ ^ morph flash ].	SystemNavigation default		spawnHierarchyForClass: aClass		selector: nil! !!TextEditor methodsFor: 'menu messages' stamp: 'nice 8/3/2011 22:11'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry brow |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol := self selectedSymbol) isNil ifTrue: [^ morph flash].	aSymbol first isUppercase		ifTrue:			[anEntry := (Smalltalk				at: aSymbol				ifAbsent:					[ self systemNavigation browseAllImplementorsOf: aSymbol.					^ nil]).			anEntry ifNil: [^ morph flash].			(anEntry isKindOf: Class)				ifFalse:	[anEntry := anEntry class].			brow := Preferences browseToolClass new.			brow setClass: anEntry selector: nil.			brow class				openBrowserView: (brow openEditString: nil)				label: 'System Browser']		ifFalse:			[self systemNavigation browseAllImplementorsOf: aSymbol]! !!TextEditor methodsFor: 'menu messages' stamp: 'fbs 3/16/2011 17:27'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b := model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ morph flash].	model okToChange ifFalse: [^ morph flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol := self selectedSymbol) isNil ifTrue: [^ morph flash].	foundClass := (Smalltalk at: aSymbol ifAbsent: [nil]).		foundClass isNil ifTrue: [^ morph flash].		(foundClass isKindOf: Class)			ifTrue:				[model selectSystemCategory: foundClass category.	model classListIndex: (model classList indexOf: foundClass name)]! !!TextEditor methodsFor: 'menu messages' stamp: 'nice 5/8/2011 12:11'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	Cursor execute showWhile: 			[ | string numbers delimitors cgVars reply selectors tiVars symbol sorry |			sorry := '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry := sorry , (morph canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string := self selection asString) isEmpty				ifTrue: [reply := '']				ifFalse: [string := self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are all letters"					(string allSatisfy: [:char | char isLetter or: [char isDigit]])						ifTrue: 							[tiVars := self explainTemp: string.							tiVars == nil ifTrue: [tiVars := self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars := model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars := '']						ifFalse: [tiVars := tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol := s])						ifTrue: [cgVars := self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars := self explainClass: symbol.									cgVars == nil ifTrue: [cgVars := self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors := self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors := self explainPartSel: string.									selectors == nil ifTrue: [										selectors := self explainAnySel: symbol]]]						ifFalse: [selectors := self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars := '']						ifFalse: [cgVars := cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors := '']						ifFalse: [selectors := selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors := self explainChar: string]						ifFalse: ["matched delimitors"							delimitors := self explainDelimitor: string].					numbers := self explainNumber: string.					numbers == nil ifTrue: [numbers := ''].					delimitors == nil ifTrue: [delimitors := ''].					reply := tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply := sorry].			self afterSelectionInsertAndSelect: reply]! !!TextEditor methodsFor: 'menu messages' stamp: 'nice 2/23/2011 21:42'!prettyPrint: decorated 	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	selectedClass := model selectedClassOrMetaClass.	selectedClass ifNil: [ ^ morph flash ].	newText := selectedClass newCompiler		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[ self			deselect ;			selectInvisiblyFrom: 1			to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: self text size + 1 ]! !!TextEditor methodsFor: 'menu messages' stamp: 'cmm 6/4/2011 16:06'!referencesToIt	"Open a MessageSet with the references to the selected global or variable name."	| selection environment binding |	self selection isEmpty ifTrue: [ self selectWord ].	environment := (model respondsTo: #selectedClassOrMetaClass)		ifTrue: [ model selectedClassOrMetaClass ifNil: [ Smalltalk globals ] ]		ifFalse: [ Smalltalk globals ].	selection := self selectedSymbol ifNil: [ self selection asString ].	(environment isBehavior and:		[ (environment			instVarIndexFor: selection			ifAbsent: [ 0 ]) ~= 0 ]) ifTrue: [ ^ self systemNavigation			browseAllAccessesTo: selection			from: environment ].	selection isSymbol ifFalse: [ ^ morph flash ].	binding := (environment bindingOf: selection) ifNil: [ ^ morph flash ].	self systemNavigation browseAllCallsOn: binding! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 5/30/2011 10:04'!undo	"Reset the state of the paragraph prior to the previous edit.	 If another ParagraphEditor instance did that edit, UndoInterval is invalid;	 just recover the contents of the undo-buffer at the start of the paragraph."	self closeTypeIn.	UndoParagraph == paragraph ifFalse: [ "Can't undo another paragraph's edit"		UndoMessage := Message selector: #undoReplace.		UndoInterval := 1 to: 0.		Undone := true].	UndoInterval ~= self selectionInterval ifTrue: [ "blink the actual target"		self selectInterval: UndoInterval].	"Leave a signal of which phase is in progress"	UndoParagraph := Undone ifTrue: [#redoing] ifFalse: [#undoing].	UndoMessage sentTo: self.	UndoParagraph := paragraph! !!TextEditor methodsFor: 'new selection' stamp: 'nice 8/3/2011 23:00'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| userSelection delta loc wasShowing |	aString = '#insert period' ifTrue: [		loc := start.		[(loc := loc-1)>0 and: [(paragraph string at: loc) isSeparator]]			whileTrue: [loc := loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	(wasShowing := selectionShowing) ifTrue: [ self reverseSelection ].	userSelection := self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString.	delta := aString size - (stop - start + 1).	self		selectInvisiblyFrom: userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ]).	wasShowing ifTrue: [ self reverseSelection ].! !!TextEditor methodsFor: 'new selection' stamp: 'nice 8/3/2011 21:33'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	self hasSelection ifFalse: [morph flash.  ^ returnBlock value]! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 9/17/2010 12:09'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc := start + dir.	str := paragraph string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc := loc + dir].	^ loc! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 9/17/2010 12:10'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok := false.	string := paragraph string.	stop := self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop := stop - 1].	sep := stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok := true. sep := sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!TextEditor methodsFor: 'private' stamp: 'cmm 8/17/2011 22:22'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where := self text				findString: FindText				startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	"Repeat it here. Senders beware: only one of these should last"	ChangeText ~~ FindText ifTrue: [ self zapSelectionWith: ChangeText ].	indices nextPut: where.	^ true! !!TextEditor methodsFor: 'private' stamp: 'nice 8/3/2011 19:22'!againOrSame: useOldKeys	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.	 1/26/96 sw: real worked moved to againOrSame:many:"	self againOrSame: useOldKeys many: false.	(morph respondsTo: #editView) 		ifTrue: [morph editView selectionInterval: self selectionInterval]! !!TextEditor methodsFor: 'private' stamp: 'nice 8/3/2011 21:33'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home := self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: [ "Choose as FindText..."		FindText := UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: [ "... else set it now as follows."			UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText := ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey := FindText size = 0)		ifTrue: [ "just inserted at a caret"			home := self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText := ChangeText] "... and search for it, without replacing"		ifFalse: [ "Show where the search will start"			home last = self selectionInterval last ifFalse: [				self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices := WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	"Last find was also stored in markBlock / pointBlock"	indices isEmpty ifTrue: [  "none found"		self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: [ "after undo, select this replacement"		home := self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!TextEditor methodsFor: 'private' stamp: 'nice 8/3/2011 22:52'!applyAttribute: aTextAttribute	"The user selected aTextAttribute via shortcut, menu or other means.	If there is a selection, apply the attribute to the selection.	In any case use the attribute for the user input (emphasisHere)"	| interval |	emphasisHere := Text addAttribute: aTextAttribute toArray: emphasisHere.		interval := self selectionInterval.	(interval isEmpty and: [ aTextAttribute isParagraphAttribute not ])		ifTrue: [ ^self ].		self text addAttribute: aTextAttribute from: interval first to: interval last.	paragraph recomposeFrom: interval first to: interval last delta: 0.	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"	morph changed! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:48'!beginningOfLine: position	"Redefined in subclasses using Paragraph support"	^ (paragraph lines at:(paragraph lineIndexFor: position)) first! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/21/2010 14:49'!endOfLine: position	"Redefined in subclasses using Paragraph support"	| targetLine |	targetLine := paragraph lines at: (paragraph lineIndexFor: position).	^ targetLine = paragraph lastLine		ifFalse: [ targetLine last ]		ifTrue: [ targetLine last + 1 ]! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!indent: delta fromStream: inStream toStream: outStream	"Append the contents of inStream to outStream, adding or deleting delta or -delta	 tabs at the beginning, and after every CR except a final CR.  Do not add tabs	 to totally empty lines, and be sure nothing but tabs are removed from lines."	| ch skip cr tab prev atEnd |	cr := Character cr.	tab := Character tab.	delta > 0		ifTrue: "shift right"			[prev := cr.			 [ch := (atEnd := inStream atEnd) ifTrue: [cr] ifFalse: [inStream next].			  (prev == cr and: [ch ~~ cr]) ifTrue:				[delta timesRepeat: [outStream nextPut: tab]].			  atEnd]				whileFalse:					[outStream nextPut: ch.					prev := ch]]		ifFalse: "shift left"			[skip := delta. "a negative number"			 [inStream atEnd] whileFalse:				[((ch := inStream next) == tab and: [skip < 0]) ifFalse:					[outStream nextPut: ch].				skip := ch == cr ifTrue: [delta] ifFalse: [skip + 1]]]! !!TextEditor methodsFor: 'private' stamp: 'nice 8/3/2011 22:37'!moveCursor: directionBlock forward: forward event: aKeyboardEvent specialBlock: specialBlock 	super moveCursor: directionBlock forward: forward event: aKeyboardEvent specialBlock: specialBlock.	self setEmphasisHere! !!TextEditor methodsFor: 'private' stamp: 'cmm 8/16/2011 23:11'!resetTypeAhead	typeAhead := WriteStream on: (String new: 1)! !!TextEditor methodsFor: 'private' stamp: 'cmm 8/16/2011 22:04'!typeAhead	^ typeAhead ifNil:		[ self resetTypeAhead.		typeAhead ]! !!TextEditor methodsFor: 'private' stamp: 'nice 8/3/2011 22:52'!unapplyAttribute: aTextAttribute	"The user selected aTextAttribute to be removed.	If there is a selection, unapply the attribute to the selection.	In any case do not use the attribute for the user input (emphasisHere)"	| interval |	emphasisHere := emphasisHere copyWithout: aTextAttribute.	interval := self selectionInterval.	(interval isEmpty and: [ aTextAttribute isParagraphAttribute not ])		ifTrue: [ ^self ].		self text removeAttribute: aTextAttribute from: interval first to: interval last.	paragraph recomposeFrom: interval first to: interval last delta: 0.	self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"	morph changed! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:42'!align: aKeyboardEvent	"Triggered by Cmd-u;  cycle through alignment alternatives.  8/11/96 sw"	self align.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:40'!browseIt: aKeyboardEvent	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"	self browseIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 19:26'!browseItHere: aKeyboardEvent 	"Triggered by Cmd-shift-B; browse the thing represented by the current selection, if plausible, in the receiver's own window.  3/1/96 sw"	self browseItHere.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:42'!cancel: aKeyboardEvent	"Cancel unsubmitted changes."	self cancel.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 20:46'!changeEmphasis: aKeyboardEvent 	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis. Emphasis change amounts to a font change.  Keeps typeahead."	"control 0..9 -> 0..9"	| keyCode attribute oldAttributes index thisSel colors extras |	keyCode := ('0123456789-=' indexOf: aKeyboardEvent keyCharacter ifAbsent: [1]) - 1.	oldAttributes := paragraph text attributesAt: self pointIndex.	thisSel := self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) 		ifTrue: [attribute := TextFontChange fontNumber: keyCode].	keyCode = 6 		ifTrue: [			colors := #(#black #magenta #red #yellow #green #blue #cyan #white).			extras := self emphasisExtras.			index := UIManager default chooseFrom:colors , #('choose color...' ), extras						lines: (Array with: colors size + 1).			index = 0 ifTrue: [^true].			index <= colors size 				ifTrue: [attribute := TextColor color: (Color perform: (colors at: index))]				ifFalse: [					index := index - colors size - 1.	"Re-number!!!!!!"					index = 0 						ifTrue: [attribute := self chooseColor]						ifFalse:[^self handleEmphasisExtra: index with: aKeyboardEvent]	"handle an extra"]].	(keyCode between: 7 and: 11) 		ifTrue: [			aKeyboardEvent shiftPressed 				ifTrue: [					keyCode = 10 ifTrue: [attribute := TextKern kern: -1].					keyCode = 11 ifTrue: [attribute := TextKern kern: 1]]				ifFalse: [					attribute := TextEmphasis 								perform: (#(#bold #italic #narrow #underlined #struckOut) at: keyCode - 6).					oldAttributes 						do: [:att | (att dominates: attribute) ifTrue: [attribute turnOff]]]].	keyCode = 0 ifTrue: [attribute := TextEmphasis normal].	attribute ifNotNil: [		thisSel size = 0			ifTrue: [				"only change emphasisHere while typing"				self insertTypeAhead.				emphasisHere := Text addAttribute: attribute toArray: oldAttributes ]			ifFalse: [				self replaceSelectionWith: (thisSel asText addAttribute: attribute) ]].	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 20:47'!changeLfToCr: aKeyboardEvent 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites	jmv- Modified to als change crlf by cr"		| fixed |	fixed := self selection string withSqueakLineEndings. 	self replaceSelectionWith: (Text fromString: fixed).	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'cmm 12/4/2010 15:11'!chooseColor	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"	| attribute |	attribute := TextColor color: Color black.	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph on: attribute) openNear: morph fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: morph activeHand ;				 target: attribute ;				 selector: #color: ;				 originalColor: Color black ;								putUpFor: morph				near: morph fullBoundsInWorld ].	^ attribute! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:42'!compareToClipboard: aKeyboardEvent	"Compare the receiver to the text on the clipboard."	self compareToClipboard.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 8/11/2010 10:33'!copyHiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hiddeninfo.  Copy that to the clipboard.  You can paste it and see what it is.Usually enclosed in <>."	^ self clipboardTextPut: self hiddenInfo! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!doIt: aKeyboardEvent	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.	2/29/96 sw: don't call selectLine; it's done by doIt now"	self doIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 22:45'!duplicate: aKeyboardEvent	"Paste the current selection over the prior selection, if it is non-overlapping and	 legal.  Flushes typeahead.  Undoer & Redoer: undoAndReselect."	self closeTypeIn.	(self hasSelection and: [self isDisjointFrom: otherInterval])		ifTrue: "Something to duplicate"			[self replace: otherInterval with: self selection and:				[self selectAt: self pointIndex]]		ifFalse:			[morph flash].	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'cmm 8/16/2011 19:34'!enclose: aKeyboardEvent	"Insert or remove bracket characters around the current selection."	| left right startIndex stopIndex oldSelection which t |	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([<{|"''9' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].	"Allow Control key in lieu of Alt+Shift for (, {, and double-quote."	left := ((Preferences cmdKeysInText and: [ aKeyboardEvent controlKeyPressed ])		ifTrue: [ '({<{|""(' ]		ifFalse: ['([<{|"''(']) at: which.	right := ((Preferences cmdKeysInText and: [ aKeyboardEvent controlKeyPressed ])		ifTrue: [ ')}>}|"")' ] 		ifFalse: [')]>}|"'')']) at: which.	t := self text.	((startIndex > 1 and: [stopIndex <= t size])			and: [ (t at: startIndex-1) = left and: [(t at: stopIndex) = right]])		ifTrue: [			"already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse: [			"not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string, (String with: right) attributes: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 22:46'!exchange: eKeyboardEvent	"Exchange the current and prior selections.  Keeps typeahead."	self insertAndCloseTypeIn.	self exchange.	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!exploreIt: aKeyboardEvent	"Explore the selection -- invoked via cmd-shift-I.  If there is no current selection, use the current line."	self exploreIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!fileItIn: aKeyboardEvent	"File in the selection; invoked via a keyboard shortcut, -- for now, cmd-shift-G."	self fileItIn.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 22:46'!handleEmphasisExtra: index with: aKeyboardEvent	"Handle an emphasis extra choice"	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 21:00'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList := self text attributesAt: (self pointIndex + self markIndex)//2.	attrList do: [:attr |		(attr isKindOf: TextAction) ifTrue:			[^ self selection asString, '<', attr info, '>']].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue:			[^ self selection asString, '<', attr color printString, '>']].	^ self selection asString, '[No hidden info]'! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!implementorsOfIt: aKeyboardEvent	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	self implementorsOfIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 22:46'!inOutdent: aKeyboardEvent delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| realStart realStop lines startLine stopLine start stop adjustStart indentation numLines oldString newString newSize |	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart := self startIndex.	realStop := self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == Character cr or: [(paragraph string at: realStart - 1) == Character lf]]])		ifTrue:			[delta < 0				ifTrue:					[morph flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^true].	lines := paragraph lines.	startLine := paragraph lineIndexOfCharacterIndex: realStart.	"start on a real line, not a wrapped line"	[startLine = 1 or: [CharacterSet crlf includes: (paragraph string at: (lines at: startLine-1) last)]] whileFalse: [startLine := startLine - 1].	stopLine := paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start := (lines at: startLine) first.	stop := (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart := realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation := (startLine to: stopLine) inject: 1000 into:		[:m :l |		m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].	indentation + delta <= 0 ifTrue: ["^false"].	numLines := stopLine + 1 - startLine.	oldString := paragraph string copyFrom: start to: stop.	newString := oldString species new: oldString size + ((numLines * delta) max: 0).	"Do the actual work"	newSize := 0.	delta > 0		ifTrue: [| tabs |			tabs := oldString species new: delta withAll: Character tab.			oldString lineIndicesDo: [:startL :endWithoutDelimiters :endL |				startL < endWithoutDelimiters ifTrue: [newString replaceFrom: 1 + newSize to: (newSize := newSize + delta) with: tabs startingAt: 1].				newString replaceFrom: 1 + newSize to: (newSize := 1 + newSize + endL - startL) with: oldString startingAt: startL]]		ifFalse: [| tab |			tab := Character tab.			oldString lineIndicesDo: [:startL :endWithoutDelimiters :endL |				| i |				i := 0.				[i + delta < 0 and: [ i + startL <= endWithoutDelimiters and: [(oldString at: i + startL) == tab]]] whileTrue: [i := i + 1].				newString replaceFrom: 1 + newSize to: (newSize := 1 + newSize + endL - (i + startL)) with: oldString startingAt: i + startL]].	newSize < newString size ifTrue: [newString := newString copyFrom: 1 to: newSize].	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart := (realStart + delta) max: start].	realStop := realStop + newSize - oldString size.	"Replace selection"	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: newString asText.	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:44'!indent: aKeyboardEvent	"Add a tab at the front of every line occupied by the selection. Invoked from keyboard via cmd-shift-R.  2/29/96 sw"	^ self inOutdent: aKeyboardEvent delta: 1! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!inspectIt: aKeyboardEvent	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"	self inspectIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 8/11/2010 10:08'!makeCapitalized: aKeyboardEvent	"Force the current selection to uppercase.  Triggered by Cmd-X."	| prev |	prev := $-.  "not a letter"	self replaceSelectionWith: 		(self selection string collect:			[:c | prev := prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]]).	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 8/11/2010 10:08'!makeLowercase: aKeyboardEvent	"Force the current selection to lowercase.  Triggered by Cmd-X."	self replaceSelectionWith: (self selection string asLowercase).	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 8/11/2010 10:08'!makeUppercase: aKeyboardEvent	"Force the current selection to uppercase.  Triggered by Cmd-Y."	self replaceSelectionWith: (self selection string asUppercase).	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 22:47'!methodNamesContainingIt: aKeyboardEvent 	"Browse methods whose selectors containing the selection in their names"	self methodNamesContainingIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 22:47'!methodStringsContainingIt: aKeyboardEvent 	"Invoked from cmd-E -- open a browser on all methods holding string constants containing it.  Flushes typeahead. "	self methodStringsContainingit.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:44'!offerFontMenu: aKeyboardEvent 	"The user typed the command key that requests a font change; Offer the font menu.  5/27/96 sw"	self insertAndCloseTypeIn.	self offerFontMenu.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:45'!outdent: aKeyboardEvent	"Remove a tab from the front of every line occupied by the selection.	Invoked from keyboard via cmd-shift-L.  2/29/96 sw"	^ self inOutdent: aKeyboardEvent delta: -1! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!pasteInitials: aKeyboardEvent 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor."	self insertAndCloseTypeIn.	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: self stopIndex].	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!printIt: aKeyboardEvent	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine now, since it's called by doIt"	self printIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!referencesToIt: aKeyboardEvent	"Triggered by Cmd-N; browse references to the current selection"	self referencesToIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!save: aKeyboardEvent	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw"	self insertAndCloseTypeIn.	self accept.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:41'!sendersOfIt: aKeyboardEvent	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	self sendersOfIt.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 19:26'!spawnIt: aKeyboardEvent	"Triggered by Cmd-o; spawn a new code window, if it makes sense."	self spawn.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 8/3/2011 22:47'!swapChars: aKeyboardEvent 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	(chars := self selection) size = 0		ifTrue:			[currentSelection := self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size = 2				ifFalse:					[morph flash. ^ true]				ifTrue:					[currentSelection := self pointIndex - 1]].	aString := self selection string.	self replaceSelectionWith: (Text string: aString reversed attributes: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:45'!undo: aKeyboardEvent 	"Undo the last edit."	self insertAndCloseTypeIn.	self undo.	^true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 20:32'!argAdvance: aKeyboardEvent	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	self insertAndCloseTypeIn.	start := paragraph text findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [start := paragraph text size + 1].	self selectAt: start + 2.	^true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 19:25'!changeStyle: aKeyboardEvent 	"Put up the style-change menu"	self insertAndCloseTypeIn.	self changeStyle.	^ true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 19:28'!crWithIndent: aKeyboardEvent 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	self addString: (String streamContents: [:characterStream | characterStream crtab: self tabCount]).  "Now inject CR with tabCount tabs"	^ false! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'cmm 8/16/2011 22:39'!destructiveBackWord: aKeyboardEvent	typeAhead isEmpty		ifTrue: [ super destructiveBackWord: aKeyboardEvent ]		ifFalse: [ typeAhead reset ].	^ false! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:40'!displayIfFalse: aKeyboardEvent	"Replace the current text selection with the text 'ifFalse:'--initiated by 	ctrl-f."	self addString: 'ifFalse:'.	^false! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:40'!displayIfTrue: aKeyboardEvent	"Replace the current text selection with the text 'ifTrue:'--initiated by 	ctrl-t."	self addString: 'ifTrue:'.	^false! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 19:29'!doAgainMany: aKeyboardEvent 	"Do the previous thing again repeatedly. 1/26/96 sw"	self insertAndCloseTypeIn.	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:) many: true.	^ true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:41'!doAgainOnce: aKeyboardEvent 	"Do the previous thing again once. 1/26/96 sw"	self insertAndCloseTypeIn.	self again.	^ true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'nice 8/3/2011 20:32'!find: aKeyboardEvent	"Prompt the user for what to find, then find it, searching from the current selection onward.  1/24/96 sw"	self insertAndCloseTypeIn.	self find.	^ true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 13:30'!findAgain: aKeyboardEvent 	"Find the desired text again.  1/24/96 sw"	self insertAndCloseTypeIn.	self againOrSame: true many: aKeyboardEvent shiftPressed.	^ true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'nice 8/4/2011 00:09'!forwardDelete: aKeyboardEvent	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex := self markIndex.	startIndex > self text size ifTrue: [		^ false].	self hasSelection ifTrue: [		"there was a selection"		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInIndex ifNil: [	"no previous typing.  openTypeIn"		self openTypeIn. UndoSelection := self nullText].	uinterval := UndoInterval copy.	upara := UndoParagraph copy.	stopIndex := startIndex.	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph := upara.  UndoInterval := uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel := UndoSelection.			ind := startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with: self nullText]].	^false! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 12:41'!querySymbol: aKeyboardEvent	"Invoked by Ctrl-q to query the Symbol table and display alternate symbols.	 See comment in completeSymbol:lastOffering: for details."	self insertAndCloseTypeIn.	self hasCaret		ifTrue: "Ctrl-q typed when a caret"			[self perform: #completeSymbol:lastOffering: withArguments:				((UndoParagraph == paragraph and: [UndoMessage sends: #undoQuery:lastOffering:])					ifTrue: [UndoMessage arguments] "repeated Ctrl-q"					ifFalse: [Array with: nil with: nil])] "initial Ctrl-q"		ifFalse: "Ctrl-q typed when statements were highlighted"			[morph flash].	^true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/2/2009 13:27'!search: aKeyboardEvent	"Invoked by Ctrl-S.  Same as 'again', but always uses the existing FindText	 and ChangeText regardless of the last edit."	self insertAndCloseTypeIn.	self		againOrSame: true "true means use same keys"		many: aKeyboardEvent shiftPressed.	^true! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 8/11/2010 10:01'!addString: aString	self typeAhead nextPutAll: aString! !!TextEditor methodsFor: 'typing support' stamp: 'cmm 8/17/2011 22:12'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over;	(3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit := beginTypeInIndex		ifNil: [self openTypeIn. UndoSelection := self nullText. self stopIndex].	markBlock := paragraph characterBlockForIndex: startIndex.	startIndex < saveLimit ifTrue: [		newBackovers := beginTypeInIndex - startIndex.		beginTypeInIndex := self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(self text copyFrom: startIndex to: saveLimit - 1).		UndoMessage arguments size > 0 ifTrue: [			UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers]].	self zapSelectionWith: self nullText.	self unselect! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 5/27/2011 10:49'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin stop |	beginTypeInIndex ifNotNil: [		(UndoMessage sends: #noUndoer) ifTrue: [ "should always be true, but just in case..."			begin := beginTypeInIndex.			stop := self stopIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval := begin to: stop - 1].		beginTypeInIndex := nil]! !!TextEditor methodsFor: 'typing support' stamp: 'nice 8/3/2011 20:32'!dispatchOnEnterWith: aKeyboardEvent	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it. "	aKeyboardEvent commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self insertAndCloseTypeIn.			self accept].	^ true! !!TextEditor methodsFor: 'typing support' stamp: 'Richo 10/6/2011 16:01'!dispatchOnKeyboardEvent: aKeyboardEvent	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys openers closers result |	(aKeyboardEvent keyCharacter == Character cr and: [ morph acceptOnCR ])		ifTrue: [ 			self closeTypeIn.			^ true ].	self clearParens.	aKeyboardEvent keyValue = 13		ifTrue: [ 			aKeyboardEvent controlKeyPressed				ifTrue: [ ^ self normalCharacter: aKeyboardEvent ].			aKeyboardEvent shiftPressed				ifTrue: [ ^ self lf: aKeyboardEvent ].			aKeyboardEvent commandKeyPressed				ifTrue: [ ^ self crlf: aKeyboardEvent ].			^ self crWithIndent: aKeyboardEvent ].	((honorCommandKeys := Preferences cmdKeysInText) and: [ aKeyboardEvent keyCharacter = Character enter ])		ifTrue: [ ^ self dispatchOnEnterWith: aKeyboardEvent ].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl."	((self class specialShiftCmdKeys includes: aKeyboardEvent keyValue) and: [ aKeyboardEvent keyValue < 27 ])		ifTrue: [ 			^ aKeyboardEvent controlKeyPressed				ifTrue: [ self perform: (self class shiftCmdActions at: aKeyboardEvent keyValue + 1) with: aKeyboardEvent ]				ifFalse: [ self perform: (self class cmdActions at: aKeyboardEvent keyValue + 1) with: aKeyboardEvent ] ].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [ aKeyboardEvent commandKeyPressed ])		or: [ self class specialShiftCmdKeys includes: aKeyboardEvent keyValue ])		ifTrue: [ 			^ aKeyboardEvent shiftPressed				ifTrue: [ self perform: (self class shiftCmdActions at: aKeyboardEvent keyValue + 1) with: aKeyboardEvent ]				ifFalse: [ self perform: (self class cmdActions at: aKeyboardEvent keyValue + 1) with: aKeyboardEvent ] ].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [ aKeyboardEvent controlKeyPressed ])		ifTrue: [ ^ self perform: (self class shiftCmdActions at: aKeyboardEvent keyValue + 1) with: aKeyboardEvent ].	openers := '([{'.	closers := ')]}'.	result := self normalCharacter: aKeyboardEvent.	(closers includes: aKeyboardEvent keyCharacter)		ifTrue: [ self blinkPrevParen: aKeyboardEvent keyCharacter].	(self class autoEnclose and: [ openers includes: aKeyboardEvent keyCharacter ])		ifTrue: [ 			self 				addString: (closers at: (openers indexOf: aKeyboardEvent keyCharacter)) asString;  				insertTypeAhead ;				moveCursor: [ :position | position - 1 ] 				forward: false 				select: false ].	^ result! !!TextEditor methodsFor: 'typing support' stamp: 'nice 8/3/2011 21:27'!doneTyping	beginTypeInIndex := nil! !!TextEditor methodsFor: 'typing support' stamp: 'cmm 8/17/2011 21:13'!insertAndCloseTypeIn	self		insertTypeAhead ;		closeTypeIn! !!TextEditor methodsFor: 'typing support' stamp: 'cmm 8/16/2011 22:05'!insertTypeAhead	self typeAhead position = 0 ifFalse:		[self zapSelectionWith: (Text string: self typeAhead contents emphasis: emphasisHere).		self typeAhead reset.		self unselect]! !!TextEditor methodsFor: 'typing support' stamp: 'nice 8/3/2011 21:28'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInIndex ifNil: [		UndoSelection := self nullText.		self undoer: #noUndoer with: 0.		beginTypeInIndex := self startIndex]! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 9/1/2009 18:45'!setEmphasisHereFromText	self setEmphasisHereFromTextForward: true! !!TextEditor methodsFor: 'typing support' stamp: 'nice 8/3/2011 21:51'!setEmphasisHereFromTextForward: f	| i t forward delta prevIsSeparator nextIsSeparator |	i := self pointIndex.	t := self text.	"Try to set emphasisHere correctly after whitespace.	Most important after a cr, i.e. at the start of a new line"	prevIsSeparator :=  i > 1 and: [ (t at: i-1) isSeparator ].	nextIsSeparator := i <= t size and: [ (t at: i) isSeparator ].	forward := prevIsSeparator = nextIsSeparator		ifTrue: [ f ]		ifFalse: [ nextIsSeparator ].	delta := forward ifTrue: [ 1 ] ifFalse: [ 0 ].	emphasisHere := (t attributesAt: (i - delta max: 1))					select: [:att | att mayBeExtended].! !!TextEditor methodsFor: 'typing support' stamp: 'nice 8/3/2011 21:28'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInIndex == nil ifTrue: [^ nil].	beginTypeInIndex isNumber ifTrue: [^ beginTypeInIndex].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInIndex stringIndex! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 11/12/2010 14:56'!blinkParen	"Used if Shout"	lastParenLocation ifNotNil: [		self text string size >= lastParenLocation ifTrue: [			self text				addAttribute: TextEmphasis bold				from: lastParenLocation				to: lastParenLocation]]! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 11/12/2010 14:55'!blinkPrevParen: aKeyboardEvent	"Used if not Shout"	| openDelimiter closeDelimiter level string here hereChar |	string := paragraph string.	here := pointBlock stringIndex.	openDelimiter := aKeyboardEvent keyCharacter.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	[level > 0 and: [here > 1]]		whileTrue:			[hereChar := string at: (here := here - 1).			hereChar = closeDelimiter				ifTrue:					[level := level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level := level + 1]]]! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 8/16/2009 18:31'!clearParens	lastParenLocation ifNotNil: [		self text string size >= lastParenLocation ifTrue: [			self text				removeAttribute: TextEmphasis bold				from: lastParenLocation				to: lastParenLocation]].	lastParenLocation := nil! !!TextEditor methodsFor: 'attributes' stamp: 'nice 8/3/2011 22:41'!changeEmphasisOrAlignment	| aList reply  code align menuList startIndex |	startIndex := self startIndex.	aList := #(normal bold italic narrow underlined struckOut leftFlush centered rightFlush justified).		align := paragraph text alignmentAt: startIndex 		ifAbsent: [ paragraph textStyle alignment ].	code := paragraph text emphasisAt: startIndex.	menuList := WriteStream on: Array new.	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'normal' translated.	menuList nextPutAll: (#(bold italic underlined struckOut) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue: [ '<on>', emph asString translated ]			ifFalse: [ '<off>',emph asString translated ]]).	((paragraph text attributesAt: startIndex)		anySatisfy: [ :attr | attr isKern and: [attr kern < 0 ]]) 			ifTrue: [ menuList nextPut:'<on>', 'narrow' translated ]			ifFalse: [ menuList nextPut:'<off>', 'narrow' translated ].	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collectWithIndex: [ :type :i |		align = (i-1)			ifTrue: [ '<on>',type asString translated ]			ifFalse: [ '<off>',type asString translated ]]).	aList := #(normal bold italic underlined struckOut narrow leftFlush centered rightFlush justified).	reply := UIManager default chooseFrom: menuList contents values: aList lines: #(1 6).	reply notNil ifTrue: [		(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue: [				self setAlignment: reply.				paragraph composeAll.				self recomputeSelection]			ifFalse: [				self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection]].	^ true! !!TextEditor methodsFor: 'attributes' stamp: 'nice 8/3/2011 22:41'!changeSelectionFontTo: aFont 	| attr |	aFont ifNil: [ ^ self ].	attr := TextFontReference toFont: aFont.	paragraph text		addAttribute: attr		from: self startIndex		to:			(self hasSelection				ifTrue: [ self stopIndex - 1 min: paragraph text size ]				ifFalse: [ paragraph text size ]).	paragraph composeAll.	self recomputeSelection.	morph changed! !!TextEditor methodsFor: 'attributes' stamp: 'cmm 12/1/2010 10:42'!changeTextFont	"Present a dialog which allows the user to select a font, and if one is chosen, apply it to the current selection.	If there is no selection, or the selection is empty, apply it to the whole morph."	| curFont startIndex |	startIndex := self startIndex.	curFont := (paragraph text fontAt: startIndex withStyle: paragraph textStyle).	morph openModal: (		Cursor wait showWhile: [ 			(FontChooserTool default				withTitle: 'Change the selected text''s font to...' translated				for: self 				setSelector: #changeSelectionFontTo:				getSelector: curFont)			"Do not allow changing the emphasis; we don't know how to deal with			a 'pre-emphasized' font here, so bail."					offerStyleList: false;					open])! !!TextEditor methodsFor: 'initialize-release' stamp: 'nice 8/3/2011 23:25'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	pointBlock := markBlock := paragraph defaultCharacterBlock.	beginTypeInIndex := nil.	UndoInterval := otherInterval := 1 to: 0.	self setEmphasisHere.	selectionShowing := false! !!TextEditor methodsFor: 'initialize-release' stamp: 'nice 8/3/2011 21:27'!stateArrayPut: stateArray	| sel |	ChangeText := stateArray at: 1.	FindText := stateArray at: 2.	UndoInterval := stateArray at: 3.	UndoMessage := stateArray at: 4.	UndoParagraph := stateArray at: 5.	UndoSelection := stateArray at: 6.	Undone := stateArray at: 7.	sel := stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInIndex := stateArray at: 9.	emphasisHere := stateArray at: 10! !!TextEditor methodsFor: 'do-its' stamp: 'ul 6/13/2011 12:19'!debug: aCompiledMethod receiver: anObject in: evalContext	| guineaPig debugger context |	guineaPig := [		aCompiledMethod			valueWithReceiver: anObject			 arguments: (evalContext ifNil: [ #() ] ifNotNil: [ { evalContext } ]) ] newProcess.	context := guineaPig suspendedContext.	debugger := Debugger new		process: guineaPig		controller: nil		context: context.	debugger openFullNoSuspendLabel: 'Debug it'.	[ debugger interruptedContext method == aCompiledMethod ]		whileFalse: [ debugger send ]! !!TextEditor methodsFor: 'do-its' stamp: 'nice 2/14/2011 22:15'!debugIt	| method receiver context |	(model respondsTo: #doItReceiver) 		ifTrue: 			[receiver := model doItReceiver.			context := model doItContext]		ifFalse:			[receiver := context := nil].	self lineSelectAndEmptyCheck: [^self].	method := self compileSelectionFor: receiver in: context.	method notNil ifTrue:		[self debug: method receiver: receiver in: context].! !!TextEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:51'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"		^self evaluateSelectionAndDo: [:result | result]! !!TextEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:57'!evaluateSelectionAndDo: aBlock	"Treat the current selection as an expression; evaluate it and invoke aBlock with the result."	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ nil].	(model respondsTo: #doItReceiver) 		ifTrue: [ rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [morph flash. ^ nil]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	^aBlock value: result! !!TextEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:49'!exploreIt	self evaluateSelectionAndDo: [:result | result explore]! !!TextEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:49'!inspectIt	 self evaluateSelectionAndDo: [:result | result inspect]! !!TextEditor methodsFor: 'do-its' stamp: 'nice 3/31/2011 21:50'!printIt	self evaluateSelectionAndDo:		[:result | self afterSelectionInsertAndSelect: result printString]! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:41'!cursorEnd: aKeyboardEvent 	"Private - Move cursor end of current line."	| string |	self insertAndCloseTypeIn.	string := paragraph text string.	self		moveCursor:			[:position | Preferences wordStyleCursorMovement				ifTrue:[| targetLine |					targetLine := paragraph lines at:(paragraph lineIndexOfCharacterIndex: position).					targetLine = paragraph lastLine						ifTrue:[targetLine last + 1]						ifFalse:[targetLine last]]				ifFalse:[					string						indexOfAnyOf: CharacterSet crlf						startingAt: position						ifAbsent:[string size + 1]]]		forward: true		event: aKeyboardEvent		specialBlock:[:dummy | string size + 1].	^true! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:41'!cursorHome: aKeyboardEvent 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	| string |	string := paragraph text string.	self		moveCursor: [ :position | Preferences wordStyleCursorMovement				ifTrue:[					(paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first]				ifFalse:[					(string						lastIndexOfAnyOf: CharacterSet crlf						startingAt: position - 1						ifAbsent:[0]) + 1]]		forward: false		event: aKeyboardEvent		specialBlock: [:dummy | 1].	^true! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 21:09'!raiseContextMenu: aKeyboardEvent 	(morph respondsTo: #editView)		ifTrue: [morph editView yellowButtonActivity: false].	^ true! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:33'!selectCurrentTypeIn: aKeyboardEvent 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	self insertAndCloseTypeIn.	prior := otherInterval.	self insertAndCloseTypeIn.	self selectInterval: UndoInterval.	otherInterval := prior.	^ true! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 8/3/2011 20:33'!setSearchString: aKeyboardEvent	"Establish the current selection as the current search string."	| aString |	self insertAndCloseTypeIn.	self lineSelectAndEmptyCheck: [^ true].	aString :=  self selection string.	aString size = 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!TextEditor methodsFor: 'explain' stamp: 'jmv 3/2/2010 17:16'!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = ${ and: [string last = $}]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str := string allButFirst.				(self explainTemp: str) ifNotNil: [					^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil! !!TextEditor methodsFor: 'explain' stamp: 'nice 5/8/2011 12:13'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply := Smalltalk at: symbol ifAbsent: [^nil].	(reply class == Dictionary or:[reply isKindOf: SharedPool class])		ifTrue: 			[classes := Set new.			self systemNavigation allBehaviorsDo: [:each | (each sharedPools anySatisfy: [:pool | pool == reply])				ifTrue: [classes add: each]].			classes := classes printString.			^'"is a global variable.  It is a pool which is used by the following classes ' , (classes allButFirst: 5) , '"'].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!TextEditor methodsFor: 'explain' stamp: 'nice 5/6/2011 00:21'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls := model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes := (Array with: cls)				, cls allSuperclasses.	classes := classes detect: [:each | each instVarNames anySatisfy: [:name | name = string]] ifNone: [^nil].	classes := classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!TextEditor methodsFor: 'explain' stamp: 'nice 5/8/2011 12:13'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^nil].	"not in a message"	classes := self systemNavigation allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits anySatisfy: [:each | each == symbol])				ifFalse: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!TextEditor methodsFor: 'explain' stamp: 'nice 5/8/2011 12:14'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits := Array with: msg.	(whole := lits detect: [:each | each keywords anySatisfy: [:frag | frag = string] ]				ifNone: []) ~~ nil		ifTrue: [reply := ', which is the selector of this very method!!'.			s := '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply := '.'.			s := '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes := self systemNavigation allClassesImplementing: whole.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!TextEditor methodsFor: 'explain' stamp: 'nice 2/23/2011 21:50'!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode tempNode |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass newParser parse: model selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [:n| n name = string] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:24'!hasCaret	^ markBlock = pointBlock! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:25'!markIndex	^ markBlock stringIndex! !!TextEditor methodsFor: 'accessing-selection' stamp: 'nice 8/3/2011 23:25'!markIndex: anIndex pointIndex: anotherIndex	"Called, for example, when selecting text with shift+arrow keys"	markBlock := paragraph characterBlockForIndex: anIndex.	pointBlock := paragraph characterBlockForIndex: anotherIndex! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:24'!pointIndex	^ pointBlock stringIndex! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 3/18/2010 22:42'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently  selected."	^ReadWriteStream		on: paragraph string		from: self startIndex		to: self stopIndex - 1! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:24'!startBlock	^ pointBlock min: markBlock! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 10:24'!stopBlock	^ pointBlock max: markBlock! !!TextEditor methodsFor: 'accessing-selection' stamp: 'cmm 8/16/2011 22:29'!unselect	markBlock := pointBlock copy! !!TextEditor methodsFor: 'model access' stamp: 'jmv 11/25/2010 15:02'!model: aModel	model := aModel! !!TextEditor methodsFor: 'events' stamp: 'cmm 8/17/2011 22:47'!keyStroke: anEvent 	self resetTypeAhead; deselect.	(self dispatchOnKeyboardEvent: anEvent) 		ifTrue:			[self doneTyping.			self storeSelectionInParagraph.			^self].	self openTypeIn.	self hasSelection ifTrue: [ "save highlighted characters"		UndoSelection := self selection].	self 		zapSelectionWith: self typeAhead contents ; 		resetTypeAhead ;		unselect ;		storeSelectionInParagraph! !!TextEditor methodsFor: 'events' stamp: 'nice 8/3/2011 21:04'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint b |	oldInterval := self selectionInterval.	clickPoint := evt cursorPoint.	b := paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [		markBlock := b.		pointBlock := b.		evt hand releaseKeyboardFocus: self.		^ self ].		evt shiftPressed		ifFalse: [			self closeTypeIn.			markBlock := b.			pointBlock := b ]		 ifTrue: [			self closeTypeIn.			self mouseMove: evt ].       self storeSelectionInParagraph! !!TextEditor methodsFor: 'events' stamp: 'nice 8/3/2011 23:25'!mouseMove: evt	"Change the selection in response to mouse-down drag"	pointBlock := paragraph characterBlockAtPoint: evt position.	self storeSelectionInParagraph! !!TextEditor methodsFor: 'events' stamp: 'ar 5/5/2004 19:10'!yellowButtonDown: event	"Process a yellow button event. Answer true if the event was handled, false otherwise."	(paragraph attributesAt: event cursorPoint) do:[:attr|		attr menu ifNotNil:[			attr menu openAt: event cursorPoint.			^true]].	^false! !!TextEditor methodsFor: 'menu commands' stamp: 'nice 8/3/2011 21:08'!offerMenuFromEsc: aKeyboardEvent 	"The escape key was hit while the receiver has the keyboard focus; take action"	ActiveEvent shiftPressed ifFalse: [		self raiseContextMenu: aKeyboardEvent ].	^true! !!TextEditor methodsFor: 'current selection' stamp: 'jmv 5/30/2011 10:03'!recomputeSelection	"The same characters are selected but their coordinates may have changed."	self markIndex: self markIndex pointIndex: self pointIndex! !!TextEditor methodsFor: 'current selection' stamp: 'nice 8/3/2011 22:39'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing := selectionShowing not.	paragraph reverseFrom: pointBlock to: markBlock! !!TextEditor methodsFor: 'accessing' stamp: 'ul 3/30/2011 03:16'!model	^model! !!TextEditor methodsFor: 'accessing' stamp: 'ul 12/5/2010 15:20'!paragraph	^paragraph! !!TextEditor methodsFor: 'accessing' stamp: 'nice 8/3/2011 21:28'!replaceSelectionWith: aText	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	beginTypeInIndex ifNotNil: [^self zapSelectionWith: aText]. "called from old code"	UndoSelection := self selection.	self zapSelectionWith: aText.	self undoer: #undoReplace! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 8/11/2010 10:14'!setSearch: aStringOrText	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	FindText = aStringOrText		ifFalse: [FindText := ChangeText := aStringOrText]! !!TextEditor methodsFor: 'mvc compatibility' stamp: 'nice 8/3/2011 22:04'!zapSelectionWith: replacement	| start stop rep |	self deselect.	start := self startIndex.	stop := self stopIndex.	(replacement isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere := (self text attributesAt: start) select: [:att | att mayBeExtended]].	(start = stop and: [ replacement isEmpty ]) ifFalse: [		replacement isText			ifTrue: [ rep := replacement]			ifFalse: [ rep := Text string: replacement attributes: emphasisHere ].		self text replaceFrom: start to: stop - 1 with: rep.		paragraph			recomposeFrom: start			to:  start + rep size - 1			delta: rep size - (stop-start).		self markIndex: start pointIndex: start + rep size.		UndoInterval := otherInterval := self selectionInterval].	self userHasEdited  " -- note text now dirty"! !!TextEditor commentStamp: '<historical>' prior: 0!See comment in Editor.My instances edit Text, this is, they support multiple lines and TextAttributes.They have no specific facilities for editing Smalltalk code. Those are found in SmalltalkEditor.!!TextEditor class methodsFor: 'accessing' stamp: 'cmm 7/3/2010 16:18'!autoEnclose	<preference: 'Auto Enclose'		category: 'Morphic'		description: 'When true, typing an opening parenthesis, bracket or square-bracket will also add its corresponding closing character in front of the cursor.'		type: #Boolean>	^ AutoEnclose ifNil: [ false ]! !!TextEditor class methodsFor: 'accessing' stamp: 'cmm 7/3/2010 16:17'!autoEnclose: aBoolean	AutoEnclose := aBoolean! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'nice 8/4/2011 01:13'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"TextEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.				"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.			"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.		"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.		"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.				"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.				"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.				"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.				"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"				'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].			'([<{|"''' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		cmds := #($a #selectAll: $c #copySelection: $e #exchange: $f #find: $g #findAgain: $h #setSearchString: $k #offerFontMenu: $u #align: $v #paste: $w #backWord: $x #cut: $y #swapChars: $z #undo:).	1 to: cmds size		by: 2		do: [:i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions := cmdMap! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'cmm 8/16/2011 18:44'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	"TextEditor initialize"		| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap := Array new: 256 withAll: #noop:.  		"use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.				"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.			"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"On some keyboards, these characters require a shift"	'([<{|"''9' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].	"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	cmds := #(		$c	compareToClipboard:		$d	duplicate:		$h	cursorTopHome:		$j	doAgainMany:		$k	changeStyle:		$l	outdent:		$m	selectCurrentTypeIn:		$r	indent:		$s	search:		$u	changeLfToCr:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).			"plain keys"		cmdMap at: ((cmds at: i) asciiValue - 32 + 1) put: (cmds at: i + 1).		"shifted keys"		cmdMap at: ((cmds at: i) asciiValue - 96 + 1) put: (cmds at: i + 1).		"ctrl keys"	].	shiftCmdActions := cmdMap! !!TextMorph methodsFor: 'accessing' stamp: 'spd 1/4/2011 17:36'!autoFit: trueOrFalse	"Whether I automatically adjust my size to fit text as it changes"		self isAutoFit = trueOrFalse ifTrue: [^ self].	self autoFitOnOff.! !!TextMorph methodsFor: 'accessing' stamp: 'sw 2/17/2003 18:20'!cursorWrapped: aNumber	"Set the cursor as indicated"	self setProperty: #textCursorLocation toValue: (((aNumber rounded - 1) \\  text string size) + 1)	! !!TextMorph methodsFor: 'accessing' stamp: 'sw 2/18/2003 02:58'!elementCount	"Answer how many sub-objects are within me"	^ self text string size ! !!TextMorph methodsFor: 'accessing' stamp: 'spd 1/4/2011 17:33'!wrapFlag: aBoolean	"Whether contained text will adjust its bounds as I change shape:		|	wrapFlag 	|		TextMorph grows			|		TextMorph shrinks 	|		|		true 		| wrapped lines fill new space	|	long lines wrap to fit 		|		|		false 		|   wrapped lines stay same 		|	long lines are cut off 		|"	aBoolean == wrapFlag ifTrue: [^ self].	wrapFlag := aBoolean.	self composeToBounds! !!TextMorph methodsFor: 'editing' stamp: 'nice 8/3/2011 03:06'!handleInteraction: interactionBlock fromEvent: evt	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	| oldEditor oldParagraph oldText |	oldEditor := editor.	oldParagraph := paragraph.	oldText := oldParagraph text copy.	self selectionChanged.  "Note old selection"		interactionBlock value.	(oldParagraph == paragraph) ifTrue:[		"this will not work if the paragraph changed"		editor := oldEditor.     "since it may have been changed while in block"	].	self selectionChanged.  "Note new selection"	(oldText = paragraph text and: [ oldText runs = paragraph text runs ])		ifFalse:[ self updateFromParagraph ].	self setCompositionWindow.! !!TextMorph methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58'!keyboardFocusChange: aBoolean 	| w |	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."			self hasFocus ifFalse: [self editor	"Forces install"].			Editor blinkingCursor ifTrue: [ self startBlinking ].	] ifFalse:["A hand has clicked elsewhere..."		(w := self world) ifNotNil:[			w handsDo: [:h | h keyboardFocus == self ifTrue: [^self]].			"Release control unless some hand is still holding on"			self releaseEditor].		self stopBlinking.	].! !!TextMorph methodsFor: 'event handling' stamp: 'nice 8/5/2011 19:42'!keyStroke: evt	"Handle a keystroke event."		self resetBlinkCursor. "don't blink during type-in"	ToolSet 		codeCompletionAround: [			evt keyValue = 13 ifTrue: [ "CR - check for special action"				self crAction ifNotNil: [ :action |					"Note: Code below assumes that this was some					input field reacting on CR. Break the keyboard					focus so that the receiver can be safely deleted."					evt hand newKeyboardFocus: nil.					^action valueWithEnoughArguments: { evt } ] ].			self handleInteraction: [ self editor keyStroke: evt ] fromEvent: evt.			"self updateFromParagraph."			super keyStroke: evt  "sends to keyStroke event handler, if any" ]		textMorph: self		keyStroke: evt! !!TextMorph methodsFor: 'event handling' stamp: 'nice 8/3/2011 18:26'!mouseMove: evt	evt redButtonPressed ifFalse: [^ self enterClickableRegion: evt].	self handleInteraction: [self editor mouseMove: evt] fromEvent: evt! !!TextMorph methodsFor: 'geometry' stamp: 'jmv 3/2/2010 16:42'!privateMoveBy: delta 	super privateMoveBy: delta.	editor 		ifNil: [ paragraph ifNotNil: [paragraph moveBy: delta]]		ifNotNil: [ 			"When moving text with an active editor, save and restore all state."			paragraph moveBy: delta.			self installEditorToReplace: editor]! !!TextMorphEditor methodsFor: 'editing keys' stamp: 'cmm 12/4/2010 15:11'!chooseColor	| attribute |	attribute := TextColor color: Color black. "default"	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"	NewColorPickerMorph useIt		ifTrue: [ (NewColorPickerMorph on: attribute) openNear: morph fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: morph activeHand ;				 target: attribute ;				 selector: #color: ;				 originalColor: Color black ;								putUpFor: morph				near: morph fullBoundsInWorld ].	^ attribute! !!TextMorphEditor methodsFor: 'events' stamp: 'nice 8/3/2011 18:27'!keyStroke: anEvent	self fakeSensorWithEvent: anEvent.	self readKeyboard! !!TextMorphEditor methodsFor: 'events' stamp: 'ar 5/5/2004 19:10'!yellowButtonDown: event	"Process a yellow button event. Answer true if the event was handled, false otherwise."	(paragraph attributesAt: event cursorPoint) do:[:attr|		attr menu ifNotNil:[			attr menu openAt: event cursorPoint.			^true]].	^false! !!TextMorphEditor methodsFor: 'typing support' stamp: 'nice 8/3/2011 02:30'!fakeSensorWithEvent: anEvent	"Pass the event to a polling-friendly-sensor-fake so that old st-80 code shall still work"	self sensor: (KeyboardBuffer new startingEvent: anEvent).! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58'!keyboardFocusChange: aBoolean 	"rr 3/21/2004 22:55 : removed the #ifFalse: branch, 	which was responsible of the deselection of text when the 	paragraph lost focus. This way selection works in a more standard 	way, and this permits the menu keyboard control to be really effective"	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."		self hasFocus ifFalse: [self editor	"Forces install"].		Editor blinkingCursor ifTrue: [self startBlinking].	] ifFalse:[		self stopBlinking.	].	self changed.! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'ar 5/5/2004 19:11'!mouseDown: event	event yellowButtonPressed ifTrue: [		(editor yellowButtonDown: event) ifTrue:[^self].		^ editView yellowButtonActivity: event shiftPressed].	^ super mouseDown: event! !!TextOnCurve methodsFor: 'display' stamp: 'bf 6/17/2010 19:19'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| warp lineRect lineCanvas backgroundColor lineForm leftInRun sourceQuad maxExtent |	"most of these temps are initialized lazily and need to be at the method level - do not move into the block below!!"	warp := nil.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		false ifTrue:			["Show the dest rects for debugging..."			aCanvas frameRectangle: destRect width: 1 color: Color black].		(aCanvas isVisible: destRect) ifTrue:			[warp ifNil:				["Lazy initialization because may not have to display at all."				maxExtent := lines inject: lines first rectangle extent 					into: [:maxWid :lin | maxWid max: lin rectangle extent].				lineForm := Form extent: maxExtent depth: aCanvas depth.				displayScanner setDestForm: lineForm.				lineRect := lineForm boundingBox.				leftInRun := 0.				backgroundColor := (curve borderWidth > 10							ifTrue: [curve color]							ifFalse: [curve owner isHandMorph									ifTrue: [curve owner owner color]									ifFalse: [curve owner color]]) dominantColor.				warp := (aCanvas warpFrom: lineRect corners toRect: lineRect)						cellSize: 2;  "installs a colormap if smoothing > 1"						sourceForm: lineForm.				warp colorMap: (self warpMapForDepth: aCanvas depth									withTransparentFor: backgroundColor).				lineCanvas := lineForm getCanvas].			sourceQuad := destRect innerCorners collect:				[:p | self pointInLine: line forDestPoint: p						segStart: segStart segAngle: segAngle].			lineForm fill: lineForm boundingBox fillColor: backgroundColor.			self displaySelectionInLine: line on: lineCanvas.			leftInRun := displayScanner displayLine: line offset: 0@0 leftInRun: leftInRun.			warp sourceQuad: sourceQuad destRect: (destRect translateBy: aCanvas origin).			warp warpBits]].! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'nice 8/19/2010 16:36'!addNewFontSize: pointSize	"Add a font in specified size to the array of fonts."	| f d newArray t isSet |	fontArray first emphasis ~= 0 ifTrue: [		t := TextConstants at: self fontArray first familyName asSymbol.		t fonts first emphasis = 0 ifTrue: [			^ t addNewFontSize: pointSize.		].	].	pointSize <= 0 ifTrue: [^ nil].	fontArray do: [:s |		s pointSize = pointSize ifTrue: [^ s].	].	(isSet := fontArray first isKindOf: TTCFontSet) 	ifTrue:[		| fonts |		fonts := fontArray first fontArray collect: [ :font |			| newFont |			(font isNil)			ifTrue: [newFont := nil]			ifFalse: [				newFont := (font ttcDescription size > 256)					ifTrue: [MultiTTCFont new initialize]					ifFalse: [TTCFont new initialize].				newFont ttcDescription: font ttcDescription.				newFont pixelSize: pointSize * 96 // 72.				font derivativeFonts notEmpty ifTrue: [font derivativeFonts do: [ :proto |					proto ifNotNil: [						d := proto class new initialize.						d ttcDescription: proto ttcDescription.						d pixelSize: newFont pixelSize.						newFont derivativeFont: d]]].				].			newFont].		f := TTCFontSet newFontArray: fonts]	ifFalse: [		f := fontArray first class new initialize: fontArray first.		f pointSize: pointSize.		fontArray first derivativeFonts do: [:proto |			proto ifNotNil: [				d := proto class new initialize: proto.				d pointSize: f pointSize.				f derivativeFont: d mainFont: proto.			].		].	].	newArray := (fontArray copyWith: f) asArray sort: [:a :b | a pointSize <= b pointSize].	self newFontArray: newArray.	isSet ifTrue: [		TTCFontSet register: newArray at: newArray first familyName asSymbol.	].	^ self fontOfPointSize: pointSize! !!TextStyle class methodsFor: 'mime file in/out' stamp: 'ar 9/5/2010 09:02'!replaceFontsIn: oldFontArray with: newStyle	"	TextStyle replaceFontsIn: (TextStyle looseFontsFromFamily: #Accuny) with: (TextStyle named: #Accuny)	"	"Try to find corresponding fonts in newStyle and substitute them for the fonts in oldFontArray"	newStyle fontArray do: [ :newFont | newFont releaseCachedState ].	oldFontArray do: [ :oldFont | | newFont |		oldFont reset.		newFont := (newStyle fontOfPointSize: oldFont pointSize) emphasis: oldFont emphasis.		oldFont becomeForward: newFont ].	Smalltalk at: #StringMorph ifPresent:[:cls| cls allSubInstancesDo: [ :s | s layoutChanged]].	Smalltalk at: #TextMorph ifPresent:[:cls| cls allSubInstancesDo: [ :s | s layoutChanged]].	Smalltalk at: #SystemWindow ifPresent:[:cls| 		cls allInstancesDo: [ :w | [ w update: #relabel ] on: Error do: [ :ex | ] ]].	World ifNotNil: [ :w | w changed ].! !!TextURL methodsFor: '*Morphic' stamp: 'rbb 2/18/2005 09:24'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m |	(url beginsWith: 'sqPr://') ifTrue: [		ProjectLoading thumbnailFromUrl: (url copyFrom: 8 to: url size).		^self		"should not get here, but what the heck"	].	"if it's a web browser, tell it to jump"	anObject isWebBrowser		ifTrue: [anObject jumpToUrl: url. ^ true]		ifFalse: [((anObject respondsTo: #model) and: [anObject model isWebBrowser])				ifTrue: [anObject model jumpToUrl: url. ^ true]].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m := anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [					m  jumpToUrl: url.					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m := m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	((self confirm: 'open a browser to view this URL?' translated) and: [WebBrowser default notNil]) ifTrue: [		WebBrowser default openOnUrl: url.		^ true ].	"couldn't display in a browser.  Offer to put up just the source"	response := (UIManager default 				chooseFrom: (Array with: 'View web page as source' translated									with: 'Cancel' translated)				title:  'Couldn''t find a web browser. View\page as source?' withCRs translated).	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'rhi 5/18/2010 21:03'!fillDockingBar: aDockingBar 	"Private - fill the given docking bar"		aDockingBar addSpace: 6.	self menusOn: aDockingBar.	aDockingBar addSpacer.	self rightSideOn: aDockingBar.	aDockingBar		setProperty: #mainDockingBarTimeStamp 		toValue: self class timeStamp.! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'cmm 6/21/2011 16:35'!menusOn: aDockingBar	self		squeakMenuOn: aDockingBar;		projectsMenuOn: aDockingBar;		toolsMenuOn: aDockingBar;		appsMenuOn: aDockingBar;		extrasMenuOn: aDockingBar;		windowsMenuOn: aDockingBar;		helpMenuOn: aDockingBar.! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'kb 11/20/2009 10:31'!projectsMenuOn: aDockingBar	aDockingBar addItem: [ :item |		item			contents: 'Projects' translated;			addSubMenu: [ :menu | 				self					newProjectMenuItemOn: menu;					saveProjectMenuItemOn: menu;					loadProjectMenuItemOn: menu;					previousProjectMenuItemOn: menu;					jumpToProjectMenuItemOn: menu ] ]! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'rhi 5/18/2010 21:04'!rightSideOn: aDockingBar	self		searchBarOn: aDockingBar;		clockOn: aDockingBar;		toggleFullScreenOn: aDockingBar.! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'jmg 8/17/2011 17:43'!toolsMenuOn: aDockingBar 	aDockingBar addItem: [ :item |		item			contents: 'Tools' translated;			addSubMenu: [ :menu | 				self					browserMenuItemOn: menu;					workspaceMenuItemOn: menu;					transcriptMenuItemOn: menu;					testRunnerMenuItemOn: menu;					methodFinderMenuItemOn: menu.				menu addLine.				self 					monticelloBrowserMenuItemOn: menu;					monticelloConfigurationsMenuItemOn: menu;					simpleChangeSorterMenuItemOn: menu;					dualChangeSorterMenuItemOn: menu.				menu addLine.				self					processBrowserMenuItemOn: menu;					preferenceBrowserMenuItemOn: menu;					fileListMenuItemOn: menu.			] ]! !!TheWorldMainDockingBar methodsFor: 'private' stamp: 'laza 4/26/2010 10:31'!colorIcon: aColor	"Guess if 'uniform window colors' are used and avoid all icons to be just gray"	(aColor = Preferences uniformWindowColor or: [Preferences tinyDisplay]) ifTrue: [ ^nil ].	^(aColor iconOrThumbnailOfSize: 14)		borderWidth: 3 color: Preferences menuColor muchDarker;		borderWidth: 2 color: Color transparent! !!TheWorldMainDockingBar methodsFor: 'private' stamp: 'cmm 5/4/2011 13:07'!updateIfNeeded: aDockingBar 	"Update the given docking bar if needed"	| timeStamp |	timeStamp := aDockingBar		valueOfProperty: #mainDockingBarTimeStamp		ifAbsent: [ ^ self ].	timeStamp = self class timeStamp ifTrue: [ ^ self ].	""	aDockingBar		 release ;		 removeAllMorphs.	self fillDockingBar: aDockingBar! !!TheWorldMainDockingBar methodsFor: 'submenu - squeak' stamp: 'MAD 12/22/2010 00:11'!quitMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Quit' translated;			help: 'Quit out of Squeak' translated;			icon: MenuIcons smallQuitNoSaveIcon;			target: self;			selector: #quitSqueak ]! !!TheWorldMainDockingBar methodsFor: 'submenu - squeak' stamp: 'MAD 12/22/2010 00:11'!saveAsNewVersionMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Save As New Version' translated;			help: 'Save the current state of Squeak on disk under a version-stamped name' translated;			icon: MenuIcons smallSaveNewIcon;			target: self;			selector: #saveAsNewVersion ]! !!TheWorldMainDockingBar methodsFor: 'submenu - tools' stamp: 'jmg 8/17/2011 17:43'!methodFinderMenuItemOn: menu 	menu addItem: [:item | 		item 			contents: 'Method Finder' translated;			help: 'Open the Method Finder' translated;			icon: (self colorIcon: Preferences methodFinderWindowColor);			target: StandardToolSet;			selector: #openSelectorBrowser]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 1/1/2011 19:18'!jumpToProjectMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Jump To Project' translated;			icon: MenuIcons smallProjectJumpIcon;			subMenuUpdater: self			selector: #updateJumpToProjectSubMenu: ]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 12/22/2010 00:13'!loadProjectMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Load Project' translated;			help: 'Load a project from a file' translated;			icon: MenuIcons smallProjectLoadIcon;			target: self;			selector: #loadProject ]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 12/22/2010 00:14'!previousProjectMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Previous Project' translated;			help: 'Return to the most-recently-visited project' translated;			icon: MenuIcons smallProjectBackIcon;			target: World;			selector: #goBack ]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 12/22/2010 00:12'!saveProjectMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Save Project' translated;			help: 'Save this project on a file' translated;			icon: MenuIcons smallProjectSaveIcon;			target: World;			selector: #saveOnFile ]! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 4/26/2010 10:57'!listWindowsOn: menu	| windows |	windows := SortedCollection sortBlock: [:winA :winB |		winA model name = winB model name			ifTrue: [winA label < winB label]			ifFalse: [winA model name < winB model name]].	windows addAll: self allVisibleWindows.	windows ifEmpty: [ 		menu addItem: [ :item | 			item				contents: 'No Windows' translated;				isEnabled: false ] ].	windows do: [ :each |		menu addItem: [ :item |			item 				contents: (self windowMenuItemLabelFor: each);				icon: (self colorIcon: each model defaultBackgroundColor);				target: each;				selector: #comeToFront;				subMenuUpdater: self				selector: #windowMenuFor:on:				arguments: { each };				action: [ each activateAndForceLabelToShow; expand ] ] ].! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'cmm 6/21/2011 20:09'!windowMenuFor: window on: menu	menu 		addItem: [ :item |			item				contents: 'Close' translated ;				target: window;				selector: #delete ];		addItem: [ :item |			item				contents: 'Close all like this' translated ;				target: self;				selector: #closeAllWindowsLike:;				arguments: { window } ];		addItem: [ :item |			item				contents: 'Close all but this' translated ;				target: self;				selector: #closeAllWindowsBut:;				arguments: { window } ];		addItem: [ :item |			item 				contents: 'Expand or Contract' translated ;				target: window;				selector: #expandBoxHit ]! !!TheWorldMainDockingBar methodsFor: 'right side' stamp: 'cmm 8/20/2011 14:15'!clockOn: aDockingBar 	aDockingBar 		addMorphBack: ClockMorph new ;		addDefaultSpace! !!TheWorldMainDockingBar methodsFor: 'right side' stamp: 'cmm 6/21/2011 20:03'!toggleFullScreenOn: aDockingBar 	| toggleMorph |	toggleMorph := (SketchMorph withForm: MenuIcons smallFullscreenOffIcon) setBalloonText: 'toggle full screen mode' translated;								on: #mouseDown				send: #value				to:					[ Project current toggleFullScreen. 					toggleMorph form: MenuIcons smallFullscreenOffIcon ] ;				on: #mouseEnter				send: #value				to: [toggleMorph form: MenuIcons smallFullscreenOnIcon];								on: #mouseLeave				send: #value				to: [toggleMorph form: MenuIcons smallFullscreenOffIcon];				 yourself.	aDockingBar addMorphBack: toggleMorph! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 12/22/2011 09:43'!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."OCompletion provides source code completion as you type"(Installer ss project: ''OCompletion'') install: ''Ocompletion''.(Smalltalk at: #ECToolSet) register.(Smalltalk at: #ToolSet) default: (Smalltalk at: #ECToolSet)."Omnibrowser, including Refactoring engine"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfOmniBrowser''.((Smalltalk at: #ConfigurationOfOmniBrowser) project perform: #lastVersion) load: #( Dev )."OpenGL""First load FFI"(Installer repository: ''http://www.squeaksource.com/CroquetGL'')	install: ''3DTransform'';	install: ''OpenGL-Pools'';	install: ''OpenGL-Core''."OpenGL example""Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WAPharoServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register."Open Cobalt: http://opencobalt.org (Best to run this from an image in an open cobalt directory)"Installer ss project: ''TweakCore''; install: ''update''.[Installer ss project: ''TweakExtras''; install: ''update'']	on: (Smalltalk at: #CUnsynchronizedModification) do: [:ex | ex resume].Installer cobalt project: ''Tweak'';	answer: ''Would you like to conserve memory at all costs?'' with: true;	answer: ''Password for interactive VNC connections?'' with: ''cobalt'';	answer: ''Would you like to add the RFBServer to the World open menu?'' with: true;	install: ''update''!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 57 12 2 1 8 1 13 2 8 1 13 13 3 1 10 2 8 13 3 1 8 2 8 12 3 1 10 4 43 12 2 1 8 1 21 2 8 1 28 3 1 10 3 1 27 1 1 7 1 8 1 12 2 5 4 3 5 8 1 16 12 11 1 39 3 8 1 13 3 8 1 14 3 8 1 13 2 16 2 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 28 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 3 97 11 2 1 8 1 11 2 8 1 8 13 2 1 8 1 13 2 8 1 8 3 3 12 3 1 28 2 3 3 2 1 1 1 2 1 6 13 6 1 8 1 7 3 7 1 49 1 5 1 4 3 7 1 43 1 5 1 8 3 7 1 61 1 5 1 4 3 8 1 8 1)c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126000,cblack;,c000000126,cblack;,c000000126,c000126000,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,cgray;,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000000,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000000,cblack;,c000000126,cblack;,c126000126,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'dtl 1/18/2011 21:50'!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				(Smalltalk classNamed: #SystemReporter) ifNotNil: [:classSystemReporter |					menu addItem: [:item |						item							contents: 'About this System' translated;							help: 'SystemReporter status of the image and runtime environment' translated;							target: classSystemReporter;							selector: #open]].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk classNamed: #HelpBrowser) ifNotNil: [:classHelpBrowser |					(Smalltalk classNamed: #TerseGuideHelp) ifNotNil: [:classTerseGuideHelp |						menu addLine.						menu addItem: [:item |							item								contents: 'Terse Guide to Squeak' translated;								help: 'Concise information about language and environment' translated;								target: classHelpBrowser;								selector: #openOn:;								arguments: { classTerseGuideHelp }]].					menu addLine.					menu addItem: [:item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: classHelpBrowser;							selector: #open]]]]! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'hjh 4/21/2010 18:40'!showWelcomeText: aSelector label: labelString in: bounds	"Show a welcome text. Linked in here so that the text can be edited	by changing the acceptBlock below."	| acceptBlock window |	"Change the following to allow editing the text"	true ifTrue:[		acceptBlock := [:text|			self class				compile: aSelector,'	^', (String streamContents:[:s| s nextChunkPutWithStyle: text]) storeString, ' readStream nextChunkText'				classified: (self class organization categoryOfElement: aSelector).		].	].	window := UIManager default 		edit: (self perform: aSelector)		label: labelString		accept: acceptBlock.	window bounds: bounds.! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 12/22/2011 17:15'!squeakOnlineResources	^'Squeak web sites	Main Squeak site						http://www.squeak.org	Weekly Squeak							http://news.squeak.org	Oversight Board						http://board.squeak.org	Downloads for many versions			http://ftp.squeak.org	Development of the virtual machine	http://squeakvm.org	Google+ Page		https://plus.google.com/u/0/b/115950529692424242526/	Squeak-dev - The main Squeak mailing list	http://lists.squeakfoundation.org/mailman/listinfo/squeak-dev	http://dir.gmane.org/gmane.comp.lang.smalltalk.squeak.general	http://n4.nabble.com/Squeak-Dev-f45488.htmlSqueak-Beginners - The place to ask even the most basic questions	http://lists.squeakfoundation.org/mailman/listinfo/beginners	http://dir.gmane.org/gmane.comp.lang.smalltalk.squeak.beginners	http://n4.nabble.com/Squeak-Beginners-f107673.htmlSqueak By Example	http://www.squeakbyexample.org/Squeak, Open Personal Computing and Multimedia	http://coweb.cc.gatech.edu/squeakbook/	http://stephane.ducasse.free.fr/FreeBooks/CollectiveNBlueBook/Squeak, Open Personal Computing for Multimedia	http://www.cc.gatech.edu/~mark.guzdial/drafts/	http://stephane.ducasse.free.fr/FreeBooks/GuzdialBookDrafts/More Books about Squeak and Smalltalk	http://stephane.ducasse.free.fr/FreeBooks.html!!]style[(16 316 41 173 65 181 17 35 46 106 46 112 37 49)bu,,bu,,bu,,bu,,bu,,bu,,bu,!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'spd 5/24/2010 19:19'!squeakUserInterface	^'The Squeak UI has some unusual elements that you may not have seen before.  Here is a brief introduction to those elements:ProjectsA project is an entire Squeak desktop full of windows.  Projects can be used to change quickly from one task to another.  An inactive project is represented by a project window, which shows a thumbnail of its state.  Project windows are actually more like doors than windows, since you can enter the project just by clicking on them.  You can create a new project by choosing ''open...project'' from the screen menu.  To exit a project (and return to its parent project), choose ''previous project'' from the screen menu.  Each project maintains its own set of windows and other information.Morphic HalosIn a morphic project, pressing cmd-click (Mac) or alt-click (Windows) on a graphical object (e.g. a window) will surround it with a constellation of colored circles.  These are called "halo handles."  Additional clicks will cycle through the halos for the other graphical objects in the nesting structure.  If you hold down the Shift key while cmd/alt-clicking, the nested morphs will be traversed from innermost outward.  Clicking without the cmd/alt key will dismiss the halo.  While the halo is up, letting the cursor linger over one of the halo handles for a few seconds will cause a balloon to pop up with the name of that handle.  Three useful handles are the top-left "X" handle (delete), the bottom-right yellow handle (resize), and the brown handle (slide the object within its containing object).  Halos allow complex graphical objects to be explored - or even disassembled (using the black halo handle).  Usually no harm results from taking apart an object; you can just discard the pieces and create a new one.FlapsTo enable Flaps, click on the desktop to show the world menu, choose the "Flaps..." menu and "show shared tags". Tabs labeled "Squeak", "Tools", "Supplies", etc., will appear along the edges of the Squeak desktop.  Click on any tab to open the corresponding flap.  Drag a tab to resize the flap and to relocate the tab.  Bring up the halo on any tab and click on its menu handle to be presented with many options relating to the flap.  Use the "Flaps..." menu, reached via the desktop menu, to control which flaps are visible and for other flap-related options and assistance.Parts BinsYou can obtain new objects in many ways.  The "Objects Catalog" (choose "objects'' from the world menu or open the objects flap) and several of the standard flaps (e.g. "Tools" and "Supplies") serve as "Parts Bins" the for new objects.  Drag any icon you see in a Parts Bin and a fresh copy of the kind of object it represents will appear "in your hand"; click to deposit the new object anywhere you wish.  You can also add your own objects to any of the flaps - just drag your object over the tab, wait for the flap to pop open, then drop the object at the desired position in the flap.!!]style[(123 9 663 13 991 5 579 10 589),bu,,bu,,bu,,bu,!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'chc 12/13/2011 04:19'!welcomeFutureDirections		^'- This image is ~15M. If you execute - Smalltalk unloadAllKnownPackages - it will become ~10M - A SqueakCore image is available at http://ftp.squeak.org/4.3- A reasonable target is the creation of a smaller image, which may be a task before the community- A place to explore where to make reductions is likely the removal/replacement of GUIs- Once we have a smaller core image, we can employ Andreas Raab''s memo [1] on how to load code back into the image. This will be based on tests delineating the separate responsibilities of core and application developers [1]]http://lists.squeakfoundation.org/pipermail/squeak-dev/2010-May/150658.html'! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'chc 12/15/2011 09:31'!welcomeToSqueak43	^'Squeak 4.3 - Rice Paper This is a list of the main achievements that went into the trunk image.Networking- better control of socket connection timeoutsThreads- added support for threaded VMsPackage Management- packages specifiable either with or without a version-number in Installer- extended support for MCConfigurations to regular MCDirectoryRepositorysMath- corrected Complex so arcSin and arcCos let (1 arTanh) return infUser Interface- full-screen toggle option has been moved out from the menu and onto the bar directly just to the right of the clock for one-click access - rejection of literals with superfluous # at the beginning like #$a #123 ##foo ##(1 2 3)- TextEditor is event driven sensor usage is banned from it- ancient behavior of selecting whole text when clicking twice before first or twice after last character is restored- drag/drop between inspectors changed to drag a field onto another field to replace the object in it- updated button for "what to show" on CodeHolder similar to Squeak 3.8 - changes enabling both Yellow and Blue buttons from a two-button mouse in Cog VMCompiler- Compiler changed to create subclasses of CompiledMethod- blocks and MessageSends are exchangeable in more situationsMorphic- SMxMorphicProject now able to host a SimpleMorphic World- when present a SMxMorphicProject is made available in the World menu!!]style[(24 75 10 48 9 34 18 152 4 69 14 667 8 120 1 1 7 131)FBitstreamVeraSans#20.0,,bu,,bu,,bu,,bu,,bu,,bu,,bu,,bu,!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'chc 12/13/2011 05:16'!welcomeWorkspacesOn: menu	menu addItem:[:item|		item			contents: 'Welcome to Squeak 4.3' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#welcomeToSqueak43. 				'Welcome to Squeak 4.3'. 				(200@200 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'Welcome Future Directions' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#welcomeFutureDirections. 				'Future Directions'. 				(140@140 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'The Squeak User Interface' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#squeakUserInterface. 				'The Squeak User Interface'. 				(160@160 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'Working With Squeak' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#workingWithSqueak. 				'Working With Squeak'. 				(180@180 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'License Information' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#licenseInformation. 				'License Information'. 				(200@200 extent: 500@300)			}].! !!TheWorldMainDockingBar methodsFor: 'submenu - apps' stamp: 'ar 8/6/2010 23:40'!appsMenuOn: aDockingBar	"Create a menu with the registered apps"	aDockingBar addItem: [ :item |		item			contents: 'Apps' translated;			subMenuUpdater: self			selector: #listAppsOn: ]! !!TheWorldMainDockingBar methodsFor: 'submenu - apps' stamp: 'ar 8/6/2010 23:44'!listAppsOn: menu	"Update the apps list in the menu"	| args |	TheWorldMenu registeredOpenCommands do:[:spec|		args := spec second.		menu addItem: [ :item |			item				contents: spec first translated;				target: args first;				selector: args second].	].! !!TheWorldMainDockingBar methodsFor: 'submenu - extras' stamp: 'cmm 6/21/2011 20:06'!extrasMenuOn: aDockingBar 	aDockingBar addItem: [ :it|		it 	contents: 'Extras' translated;			addSubMenu: [:menu|				menu addItem:[:item|					item						contents: 'Recover Changes' translated;						help: 'Recover changes after a crash' translated;						icon: MenuIcons smallHelpIcon;						target: ChangeList;						selector: #browseRecentLog].				menu addLine.				menu addItem:[:item|					item						contents: 'Window Colors' translated;						help: 'Changes the window color scheme' translated;						addSubMenu:[:submenu| self windowColorsOn: submenu]].				menu addItem:[:item|					item						contents: 'Set Author Initials' translated;						help: 'Sets the author initials' translated;						target: Utilities;						selector: #setAuthorInitials].				menu addItem:[:item|					item						contents: 'Restore Display (r)' translated;						help: 'Redraws the entire display' translated;						target: World;						selector: #restoreMorphicDisplay].				menu addItem:[:item|					item						contents: 'Rebuild Menus' translated;						help: 'Rebuilds the menu bar' translated;						target: TheWorldMainDockingBar;						selector: #updateInstances].				menu addLine.				menu addItem:[:item|					item						contents: 'Start Profiler' translated;						help: 'Starts the profiler' translated;						target: self;						selector: #startMessageTally].				menu addItem:[:item|					item						contents: 'Collect Garbage' translated;						help: 'Run the garbage collector and report space usage' translated;						target: Utilities;						selector: #garbageCollectAndReport].				menu addItem:[:item|					item						contents: 'Purge Undo Records' translated;						help: 'Save space by removing all the undo information remembered in all projects' translated;						target: CommandHistory;						selector: #resetAllHistory].				menu addItem:[:item|					item						contents: 'VM statistics' translated;						help: 'Virtual Machine information' translated;						target: self;						selector: #vmStatistics].				menu addLine.				menu addItem:[:item|					item						contents: 'Graphical Imports' translated;						help: 'View the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList' translated;						target: (Imports default);						selector: #viewImages].				menu addItem:[:item|					item						contents: 'Standard Graphics Library' translated;						help: 'Lets you view and change the system''s standard library of graphics' translated;						target: ScriptingSystem;						selector: #inspectFormDictionary].				menu addItem:[:item|					item						contents: 'Annotation Setup' translated;						help: 'Click here to get a little window that will allow you to specify which types of annotations, in which order, you wish to see in the annotation panes of browsers and other tools' translated;						target: Preferences;						selector: #editAnnotations].				menu addItem:[:item|					item						contents: 'Browse My Changes' translated;						help: 'Browse all of my changes since the last time #condenseSources was run.' translated;						target: SystemNavigation new;						selector: #browseMyChanges].			] ]! !!TheWorldMainDockingBar class methodsFor: 'class initialization' stamp: 'dtl 1/18/2011 21:37'!initialize	"self initialize"		Locale addLocalChangedListener: self.	self updateInstances.! !!TheWorldMainDockingBar class methodsFor: 'events' stamp: 'kb 11/19/2009 18:48'!localeChanged	self updateInstances! !!TheWorldMainDockingBar class methodsFor: 'access' stamp: 'cmm 11/16/2010 19:14'!instance	"Answer the receiver's instance"	^ Instance ifNil: [ Instance := self new ]! !!TheWorldMainDockingBar class methodsFor: 'access' stamp: 'cmm 11/16/2010 19:15'!instance: aTheWorldMainDockingBar	Instance := aTheWorldMainDockingBar.	self updateInstances! !!TheWorldMenu methodsFor: 'action' stamp: 'ar 8/2/2010 20:51'!saveScreenshot	"Make a screenshot of the world and save it to a file"	SampledSound playSoundNamed: 'camera'.	PNGReadWriter putForm: myWorld imageForm onFileNamed:		(FileDirectory default nextNameFor: 'SqueakScreen' extension:'png').! !!TheWorldMenu methodsFor: 'commands' stamp: 'cmm 5/12/2011 21:10'!changeBackgroundColor	"Let the user select a new background color for the world"	myWorld		changeColorTarget: myWorld		selector: #color:		originalColor: myWorld color asColor		hand: myWorld activeHand! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 8/2/2010 20:51'!addPrintAndDebug: menu	Preferences simpleMenus ifFalse: [		self			fillIn: menu			from: {				{ 'make screenshot'. {self. #saveScreenshot}. 'makes a screenshot and saves it to disk'}.				"{ 'print PS to file...'. { self. #printWorldOnFile }. 'write the world into a postscript file' }."				{ 'debug...'. { self. #debugDo }. 'a menu of debugging items' }			} ]! !!TheWorldMenu methodsFor: 'construction' stamp: 'cbr 8/2/2010 18:34'!changesMenu        "Build the changes menu for the world."        | menu |        menu := self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { ChangeSet current . #verboseFileOut}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSet . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { ChangeSet  . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { self  . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.                nil.                { 'browse recent submissions (R)' . { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.			{ 'browse my changes' . { SystemNavigation new . #browseMyChanges }.					'Browse all of my changes since the last time #condenseSources was run.'}.			nil.                { 'recently logged changes...' . { self . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        ^ menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'dtl 3/3/2011 21:06'!openMenu	"Build the open window menu for the world."	| menu |	menu := self menu: 'open...'.	menu defaultTarget: ToolSet default.	menu addList: ToolSet menuItems.	menu defaultTarget: self.	self fillIn: menu from: {		nil.		{'file...' . { self . #openFileDirectly} . 'Lets you open a window on a single file'}.		{'transcript (t)' . {self . #openTranscript}. 'A window used to report messages sent to Transcript' }.		"{'inner world' . { WorldWindow . #test1} }."		nil.	}.	self fillIn: menu from: self class registeredOpenCommands.	menu addLine.	self mvcProjectsAllowed ifTrue:		[self fillIn: menu from: { {'mvc project' . {self. #openMVCProject} . 'Creates a new project of the classic "mvc" style'} }].	self fillIn: menu from: { 		{'morphic project' . {self. #openMorphicProject} . 'Creates a new morphic project'}.	}.	Smalltalk at: #SMxMorphicProject ifPresent: [:p |		self fillIn: menu from: { 			{ 'simple morphic project' . { self . #openSMxMorphicProject } . 'Creates a new simple morphic project' }.		}	].	^menu! !!TheWorldMenu methodsFor: 'construction' stamp: 'dtl 3/3/2011 20:59'!projectMenu	"Build the project menu for the world."	| menu |	self flag: #bob0302.	menu := self menu: 'projects...'.	self fillIn: menu from: { 		{ 'save on server (also makes a local copy)' . { #myProject . #storeOnServer } }.		{ 'save to a different server' . { #myProject . #saveAs } }.		{ 'save project on local file only' . { #myWorld . #saveOnFile } }.		{ 'see if server version is more recent...' . { #myProject . #loadFromServer } }.		{ 'load project from file...' . { self . #loadProject } }.		nil.	}.	self mvcProjectsAllowed ifTrue: [		self fillIn: menu from: {			{ 'create new mvc project'. { self . #openMVCProject } }.		}	].	self fillIn: menu from: { 		{ 'create new morphic project' . { self . #openMorphicProject } }.	}.	Smalltalk at: #SMxMorphicProject ifPresent: [:p |		self fillIn: menu from: { 			{ 'create new simple morphic project' . { self . #openSMxMorphicProject } }.		}	].	self fillIn: menu from: { 		nil.		{ 'go to previous project' . { Project . #returnToPreviousProject } }.		{ 'go to next project' . { Project . #advanceToNextProject } }.		{ 'jump to project...' . { #myWorld . #jumpToProject } }.	}.	Preferences simpleMenus ifFalse: [		self fillIn: menu from: { 			nil.			{ 'save for future revert' . { #myProject . #saveForRevert } }.			{ 'revert to saved copy' . { #myProject . #revert } }.		}.	].	^ menu! !!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'nice 8/28/2010 22:34'!load: anInteger	"Set my contents to the value of given integer."	(anInteger positive and: [anInteger digitLength <= 4])		ifFalse: [self error: 'out of range: ', anInteger printString].	low := anInteger bitAnd: 16rFFFF.	hi := (anInteger bitShift: -16) bitAnd: 16rFFFF! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'nice 8/28/2010 21:03'!leftRotateBy: bits	"Rotate my contents left by the given number of bits, retaining exactly 32 bits."	"Details: Perform this operation with as little LargeInteger arithmetic as possible."	| bitCount s1 s2 newHi |	"ensure bitCount is in range [0..31]"	bitCount := bits \\ 32.	bitCount > 16		ifTrue: [			s1 := bitCount - 16.			s2 := s1 - 16.			newHi := ((low bitShift: s1) bitAnd: 16rFFFF) bitOr: (hi bitShift: s2).			low := ((hi bitShift: s1) bitAnd: 16rFFFF) bitOr: (low bitShift: s2).			hi := newHi]		ifFalse: [			s1 := bitCount.			s2 := s1 - 16.			newHi := ((hi bitShift: s1) bitAnd: 16rFFFF) bitOr: (low bitShift: s2).			low := ((low bitShift: s1) bitAnd: 16rFFFF) bitOr: (hi bitShift: s2).			hi := newHi]! !!ThirtyTwoBitRegister class methodsFor: 'instance creation' stamp: 'nice 8/28/2010 22:42'!fromByteArray: aByteArray at: startIndex	"Answer a new instance whose initial contents is copied from next four bytes from aByteArray starting at startIndex..	Convention is Most Significant Byte first (aka big endian)."	^ self basicNew loadFrom: aByteArray at: startIndex! !!ThirtyTwoBitRegister class methodsFor: 'instance creation' stamp: 'nice 8/28/2010 22:38'!fromInteger: aPositiveInteger	"Answer a new instance whose initial contents is copied from aPositiveInteger.	It is required that aPositiveInteger has no more than 32 bits."	^ self basicNew load: aPositiveInteger! !!TileMorphTest methodsFor: 'testing' stamp: 'tak 12/5/2004 18:58'!testArrowAction	"self debug: #testArrowAction"	| dummy tile |	dummy := Morph new.	tile := TileMorph new setOperator: '+'.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '-'.	tile := TileMorph new setOperator: '<'.	dummy addMorph: tile.	tile arrowAction: 1.	"Because receiver is not tile"	self assert: tile codeString = '='.	tile := true newTileMorphRepresentative.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '(false)'.! !!TileMorphTest methodsFor: 'testing' stamp: 'tak 12/5/2004 18:58'!testAssignmentTile	"self debug: #testAssignmentTile"	| player viewer tile phrase |	player := Morph new assuredPlayer.	viewer := CategoryViewer new invisiblySetPlayer: player.	viewer  makeSetter: #(#getX #Number) event: nil from: player costume.	phrase := ActiveHand firstSubmorph.	ActiveHand removeAllMorphs.	tile := phrase submorphs second.	self assert: tile codeString = 'setX: '.	tile arrowAction: 1.	self assert: tile codeString = 'setX: self getX + '.! !!TileMorphTest methodsFor: 'testing' stamp: 'ar 7/21/2010 19:48'!testNewTileMorphRepresentative		self assert: (nil newTileMorphRepresentative class =  UndescribedTile).	self assert: (false newTileMorphRepresentative isKindOf: TileMorph).	self assert: (false newTileMorphRepresentative literal = false).	self assert: (true newTileMorphRepresentative literal = true).! !!TileMorphTest methodsFor: 'testing' stamp: 'tlk 5/6/2006 16:35'!testSoundTile	"self debug: #testSoundTile"	| tile dummy |	dummy := Morph new.	tile := SoundTile new literal: 'croak'.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '(''horn'')'.	! !!Time methodsFor: 'printing' stamp: 'ul 11/15/2010 10:12'!print24: hr24 showSeconds: showSeconds on: aStream 	"Format is 'hh:mm:ss' or 'h:mm:ss am'  or, if showSeconds is false, 'hh:mm' or 'h:mm am'"	| h m s |	h := self hour. m := self minute. s := self second.	hr24		ifTrue: 			[ h < 10 ifTrue: [ aStream nextPutAll: '0' ].			h printOn: aStream ]		ifFalse:			[ h > 12				ifTrue: [h - 12 printOn: aStream]				ifFalse: 					[h < 1						ifTrue: [ 12 printOn: aStream ]						ifFalse: [ h printOn: aStream ]]].	aStream nextPutAll: (m < 10 ifTrue: [':0'] ifFalse: [':']).	m printOn: aStream.	showSeconds ifTrue:		[ aStream nextPutAll: (s < 10 ifTrue: [':0'] ifFalse: [':']).		self nanoSecond = 0			ifTrue: [s asInteger printOn: aStream]			ifFalse: [(s + (self nanoSecond / NanosInSecond) asFloat) printOn: aStream]].	hr24 ifFalse:		[ aStream nextPutAll: (h < 12 ifTrue: [' am'] ifFalse: [' pm']) ].! !!Time commentStamp: 'dew 10/23/2004 17:58' prior: 0!This represents a particular point in time during any given day.  For example, '5:19:45 pm'.If you need a point in time on a particular day, use DateAndTime.  If you need a duration of time, use Duration.!!Time class methodsFor: 'general inquiries' stamp: 'dtl 4/13/2011 08:06'!millisecondClockMask	"Answer the mask used for millisecond clock rollover in the virtual machine.	Answer a default if the VM cannot supply the value."	^MillisecondClockMask ifNil: [16r1FFFFFFF]! !!Time class methodsFor: 'squeak protocol' stamp: 'dtl 4/13/2011 08:05'!milliseconds: currentTime since: lastTime	"Answer the elapsed time since last recorded in milliseconds.	Compensate for rollover."	| delta |	delta := currentTime - lastTime.	^ delta < 0		ifTrue: [self millisecondClockMask + delta]		ifFalse: [delta]! !!Time class methodsFor: 'clock' stamp: 'dtl 4/13/2011 08:09'!initializeMillisecondClockMask	"Initialize cached value from the VM, or set to nil if VM cannot support the request"	MillisecondClockMask := self primMillisecondClockMask! !!Time class methodsFor: 'clock' stamp: 'dtl 8/14/2010 15:25'!primMicrosecondClock	"Answer the number of microseconds since the microsecond clock	was last reset or rolled over. Answer zero if the primitive fails."	<primitive: 'primitiveMicrosecondClock'>	^ 0! !!Time class methodsFor: 'clock' stamp: 'dtl 4/13/2011 08:02'!primMillisecondClockMask	"Answer the mask value used for millisecond clock rollover in the	virtual machine, or nil if the VM cannot support the request."	<primitive: 'primitiveMillisecondClockMask'>	^nil! !!TimeProfileBrowser methodsFor: 'private' stamp: 'fbs 6/7/2011 17:30'!initializeMessageList: anArray	messageList := anArray.	messageListIndex := 0.	contents := ''! !!TimeProfileBrowser methodsFor: 'private' stamp: 'ul 8/3/2011 01:54'!messageListKey: aChar from: view 	"Respond to a Command key. Cmd-D means re-run block."	aChar == $d ifTrue: [ ^Cursor execute showWhile: block ].	^super messageListKey: aChar from: view! !!TimeProfileBrowser methodsFor: 'contents' stamp: 'ul 11/2/2011 02:45'!isModeStyleable	"Ensure that only methods are styled."	^self selectedMessageName notNil and: [ super isModeStyleable ]! !!TimeStamp methodsFor: 'squeak protocol' stamp: 'klc 9/12/2010 16:10'!asDateAndTime	"Answer the receiver as an instance of DateAndTime."	^ DateAndTime new setJdn: jdn seconds: seconds nano: nanos offset: offset! !!Timespan methodsFor: 'squeak protocol' stamp: 'cmm 7/10/2011 21:31'!makeUTC	"Change the receiver's timezone to UTC, which affords substantially better hashing performance."	start makeUTC! !!TimespanTest methodsFor: 'testing' stamp: 'klc 9/10/2010 17:11'!testEnd	self assert: aTimespan end + (Duration  nanoSeconds:1)  =  aDisjointTimespan start.	self assert: aTimespan end = (DateAndTime year: 2005 month: 1 day: 7 hour: 23 minute: 59 second: 59 nanoSecond: 999999999 offset: 0 hours)! !!ToolBuilder methodsFor: 'defaults' stamp: 'rww 9/11/2010 14:09'!pluggableDropDownListSpec	^PluggableDropDownListSpec! !!ToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 18:56'!openDebugger: aSpec	"Build and open a debugger from the given spec.	Answer the widget opened. Subclasses can override this	method if opening a debugger has specific requirements	different from opening other widgets." 	self open: aSpec! !!ToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 18:59'!openDebugger: aSpec label: aString	"Build and open a debugger from the given spec, labeling it appropriately.	Answer the widget opened. Subclasses can override this	method if opening a debugger has specific requirements	different from opening other widgets." 	self open: aSpec label: aString! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'rww 9/11/2010 13:37'!buildPluggableDropDownList: spec	^self buildPluggableList: spec! !!ToolBuilder commentStamp: '<historical>' prior: 0!I am a tool builder, that is an object which knows how to create concrete widgets from abstract specifications. Those specifications are used by tools which want to be able to function in diverse user interface paradigms, such as MVC, Morphic, Tweak, wxWidgets etc.The following five specs must be supported by all implementations:	* PluggableButton	* PluggableList	* PluggableText	* PluggablePanel	* PluggableWindowThe following specs are optional:	* PluggableTree: If not supported, the tool builder must answer nil when asked for a pluggableTreeSpec. Substitution will require client support so clients must be aware that some tool builders may not support trees (MVC for example, or Seaside). See examples in FileListPlus or TestRunnerPlus.	* PluggableMultiSelectionList: If multi-selection lists are not supported, tool builder will silently support regular single selection lists.	* PluggableInputField: Intended as a HINT for the builder that this widget will be used as a single line input field. Unless explicitly supported it will be automatically substituted by PluggableText.	* PluggableActionButton: Intended as a HINT for the builder that this widget will be used as push (action) button. Unless explicitly supported it will be automatically substituted by PluggableButton.	* PluggableRadioButton: Intended as a HINT for the builder that this widget will be used as radio button. Unless explicitly supported it will be automatically substituted by PluggableButton.	* PluggableCheckBox: Intended as a HINT for the builder that this widget will be used as check box. Unless explicitly supported it will be automatically substituted by PluggableButton.!!ToolBuilder class methodsFor: 'accessing' stamp: 'dtl 3/5/2011 09:21'!default	"Answer the default tool builder"	^ Project current uiManager toolBuilder		ifNil: [self findDefault]! !!ToolBuilder class methodsFor: 'accessing' stamp: 'dtl 3/5/2011 09:33'!default: aToolBuilder	"Set a new default tool builder"	self deprecated: 'The default ToolBuilder is an attribute of the UIManager'! !!ToolBuilder class methodsFor: 'accessing' stamp: 'dtl 3/4/2011 17:15'!findDefault	"Answer a default tool builder"	| builderClass |	"Note: The way the following is phrased ensures that you can always make 'more specific' builders merely by subclassing a tool builder and implementing a more specific way of reacting to #isActiveBuilder. For example, a BobsUIToolBuilder can subclass MorphicToolBuilder and (if enabled, say Preferences useBobsUITools) will be considered before the parent (generic MorphicToolBuilder)."	builderClass := self allSubclasses 		detect:[:any| any isActiveBuilder and:[			any subclasses noneSatisfy:[:sub| sub isActiveBuilder]]] ifNone:[nil].	builderClass ifNotNil: [^builderClass new].	^self error: 'ToolBuilder not found'! !!ToolSet class methodsFor: 'debugging' stamp: 'jrd 5/23/2009 00:54'!debugError: anError	"Handle an otherwise unhandled error"	self default ifNil:[ | ctx |		Smalltalk 			logSqueakError: anError description 			inContext: (ctx := anError signalerContext) .		self inform: (anError description, String cr, ctx shortStack).		^anError return].	^self default debugError: anError! !!ToolSet class methodsFor: 'completion' stamp: 'damiencassou 7/29/2009 16:24'!codeCompletionAround: aBlock textMorph: aTextMorph keyStroke: evt	self default ifNil: [aBlock value. ^ self].	self default codeCompletionAround: aBlock textMorph: aTextMorph keyStroke: evt! !!TopGripMorph methodsFor: 'target resize' stamp: 'ael 6/3/2011 00:38'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (0 @ delta y) corner: oldBounds corner)! !!TopGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!TopGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:31'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (0 @ -40  corner: 0@ 0)! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!ptName	^#top! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!resizeCursor	^ Cursor resizeForEdge: #top! !!TraitAlias methodsFor: 'operations' stamp: 'ul 8/2/2011 20:12'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	subject selectorsAndMethodsDo: aBlock.	aliases do:[:assoc| | method |		"Method can be nil during removals"		method := subject compiledMethodAt: assoc value ifAbsent:[nil].		method ifNotNil:[aBlock value: assoc key value: method].	].! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'jrd 11/9/2010 14:01'!showln: anObject  "TextCollector compatibility"	self nextPutAll: anObject asString; cr ;  endEntry! !!TranscriptStream methodsFor: '*Tools' stamp: 'ar 2/11/2005 20:36'!buildWith: builder	| windowSpec textSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec model: self.	windowSpec label: 'Transcript'.	windowSpec children: OrderedCollection new.	textSpec := builder pluggableTextSpec new.	textSpec 		model: self;		menu: #codePaneMenu:shifted:;		frame: (0@0corner: 1@1).	windowSpec children add: textSpec.	^builder build: windowSpec! !!TranscriptStream methodsFor: '*Tools' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!TranscriptStream methodsFor: '*Tools' stamp: 'mp 2/2/2010 20:36'!open	| openCount |	openCount := self countOpenTranscripts.	openCount = 0		ifTrue: [self openLabel: 'Transcript']		ifFalse: [self openLabel: 'Transcript #' , (openCount+1) printString]! !!TranscriptStream methodsFor: '*Tools' stamp: 'ar 8/7/2009 22:28'!openLabel: aString 	"Open a window on this transcriptStream"	^ToolBuilder open: self label: aString! !!TranscriptStream class methodsFor: '*Tools' stamp: 'dtl 10/4/2009 23:44'!buildWith: aBuilder	^(Smalltalk at: #Transcript) buildWith: aBuilder! !!TranscriptStream class methodsFor: '*Tools' stamp: 'ar 8/7/2009 22:24'!openMorphicTranscript	"Have the current project's transcript open up as a morph"	^ToolBuilder open: self! !!TranscriptStream class methodsFor: '*Tools' stamp: 'sw 2/26/2002 14:46'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name wording: 'Transcript' brightColor: #lightOrange pastelColor: #paleOrange helpMessage: 'The system transcript'! !!Transcripter methodsFor: 'command line' stamp: 'ul 6/17/2011 12:48'!confirm: queryString 	| choice |	[choice := self request: queryString , 'Please type yes or no followed by return'.	choice first asUppercase = $Y ifTrue: [^ true].		choice first asUppercase = $N ifTrue: [^ false]] repeat! !!TransferMorph methodsFor: 'stepping and presenter' stamp: 'bf 11/14/2011 16:46'!step	self shouldCopy: self primaryHand lastEvent shiftPressed.	self updateCopyIcon! !!TrashCanMorph methodsFor: 'event handling' stamp: 'HenrikSperreJohansen 1/21/2011 18:35'!mouseEnter: event 	"Present feedback for potential deletion."	| hand firstSub |	hand := event hand.	((hand submorphCount > 0				and: [(firstSub := hand submorphs first) ~~ self])			and: [self wantsDroppedMorph: firstSub event: event])		ifTrue: [SoundService soundEnabled				ifTrue: [self class playMouseEnterSound].			"hand visible: false." "This leads to confusion. Let morph and hand appear til dropped."			"self world abandonAllHalos."			"hand halo: nil."			self state: #pressed]		ifFalse: [self showStampIn: hand]! !!TrashCanMorph methodsFor: 'event handling' stamp: 'HenrikSperreJohansen 1/21/2011 18:35'!mouseLeave: event	"Present feedback for aborted deletion."	| hand |	hand := event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue:			[SoundService soundEnabled ifTrue: [self class playMouseLeaveSound].			hand visible: true.			self state: #off]		ifFalse:			[self stopShowingStampIn: hand].! !!TrashCanMorph methodsFor: 'layout' stamp: 'HenrikSperreJohansen 1/21/2011 18:35'!acceptDroppingMorph: aMorph event: evt 	SoundService soundEnabled		ifTrue: [Preferences preserveTrash				ifTrue: [self class playDeleteSound]				ifFalse: [self playSoundNamed: 'scratch']].	evt hand visible: true.	self state: #off.	aMorph delete.	aMorph == Utilities scrapsBook		ifFalse: [Utilities addToTrash: aMorph removeHalo]! !!TrashCanMorph class methodsFor: 'miscellaneous' stamp: 'HenrikSperreJohansen 1/21/2011 18:36'!moveToTrash: aMorph	SoundService soundEnabled ifTrue:		[Preferences preserveTrash 			ifFalse:				[self playSoundNamed: 'scratch']			ifTrue:				[self playDeleteSound]].	aMorph delete.	aMorph == Utilities scrapsBook ifFalse:		[Utilities addToTrash: aMorph]! !!True methodsFor: 'logical operations' stamp: 'nice 2/1/2011 21:50'!==> aBlock	^aBlock value! !!UIManager methodsFor: 'ui requests' stamp: 'ul 12/12/2010 21:05'!chooseClassOrTrait	"Let the user choose a Class or Trait"		^self chooseClassOrTrait: 'Class name or fragment?'! !!UIManager methodsFor: 'ui requests' stamp: 'ul 12/12/2010 21:04'!chooseClassOrTrait: label	"Let the user choose a Class or Trait"		^self chooseClassOrTrait: label from: Smalltalk environment! !!UIManager methodsFor: 'ui requests' stamp: 'ul 12/12/2010 23:06'!chooseClassOrTrait: label from: environment	"Let the user choose a Class or Trait."		| pattern |	pattern := self request: label.	^Utilities classOrTraitFrom: environment pattern: pattern label: label	! !!UIManager methodsFor: 'accessing' stamp: 'cmm 6/15/2011 14:50'!screenBounds	^ Display boundingBox! !!UIManager methodsFor: 'accessing' stamp: 'dtl 3/5/2011 12:48'!toolBuilder	^toolBuilder! !!UIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 0!UIManager is a dispatcher for various user interface requests, such as menu and dialog interactions. An instance of UIManager is associated with each Project to implement the appropriate functions for Morphic, MVC or other user interfaces.!!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:54'!default	^ Project current uiManager! !!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:52'!getDefault	"Ensure that a more specific manager can always be made by subclassing	a tool builder and implementing a more specific way of reacting to	#isActiveManager. For example, a BobsUIManager can subclass	MorphicUIManager and (if enabled, say Preferences useBobsUI) will	be considered before the parent (generic MorphicUIManager)."	^ (self allSubclasses		detect: [:any | any isActiveManager				and: [any subclasses						noneSatisfy: [:sub | sub isActiveManager]]]		ifNone: [])		ifNotNilDo: [:mgrClass | mgrClass new]! !!URI class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 12:09'!extractSchemeFrom: aString	| colonIndex slashIndex |	colonIndex := aString indexOf: $: .	^colonIndex > 0		ifTrue: [			slashIndex := aString indexOf: $/ .			(slashIndex = 0				or: [colonIndex < slashIndex])				ifTrue: [aString copyFrom: 1 to: colonIndex-1]				ifFalse: [nil]]		ifFalse: [nil]! !!UTF16TextConverter methodsFor: 'accessing' stamp: 'ul 5/22/2011 14:01'!useByteOrderMark	^useByteOrderMark! !!UTF16TextConverter methodsFor: 'accessing' stamp: 'ul 5/22/2011 14:03'!useLittleEndian	^useLittleEndian! !!UTF16TextConverter methodsFor: 'accessing' stamp: 'ul 5/22/2011 14:00'!useLittleEndian: aBoolean	aBoolean = useLittleEndian ifFalse: [ self swapLatin1EncodingByteOrder ].	useLittleEndian := aBoolean.! !!UTF16TextConverter methodsFor: 'conversion' stamp: 'ul 5/22/2011 17:12'!nextFromStream: aStream	| character1 character2 readBOM charValue |	aStream isBinary ifTrue: [ ^aStream basicNext ].	character1 := aStream basicNext ifNil: [ ^nil ].	character2 := aStream basicNext ifNil: [ ^nil ].		readBOM := false.	(character1 asciiValue = 16rFF and: [character2 asciiValue = 16rFE]) ifTrue: [		self			useByteOrderMark: true;			useLittleEndian: true.		readBOM := true ].	(character1 asciiValue = 16rFE and: [character2 asciiValue = 16rFF]) ifTrue: [		self			useByteOrderMark: true;			useLittleEndian: false.		readBOM := true ].	readBOM ifTrue: [		character1 := aStream basicNext ifNil: [ ^nil ].		character2 := aStream basicNext ifNil: [ ^nil ] ].	useLittleEndian 		ifTrue: [ charValue := (character2 charCode bitShift: 8) + character1 charCode ]		ifFalse: [ charValue := (character1 charCode bitShift: 8) + character2 charCode ].	^ self charFromStream: aStream withFirst: charValue! !!UTF16TextConverter methodsFor: 'conversion' stamp: 'ul 5/22/2011 14:02'!nextPut: aCharacter toStream: aStream	| charCode |	aStream isBinary ifTrue: [ ^aCharacter storeBinaryOn: aStream ].	(useByteOrderMark and: [ byteOrderMarkDone not ]) ifTrue: [		self next16BitValue: 16rFEFF toStream: aStream.		byteOrderMarkDone := true ].	(charCode := aCharacter charCode) < 256		ifTrue: [			(latin1Encodings at: charCode + 1)				ifNil: [ self next16BitValue: charCode toStream: aStream ]				ifNotNil: [ :encodedString | aStream basicNextPutAll: encodedString ] ]		ifFalse: [			charCode <= 16rFFFF				ifTrue: [ self next16BitValue: charCode toStream: aStream ]				ifFalse: [					| low high |					charCode := charCode - 16r10000.					low := charCode \\ 16r400 + 16rDC00.					high := charCode // 16r400 + 16rD800.					self						next16BitValue: high toStream: aStream;						next16BitValue: low toStream: aStream ] ].	^aCharacter! !!UTF16TextConverter methodsFor: 'private' stamp: 'ul 5/22/2011 13:58'!charFromStream: aStream withFirst: firstValue	| character1 character2 n secondValue |	(16rD800 <= firstValue and: [firstValue <= 16rDBFF]) ifFalse: [		^Unicode value: firstValue ].	character1 := aStream basicNext ifNil: [ ^nil ].	character2 := aStream basicNext ifNil: [ ^nil ].	useLittleEndian ifTrue: [		| tmp |		tmp := character1.		character1 := character2.		character2 := tmp ].	secondValue := (character1 charCode bitShift: 8) + character2 charCode.	n := firstValue - 16rD800 * 16r400 + (secondValue - 16rDC00) + 16r10000.	^Unicode value: n! !!UTF16TextConverter methodsFor: 'private' stamp: 'ul 5/22/2011 13:57'!next16BitValue: value toStream: aStream	| v1 v2 |	v1 := (value bitShift: -8) bitAnd: 16rFF.	v2 := value bitAnd: 16rFF.	useLittleEndian		ifTrue: [			aStream 				basicNextPut: (Character value: v2);				basicNextPut: (Character value: v1) ]		ifFalse: [			aStream				basicNextPut: (Character value: v1);				basicNextPut: (Character value: v2) ].! !!UTF16TextConverter methodsFor: 'private' stamp: 'HenrikSperreJohansen 6/7/2010 15:04'!swapLatin1EncodingByteOrder	latin1Encodings := latin1Encodings collect: [:each | each reverse]! !!UTF16TextConverter methodsFor: 'initialize-release' stamp: 'ul 5/22/2011 14:04'!initialize	super initialize.	useLittleEndian := useByteOrderMark := byteOrderMarkDone := false! !!UTF16TextConverterTest methodsFor: 'testing' stamp: 'HenrikSperreJohansen 6/7/2010 15:03'!testByteOrders	|converter originalText bytes decodedText |	originalText := 'test'.	converter := UTF16TextConverter new.		"Default (ie useLittleEndian instvar nil)"	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		"Little-endian"	converter useLittleEndian: true.	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		"Big-endian"	converter useLittleEndian: false.	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:21'!errorMalformedInput: aString	"Invalid UTF-8 input has been detected in the given string.	Raise an error if strict conversions are enabled, otherwise allow	the original string to be returned."		^self class errorMalformedInput: aString! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:21'!nextFromStream: aStream	| char1 value1 char2 value2 unicode char3 value3 char4 value4 |	aStream isBinary ifTrue: [^ aStream basicNext].	char1 := aStream basicNext.	char1 ifNil:[^ nil].	value1 := char1 asciiValue.	value1 <= 127 ifTrue: [		"1-byte char"		^ char1	].	"at least 2-byte char"	char2 := aStream basicNext.	char2 ifNil:[^self errorMalformedInput: (String with: char1)].	value2 := char2 asciiValue.	(value1 bitAnd: 16rE0) = 192 ifTrue: [		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63).	].	"at least 3-byte char"	char3 := aStream basicNext.	char3 ifNil:[^self errorMalformedInput: (String with: char1 with: char2)].	value3 := char3 asciiValue.	(value1 bitAnd: 16rF0) = 224 ifTrue: [		unicode := ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63).	].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte char"		char4 := aStream basicNext.		char4 ifNil:[^self errorMalformedInput: (String with: char1 with: char2 with: char3)].		value4 := char4 asciiValue.		unicode := ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63).	].	unicode ifNil:[^self errorMalformedInput: (String with: char1 with: char2 with: char3)].	unicode > 16r10FFFD ifTrue: [		^self errorMalformedInput: (String with: char1 with: char2 with: char3).	].		unicode = 16rFEFF ifTrue: [^ self nextFromStream: aStream].	^ Unicode value: unicode.! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 5/17/2011 17:25'!nextPut: aCharacter toStream: aStream 		| nBytes mask shift ucs2code |	aStream isBinary ifTrue: [ ^aCharacter storeBinaryOn: aStream ].	ucs2code := aCharacter asUnicode ifNil: [ ^aCharacter ].	ucs2code < 256 ifTrue: [		(latin1Encodings at: ucs2code + 1)			ifNil: [ aStream basicNextPut: aCharacter ]			ifNotNil: [ :encodedString | aStream basicNextPutAll: encodedString ].		^aCharacter ].	nBytes := ucs2code highBit + 3 // 5.	mask := #[128 192 224 240 248 252 254 255] at: nBytes.	shift := nBytes - 1 * -6.	aStream basicNextPut: (Character value: (ucs2code bitShift: shift) + mask).	2 to: nBytes do: [ :i | 		shift := shift + 6.		aStream basicNextPut: (			Character value: ((ucs2code bitShift: shift) bitAnd: 63) + 128) ].	^aCharacter.! !!UTF8TextConverter commentStamp: '<historical>' prior: 0!Text converter for UTF-8.  Since the BOM is used to distinguish the MacRoman code and UTF-8 code, BOM is written for UTF-8 by #writeBOMOn: which is called by client.!!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!errorMalformedInput: aString	"Invalid UTF-8 input has been detected in the given string.	Raise an error if strict conversions are enabled, otherwise allow	the original string to be returned."	self strictUtf8Conversions ifTrue:[		self error: 'Invalid utf8: ', aString	].	^aString! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!strictUtf8Conversions	"Preference setter for strict utf-8 conversions"	<preference: 'Strict utf8 conversions'		category: 'general' "should this be localization?"		description: 'If true, invalid utf-8 input will raise errors. If false, invalid utf-8 input will be allowed to pass through the conversion unchanged'		type: #Boolean>		^StrictUtf8Conversions ifNil:[true]! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!strictUtf8Conversions: aBool	"Preference setter for strict utf-8 conversions"	StrictUtf8Conversions := aBool.! !!UTF8TextConverter class methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:11'!decodeByteString: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex byte1 byte2 byte3 byte4 unicode |	lastIndex := 1.	(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0		ifTrue: [ ^aByteString ].	outStream := (String new: aByteString size) writeStream.	[		outStream next: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex.		byte1 := aByteString byteAt: nextIndex.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[	^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63)].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63)].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte4 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte4 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63)].		unicode ifNil: [ ^self errorMalformedInput: aByteString ].		unicode = 16rFEFF ifFalse: [ "Skip byte order mark"			outStream nextPut: (Unicode value: unicode) ].		lastIndex := nextIndex + 1.		(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0 ] whileFalse.	^outStream 		next: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex;		contents! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:30'!testLazyConversion	"Ensure the lazy conversions do what they should"	| strict result |	strict := UTF8TextConverter strictUtf8Conversions.	[UTF8TextConverter strictUtf8Conversions: false.	self shouldnt:[result := 'Gr Gott' utf8ToSqueak ] raise: Error.	] ensure:[UTF8TextConverter strictUtf8Conversions: strict].	self assert: result = 'Gr Gott'.! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:29'!testSqueakToUtf8	"Ensure proper encoding"	self assert: '' squeakToUtf8 equals: ''.	self assert: 'Hello World' squeakToUtf8 equals: 'Hello World'.	self assert: 'Gr Gott' squeakToUtf8 asByteArray 		equals: #[71 114 195 188 195 159 32 71 111 116 116]! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:27'!testStrictConversion	"Ensure the strict conversions do what they should"	| strict |	strict := UTF8TextConverter strictUtf8Conversions.	[UTF8TextConverter strictUtf8Conversions: true.	self should:[ 'Gr Gott' utf8ToSqueak ] raise: Error.	] ensure:[UTF8TextConverter strictUtf8Conversions: strict].! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:28'!testUtf8ToSqueak	"Ensure proper encoding"	self assert: '' utf8ToSqueak equals: ''.	self assert: 'Hello World' utf8ToSqueak equals: 'Hello World'.	self assert: #[71 114 195 188 195 159 32 71 111 116 116] asString utf8ToSqueak		equals: 'Gr Gott'! !!UUID methodsFor: 'comparing' stamp: 'ul 11/9/2011 23:01'!< aMagnitude 	"Answer whether the receiver is less than the argument."	1 to: self size do: [ :i |		| x y |		(x := self at: i) = (y := aMagnitude at: i) ifFalse: [ ^x < y ] ].	^false.! !!UUID class methodsFor: '*smbase-macsafe' stamp: 'nice 8/21/2010 11:26'!fromString36: aString	"Decode the UUID from a base 36 string using 0-9 and lowercase a-z.	This is the shortest representation still being able to work as	filenames etc since it does not depend on case nor characters	that might cause problems."	| object num |	object := self nilUUID.	num := Integer readFrom: aString asUppercase readStream base: 36.	1 to: 16 do: [:i | object at: i put: (num digitAt: i)].	^object! !!UUIDGenerator methodsFor: 'random seed' stamp: 'ul 9/11/2011 16:40'!makeUnixSeed		^[		StandardFileStream readOnlyFileNamed: '/dev/urandom' do: [ :stream |			stream binary.			(Integer				byte1: stream next				byte2: stream next				byte3: stream next				byte4: stream next) ] ] 		on: Error		do: [ nil ]! !!UUIDTest methodsFor: 'as yet unclassified' stamp: 'ul 11/9/2011 23:58'!testComparison	"Test if the comparison operators define a total sort function."	#(		#[3 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0] #[2 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0]		#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 1] #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 4]		#[2 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0] #[3 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]		#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 4] #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 1]		#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 4] #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 4]	) pairsDo: [ :x :y |		| a b c d |		a := UUID newFrom: x.		b := UUID newFrom: y.		c := x asString.		d := y asString.		"Check if the comparison is lexicographical, just like strings'."		#(< > <= >= = ~=) do: [ :operation | 			self assert: (a perform: operation with: b) = (c perform: operation with: d) ].		"And a few more"		self			assert: (a < b) = (a >= b) not;			assert: (a > b) = (a <= b) not;			assert: (a = b) = (a ~= b) not;			assert: (a < b) = (b > a);			assert: (a > b) = (b < a);			assert: (a >= b) = (b <= a);			assert: (a <= b) = (b >= a);			assert: (a = b) = (b = a);			assert: (a ~= b) = (b ~= a);			assert: (a > b) = ((a >= b) & (a ~= b));			assert: (a < b) = ((a <= b) & (a ~= b));			assert: (a >= b) = ((a = b) | (a > b));			assert: (a <= b) = ((a = b) | (a < b));			assert: (a ~= b) = ((a < b) | (a > b));			assert: (a <= b) & (b <= a) = (a = b);			assert: (a >= b) & (b >= a) = (a = b);			assert: (a <= b) | (b <= a);			assert: (a = b) asBit + (a < b) asBit + (b < a) asBit = 1 ]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'nice 8/19/2010 16:36'!categories	^(self sortedPackages collect: [ :p | p category])		asSet asArray sort: [ :p1 :p2 | p1 asString < p2 asString]! !!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'nice 4/20/2011 00:35'!openMenuIn: aBlock 	| alternatives labels actions lines caption choice |	alternatives := parser possibleVariablesFor: name.	labels := OrderedCollection new.	actions := OrderedCollection new.	lines := OrderedCollection new.	name first isLowercase 		ifTrue: 			[labels add: 'declare method temp'.			actions add: [parser declareTemp: name at: #method].			labels add: 'declare block-local temp'.			actions add: [parser declareTemp: name at: #block].			parser canDeclareInstanceVariable 				ifTrue: 					[labels add: 'declare instance'.					actions add: [parser declareInstVar: name]]]		ifFalse: 			[labels add: 'define new class'.			actions add: [parser defineClass: name].			labels add: 'declare global'.			actions add: [parser declareGlobal: name].			parser canDeclareClassVariable 				ifTrue: 					[labels add: 'declare class variable'.					actions add: [parser declareClassVar: name]]].	lines add: labels size.	alternatives do: 		[:each | 		labels add: each.		actions add: [parser substituteVariable: each atInterval: interval]].	lines add: labels size.	labels add: 'cancel'.	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.	choice := aBlock value: labels value: lines value: caption.	self resume: (actions at: choice ifAbsent: [nil])! !!UndeclaredVariableNode methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:51'!accept: aVisitor	^aVisitor visitUndeclaredVariableNode: self! !!UndeclaredVariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^true! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	^tag! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag: anObject	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	tag := anObject! !!UniclassScript methodsFor: 'script editor' stamp: 'ul 11/15/2010 12:09'!instantiatedScriptEditorForPlayer: aPlayer	"Return the current script editor, creating it if necessary"	currentScriptEditor ifNil:		[currentScriptEditor := (self playerClass includesSelector: selector) 			ifTrue:				[Preferences universalTiles					ifFalse:						[self error: 'duplicate selector'].				ScriptEditorMorph new fromExistingMethod: selector forPlayer: aPlayer]			ifFalse:				[ScriptEditorMorph new setMorph: aPlayer costume scriptName: selector].		(defaultStatus == #ticking and: [selector numArgs = 0]) ifTrue:			[aPlayer costume arrangeToStartStepping]].		^ currentScriptEditor! !!UniclassScript methodsFor: 'versions' stamp: 'ul 11/15/2010 12:09'!revertScriptVersionFrom: anEditor 	"Let user choose which prior tile version to revert to, and revert to it"	| chosenStampAndTileList |	formerScriptingTiles isEmptyOrNil ifTrue: [^Beeper beep].	chosenStampAndTileList := formerScriptingTiles size = 1 		ifTrue: [ formerScriptingTiles first]		ifFalse: 			[UIManager default 						chooseFrom: (formerScriptingTiles collect: [:e | e first])						values: formerScriptingTiles].	chosenStampAndTileList ifNotNil: 			[anEditor reinsertSavedTiles: chosenStampAndTileList second.			isTextuallyCoded := false]! !!Unicode commentStamp: 'yo 10/19/2004 20:44' prior: 0!This class holds the entry points for the utility functions around characters.!!Unicode class methodsFor: 'class methods' stamp: 'nice 6/11/2010 21:29'!parseUnicodeDataFrom: stream"	self halt.	self parseUnicodeDataFile"	| line fieldEnd point fieldStart toNumber generalCategory decimalProperty |	toNumber := [:quad | ('16r', quad) asNumber].	GeneralCategory := SparseLargeTable new: 16rE0080 chunkSize: 1024 arrayClass: Array base: 1 defaultValue:  'Cn'.	DecimalProperty := SparseLargeTable new: 16rE0080 chunkSize: 32 arrayClass: Array base: 1 defaultValue: -1.	16r3400 to: 16r4DB5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16r4E00 to: 16r9FA5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16rAC00 to: 16rD7FF do: [:i | GeneralCategory at: i+1 put: 'Lo'].	[(line := stream nextLine) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := toNumber value: (line copyFrom: 1 to: fieldEnd - 1).		point > 16rE007F ifTrue: [			GeneralCategory zapDefaultOnlyEntries.			DecimalProperty zapDefaultOnlyEntries.			^ self].		2 to: 3 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		generalCategory := line copyFrom: fieldStart to: fieldEnd - 1.		GeneralCategory at: point+1 put: generalCategory.		generalCategory = 'Nd' ifTrue: [			4 to: 7 do: [:i |				fieldStart := fieldEnd + 1.				fieldEnd := line indexOf: $; startingAt: fieldStart.			].			decimalProperty :=  line copyFrom: fieldStart to: fieldEnd - 1.			DecimalProperty at: point+1 put: decimalProperty asNumber.		].	].	GeneralCategory zapDefaultOnlyEntries.	DecimalProperty zapDefaultOnlyEntries.! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:47'!initializeCaseMappings	"Unicode initializeCaseMappings"	ToCasefold := IdentityDictionary new.	ToUpper := IdentityDictionary new.	ToLower := IdentityDictionary new.	UIManager default informUserDuring: [:bar|		| stream |		bar value: 'Downloading Unicode data'.		stream := HTTPClient httpGet: 'http://www.unicode.org/Public/UNIDATA/CaseFolding.txt'.		(stream isKindOf: RWBinaryOrTextStream) ifFalse:[^self error: 'Download failed'].		stream reset.		bar value: 'Updating Case Mappings'.		self parseCaseMappingFrom: stream.	].! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:49'!parseCaseMappingFrom: stream	"Parse the Unicode casing mappings from the given stream.	Handle only the simple mappings"	"		Unicode initializeCaseMappings.	"	ToCasefold := IdentityDictionary new: 2048.	ToUpper := IdentityDictionary new: 2048.	ToLower := IdentityDictionary new: 2048.	[stream atEnd] whileFalse:[		| fields line srcCode dstCode |		line := stream nextLine copyUpTo: $#.		fields := line withBlanksTrimmed findTokens: $;.		(fields size > 2 and: [#('C' 'S') includes: (fields at: 2) withBlanksTrimmed]) ifTrue:[			srcCode := Integer readFrom: (fields at: 1) withBlanksTrimmed base: 16.			dstCode := Integer readFrom: (fields at: 3) withBlanksTrimmed base: 16.			ToCasefold at: srcCode put: dstCode.		].	].	ToCasefold keysAndValuesDo:		[:k :v |		(self isUppercase: (self value: k))			ifTrue:				["In most cases, uppercase letter are folded to lower case"				ToUpper at: v put: k.				ToLower at: k put: v].		(self isLowercase: (self value: k))			ifTrue:				["In a few cases, two lower case letters are folded to the same lower case.				We must find an upper case letter folded to the same letter"				| up |				up := ToCasefold keys detect: [:e | (self isUppercase: (self value: e)) and: [(ToCasefold at: e) = v]] ifNone: [nil].				up ifNotNil: [ToUpper at: k put: up]]].! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:00'!toCasefold: aWideString	"Transform a Wide String into fold case.	This is to enable case insensitive conversion."		^aWideString collect: [:e |		(ToCasefold at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:low | self value: low]]! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 13:11'!toLowercase: aWideString	"Transform a Wide String into lowercase.	This does not handle special cases where number of characters could change.	The algorithm would work for ByteString, however it's far from the most efficient."		^aWideString collect: [:e |		(ToLower at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:low | self value: low]]! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 13:08'!toUppercase: aWideString	"Transform a Wide String into uppercase.	This does not handle special cases where number of characters could change.	The algorithm would work for ByteString, however it's far from the most efficient."		^aWideString collect: [:e |		(ToUpper at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:up | self value: up]]! !!UnixFileDirectory methodsFor: 'file names' stamp: 'eem 6/2/2010 09:38'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName |	fName := super checkName: aFileName fixErrors: fixing.	(fName includes: self class pathNameDelimiter) ifFalse:		[^fName].	^fixing		ifTrue: [fName copyReplaceAll: (String with: self class pathNameDelimiter) with: '#']		ifFalse: [self error:'Invalid file name']! !!UpdatingMenuItemMorph methodsFor: 'world' stamp: 'laza 5/16/2011 12:54'!updateContents	"Update the receiver's contents"	| newString enablement nArgs |	((wordingProvider isNil) or: [wordingSelector isNil]) ifFalse: [		nArgs := wordingSelector numArgs.		newString := nArgs = 0			ifTrue:				[wordingProvider perform: wordingSelector]			ifFalse:				[(nArgs = 1 and: [wordingArgument notNil])					ifTrue:						[wordingProvider perform: wordingSelector with: wordingArgument]					ifFalse:						[nArgs == arguments size ifTrue:							[wordingProvider perform: wordingSelector withArguments: arguments]]].		newString = (self contentString ifNil: [ contents ])			ifFalse: [self contents: newString.				MenuIcons decorateMenu: owner ]].	enablementSelector ifNotNil:		[(enablement := self enablement) == isEnabled 			ifFalse:	[self isEnabled: enablement]]! !!Url commentStamp: '<historical>' prior: 0!A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.!!Url class methodsFor: 'parsing' stamp: 'fbs 9/2/2010 12:56'!urlClassForScheme: scheme	^ SchemeRegistry at: scheme ifAbsent: [GenericUrl].! !!Url class methodsFor: 'class initialization' stamp: 'ul 10/28/2010 04:22'!initialize	SchemeRegistry := Dictionary new		at: 'browser' put: BrowserUrl;		at: 'file' put: FileUrl;		at: 'ftp' put: FtpUrl;		at: 'http' put: HttpUrl;		at: 'https' put: HttpUrl;		at: 'mailto' put: MailtoUrl;		at: nil put: HttpUrl;		yourself! !!Url class methodsFor: 'class initialization' stamp: 'fbs 9/2/2010 12:55'!registerUrlClass: aClass forScheme: aString	SchemeRegistry at: aString put: aClass.! !!UrlTest methodsFor: 'tests' stamp: 'ar 9/4/2010 11:25'!testUrlEncoded	"Test the behavior of #urlEncoded"	self assert: 'http://squeak.org/name with space?and=value' urlEncoded		equals: 'http://squeak.org/name%20with%20space?and=value'.	self assert: 'http://squeak.org/name%20with%20space?and=value' urlEncoded		equals: 'http://squeak.org/name%20with%20space?and=value'.	self assert: 'http://squeak.org/name%with%space?and=value' urlEncoded		equals: 'http://squeak.org/name%25with%25space?and=value'.! !!UrlTest methodsFor: 'tests' stamp: 'topa 5/4/2010 14:33'!testUsernamePasswordEncoded	"Sometimes, weird usernames or passwords are necessary in 	applications, and, thus, we might receive them in a Url.	The @ and the : ar the kind of critical ones.	"	#(	"('user' 'pword' 'host' port 'path')"		('Frst Pckler' 'leckerEis' 'cottbus.brandenburg' 80 'mein/Zuhause')		('Jeannde.d''Arc' 'jaiunescret' 'orleans' 8080 'une/deux/trois')		('HaXor@roxor:fnac' 'my~Pa$wert' 'cbase' 42 'do/not_try')	) do: [:urlParts | |theUrl|		theUrl := ('http://{1}:{2}@{3}:{4}/{5}' format: {			(urlParts at: 1) encodeForHTTP. 	(urlParts at: 2) encodeForHTTP.			urlParts at: 3. urlParts at: 4. urlParts at: 5.		}) asUrl.		self 			should: [theUrl schemeName = 'http'];			should: [theUrl username = (urlParts at: 1)];			should: [theUrl password = (urlParts at: 2)];			should: [theUrl authority = (urlParts at: 3)];			should: [theUrl port = (urlParts at: 4)];			should: [theUrl path first = ((urlParts at: 5) copyUpTo: $/)]].! !!UrlTest methodsFor: 'tests' stamp: 'topa 5/5/2010 13:50'!testUsernamePasswordPrintingEncoded	#(	'http://F%C3%BCrst%20P%C3%BCckler:leckerEis@cottbus.brandenburg:80/mein/Zuhause'		'http://Jeannde.d%27Arc:jaiunes%C3%A9cret@orleans:8080/une/deux/trois' 		'http://HaXor%40roxor%3Afnac:my%7EPa%24%C2%A7wert@cbase:42/do/not_try'	) do: [ :urlText |		self should: [ urlText = urlText asUrl asString ] ].! !!UserDialogBoxMorph methodsFor: 'constructing' stamp: 'laza 9/16/2011 11:28'!triggerAfter: seconds	timeout := seconds! !!UserDialogBoxMorph methodsFor: 'running' stamp: 'laza 9/19/2011 16:07'!runModalIn: aWorld forHand: aHand at: aPointOrNil	"Ensure that we have a reasonable minimum size"	| oldFocus pos offset |	(ProvideAnswerNotification signal: self label asString) ifNotNil:[:answer| ^answer].	self openInWorld: aWorld.	pos := aPointOrNil ifNil: [aHand position].   	offset := aPointOrNil		ifNil: [selectedButton fullBounds origin - (selectedButton fullBounds extent // 2 * (-1@1))]		ifNotNil: [self fullBounds extent // 2].	self setConstrainedPosition: pos - offset hangOut: false.	oldFocus := aHand keyboardFocus.	aHand newMouseFocus: self.	aHand newKeyboardFocus: self.	savedLabel := selectedButton label.	[self isInWorld] whileTrue:[aWorld doOneSubCycle].	oldFocus ifNotNil:[aHand keyboardFocus: oldFocus].	^value! !!UserDialogBoxMorph methodsFor: 'events' stamp: 'laza 9/16/2011 10:18'!keyStroke: evt	| evtCharacter |	self stopAutoTrigger.	evtCharacter := evt keyCharacter.	evtCharacter = Character escape ifTrue: [		^cancelButton ifNotNil: [ cancelButton performAction ] ].	evtCharacter = Character cr ifTrue: [		^selectedButton ifNotNil: [ selectedButton performAction ] ].	(evtCharacter = Character arrowLeft or: [ 		evt shiftPressed and: [ evtCharacter = Character tab ] ]) ifTrue: [ 			^self selectPreviousButton ].	(evtCharacter = Character arrowRight or: [ 		evtCharacter = Character tab ]) ifTrue: [ 			^self selectNextButton ].! !!UserDialogBoxMorph methodsFor: 'events' stamp: 'laza 9/16/2011 10:18'!mouseDown: event	self stopAutoTrigger.	"Always bring me to the front since I am modal"	self comeToFront.	(self containsPoint: event position) ifFalse:[		Beeper beepPrimitive.		^self flash].	event hand grabMorph: self.! !!UserDialogBoxMorph methodsFor: 'events' stamp: 'laza 9/16/2011 10:16'!mouseUp: event	self stopAutoTrigger.	"aggressively preserve focus"	event hand newMouseFocus: self.! !!UserDialogBoxMorph methodsFor: 'stepping and presenter' stamp: 'laza 9/16/2011 10:26'!step	timeout ifNil: [^self].	timeout = 0		ifTrue: [			self stopStepping.			selectedButton performAction]		ifFalse: [			selectedButton label: savedLabel, '(', timeout printString, ')'.			timeout := timeout - 1]! !!UserDialogBoxMorph methodsFor: 'stepping and presenter' stamp: 'laza 9/16/2011 09:56'!stepTime	^1000! !!UserDialogBoxMorph methodsFor: 'stepping and presenter' stamp: 'laza 9/16/2011 10:26'!stopAutoTrigger	timeout ifNil: [^self].	timeout := nil.	self stopStepping.	selectedButton label: savedLabel ! !!UserDialogBoxMorph commentStamp: 'ar 12/11/2009 22:33' prior: 0!A DialogBoxMorph is Morph used in simple yes/no/confirm dialogs. Strongly modal.!!UserDialogBoxMorph class methodsFor: 'utilities' stamp: 'laza 9/19/2011 08:39'!confirm: aString title: titleString trueChoice: trueChoice falseChoice: falseChoice default: default triggerAfter: seconds at: aPointOrNil	"UserDialogBoxMorph confirm: 'I like hot java' title: 'What do you say?' trueChoice: 'You bet!!' falseChoice: 'Nope' default: false triggerAfter: 12 at: 121@212"	^self new		title: titleString;		label: aString;		addButton: '   ', trueChoice translated, '   ' value: true selected: default performActionOnEscape: false;		addButton: '   ', falseChoice translated, '   ' value: false selected: default not performActionOnEscape: true;		triggerAfter: seconds;		runModalIn: ActiveWorld forHand: ActiveHand at: aPointOrNil! !!UserScript methodsFor: 'script editor' stamp: 'ul 8/2/2011 20:12'!allScriptVersionsDo: aBlock	self isTextuallyCoded ifFalse: [aBlock value: currentScriptEditor].	formerScriptEditors ifNotNil: [ formerScriptEditors do: aBlock ]! !!UserScript methodsFor: 'versions' stamp: 'ul 11/15/2010 12:09'!revertScriptVersionFrom: anEditor 	"Let user choose which prior tile version to revert to, and revert to it"	| result |	formerScriptEditors isEmptyOrNil ifTrue: [^Beeper beep].	result := formerScriptEditors size = 1 		ifTrue: [formerScriptEditors first]		ifFalse: 			[UIManager default 						chooseFrom: (formerScriptEditors collect: [:e | e timeStamp])						values: formerScriptEditors].	result 		ifNotNil: [self revertScriptVersionFrom: anEditor installing: result]! !!Utilities class methodsFor: 'common requests' stamp: 'ul 11/15/2010 12:16'!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	Smalltalk isMorphic ifTrue: [^ self offerCommonRequestsInMorphic].	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].		strings := CommonRequestStrings contents.	normalItemCount := strings asString lineCount.	aMenu := UIManager default 		chooseFrom: (strings asString lines copyWith: 'edit this menu')		lines: (Array with: normalItemCount).	index := aMenu startUp.	index = 0 ifTrue: [^ self].	reply := aMenu labelString lineNumber: index.	reply size = 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result := self evaluate: reply in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'fetching updates' stamp: 'ul 11/15/2010 12:09'!applyUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Utilities applyUpdatesFromDiskToUpdateNumber: 1234 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory := self getUpdateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest := SystemVersion current highestUpdate.	currentUpdateNumber := previousHighest.	done := false.	loaded := 0.	[done]		whileFalse: [currentUpdateNumber := currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done := true]				ifFalse: [fileNames := updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size = 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done := stopIfGapFlag]						ifFalse: [ChangeSet								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							SystemVersion current registerUpdate: currentUpdateNumber.							loaded := loaded + 1]]].	aMessage := loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!Utilities class methodsFor: 'fetching updates' stamp: 'nice 6/11/2010 21:30'!parseListContents: listContents	| sections vers strm line fileNames |	"Parse the contents of updates.list into {{vers. {fileNames*}}*}, and return it."	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	vers := nil.	strm := ReadStream on: listContents.	[strm atEnd] whileFalse:		[line := strm nextLine.		line size > 0 ifTrue:			[line first = $#				ifTrue: [vers ifNotNil: [sections addLast: {vers. fileNames asArray}].						"Start a new section"						vers := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	vers ifNotNil: [sections addLast: {vers. fileNames asArray}].	^ sections asArray" TEST: | list |list := Utilities parseListContents: (FileStream oldFileNamed: 'updates.list') contentsOfEntireFile.list = (Utilities parseListContents: (String streamContents: [:s | Utilities writeList: list toStream: s]))	ifFalse: [self error: 'test failed']	ifTrue: [self inform: 'test OK']"! !!Utilities class methodsFor: 'fetching updates' stamp: 'ul 6/17/2011 12:31'!readServer: serverList special: indexPrefix updatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.""Utilities readServer: Utilities serverUrls updatesThrough: 828 saveLocally: true updateImage: true"	| str urls failed loaded |	Cursor wait showWhile: [ | docQueue docQueueSema |	urls := self newUpdatesOn: (serverList collect: [:url | url, 'updates/']) 				special: indexPrefix				throughNumber: maxNumber.	loaded := 0.	failed := nil.	"send downloaded documents throuh this queue"	docQueue := SharedQueue new.	"this semaphore keeps too many documents from beeing queueed up at a time"	docQueueSema := Semaphore new.	5 timesRepeat: [ docQueueSema signal ].	"fork a process to download the updates"	self retrieveUrls: urls ontoQueue: docQueue withWaitSema: docQueueSema.	"process downloaded updates in the foreground"	'Processing updates' displayProgressFrom: 0 to: urls size during: [:bar | | nextDoc this updateName |	[ this := docQueue next.	  nextDoc := docQueue next.  	  nextDoc = #failed ifTrue: [ failed := this ].	  (failed isNil and: [ nextDoc ~= #finished ])	] whileTrue: [		failed ifNil: [			nextDoc reset; text.			nextDoc size = 0 ifTrue: [ failed := this ]. ].		failed ifNil: [			nextDoc peek asciiValue = 4	"pure object file"				ifTrue: [failed := this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc := doc asHtml]."				"HTML source code not supported here yet"			updateImage				ifTrue: [					updateName := (this findTokens: '/') last.					ChangeSet newChangesFromStream: nextDoc named: updateName.					SystemVersion current registerUpdate: updateName initialIntegerOrNil].			saveLocally ifTrue:				[self saveUpdate: nextDoc onFile: (this findTokens: '/') last].	"if wanted"			loaded := loaded + 1.			bar value: loaded].		docQueueSema signal].	]].	failed ~~ nil & (urls size - loaded > 0) ifTrue: [		str := loaded printString ,' new update file(s) processed.'.		str := str, '\Could not load ' withCRs, 			(urls size - loaded) printString ,' update file(s).',			'\Starting with "' withCRs, failed, '".'.		self inform: str].	^ Array with: failed with: loaded! !!Utilities class methodsFor: 'fetching updates' stamp: 'ul 6/17/2011 12:31'!retrieveUrls: urls ontoQueue: queue withWaitSema: waitSema 	"download the given list of URLs. The queue will be loaded alternately  	with url's and with the retrieved contents. If a download fails, the  	contents will be #failed. If all goes well, a special pair with an empty  	URL and the contents #finished will be put on the queue. waitSema is  	waited on every time before a new document is downloaded; this keeps 	the downloader from getting too far  ahead of the main process"	"kill the existing downloader if there is one"	| updateCounter |	UpdateDownloader		ifNotNil: [UpdateDownloader terminate].	updateCounter := 0.	"fork a new downloading process"	UpdateDownloader := [		'Downloading updates' displayProgressFrom: 0 to: urls size during: [:bar |			urls				do: [:url | | front canPeek doc | 					waitSema wait.					queue nextPut: url.					doc := HTTPClient httpGet: url.					doc isString						ifTrue: [queue nextPut: #failed.							UpdateDownloader := nil.							Processor activeProcess terminate]						ifFalse: [canPeek := 120 min: doc size.							front := doc next: canPeek.  doc skip: -1 * canPeek.							(front beginsWith: '<!!DOCTYPE') ifTrue: [								(front includesSubString: 'Not Found') ifTrue: [									queue nextPut: #failed.									UpdateDownloader := nil.									Processor activeProcess terminate]]].						UpdateDownloader ifNotNil: [queue nextPut: doc. updateCounter := updateCounter + 1. bar value: updateCounter]]].			queue nextPut: ''.			queue nextPut: #finished.			UpdateDownloader := nil] newProcess.	UpdateDownloader priority: Processor userInterruptPriority.	"start the process running"	UpdateDownloader resume! !!Utilities class methodsFor: 'fetching updates' stamp: 'ar 5/7/2010 20:50'!updateFromServer	"Update the image by loading all pending updates from the server."	| config |	"Flush all caches. If a previous download failed this is often helpful"	MCFileBasedRepository flushAllCaches.	config := MCMcmUpdater updateFromDefaultRepository.	config ifNil: [^self inform: 'Unable to retrieve updates from remote repository.' translated].	self setSystemVersionFromConfig: config.	self inform: ('Update completed.Current update number: ' translated, SystemVersion current highestUpdate).! !!Utilities class methodsFor: 'finding pointers' stamp: 'mtf 8/15/2008 23:54'!pointersTo: anObject except: objectsToExclude 	"Find all occurrences in the system of pointers to the argument	anObject. Remove objects in the exclusion list from the	results. "	^ anObject inboundPointersExcluding: objectsToExclude! !!Utilities class methodsFor: 'miscellaneous' stamp: 'ul 11/15/2010 12:16'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict := Dictionary new.	report := ReadWriteStream on: ''.	f := FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size = 4 or: [items size = 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f := FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size = 4 or: [items size = 5]) ifTrue:			[className := items first.			newInstCount := items third asNumber.			newSpace := items fourth asNumber.			oldPair := instCountDict at: className ifAbsent: [nil].			oldInstCount := oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace := oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'recent method submissions' stamp: 'ul 11/15/2010 12:09'!revertLastMethodSubmission	| changeRecords lastSubmission theClass theSelector |	"If the most recent method submission was a method change, revert	that change, and if it was a submission of a brand-new method, 	remove that method."	RecentSubmissions isEmptyOrNil ifTrue: [^ Beeper beep].	lastSubmission := RecentSubmissions last.	theClass := lastSubmission actualClass ifNil: [^ Beeper beep].	theSelector := lastSubmission methodSymbol.	changeRecords := theClass changeRecordsAt: theSelector.	changeRecords isEmptyOrNil ifTrue: [^ Beeper beep].	changeRecords size = 1		ifTrue:			["method has no prior version, so reverting in this case means removing"			theClass removeSelector: theSelector]		ifFalse:			[changeRecords second fileIn]."Utilities revertLastMethodSubmission"! !!Utilities class methodsFor: 'support windows' stamp: 'ul 11/23/2010 15:27'!commandKeyMappings	^ (self class firstCommentAt: #commandKeyMappings) translated"Lower-case command keys(use with Cmd key on Mac and Alt key on other platforms)a	Select allb	Browse it (selection is a class name or cursor is over a class-list or message-list)c	Copy selectiond	Do it (selection is a valid expression)e	Exchange selection with prior selectionf	Findg	Find againh	Set selection as search string for find againi	Inspect it (selection is a valid expression, or selection is over an inspect-ilst)j	Again once (do the last text-related operation again)k	Set fontl	Cancelm	Implementors of it (selection is a message selector or cursor is over a class-list or message-list)n	Senders of it (selection is a message selector or cursor is over a class-list or message-list)o	Spawn current methodp	Print it (selection is a valid expression)q	Query symbol (toggle all possible completion for a given prefix)r	Recognizers	Save (i.e. accept)t	Finds a Transcript (when cursor is over the desktop)u	Toggle alignmentv	Pastew	Delete preceding word (over text);  Close-window (over morphic desktop)x	Cut selectiony	Swap charactersz	UndoNote: for Do it, Senders of it, etc., a null selection will be expanded to a word or to the current line in an attempt to do what you want.  Also note that Senders/Implementors of it will find the outermost keyword selector in a large selection, as when you have selected a bracketed expression or an entire line.  Finally note that the same cmd-m and cmd-n (and cmd-v for versions) work in the message pane of most browsers.Upper-case command keys	(use with Shift-Cmd, or Ctrl on Mac	or Shift-Alt on other platforms; sometimes Ctrl works too)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'G	fileIn from it (a file name)H	cursor TopHome:I	Inspect via Object ExplorerJ	Again many (apply the previous text command repeatedly until the end of the text)K	Set styleL	Outdent (move selection one tab-stop left)M	Select current type-inN	References to it (selection is a class name, or cursor is over a class-list or message-list)O	Open single-message browser (in message lists)P	Make project linkR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing it (in text); show-world-menu (when issued with cursor over desktop)X	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selectionOther special keysBackspace	Backward delete characterDel			Forward delete characterShift-Bksp	Backward delete wordShift-Del	Forward delete wordEsc			Pop up the Desktop Menu\			Send top window to backCursor keysleft, right,up, down	Move cursor left, right, up or downCtrl-left		Move cursor left one wordCtrl-right	Move cursor right one wordHome		Move cursor to begin of line or begin of textEnd			Move cursor to end of line or end of textPgUp, Ctrl-up	Move cursor up one pagePgDown, Ctrl-Dn	Move cursor down one pageNote all these keys can be used together with Shift to define or enlarge the selection. You cannot however shrink that selection again, as in some other systems.Other Cmd-key combinations (not available on all platforms)Return		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)Space		Select the current word as with double clickingEnclose the selection in a kind of bracket.  Each is a toggle.	(not available on all platforms)Ctrl-(	Enclose within ( and ), or remove enclosing ( and )Ctrl-[	Enclose within [ and ], or remove enclosing [ and ]Crtl-{	Enclose within { and }, or remove enclosing { and }Ctrl-<	Enclose within < and >, or remove enclosing < and >Ctrl-'	Enclose within ' and ', or remove enclosing ' and 'Ctrl-""	Enclose within "" and "", or remove enclosing "" and ""Note also that you can double-click just inside any of the above delimiters,or at the beginning or end of a line, to select the text enclosed.Text Emphasis	(not available on all platforms)Cmd-1	type the first method argumentCmd-2	type the second method argumentCmd-3	type the third method argumentCmd-4	type the fourth method argumentCmd-5	for future useCmd-6	color, action-on-click, link to class comment, link to method, url		Brings up a menu.  To remove these properties, select		more than the active part and then use command-0.Cmd-7	boldCmd-8	italicCmd-9	narrow (same as negative kern)Cmd-0	plain text (resets all emphasis)Cmd--	underlined (toggles it)Cmd-=	struck out (toggles it)Shift-Cmd--	(aka :=) negative kern (letters 1 pixel closer)Shift-Cmd-+	positive kern (letters 1 pixel larger spread)	Docking BarCtrl-<n> opens the n-th (where n is between 0 and 7) menu if such exists, otherwise it moves the keyboard focus to the Search Bar. Currently this means:Ctrl-0	Activates Search BarCtrl-1	Squeak menuCtrl-2	Projects menuCtrl-3	Tools menuCtrl-4	Apps menuCtrl-5	Extras menuCtrl-6	Windows menuCtrl-7	Help menu	"! !!Utilities class methodsFor: 'support windows' stamp: 'spd 5/24/2010 20:23'!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 10000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.Preferences editAnnotations.Flaps reinstateDefaultFlaps. Preferences resetCategoryInfo(FileStream oldFileNamed: 'Lives of the Wolves') edit.(FileStream oldFileNamed: 'tuesdayFixes.cs') fileInChangeList browseFile: 'myChanges.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode in mvc""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspect.Utilities storeTextWindowContentsToFileNamed: 'TextWindows'Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'ScriptingSystem resetStandardPartsBin.ScheduledControllers screenController openMorphicConstructionWorld.ScheduledControllers screenController openMorphicWorld.SystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[SystemNavigation default allCallsOn: #asOop].MessageTally spyOn: [SystemNavigation default allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!Utilities class methodsFor: '*Tools' stamp: 'ul 11/15/2010 12:09'!browseRecentSubmissions	"Open up a browser on the most recent methods submitted in the image.  5/96 sw."	"Utilities browseRecentSubmissions"	| recentMessages |	self recentMethodSubmissions size = 0 ifTrue:		[^ self inform: 'There are no recent submissions'].		recentMessages := RecentSubmissions copy reversed.	RecentMessageSet 		openMessageList: recentMessages 		name: 'Recent submissions -- youngest first ' 		autoSelect: nil! !!Utilities class methodsFor: '*ToolBuilder-Kernel' stamp: 'ul 12/12/2010 23:09'!classFromPattern: pattern withCaption: aCaption	"If there is a class or trait whose name exactly given by pattern, return it.	If there is only one class or trait in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores separator characters in the pattern"	^self classOrTraitFrom: Smalltalk environment pattern: pattern label: aCaption"	self classFromPattern: 'CharRecog' withCaption: ''	self classFromPattern: 'rRecog' withCaption: ''	self classFromPattern: 'znak' withCaption: ''	self classFromPattern: 'orph' withCaption: ''	self classFromPattern: 'TCompil' withCaption: ''"! !!Utilities class methodsFor: '*ToolBuilder-Kernel' stamp: 'cmm 12/23/2010 14:16'!classOrTraitFrom: environment pattern: pattern label: label	"If there is a class or trait whose name exactly given by pattern, return it.	If there is only one class or trait in the given environment whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores separator characters in the pattern"		| toMatch potentialNames names exactMatch lines reducedIdentifiers selectedIndex |	toMatch := pattern copyWithoutAll: Character separators.	toMatch ifEmpty: [ ^nil ].	"If there's a class or trait named as pattern, then return it."	Symbol hasInterned: pattern ifTrue: [ :symbol |		environment at: symbol ifPresent: [ :maybeClassOrTrait |			((maybeClassOrTrait isKindOf: Class) or: [				maybeClassOrTrait isTrait ])					ifTrue: [ ^maybeClassOrTrait ] ] ].	"No exact match, look for potential matches."	toMatch := pattern asLowercase copyWithout: $..	potentialNames := (environment classAndTraitNames) asOrderedCollection.	names := pattern last = $. "This is some old hack, using String>>#match: may be better."		ifTrue: [ potentialNames select: [ :each | each asLowercase = toMatch ] ]		ifFalse: [			potentialNames select: [ :each |				each includesSubstring: toMatch caseSensitive: false ] ].	exactMatch := names detect: [ :each | each asLowercase = toMatch ] ifNone: [ nil ].	lines := OrderedCollection new.	exactMatch ifNotNil: [ lines add: 1 ].	"Also try some fuzzy matching."	reducedIdentifiers := pattern suggestedTypeNames select: [ :each |		potentialNames includes: each ].	reducedIdentifiers ifNotEmpty: [		names addAll: reducedIdentifiers.		lines add: 1 + names size + reducedIdentifiers size ].	"Let the user select if there's more than one possible match. This may give surprising results."	selectedIndex := names size = 1		ifTrue: [ 1 ]		ifFalse: [			exactMatch ifNotNil: [ names addFirst: exactMatch ].			UIManager default chooseFrom: names lines: lines title: label ].	selectedIndex = 0 ifTrue: [ ^nil ].	^environment at: (names at: selectedIndex) asSymbol! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForLoad: stack encoder: encoder	"Do nothing"! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41'!emitCodeForReturn: stack encoder: encoder	encoder		if: code		isSpecialLiteralForReturn:			[:specialLiteral|			"short returns"			 encoder genReturnSpecialLiteral: specialLiteral.			 stack push: 1 "doesnt seem right".			 ^self].	(self code = LdSelf or: [self code = LdSuper]) ifTrue: 		["short returns"		 encoder genReturnReceiver.		 stack push: 1 "doesnt seem right".		 ^self].	super emitCodeForReturn: stack encoder: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41'!emitCodeForStorePop: stack encoder: encoder	self type ~= 1 ifTrue:		[self halt].	encoder genStorePopInstVar: index.	stack pop: 1! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!emitCodeForValue: stack encoder: encoder	stack push: 1.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder genPushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder genPushReceiver].	code = LdThisContext ifTrue:		[^encoder genPushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder genPushInstVar: index! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:58'!sizeCodeForReturn: encoder	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizeReturnSpecialLiteral: specialLiteral].	(self code = LdSelf or: [self code = LdSuper]) ifTrue:		[^encoder sizeReturnReceiver].	^super sizeCodeForReturn: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09'!sizeCodeForStore: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09'!sizeCodeForStorePop: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:54'!sizeCodeForValue: encoder	self reserve: encoder.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral| "i.e. the pseudo-variables nil true & false"			 ^encoder sizePushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder sizePushReceiver].	code = LdThisContext ifTrue:		[^encoder sizePushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder sizePushInstVar: index! !!VariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^false! !!VariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitVariableNode: self! !!VariableNode methodsFor: 'tiles' stamp: 'nice 12/29/2010 15:11'!variableGetterBlockIn: aContext	| temps tempIndex ivars |	(self type = 4 and: [self key isVariableBinding]) ifTrue: [		^[self key value]	].	aContext ifNil: [^nil].	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].	self type = 1 ifTrue: [		ivars := aContext receiver class allInstVarNames.		tempIndex := ivars indexOf: self name ifAbsent: [^nil].		^[aContext receiver instVarAt: tempIndex]	].	self type = 2 ifTrue: [		temps := aContext tempNames.		tempIndex := temps indexOf: self name ifAbsent: [^nil].		^[aContext tempAt: tempIndex]	].	^nil! !!VariableNode class methodsFor: 'class initialization' stamp: 'ul 10/24/2010 06:33'!initialize    "VariableNode initialize.  Decompiler initialize"	| encoder |	encoder := Encoder new.	StdVariables := Dictionary new: 16.	encoder		fillDict: StdVariables		with: VariableNode		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )		to: (Array with: LdSelf with: LdThisContext with: LdSuper)				, (Array with: LdNil with: LdFalse with: LdTrue).	StdSelectors := Dictionary new: 64.	encoder		fillDict: StdSelectors		with: SelectorNode		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 							[:i | Smalltalk specialSelectorAt: i])		to: (SendPlus to: SendPlus + 31).	StdLiterals := PluggableDictionary new equalBlock: [ :x :y | x literalEqual: y ].	encoder		fillDict: StdLiterals		with: LiteralNode		mapping: #(-1 0 1 2 )		to: (LdMinus1 to: LdMinus1 + 3).	encoder initScopeAndLiteralTables.	NodeNil := encoder encodeVariable: 'nil'.	NodeTrue := encoder encodeVariable: 'true'.	NodeFalse := encoder encodeVariable: 'false'.	NodeSelf := encoder encodeVariable: 'self'.	NodeThisContext := encoder encodeVariable: 'thisContext'.	NodeSuper := encoder encodeVariable: 'super'! !!VariableScopeFinder methodsFor: 'private' stamp: 'eem 8/12/2010 16:50'!enclosingNodeFor: enumerator of: rootNode	"Answer the minimum enclosing root node for aVariabe or nil if none.	 If the variable is accessed in more than one subnode then the rootNode is the	 enclosing node, otherwise it is which ever single subnode node that includes it, if any.	 enumerator applies its argument to all relevant subnodes of rootNode."	| enclosingNodeOrNil |	enclosingNodeOrNil := nil.	enumerator value:		[:subnode|		(subnode accept: self) ifNotNil:			[:enclosingNode|			enclosingNodeOrNil := enclosingNodeOrNil										ifNil: [enclosingNode]										ifNotNil: [rootNode]]].	^enclosingNodeOrNil! !!VariableScopeFinder methodsFor: 'initialize-release' stamp: 'eem 8/12/2010 16:18'!ofVariable: aVariableNode	theVariable := aVariableNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:51'!visitAssignmentNode: anAssignmentNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then anAssignmentNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock								value: anAssignmentNode value;								value: anAssignmentNode variable]		of: anAssignmentNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBlockNode: aBlockNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one statement then aBlockNode is the	 enclosing node, otherwise it is which ever single block node that includes it, if any."	^(self enclosingNodeFor: [:aBlock| aBlockNode statements do: aBlock] of: aBlockNode) ifNotNil:		[:aNode|		aNode isBlockNode ifTrue: [aNode] ifFalse: [aBlockNode]]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBraceNode: aBraceNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aBraceNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock| aBraceNode elements do: aBlock]		of: aBraceNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/16/2010 18:02'!visitCascadeNode: aCascadeNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aCascadeNode receiver.							aCascadeNode messages do:								[:msg| msg argumentsInEvaluationOrder do: aBlock]]		of: aCascadeNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitCommentNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitFieldNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:55'!visitFutureNode: aFutureNode	^aFutureNode receiver accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitInstanceVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitLiteralNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:03'!visitLiteralVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:07'!visitMessageNode: aMessageNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aMessageNode receiver.							aMessageNode argumentsInEvaluationOrder do: aBlock]		of: aMessageNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:00'!visitMethodNode: aMethodNode	^aMethodNode block accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitNewArrayNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitRemoteTempVectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:01'!visitReturnNode: aReturnNode	^aReturnNode expr accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitSelectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitTempVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode	^theVariable name = aVariableNode name ifTrue: [theVariable]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:06'!visitVariableNode: aVariableNode	^nil! !!VariableScopeFinder commentStamp: 'eem 8/14/2010 19:45' prior: 0!A VariableScopeFinder is used to find the minimum enclosing scope of a variable in a method.  This is used when auto-declaring temporaries to find the smallest enclosing block in which to declare the temp.Instance Variables	theVariable:		<VariableNode>theVariable	- the varable whose scope is to be determined!!VersionHistory methodsFor: 'accessing' stamp: 'svp 6/26/2002 16:32'!allVersionsAfter: aVersion	"Answer all the versions based on aVersion."	| answer |	answer := Set new.	versions do: [ :ea |		((ea inSameBranchAs: aVersion) and: 			[ea > aVersion]) ifTrue: [answer add: ea]].	^answer! !!VersionHistory methodsFor: 'accessing' stamp: 'svp 6/26/2002 16:32'!allVersionsBefore: aVersion	"Answer all versions that came before aVersion"	| answer |	answer := Set new.	versions do: [ :ea |		((ea inSameBranchAs: aVersion) and: 			[ea < aVersion]) ifTrue: [answer add: ea]].	^answer! !!VersionHistory methodsFor: 'accessing' stamp: 'svp 6/26/2002 16:32'!firstVersion	"Answer the first version in the entire version history"	^versions inject: versions anyOne into: [ :x :ea |		(x inSameBranchAs: ea)			ifTrue: [(x < ea) ifTrue: [x] ifFalse: [ea]]			ifFalse: [ea]]! !!VersionHistory methodsFor: 'accessing' stamp: 'svp 6/26/2002 16:35'!mainLineStartingAt: aVersion	"Answer all versions based on aVersion that are not branches (they have 	the same number of digits with the same values, except the last value is	greater than the last value of aVersion)."	| answer tmp |	answer := OrderedCollection new.	tmp := aVersion.	[versions includes: tmp] 		whileTrue: 			[answer add: tmp.			tmp := tmp next].	^answer! !!VersionHistory methodsFor: 'accessing' stamp: 'svp 6/26/2002 16:37'!versionBefore: aVersion	"Answer the version immediately preceeding aVersion."	| tmp |	(aVersion > '1' asVersion) ifFalse: [^nil].	(versions includes: (tmp := aVersion previous)) ifFalse: [^nil].	^tmp! !!VersionHistory methodsFor: 'accessing' stamp: 'svp 6/26/2002 16:37'!versionsAfter: aVersion	"Answer all the versions immediately following aVersion."	| answer tmp |	answer := Set new.	tmp := aVersion next.	(versions includes: aVersion next) ifTrue: [answer add: tmp].	tmp := aVersion.	[versions includes: (tmp := tmp branchNext)] whileTrue:		[answer add: tmp].	^answer! !!VersionHistory methodsFor: 'adding' stamp: 'svp 6/18/2002 17:17'!addNewVersionBasedOn: aVersion	| tmp |	(versions includes: aVersion) ifFalse: [^self error: 'Version is not in this history'].	tmp := aVersion next.	(versions includes: tmp) ifFalse: 		[versions add: tmp.		^tmp].	tmp := aVersion.	[versions includes: (tmp := tmp branchNext)] whileTrue.	versions add: tmp.	^tmp	! !!VersionHistory methodsFor: 'initialization' stamp: 'svp 6/18/2002 17:15'!initializeVersionsAt: aVersion	versions := Set new.	versions add: aVersion.! !!VersionHistory methodsFor: 'printing' stamp: 'svp 6/26/2002 16:30'!treeString	"Answer a string that show the entire version history with	each branch starting on a new line"	^self treeStringStartingAt: self firstVersion! !!VersionHistory methodsFor: 'printing' stamp: 'svp 6/26/2002 16:26'!treeStringOn: strm startingAt: aVersion	| tmp |	tmp := self mainLineStartingAt: aVersion.	tmp do: [ :ea | ea versionStringOn: strm. strm space; space ].	strm cr.	tmp do: 		[ :ea | 		(versions includes: ea branchNext)			ifTrue: [self treeStringOn: strm startingAt: ea branchNext]].! !!VersionHistory methodsFor: 'printing' stamp: 'svp 6/26/2002 11:34'!treeStringStartingAt: aVersion	| strm |	strm := WriteStream on: ''.	self treeStringOn: strm startingAt: aVersion.	^strm contents! !!VersionHistory methodsFor: 'removing' stamp: 'svp 6/26/2002 16:30'!remove: aVersion	"Remove aVersion from this version history."	^self remove: aVersion ifAbsent: [self error: 'version not found'].! !!VersionHistory methodsFor: 'removing' stamp: 'svp 6/27/2002 14:08'!remove: aVersion ifAbsent: aBlock	"Remove aVersion from this version history."	(versions includes: aVersion) ifFalse: [^aBlock value].	(self canRemove: aVersion) ifFalse:		[^self error: 'Only versions at the beginning or end with no more than one follower may be removed'].	versions remove: aVersion.! !!VersionHistory methodsFor: 'removing' stamp: 'svp 6/18/2002 17:48'!removeBranch: aVersion	"Remove aVersion and all of it's successors, providing that	aVersion is not the first version."	(self versionBefore: aVersion)		ifNil: [^self error: 'version is the first version in the history'].	versions removeAll: (self allVersionsAfter: aVersion).	versions remove: aVersion.! !!VersionHistory methodsFor: 'removing' stamp: 'nice 5/8/2011 12:18'!removeTrunk: aVersion	"Remove aVersion and all of it's predecessors, providing there	are no other branches stemming from the trunk.  Note, a trunk is defined	as all versions, starting with the first version, that have only one successor."	| tmp |	(self versionsAfter: aVersion) size > 1 		ifTrue: [^self error: 'version is at a fork'].	tmp := self allVersionsBefore: aVersion.	(tmp anySatisfy: [ :ea | (self versionsAfter: ea) size > 1 ])		ifTrue: [^self error: 'not a trunk, other branches detected'].	versions removeAll: tmp.	versions remove: aVersion.! !!VersionHistory methodsFor: 'testing' stamp: 'svp 6/27/2002 14:09'!canRemove: aVersion	| hasPriors followers |	(versions includes: aVersion) ifFalse: [^false].	hasPriors := (self versionBefore: aVersion) notNil.	followers := self versionsAfter: aVersion.			"Don't allow versions in the middle to be extracted"	(hasPriors and: [followers size > 0]) ifTrue: [^false].		"Don't allow versions with more than one follower to be extracted"	(hasPriors not and: [followers size > 1]) ifTrue: [^false].	^true! !!VersionHistory methodsFor: 'testing' stamp: 'svp 6/18/2002 16:43'!includesVersion: aVersion	^versions includes: aVersion! !!VersionHistory class methodsFor: 'as yet unclassified' stamp: 'svp 6/26/2002 16:20'!startingAt1	^self startingAt: '1' asVersion! !!VersionHistory class methodsFor: 'as yet unclassified' stamp: 'svp 6/18/2002 17:14'!startingAt: aVersion	^self new		initializeVersionsAt: aVersion;		yourself! !!VersionNumber methodsFor: 'accessing' stamp: 'svp 6/18/2002 12:22'!branchNext	^self class fromCollection: (numbers, (Array with: 1))! !!VersionNumber methodsFor: 'accessing' stamp: 'svp 6/18/2002 14:50'!commonBase: aVersion	| smallNums largeNums cutoff |	(aVersion numbers size <= numbers size) 		ifTrue: [smallNums := aVersion numbers. largeNums := numbers] 		ifFalse: [smallNums := numbers. largeNums := aVersion numbers].	cutoff := (1 to: smallNums size) 		detect: [ :in | ((smallNums at: in) ~= (largeNums at: in))] 		ifNone: [^self class fromCollection: smallNums].	^self class fromCollection: 		((numbers copyFrom: 1 to: (cutoff - 1)), 		(Array with: ((smallNums at: cutoff) min: (largeNums at: cutoff))))! !!VersionNumber methodsFor: 'accessing' stamp: 'svp 6/18/2002 12:14'!next	| tmp |	tmp := numbers copy.	tmp at: numbers size put: (numbers last + 1).	^self class fromCollection: tmp! !!VersionNumber methodsFor: 'accessing' stamp: 'svp 6/18/2002 14:51'!numbers	"Answer a copy (to discourage people from directly changing a version number).	VersionNumbers should never change, instead, instantiate a new instance."	^numbers copy! !!VersionNumber methodsFor: 'accessing' stamp: 'svp 6/18/2002 16:51'!previous	| tmp |	numbers last = 1 ifTrue: 		[^self class fromCollection: (numbers allButLast)].	tmp := numbers copy.	tmp at: numbers size put: (numbers last - 1).	^self class fromCollection: tmp! !!VersionNumber methodsFor: 'comparing' stamp: 'svp 6/18/2002 15:05'!< another 	"Answer whether the receiver is less than the argument."	| tmp |	(self inSameBranchAs: another) ifFalse: 		[^self error: 'Receiver and argument in different branches'].	tmp := another numbers.	(tmp size = numbers size) ifTrue:		[1 to: numbers size do: 			[ :in | (numbers at: in) < (tmp at: in) ifTrue: [^true]].		^false].	^numbers size < tmp size! !!VersionNumber methodsFor: 'comparing' stamp: 'svp 6/18/2002 15:10'!= aVersion	^numbers = aVersion numbers! !!VersionNumber methodsFor: 'comparing' stamp: 'svp 6/18/2002 12:23'!hash	^numbers hash! !!VersionNumber methodsFor: 'initialization' stamp: 'svp 6/18/2002 15:08'!initializeNumbers: aCollection	aCollection do: [ :ea | 		ea <= 0 ifTrue: 			[^self error: 'VersionNumbers cannot contain zero or negative numbers']].	numbers := aCollection asArray! !!VersionNumber methodsFor: 'printing' stamp: 'svp 6/18/2002 12:27'!printOn: strm	self storeOn: strm! !!VersionNumber methodsFor: 'printing' stamp: 'svp 6/18/2002 17:24'!storeOn: strm	strm nextPut: $'.	self versionStringOn: strm.	strm nextPutAll: ''' asVersion'.! !!VersionNumber methodsFor: 'testing' stamp: 'svp 6/18/2002 14:57'!inSameBranchAs: aVersion	| less more |	(aVersion numbers size <= numbers size) 		ifTrue: [less := aVersion numbers. more := numbers] 		ifFalse: [less := numbers. more := aVersion numbers].	1 to: (less size - 1) do: [ :in | ((less at: in) = (more at: in)) ifFalse: [^false]].	^less size = more size or:		[(less at: less size) <= (more at: less size)]! !!VersionNumber class methodsFor: 'as yet unclassified' stamp: 'svp 6/18/2002 16:34'!first	^self fromCollection: #(1)! !!VersionNumber class methodsFor: 'as yet unclassified' stamp: 'svp 6/18/2002 12:21'!fromCollection: aCollection	^self new		initializeNumbers: aCollection;		yourself! !!VersionNumber class methodsFor: 'as yet unclassified' stamp: 'svp 6/18/2002 12:20'!fromString: aString	^self fromCollection: 		((aString findTokens: '.') collect: [:ea | ea asNumber ])	! !!VersionsBrowser methodsFor: 'init & update' stamp: 'bf 10/11/2011 16:07'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp cat |	selectorOfMethod := selector.	currentCompiledMethod := method.	classOfMethod := meta ifTrue: [class class] ifFalse: [class].	cat := category ifNil: [''].	changeList := OrderedCollection new.	list := OrderedCollection new.	self addedChangeRecord ifNotNil: [ :change |		self addItem: change text: ('{1} (in {2})' translated format: { change stamp. change fileName }) ].	listIndex := 0.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size - 5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size - 3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size - 2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size - 2.						prevFileIndex := tokens last].				cat := tokens at: tokens size - 4.				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size - 3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size - 1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size].				cat := tokens at: tokens size - 2]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: cat meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector, ' {', cat, '}'.		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections := Array new: list size withAll: false! !!VersionsBrowser methodsFor: 'misc' stamp: 'ul 11/15/2010 12:10'!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"Add an annotation detailing the prior versions count.  Specially handled here for the case of a selector no longer in the system, whose prior versions are seen in a versions browser -- in this case, the inherited version of this method will not work."	(aClass includesSelector: aSelector) ifTrue:		[^ super addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream].	aStream nextPutAll: 		((changeList size > 0			ifTrue:				[changeList size = 1					ifTrue:						['Deleted - one prior version']					ifFalse:						['Deleted - ', changeList size printString, ' prior versions']]			ifFalse:				['surprisingly, no prior versions']), self annotationSeparator)! !!View methodsFor: 'subView access' stamp: 'ul 8/2/2011 20:13'!subViewSatisfying: aBlock	"Return the first subview that satisfies aBlock, or nil if none does.  1/31/96 sw"	^subViews detect: aBlock ifNone: [ nil ]! !!ViewerLine methodsFor: 'slot' stamp: 'nice 12/29/2010 15:02'!addGetterFeedback	"Add feedback during mouseover of a getter"	| aMorph endMorph |	endMorph :=		(#(touchesA: #seesColor: #overlaps:) includes: self elementSymbol)			ifTrue:				[submorphs eighth]			ifFalse:				[submorphs sixth].	aMorph := RectangleMorph new useRoundedCorners bounds: ((submorphs fourth topLeft - (2 @ -1)) corner: (endMorph bottomRight + (2 @ -1))).	aMorph beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.355 b: 0.839); lock.	aMorph setProperty: #highlight toValue: true.	ActiveWorld addMorphFront: aMorph"Color fromUser (Color r: 1.0 g: 0.355 b: 0.839)"! !!ViewerLine methodsFor: 'slot' stamp: 'sw 6/4/2003 02:36'!removeGetterFeedback	"Remove any existing getter feedback.  Backward-compatibility only"	self removeHighlightFeedback! !!ViewerLine methodsFor: 'slot' stamp: 'sw 6/4/2003 02:30'!removeHighlightFeedback	"Remove any existing highlight feedback"	(ActiveWorld submorphs select: [:m | m hasProperty: #highlight]) do:		[:m | m delete]! !!ViewerLine methodsFor: 'slot' stamp: 'sw 6/4/2003 02:37'!removeSetterFeedback	"Remove any existing setter feedback"	self removeHighlightFeedback  "backward compatibility with previously-launched viewer panes only"! !!VileFinalizer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 10/11/2010 13:29'!finalize	weakRegistry remove: self ifAbsent: [].! !!VileFinalizer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 10/11/2010 13:36'!initialize: wr	weakRegistry := wr.	weakRegistry add: self.! !!Vocabulary methodsFor: 'queries' stamp: 'ul 8/2/2011 20:13'!methodInterfaceAt: aSelector ifAbsent: aBlock	"Answer the vocabulary's method interface for the given selector; if absent, return the result of evaluating aBlock"	^methodInterfaces at: aSelector ifAbsent: aBlock! !!Vocabulary class methodsFor: 'class initialization' stamp: 'sw 3/11/2003 12:36'!initializeSilently	"Initialize a few standard vocabularies and place them in the AllVocabularies list."	self initializeStandardVocabularies.	self embraceAddedTypeVocabularies.	"Vocabulary initializeSilently"! !!WarpBlt methodsFor: 'setup' stamp: 'nice 2/1/2011 02:38'!cellSize: s	"Set the number of samples used for averaging"	cellSize := s.	cellSize = 1 ifTrue: [^ self].	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the	destination depth. Note that we need to install the 32->32 color map explicitly because	the VM will substitute a colorMap derived from sourceForm->destForm mapping which	is just plain wrong for <32 source and 32bit dest depth"	(destForm depth = 32 and: [sourceForm notNil and: [sourceForm depth < 32]])		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]		ifFalse:[colorMap := Color colorMapIfNeededFrom: 32 to: destForm depth].! !!WarpBlt methodsFor: 'smoothing' stamp: 'ul 11/2/2010 03:04'!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"NOTE: This code is copied verbatim from BitBltSimulation so that it	may be removed from the system"	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	<inline: true>	(d := nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask := (1 << nBitsIn) - 1.  "Transfer mask"			srcPix := sourcePixel << d.			mask := mask << d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d := nBitsIn - nBitsOut.			mask := (1 << nBitsOut) - 1.  "Transfer mask"			srcPix := sourcePixel >> d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix >> d.			destPix := destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !!WaveEditor methodsFor: 'other' stamp: 'nice 8/19/2010 21:27'!findPossibleLoopStartsFrom: index 	"Assume loopEnd is one sample before a zero-crossing."	| r postLoopCycleStart i postLoopCycleLength cycleLength cycleCount err oldI |	r := OrderedCollection new.	"Record the start and length of the first cycle after the loop endpoint."	postLoopCycleStart := loopEnd + 1.	"Assumed to be a zero-crossing."	i := self zeroCrossingAfter: postLoopCycleStart 						+ (0.9 * samplingRate / perceivedFrequency) asInteger.	postLoopCycleLength := i - loopEnd - 1.	"Step backwards one cycle at a time, using zero-crossings to find the	 beginning of each cycle, and record the auto-corrolation error between	 each cycle and the cycle following the loop endpoint. Assume pitch may shift gradually."	i := self zeroCrossingAfter: postLoopCycleStart 						- (1.1 * postLoopCycleLength) asInteger.	cycleLength := postLoopCycleStart - i.	cycleCount := 1.	[cycleLength > 0] whileTrue: 			[err := self 						autoCorrolationBetween: i						and: postLoopCycleStart						length: postLoopCycleLength.			r add: (Array 						with: i						with: err						with: cycleCount						with: ((loopEnd - i) asFloat / self samplingRate roundTo: 0.01)).			oldI := i.			i := self zeroCrossingAfter: oldI - (1.1 * cycleLength) asInteger.			cycleLength := oldI - i.	"will be zero when start of data is encountered"			cycleCount := cycleCount + 1].	^r asArray sort: [:e1 :e2 | e1 second < e2 second]! !!WeakActionSequence methodsFor: 'converting' stamp: 'jmv 5/13/2009 10:20'!asMinimalRepresentation	| valid |	valid := self reject: [:e | e isReceiverOrAnyArgumentGarbage ].	valid size = 0		ifTrue: [ ^nil ].	valid size = 1		ifTrue: [ ^valid first ].	^valid! !!WeakActionSequence methodsFor: 'evaluating' stamp: 'nice 8/22/2010 21:05'!value	"Answer the result of evaluating the elements of the receiver.	Actually, return just the last result."	^self inject: nil into: [ :previousAnswer :each | 		each valueOtherwise: [ previousAnswer ]].! !!WeakActionSequence methodsFor: 'evaluating' stamp: 'nice 8/22/2010 21:02'!valueWithArguments: anArray	"Return the last result"	^self inject: nil into: [ :previousAnswer :each |		each valueWithArguments: anArray otherwise: [ previousAnswer ]]! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'nice 8/22/2010 17:47'!valueStartingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Error so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Error."	| each answer |	answer := nil.	startIndex to: self size do: [:index |		each := self at: index.		[			answer := each valueOtherwise: [ answer ].		]			on: Halt , Error			do: [:exc | 				self valueStartingFrom: index + 1.				exc pass]].	^ answer! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'nice 8/22/2010 17:48'!valueWithArguments: anArray startingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Error so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Error."	| each answer |	answer := nil.	startIndex to: self size do: [:index |		each := self at: index.		[			answer := each valueWithArguments: anArray otherwise: [ answer ].		]			on: Halt , Error			do: [:exc | 				self valueWithArguments: anArray startingFrom: index + 1.				exc pass]].	^ answer! !!WeakArray commentStamp: '<historical>' prior: 0!WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.!!WeakArray class methodsFor: 'accessing' stamp: 'ul 8/27/2010 23:38'!addWeakDependent: anObject	FinalizationLock		critical: [			| emptySlotIndex |			emptySlotIndex := FinalizationDependents 				identityIndexOf: nil				ifAbsent: [ 					| newIndex |					newIndex := FinalizationDependents size + 1.					"Grow linearly"					FinalizationDependents := FinalizationDependents grownBy: 10.					newIndex ].			FinalizationDependents at: emptySlotIndex put: anObject ]		ifError: [ :msg :rcvr | rcvr error: msg ]! !!WeakArray class methodsFor: 'accessing' stamp: 'ul 8/27/2010 23:28'!isFinalizationSupported	"This method is only here for backwards compatibility, all closure VMs support finalization"		^true! !!WeakArray class methodsFor: 'accessing' stamp: 'ul 8/27/2010 23:25'!removeWeakDependent: anObject	FinalizationLock critical:[		1 to: FinalizationDependents size do:[:i|			((FinalizationDependents at: i) == anObject) ifTrue:[				FinalizationDependents at: i put: nil.			].		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'private' stamp: 'ul 6/17/2011 12:48'!finalizationProcess	[ WeakFinalizationList initTestPair.	FinalizationSemaphore wait.	FinalizationLock critical:		[		WeakFinalizationList checkTestPair.		FinalizationDependents do:			[:weakDependent |			weakDependent ifNotNil:				[weakDependent finalizeValues]]]		ifError:		[:msg :rcvr | rcvr error: msg] ] repeat! !!WeakArray class methodsFor: 'private' stamp: 'ul 8/27/2010 23:26'!restartFinalizationProcess	"kill any old process, just in case"	FinalizationProcess		ifNotNil: [FinalizationProcess terminate.			FinalizationProcess := nil].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess]		forkAt: Processor userInterruptPriority! !!WeakFinalizationList methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!first	^ first! !!WeakFinalizationList methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!swapWithNil	| head |	head := first.	first := nil.	^ head! !!WeakFinalizationList commentStamp: 'Igor.Stasenko 9/22/2010 21:09' prior: 0!IMPORTANT!!!!!!This class is a special object, recognized by VM.Its only purpose is to a) identify a special kind of objects who usually having a weak references but  also having an instance of me held by first non-weak fixed slot (instance variable).b) a 'first' instance variable points to the head of a list of items, reported by VM which has weak references which became garbage during last garbage collectionAt my class side, there are some public behavior, which is used by finalization process to detect if VM supports new finalization scheme or should use the old one.Weak registry using #hasNewFinalization for switching to correct finalization logic,depending on VM it currently runs on.!!WeakFinalizationList class methodsFor: 'vm capability test' stamp: 'Igor.Stasenko 9/22/2010 20:19'!checkTestPair	HasNewFinalization := TestList swapWithNil notNil.! !!WeakFinalizationList class methodsFor: 'vm capability test' stamp: 'Igor.Stasenko 9/22/2010 20:18'!hasNewFinalization	^ HasNewFinalization == true! !!WeakFinalizationList class methodsFor: 'vm capability test' stamp: 'Igor.Stasenko 9/22/2010 20:18'!initTestPair	TestItem := WeakFinalizerItem new list: TestList object: Object new.! !!WeakFinalizationList class methodsFor: 'class initialization' stamp: 'Igor.Stasenko 9/22/2010 20:17'!initialize	TestList := self new.! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!add: newExecutor	executor 		ifNil: [ executor := newExecutor ]		ifNotNil: [			executor hasMultipleExecutors				ifTrue: [ executor add: newExecutor]				ifFalse: [ executor := ObjectFinalizerCollection with: executor with: newExecutor ]		]! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!clear	list := next := nil.! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!executor	^ executor! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!list	^ list! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!list: aList	list := aList! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!next	^ next! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!object	^ self at: 1! !!WeakFinalizerItem methodsFor: 'copying' stamp: 'Igor.Stasenko 9/22/2010 21:06'!copyWithList: aList	^ self copy list: aList! !!WeakFinalizerItem methodsFor: 'copying' stamp: 'Igor.Stasenko 10/11/2010 15:06'!postCopy	executor hasMultipleExecutors ifTrue: [ executor := executor copy ].! !!WeakFinalizerItem methodsFor: 'finalizing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!finalizeValues	" cleanup the receiver, so it could be reused "	| ex |	ex := executor.	executor := nil.	next := nil.	ex finalize.! !!WeakFinalizerItem methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/22/2010 21:06'!list: weakFinalizationList object: anObject	self assert: (weakFinalizationList class == WeakFinalizationList).	list := weakFinalizationList.	self at: 1 put: anObject.! !!WeakFinalizerItem methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/22/2010 21:06'!list: weakFinalizationList object: anObject executor: anExecutor	self assert: (weakFinalizationList class == WeakFinalizationList).	list := weakFinalizationList.	self at: 1 put: anObject.	executor := anExecutor! !!WeakFinalizerItem commentStamp: 'Igor.Stasenko 9/22/2010 20:59' prior: 0!My instances is used by weak registry to hold a single weak referenceand executor(s).Once object, referenced weakly by my instance become garbage, a weak registry triggers its executionby sending #finalizeValues to my instance.Note, that a new VM finalization scheme does not implies to use this particular classin order to implement finalization scheme. VM refers only to WeakFinalizationList class. In this way, my class and its implementation can serve as an example for implementing various finalization actions, which may differ from this one, provided by default for use by weak registry.Once initialized, my instance should: - point to particular list (an instance of WeakFinalizationList), - next should be nil - executor or multiple executors initialized - weak reference slot should point to some object of interestAt the moment, when object, referenced weakly, become garbage, VM checks if its fist instance variable is an instance of WeakFinalizationList.If it so, then it adds a given object to this list, and also links the tail of list through 'next' instance variable. So, as a result of garbage collection, a list will contain all objects, which had weak references to garbage collected objects. It is a responsibility of application to manage the instances of WeakFinalizationList's , as well as clear this list before the next garbage collection.As a consequence of that you can: - use multiple different lists and manage them differently in order to react differently when some objects became garbage - you are not obliged to handle/clear the list(s) immediately after GC. You can clean up them periodically. - you can implement own kind of weak referencing object(s), which could use same finalization, provided by newer VMs.VM requires only that an object with weak reference having at least two instance variables,and its first instance variable points to instance of WeakFinalizationList. Everything else is optional.!!WeakFinalizerItem class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 3/8/2010 21:00'!new	^ self basicNew: 1! !!WeakFinalizersTest methodsFor: 'as yet unclassified' stamp: 'ul 11/2/2010 18:29'!expectedFailures	^WeakFinalizationList hasNewFinalization		ifTrue: [ #() ]		ifFalse: [ #(testNewFinalizationSupported) ]! !!WeakFinalizersTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 3/8/2010 22:15'!testNewFinalizationSupported	| list item |	list := WeakFinalizationList new.			item := WeakFinalizerItem new list: list object: Object new executor: nil.		self assert: (list first isNil).	self assert: (item object notNil).		Smalltalk garbageCollect.		self assert: (item object isNil).	self assert: (list first == item).	self assert: (list first next == nil).! !!WeakIdentityKeyDictionaryTest methodsFor: 'tests' stamp: 'ul 6/12/2010 21:14'!testFinalizeValuesWhenLastChainContinuesAtFront	| objectWithHashModulo dictionary capacity a b c |	objectWithHashModulo := [ :requestedHash :modulo |		| object |		[ 			object := Object new.			object hash \\ modulo = requestedHash ] whileFalse.		object ].	dictionary := self classToBeTested new.	capacity := dictionary capacity.	a := objectWithHashModulo value: capacity - 2 value: capacity.	dictionary at: a put: 1.	b := objectWithHashModulo value: capacity - 1 value: capacity.	dictionary at: b put: 2.	c := objectWithHashModulo value: capacity - 2 value: capacity.	dictionary at: c put: 3.	self assert: dictionary capacity = capacity.	self assert: (dictionary array at: capacity - 1) key == a.	self assert: (dictionary array at: capacity) key == b.	self assert: (dictionary array at: 1) key == c.	a := nil.	Smalltalk garbageCollect.	dictionary finalizeValues.	self assert: (dictionary includesKey: b).	self assert: (dictionary includesKey: c).	self assert: dictionary slowSize = 2.! !!WeakIdentityKeyDictionaryTest methodsFor: 'coverage' stamp: 'ul 6/12/2010 21:14'!classToBeTested 	^WeakIdentityKeyDictionary! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 6/12/2010 18:38'!finalizeValues	"Remove and finalize all elements which have nil key"		|  cleanUpAfterRemove |	tally = 0 ifTrue: [ ^self ].	cleanUpAfterRemove := false.	1 to: array size do: [ :index |		(array at: index) 			ifNil: [ cleanUpAfterRemove := false ]			ifNotNil: [ :element |				element key					ifNil: [						finalizer ifNotNil: [ finalizer value: element value ].						array at: index put: nil.						tally := tally - 1.						cleanUpAfterRemove := true ]					ifNotNil: [ :key |						cleanUpAfterRemove ifTrue: [							| newIndex |							(newIndex := self scanFor: key) = index ifFalse: [								array 									at: newIndex put: element;									at: index put: nil ] ] ] ] ].	cleanUpAfterRemove ifTrue: [ "Continue rehashing at the front of array"		self fixCollisionsFrom: array size ]					! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!WeakMessageSend methodsFor: 'converting' stamp: 'jmv 5/13/2009 10:19'!asMinimalRepresentation	^self isReceiverOrAnyArgumentGarbage		ifTrue: [ nil ]		ifFalse: [ self ]! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:21'!value	^self valueOtherwise: []! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'ul 8/2/2011 20:14'!valueOtherwise: aBlock	^ arguments		ifNil: [			self withEnsuredReceiverDo: [ :r | r perform: selector ] otherwise: aBlock ]		ifNotNil: [			self				withEnsuredReceiverAndArgumentsDo: [ :r :a |					r						perform: selector						withArguments: a ]				otherwise: aBlock ]! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:21'!valueWithArguments: anArray	^ self valueWithArguments: anArray otherwise: []! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'ul 8/2/2011 20:14'!valueWithArguments: anArray otherwise: aBlock	| argsToUse |		"Safe to use, because they are built before ensureing receiver and args..."	argsToUse := self collectArguments: anArray.	^ self		withEnsuredReceiverAndArgumentsDo: [ :r :a |			r				perform: selector				withArguments: argsToUse ]		otherwise: aBlock! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nice 8/22/2010 21:36'!valueWithEnoughArguments: anArray	"call the selector with enough arguments from arguments and anArray"	^self		withEnsuredReceiverAndArgumentsDo: [ :r :a |			r				perform: selector				withArguments: a ]		withEnoughArguments: anArray		otherwise: [ ]! !!WeakMessageSend methodsFor: 'private' stamp: 'jmv 5/14/2009 10:03'!withEnsuredReceiverAndArgumentsDo: aBlock otherwise: altBlock	"Grab real references to receiver and arguments. If they still exist, evaluate aBlock."	"Return if my receiver has gone away"	| r a |	r := self receiver.	r ifNil: [ ^altBlock value ].		"Make sure that my arguments haven't gone away"	a := Array withAll: arguments.	a with: shouldBeNil do: [ :arg :flag |		arg ifNil: [ flag ifFalse: [ ^altBlock value ]]	].	^aBlock value: r value: a! !!WeakMessageSend methodsFor: 'private' stamp: 'nice 8/22/2010 21:37'!withEnsuredReceiverAndArgumentsDo: aBlock withEnoughArguments: anArray otherwise: altBlock	"call the selector with enough arguments from arguments and anArray"	| r selfArgs enoughArgs |	r := self receiver.	r ifNil: [ ^altBlock value ].		selfArgs := self arguments.	selfArgs with: shouldBeNil do: [ :arg :flag |		arg ifNil: [ flag ifFalse: [ ^altBlock value ]]	].	enoughArgs := Array new: selector numArgs.	enoughArgs replaceFrom: 1		to: ( selfArgs size min: enoughArgs size)		with: selfArgs		startingAt: 1.	enoughArgs size > selfArgs size ifTrue: [		enoughArgs replaceFrom: selfArgs size + 1			to: (selfArgs size + anArray size min: enoughArgs size)			with: anArray			startingAt: 1.	].	^aBlock value: r value: enoughArgs! !!WeakMessageSend methodsFor: 'private' stamp: 'nice 8/22/2010 17:27'!withEnsuredReceiverDo: aBlock otherwise: altBlock	"Grab a real reference to receive. If still there, evaluate aBlock.	Use altBlock if my receiver has gone away."	^self receiver		ifNil: [ altBlock value ]		ifNotNil: [:r | aBlock value: r ]! !!WeakOrderedCollection class methodsFor: 'as yet unclassified' stamp: 'cmm 10/25/2010 22:27'!arrayType	^ WeakArray! !!WeakRegistry methodsFor: 'adding' stamp: 'Igor.Stasenko 3/8/2010 21:03'!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."		^self add: anObject executor: anObject executor! !!WeakRegistry methodsFor: 'adding' stamp: 'Igor.Stasenko 5/25/2010 05:30'!add: anObject executor: anExecutor	self protected: [ | finItem |		finItem := valueDictionary at: anObject ifAbsentPut: [			WeakFinalizerItem new list: list object: anObject ].		finItem add: anExecutor ].	^ anObject! !!WeakRegistry methodsFor: 'enumerating' stamp: 'Igor.Stasenko 5/25/2010 05:11'!do: aBlock	^self protected: [		valueDictionary keysDo: aBlock.	].! !!WeakRegistry methodsFor: 'finalization' stamp: 'ul 10/31/2010 22:05'!finalizeValues	"Finalize any values, which happen to stocked in our list, due to some weak references become garbage"		| finalizer |	WeakFinalizationList hasNewFinalization ifFalse: [		self protected: [			valueDictionary finalizeValues.			finalizer := executors.			executors := nil ].		finalizer ifNotNil: [			finalizer do: [ :each | each finalizeValues ] ].		^ self ].	finalizer :=  self protected: [ list swapWithNil ].	"We don't need to protect a following loop from concurrent access,	because at the moment we're finalizing values, 	only we can access this list of finalizers, because valueDictionary already see them	as an unused slots, because they're associated with key == nil"		[ finalizer notNil ] whileTrue: [		| next |		next := finalizer next.		finalizer finalizeValues.		finalizer := next ].! !!WeakRegistry methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/28/2010 05:12'!initialize	valueDictionary := WeakIdentityKeyDictionary new.	list := WeakFinalizationList new.	sema := Semaphore forMutualExclusion.	self installFinalizer.! !!WeakRegistry methodsFor: 'initialize-release' stamp: 'ul 10/31/2010 21:59'!installFinalizer	valueDictionary finalizer: [ :executor |		WeakFinalizationList hasNewFinalization 			ifTrue: [ executor finalizeValues ]			ifFalse: [ 				(executors ifNil: [ executors := OrderedCollection new ]) add: executor ] ]! !!WeakRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 10/11/2010 15:11'!keys	^self protected: [ valueDictionary keys ]! !!WeakRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/25/2010 05:48'!size	^ self protected: [valueDictionary slowSize]! !!WeakRegistry methodsFor: 'copying' stamp: 'Igor.Stasenko 5/28/2010 05:16'!postCopy	"should we prohibit any attempts to copy receiver?"	self protected: [ | oldDict |		sema := Semaphore forMutualExclusion.		oldDict := valueDictionary.		list := WeakFinalizationList new.		valueDictionary := WeakIdentityKeyDictionary new.		self installFinalizer.			oldDict keysAndValuesDo: [:key :value |			valueDictionary at: key put: (value copyWithList: list)		].	]! !!WeakRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:13'!printElementsOn: aStream	sema ifNil: [^super printElementsOn: aStream].	aStream nextPutAll: '(<this WeakRegistry is locked>)'! !!WeakRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:21'!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."		oldObject ifNil: [ ^nil ].	^(self protected: [ valueDictionary removeKey: oldObject ifAbsent: nil ])		ifNil: [ exceptionBlock value ]! !!WeakRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:16'!removeAll	"See super"		self protected:[		valueDictionary removeAll.	].! !!WeakRegistry methodsFor: 'private' stamp: 'Igor.Stasenko 5/25/2010 05:34'!protected: aBlock	"Execute aBlock protected by the accessLock"	^ sema		critical: aBlock		ifError: [ :msg :rcvr |		rcvr error: msg ] ! !!WeakRegistry methodsFor: 'private' stamp: 'Igor.Stasenko 5/25/2010 05:35'!species	^Set! !!WeakRegistry commentStamp: 'ul 9/26/2010 02:51' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.This kind of WeakRegistry is using a new VM feature, which allows a more robust finalization support. In contrast to the old implementation, it doesn't spend linear time checking which elements became garbage.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakRegistry class methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:22'!default	^Default ifNil:[Default := self new]! !!WeakRegistry class methodsFor: 'migrating registry' stamp: 'ul 9/26/2010 02:47'!migrateOldRegistries	Smalltalk at: #WeakFinalizationRegistry ifAbsent: [ ^ self "already done" ].		Smalltalk recreateSpecialObjectsArray.	WeakArray restartFinalizationProcess.		Smalltalk garbageCollect; garbageCollect.		"leave no chance to interrupt migration"		Compiler evaluate: '	[ | old new oldClass newClass |		old := OrderedCollection new.		new := OrderedCollection new.		WeakRegistry allInstancesDo: [:registry | | newr |			old add: registry.			newr := WeakFinalizationRegistry basicNew initialize.			registry migrateTo: newr.			new add: newr ].		old asArray elementsForwardIdentityTo: new asArray.				oldClass := WeakRegistry.		newClass := WeakFinalizationRegistry.				Smalltalk forgetClass: newClass logged: false.		newClass superclass removeSubclass: newClass.		newClass setName: #WeakRegistry.		oldClass becomeForward: newClass.	] forkAt: Processor highestPriority.	'.! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 3/8/2010 21:47'!new	| registry |	registry := super new.	WeakArray addWeakDependent: registry.	^registry! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/25/2010 05:31'!new: n	^ self new! !!WeakRegistryTest methodsFor: 'tests' stamp: 'Igor.Stasenko 10/11/2010 13:32'!testVileFinalizer	" this test checks that manipulation (or accessing) weak registry 	does not leads to deadlock, when performed from within #finalize implementation"		| reg villian proc locked |		reg := WeakRegistry new.	WeakArray removeWeakDependent: reg.  "to prevent test interference with finalization process"		villian := VileFinalizer new initialize: reg.  "add object with vile finalization to registry"		locked := true. "be pessimistic"	proc := [ reg finalizeValues. locked := false ] newProcess.	villian := nil.		Smalltalk garbageCollect.		proc resume.	100 milliSeconds asDelay wait. "give chance for created process to run "		proc isTerminated ifFalse: [ proc terminate ].	self assert: locked == false.! !!WeakSet methodsFor: 'public' stamp: 'ul 9/12/2010 03:37'!do: aBlock after: anElement	| index endIndex |	tally = 0 ifTrue: [ ^self ].	anElement		ifNil: [ index := 0 ]		ifNotNil: [ 			index := self scanFor: anElement.			(array at: index) == flag ifTrue: [				index := 0 ] ].	endIndex := array size.	[ (index := index + 1) <= endIndex ] whileTrue: [		(array at: index) ifNotNil: [ :object |			object == flag ifFalse: [				aBlock value: object enclosedSetElement] ] ]! !!WeakSet methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!WeakSet methodsFor: 'testing' stamp: 'ul 2/12/2011 01:08'!includes: anObject 		(array at: (self scanFor: anObject))		ifNil: [ ^false ]		ifNotNil: [ :object | ^object ~~ flag ]! !!WeakSetTest methodsFor: 'tests' stamp: 'ul 5/3/2010 20:13'!testDoAfter	| input weakSet array |	input := (1 to: 11) collect: [ :each | each asString asSymbol ]. "Some symbols might be garbage collected without this variable"	weakSet := WeakSet withAll: input.	array := weakSet asArray. "Assume that the elements will have the same order as the internal array of the weakset"	0 to: array size do: [ :index |		| element result |		element := array at: index ifAbsent: nil.		result := Array new: weakSet size - index streamContents: [ :stream |			weakSet				do: [ :each | stream nextPut: each ]				after: element ].		self assert: result sort = (array allButFirst: index) sort ]! !!WeakSetTest methodsFor: 'tests' stamp: 'ul 11/20/2009 22:53'!testIncludes	| weakSet transientFakeNilObject |	weakSet := WeakSet new.	#(true nil 1) do: [ :each |		self deny: (weakSet includes: each) ].	weakSet add: true.	self assert: (weakSet includes: true).	weakSet remove: true.	self deny: (weakSet includes: true).	transientFakeNilObject := ((1 to: 1000) detect: [ :each | each asString hash - nil hash \\ weakSet capacity = 0 ]) asString. "this string will occupy the same slot as nil would"	weakSet add: transientFakeNilObject.	transientFakeNilObject := transientFakeNilObject copy.	Smalltalk garbageCollect. "get rid of transientFakeNilObject"	self deny: (weakSet includes: transientFakeNilObject).	self deny: (weakSet includes: nil)			! !!WeakSetTest methodsFor: 'testing' stamp: 'nice 5/7/2009 01:06'!testAddIncludesSizeReclaim	| ws o2 o3 |	o2 := 1/2.	o3 := '123' copy.	ws := WeakSet new.	ws add: o2.	ws add: o3.	self assert: ws size = 2.	self assert: (ws includes: o2).	self assert: (ws includes: o3).		"inclusion test does use equality, not identity"	self assert: (ws includes: o3 copy) description: 'WeakSet are not WeakIdentitySet'.		"only one copy is added"	ws add: o3 copy.	self assert: ws size = 2.		"reclame objects so that slots of ws are nilled out"	o2 := o3 := nil.	Smalltalk garbageCollect.	self deny: (ws includes: 1/2).	self deny: (ws includes: '123' copy).		"fast #size is not updated automatically by dead object reclamation	But there is a slowSize trying to tell the truth"	self assert: ws slowSize = 0.! !!WeakSetTest methodsFor: 'testing' stamp: 'ul 11/15/2010 12:15'!testCollisions	| ws o1 o2 o5 on remember forget |	"create a weak set"	ws := WeakSet new: 15.		"select some fractions wanting same place in ws array"	o1 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 1].	o2 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 2].	o5 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 5].	on := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = (ws array size - 1)].		"Add some fractions to the weak set, and remember a pointer for a few of them"	remember := OrderedCollection new.	forget := OrderedCollection new.	ws add: (remember add: 1 / o1 first).	ws add: (forget add: 1 / on second).	ws add: (forget add: 1 / o1 second).	ws add: (forget add: 1 / o5 second).	ws add: (forget add: 1 / o2 second).	ws add: (forget add: 1 / o1 third).	ws add: (remember add: 1 / o2 first).	ws add: (forget add: 1 / o5 third).	ws add: (forget add: 1 / on third).	ws add: (remember add: 1 / o2 fourth).	ws add: (remember add: 1 / on first).	ws add: (remember add: 1 / o5 first).		"forget and reclaim all entries but those in remember"	forget := nil.	Smalltalk garbageCollect.		remember do: [:m | self assert: (ws includes: m)].	ws add: 1/on second.	remember do: [:m | self assert: (ws includes: m)].		ws add: (remember add: 1 / o1 fourth).	ws add: (remember add: 1 / on fourth).	remember remove: (ws remove: (1 / o5 first)).	remember remove: (ws remove: (1 / on first)).	remember remove: (ws remove: (1 / o2 first)).	remember remove: (ws remove: (1 / o1 first)).	remember do: [:m | self assert: (ws includes: m)].	ws add: 1/on second.	ws add: 1/o5 second.	remember do: [:m | self assert: (ws includes: m)].	! !!WeakSetTest methodsFor: 'testing' stamp: 'nice 5/7/2009 01:20'!testDoDontIterateOnReclaimedObjects	| ws o1 o2 size |	ws := WeakSet new.	2 to: 20 do: [:i | ws add: 1 / i].		o1 := 3.0.	o2 := 4.0.	ws add: o1; add: o2.		"Reclaim memory"	Smalltalk garbageCollect.		size := 0.	ws do: [:each |		size := size + 1.		self deny: each isNil].		self assert: size = 2! !!WeakSetTest methodsFor: 'testing' stamp: 'nice 5/7/2009 01:15'!testGrowWhenNecessary	| ws objs initialSize |	objs := (2 to: 20) collect: [:i | 1 / i].	ws := WeakSet new: 5.	initialSize := ws array size.	1 to: objs size do: [:k | ws add: (objs at: k)].	self assert: ws array size > initialSize		description: 'The WeakSet grown because not enough room were preallocated'.! !!WeakSetTest methodsFor: 'testing' stamp: 'nice 5/7/2009 01:11'!testIncludesNil	| ws |	ws := WeakSet new.	self deny: (ws includes: nil).		"After reclamation, should not includes nil: nil counts for nothing"	ws add: 1/2.	ws add: 1/3.	Smalltalk garbageCollect.	self deny: (ws includes: nil).! !!Week commentStamp: 'cbr 7/28/2010 18:11' prior: 0!I represent a week.To find out what days of the week on which Squeak is fun, select the following expression, and print it:Week dayNames!!WideString class methodsFor: 'enumeration' stamp: 'ul 7/25/2011 02:00'!allMultiStringMethods  	^CurrentReadOnlySourceFiles cacheDuring: [		self systemNavigation allMethodsSelect: [ :method |			method getSource asString isOctetString not ] ]! !!WideString class methodsFor: 'enumeration' stamp: 'ul 7/25/2011 02:00'!allNonAsciiMethods	^CurrentReadOnlySourceFiles cacheDuring: [		self systemNavigation allMethodsSelect: [ :method |			method getSource asString isAsciiString not ] ]! !!Win32VMTest methodsFor: 'tests' stamp: 'mtf 12/16/2010 11:30'!testWinVM3ButtonMousePreference	"Ensure that 3ButtonMouse preference is enabled, so that the Win32 VM sends mouse clicks the same way other VMs do"	| iniData iniPref exePath |	Smalltalk platformName = 'Win32' ifFalse:[^self].	exePath := Smalltalk vmFileName.	iniData := [		(FileStream readOnlyFileNamed: (exePath copyUpToLast: $.), '.ini')			 contentsOfEntireFile	] on: Error do:[:ex| ex return: ''].	iniPref := false. "default is OFF"	iniData linesDo:[:line|		(line beginsWith: '3ButtonMouse') ifTrue:[			iniPref := (line copyAfter: $=) withBlanksTrimmed ~= '0'.		].	].	self assert: iniPref = true.! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 15:00'!brightColor	"Answer the brightColor"	^ brightColor! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 14:59'!classSymbol	"Answer the classSymbol"	^ classSymbol! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 15:00'!helpMessage	"Answer the helpMessage"	^ helpMessage! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 15:00'!pastelColor	"Answer the pastelColor"	^ pastelColor! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 14:59'!wording	"Answer the wording"	^ wording! !!WindowColorSpec methodsFor: 'initialization' stamp: 'sw 2/26/2002 13:39'!classSymbol: sym wording: wrd brightColor: brCol pastelColor: paCol helpMessage: hlpMsg	"Initialize the receiver's instance variables"	classSymbol := sym.	wording := wrd.	brightColor := brCol.	pastelColor := paCol.	helpMessage := hlpMsg! !!WindowColorSpec methodsFor: 'printing' stamp: 'sw 4/21/2002 07:42'!printOn: aStream	"Print the receiver on a stream"	super printOn: aStream.	classSymbol printOn: aStream. 	aStream nextPutAll: ' bright: ', brightColor printString, ' pastel: ', pastelColor printString! !!WindowColorSpec class methodsFor: 'instance creation' stamp: 'sw 2/26/2002 13:40'!classSymbol: sym wording: wrd brightColor: brCol pastelColor: paCol helpMessage: hlpMsg	"Answer a new instance of the receiver with the given slots filled in"	^ self new classSymbol: sym wording: wrd brightColor: brCol pastelColor: paCol helpMessage: hlpMsg! !!Workspace methodsFor: 'accessing' stamp: 'fbs 4/28/2010 21:48'!contents: textOrString	super contents: textOrString.	self changed: #contents.! !!Workspace methodsFor: 'binding' stamp: 'nice 4/20/2011 01:08'!bindingOf: aString 	mustDeclareVariables ifTrue: [^ nil].	"I want to have workspace that force the user to declare  	variables. Still subclasses may want to do something else"	(bindings includesKey: aString) ifFalse: [		(self lookupInPools: aString)			ifNotNil: [:val |				"Caveat: since we're not inserting the pool's Association into				 the dictionary, assigning a new value to the variable will only				 affect the one Workspace (i.e. you can't assign to a variable in a				 SharedPool)."				bindings at: aString put: val]			ifNil: [aString first isUppercase					ifTrue: [^nil]					ifFalse: [bindings at: aString put: nil]]	].	^ bindings associationAt: aString! !!Workspace methodsFor: 'binding' stamp: 'nice 4/20/2011 01:08'!hasBindingOf: aString 	^bindings includesKey: aString! !!Workspace methodsFor: 'binding' stamp: 'nice 4/20/2011 01:29'!inspectBindings		bindings inspect! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:00'!lookupInPools: aString 	"Iterate through all of the lookup pools to find a match for the specified name."	LookupPools ifNil: [^nil].	LookupPools do: [:pool | (pool bindingOf: aString) ifNotNil: [:assoc | ^assoc value]].	^nil! !!Workspace methodsFor: 'drag and drop' stamp: 'em 3/24/2005 11:21'!acceptDroppedMorphsWording	^ self acceptsDroppingMorphForReference		ifTrue: ['<yes> create textual references to dropped morphs' translated]		ifFalse: ['<no> create textual references to dropped morphs' translated]! !!Workspace methodsFor: 'initialize-release' stamp: 'nice 4/20/2011 01:06'!initialize		super initialize.	self initializeBindings.	acceptDroppedMorphs := false.	mustDeclareVariables := false! !!Workspace methodsFor: 'menu commands' stamp: 'nice 4/20/2011 01:30'!addModelItemsToWindowMenu: aMenu 		aMenu addLine.	aMenu		add: 'save contents to file...'		target: self		action: #saveContentsInFile.	aMenu		add: 'inspect variables'		target: self		action: #inspectBindings.	aMenu		add: 'reset variables'		target: self		action: #initializeBindings.	aMenu		addUpdating: #mustDeclareVariableWording		target: self		action: #toggleVariableDeclarationMode.	aMenu		addUpdating: #acceptDroppedMorphsWording		target: self		action: #toggleDroppingMorphForReference.	self addToggleStylingMenuItemTo: aMenu.! !!Workspace methodsFor: 'menu commands' stamp: 'dtl 2/10/2010 17:00'!saveContentsInFile	"Pass along this message to the controller or morph.  (Possibly this Workspace menu item could be deleted, since it's now in the text menu.)"	self changed: #saveContents! !!Workspace methodsFor: 'code pane menu' stamp: 'ar 4/21/2010 21:23'!shouldStyle: aBool	"If true, contents will by rendered w/ syntax-highlighting"	shouldStyle := aBool! !!Workspace methodsFor: '*ShoutCore' stamp: 'kb 2/22/2010 22:18'!hasBindingThatBeginsWith: aString 		bindings ifNil: [ ^false ].	bindings keysDo: [ :each |		(each beginsWith: aString) ifTrue: [ ^true ] ].	^false! !!Workspace commentStamp: 'ls 10/14/2003 12:13' prior: 0!A Workspace is a text area plus a lot of support for executable code.  It is a great place to execute top-level commands to compute something useful, and it is a great place to develop bits of a program before those bits get put into class methods.To open a new workspace, execute:	Workspace openA workspace can have its own variables, called "workspace variables", to hold intermediate results.  For example, if you type into a workspace "x := 5" and do-it, then later you could type in "y := x * 2" and y would become 10.Additionally, in Morphic, a workspace can gain access to morphs that are on the screen.  If acceptDroppedMorphss is turned on, then whenever a morph is dropped on the workspace, a variable will be created which references that morph.  This functionality is toggled with the window-wide menu of a workspace.The instance variables of this class are:	bindings  -  holds the workspace variables for this workspace	acceptDroppedMorphss - whether dropped morphs should create new variables!!Workspace class methodsFor: 'preferences' stamp: 'cmm 1/10/2011 15:53'!shouldStyle	<preference: 'Shout styling in Workspace' 		category: 'browsing' 		description: 'After enabled, new workspaces use shout to style their contents.' 		type: #Boolean>	^ ShouldStyle ifNil: [ false ]! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!addLookupPool: sharedPool	"Add a SharedPool that bindings should be looked up in."	LookupPools ifNil: [LookupPools := IdentitySet new].	LookupPools add: sharedPool! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 11:08'!clearLookupPools	LookupPools := nil.! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!removeLookupPool: sharedPool	"Workspaces should no longer look up bindings in the specified SharedPool."	LookupPools ifNil: [^self].	LookupPools remove: sharedPool ifAbsent: [].! !!WorldState methodsFor: 'hands' stamp: 'nice 5/8/2011 12:18'!selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result |	result := OrderedCollection new.	hands do: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					| hBnds |					hBnds := h fullBounds.					(damageList anySatisfy: [:r | r intersects: hBnds])						ifTrue: [result add: h]]]].	^ result! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 19:51'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode handsToDraw allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode := self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	canvas roundCornersOf: aWorld during:[ | handDamageRects worldDamageRects |		worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"		"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."		handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.		handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].		allDamage := worldDamageRects, handDamageRects.		handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish: allDamage.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 16:04'!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	| properDisplay |	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	remoteServer ifNotNil:[		self assuredCanvas.		^true].	properDisplay := canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: (Display getCanvas copyClipRect: Display boundingBox).		]	].	^ true! !!WorldState methodsFor: 'update cycle' stamp: 'mtf 12/28/2010 20:41'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList n morphs rects validList |	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"	rectList := rectList asArray sort: [:r1 :r2 | r1 area > r2 area].	damageRecorder reset.	n := submorphs size.	morphs := OrderedCollection new: n * 2.	rects := OrderedCollection new: n * 2.	validList := OrderedCollection new: n * 2.	"This is added in case we are drawing to a form that is to be used as a texture, and we want the background to be translucent."	aWorld color isTranslucent ifTrue:		[rectList do: [:r | aCanvas form fill: r fillColor: aWorld color]].	rectList do: 			[:dirtyRect | 			dirtyRect allAreasOutsideList: validList				do: 					[:r | | mm rectToFill remnants c rect i | 					"Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."					rectToFill := r.					i := 1.					[rectToFill isNil or: [i > n]] whileFalse: 							[mm := submorphs at: i.							((mm fullBounds intersects: r) and: [mm visible]) 								ifTrue: 									[morphs addLast: mm.									rects addLast: rectToFill.									remnants := mm areasRemainingToFill: rectToFill.									remnants size = 1 ifTrue: [rectToFill := remnants first].									remnants isEmpty ifTrue: [rectToFill := nil]].							i := i + 1].					"Now paint from bottom to top, but using the reduced rectangles."					rectToFill 						ifNotNil: [aWorld drawOn: (c := aCanvas copyClipRect: rectToFill)].					[morphs isEmpty] whileFalse: 							[(rect := rects removeLast) == rectToFill 								ifFalse: [c := aCanvas copyClipRect: (rectToFill := rect)].							c fullDrawMorph: morphs removeLast].					morphs reset.					rects reset.					validList add: r]].	^validList! !!WorldState methodsFor: '*MorphicExtras-update cycle' stamp: 'ul 6/17/2011 12:49'!startBackgroundProcess	"Start a process to update this world in the background. Return the process created."	| p |	p := [[		self doOneCycleInBackground.		(Delay forMilliseconds: 20) wait] repeat] newProcess.	p resume.	^ p! !!WriteStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:50'!cr	"Append a carriage return character to the receiver."	self nextPut: Character cr! !!WriteStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:50'!crlf	"Append a carriage return and a line feed to the receiver."	self nextPut: Character cr; nextPut: Character lf! !!WriteStream methodsFor: 'character writing' stamp: 'eem 10/21/2010 10:22'!ensureCr	"Append a cr character to the receiver IFF there is not one on the end."	self ensureEndsWith: Character cr! !!XBMReadWriter methodsFor: 'private' stamp: 'ul 11/15/2010 10:03'!readHeader	"Set width and height, and position stream at start of bytes"	| number setwidth setheight fieldName |	setwidth := setheight := false.		[((stream atEnd) or: [setwidth and: [setheight]])]		whileFalse: [	  	self skipCComments.		(stream nextMatchAll: '#define ') ifFalse: [^ false].		(stream skipTo: $_) ifFalse: [^ false].		fieldName := String streamContents:			[:source |			[(stream atEnd) or: [ stream peek isSeparator ]]				whileFalse: [ source nextPut: stream next]].	  	(fieldName = 'width') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setwidth := true].	  		width := number.].		(fieldName = 'height') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setheight := true].			height := number.			].		].	(setwidth & setheight) ifFalse: [^ false].	^ stream skipTo: ${! !!XMLElement methodsFor: 'testing' stamp: 'ar 8/10/2010 13:19'!isEmpty	"Answer true if the receiver is empty"	^self elementsAndContents isEmpty! !!XMLElement methodsFor: 'printing' stamp: 'ar 8/10/2010 13:21'!printXMLOn: writer	"Print the receiver in XML form"	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self elementsAndContentsDo: [:content | content printXMLOn: writer].			writer endTag: self name]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mtf 6/2/2010 21:17'!removeElement: element	"Used to purge certain elements from a document after parsing."	self elements remove: element ifAbsent: []! !!XMLNodeWithElements methodsFor: 'enumerating' stamp: 'ul 8/2/2011 20:14'!elementsDo: aBlock	self elements do: aBlock! !!XMLParserTest methodsFor: 'tests' stamp: 'ar 8/10/2010 13:25'!testPrintElements	| node |	node:= (XMLElement new) name: 'foo';		setAttributes: (Dictionary new);		yourself.	self assert: node asString withBlanksTrimmed = '<foo/>'.	node:= (XMLElement new) name: 'foo';		setAttributes: (Dictionary newFromPairs: {'id'. '123'});		yourself.	self assert: node asString withBlanksTrimmed = '<foo id="123"/>'.	node:= (XMLElement new) name: 'foo';		addContent: (XMLStringNode string: 'Hello World'); 		setAttributes: (Dictionary new);		yourself.	self assert: node asString withBlanksTrimmed = '<foo>Hello World</foo>'.	node:= (XMLElement new) name: 'foo';		addContent: (XMLStringNode string: 'Hello World'); 		setAttributes: (Dictionary newFromPairs: {'id'. '123'});		yourself.	self assert: node asString withBlanksTrimmed = '<foo id="123">Hello World</foo>'.! !!XMLTokenizer class methodsFor: 'class initialization' stamp: 'bf 9/23/2011 14:12'!initialize	"XMLTokenizer initialize"	CharEscapes := CharacterSet newFrom: #( $& $" $' $> $< ).	SeparatorTable  := CharacterSet new.	#(9 10 12 13 32) do: [:each | SeparatorTable add: each asCharacter].	LiteralChars := CharacterSet newFrom: #( $: $- $_ $= $.).	0 to: 255 do: [:i | 		| char |		char := i asCharacter.		(char isDigit or: [char isLetter])		ifTrue: [LiteralChars add: char]].	NameDelimiters := CharacterSet new.	#(9 10 12 13 32 61 "$= asInteger 61" 62 "$> asInteger" 47 "$/ asInteger")		do: [:each | NameDelimiters add: each asCharacter].	DigitTable := Array new: 256.	DigitTable atAllPut: -1.	($0 to: $9) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($a to: $f) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($A to: $F) do: [:each | DigitTable at: each asciiValue put: each digitValue].! !!Year commentStamp: 'cbr 7/28/2010 18:10' prior: 0!I represent a year.Try me!! Select the following expression and print it:Year current daysInYear "Try me again next leap year!!"!!ZLibWriteStream class methodsFor: 'crc' stamp: 'ar 4/14/2010 19:50'!updateAdler32: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950""        unsigned long s1 = adler & 0xffff;        unsigned long s2 = (adler >> 16) & 0xffff;        int n;        for (n = 0; n < len; n++) {          s1 = (s1 + buf[n]) % BASE;          s2 = (s2 + s1)     % BASE;        }        return (s2 << 16) + s1;"	| s1 s2 |	<primitive: 'primitiveUpdateAdler32' module: 'ZipPlugin'>	s1 := adler bitAnd: 16rFFFF.	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.	start to: stop do: [ :n | | b |		b := aCollection byteAt: n.		s1 := (s1 + b) \\ 65521.		s2 := (s2 + s1) \\ 65521. ].	^(s2 bitShift: 16) + s1! !!ZipArchive class methodsFor: 'constants' stamp: 'ar 9/6/2010 15:29'!findEndOfCentralDirectoryFrom: stream	"Seek in the given stream to the end, then read backwards until we find the	signature of the central directory record. Leave the file positioned right	before the signature.	Answers the file position of the EOCD, or 0 if not found."	| data fileLength seekOffset pos maxOffset |	stream setToEnd.	fileLength := stream position.	"If the file length is less than 18 for the EOCD length plus 4 for the signature, we have a problem"	fileLength < 22 ifTrue: [^ self error: 'file is too short'].		seekOffset := 0.	pos := 0.	data := ByteArray new: 4100.	maxOffset := 40960 min: fileLength.	"limit search range to 40K"	[		seekOffset := (seekOffset + 4096) min: fileLength.		stream position: fileLength - seekOffset.		data := stream next: (4100 min: seekOffset) into: data startingAt: 1.		pos := self lastIndexOfPKSignature: EndOfCentralDirectorySignature in: data.		pos = 0 and: [seekOffset < maxOffset]	] whileTrue.	^ pos > 0		ifTrue: [ | newPos | stream position: (newPos := (stream position + pos - seekOffset - 1)). newPos]		ifFalse: [0]! !!ZipArchive class methodsFor: 'constants' stamp: 'ar 9/6/2010 15:28'!lastIndexOfPKSignature: aSignature in: data	"Answer the last index in data where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(data size - 3) to: 1 by: -1 do: [ :i |		(((data at: i) = a)			and: [ ((data at: i + 1) = b)				and: [ ((data at: i + 2) = c)					and: [ ((data at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 10:38'!lastModTime	"Return my last modification date/time stamp,	converted to Squeak seconds"	^self dosToSqueakTime: lastModFileDateTime! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 11:08'!setLastModFileDateTimeFrom: aSmalltalkTime	lastModFileDateTime := self squeakToDosTime: aSmalltalkTime! !!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 10:39'!dosToSqueakTime: dt	"DOS years start at 1980, so add 1980."	| year mon mday hour min sec date time |	year := (( dt bitShift: -25 ) bitAnd: 16r7F ).	mon := (( dt bitShift: -21 ) bitAnd: 16r0F ).	mday := (( dt bitShift: -16 ) bitAnd: 16r1F ).	date := Date newDay: mday month: mon year: year+1980.	hour := (( dt bitShift: -11 ) bitAnd: 16r1F ).	min := (( dt bitShift: -5 ) bitAnd: 16r3F ).	sec := (( dt bitShift: 1 ) bitAnd: 16r3E ).	time := ((( hour * 60 ) + min ) * 60 ) + sec.	^date asSeconds + time	! !!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 11:00'!squeakToDosTime: secs	| dosTime dateTime |	dateTime := Time dateAndTimeFromSeconds: secs.	dosTime := (dateTime second seconds) bitShift: -1.	dosTime := dosTime + ((dateTime second minutes) bitShift: 5).	dosTime := dosTime + ((dateTime second hours) bitShift: 11).	dosTime := dosTime + ((dateTime first dayOfMonth) bitShift: 16).	dosTime := dosTime + ((dateTime first monthIndex) bitShift: 21).	dosTime := dosTime + (((dateTime first year) - 1980) bitShift: 25).	^dosTime! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'ar 8/10/2010 13:15'!writeDataTo: aStream	"Copy my (possibly inflated or deflated) data to the given stream.	This might do compression, decompression, or straight copying, depending	on the values of compressionMethod and desiredCompressionMethod"	"Note: Do not shortcut this method if uncompressedSize = 0. Even in this case	data may be produced by the compressor (i.e., '' zipped size > 0) and must	be stored in the file or else other utilities will treat the zip file as corrupt."	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])		ifTrue: [ ^self compressDataTo: aStream ].	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])		ifTrue: [ ^self uncompressDataTo: aStream ].	self copyDataTo: aStream.! !!ZipArchiveTests methodsFor: 'tests' stamp: 'ar 9/16/2010 20:15'!testCreateWithRelativeNames	"Test creating a zip with a relative tree of files, so that the tree will	be created whereever the ."	| subdir zip |	subdir := FileDirectory default / '_test-zip-dir'.	self deny: subdir exists.	subdir assureExistence.	[ subdir		fileNamed: '_test-zip-file'		do: [ : stream | stream nextPutAll: 'file contents' ].	zip := ZipArchive new.	zip		addDirectory: subdir fullName		as: subdir localName.	zip			addFile: (subdir fullNameFor: '_test-zip-file')		as: '_test-zip-dir' , FileDirectory slash , '_test-zip-file'.	zip writeToFileNamed: (FileDirectory default fullNameFor: '_test.zip') ] 	ensure:[ 		zip close.		subdir ifNotNil: [ subdir recursiveDelete ].		FileDirectory default deleteFileNamed: '_test.zip'.	]! !!ZipArchiveTests methodsFor: 'tests' stamp: 'ar 8/11/2010 20:45'!testDate29Feb2000	"Ensure that dates with leap years don't screw up in the conversion"	| archive mbr theDate |	theDate := Date year: 2000 month: 2 day: 29.	archive := ZipArchive new.	mbr := archive addDeflateString:'foo' as: 'bar'.	mbr setLastModFileDateTimeFrom: theDate asSeconds.	self shouldnt:[mbr lastModTime] raise: Error.	self assert: (Date fromSeconds: mbr lastModTime) = theDate.! !!ZipDirectoryMember methodsFor: 'private' stamp: 'cmm 9/16/2010 18:59'!writeDataTo: aStream       "Write nothing. Directories have no contents to write."! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ul 6/17/2011 12:33'!compressAndDecompress: aFile using: tempName stats: stats	| fileSize tempFile result |	aFile == nil ifTrue:[^nil].	fileSize := aFile size.	(fileSize < 1"00000" "or:[fileSize > 1000000]") ifTrue:[aFile close. ^nil].	Transcript cr; show:'Testing ', aFile name,' ... '.	tempFile := StandardFileStream new open: tempName forWrite: true.	'Compressing ', aFile name,'...' 		displayProgressFrom: 1 to: aFile size during:[:bar|			result := self regressionCompress: aFile into: tempFile notifiying: bar stats: stats].	result ifTrue:[		'Validating ', aFile name,'...'			displayProgressFrom: 0 to: aFile size during:[:bar|				result := self regressionDecompress: aFile from: tempFile notifying: bar stats: stats]].	aFile close.	tempFile close.	FileDirectory default deleteFileNamed: tempName ifAbsent:[].	result ~~ false ifTrue:[		Transcript show:' ok (', (result * 100 truncateTo: 0.01) printString,')'].	^result! !----QUIT----{11 September 2014 . 3:18:35 pm} Squeak4.3.1.image priorSource: 2914925!----STARTUP----{11 September 2014 . 3:27:11 pm} as /Users/eliot/Glue/repositories/spur/nsboot/Squeak4.3/Squeak4.3.1-spur.image![Smalltalk	saveAs: 'Squeak4.3.1';	condenseChanges;	snapshot: true andQuit: true] valueSupplyingAnswer: true!----End fileIn of a stream----!Magnitude immediateSubclass: #Character	instanceVariableNames: ''	classVariableNames: 'CharacterTable ClassificationTable DigitValues LetterBits LowercaseBit UppercaseBit'	poolDictionaries: ''	category: 'Collections-Strings'!!Character commentStamp: 'eem 8/12/2014 14:53' prior: 59239526!I represent a character by storing its associated Unicode as an unsigned 30-bit value.  Characters are created uniquely, so that all instances of a particular Unicode are identical.  My instances are encoded in tagged pointers in the VM, so called immediates, and therefore are pure immutable values.	The code point is based on Unicode.  Since Unicode is 21-bit wide character set, we have several bits available for other information.  As the Unicode Standard  states, a Unicode code point doesn't carry the language information.  This is going to be a problem with the languages so called CJK (Chinese, Japanese, Korean.  Or often CJKV including Vietnamese).  Since the characters of those languages are unified and given the same code point, it is impossible to display a bare Unicode code point in an inspector or such tools.  To utilize the extra available bits, we use them for identifying the languages.  Since the old implementation uses the bits to identify the character encoding, the bits are sometimes called "encoding tag" or neutrally "leading char", but the bits rigidly denotes the concept of languages.	The other languages can have the language tag if you like.  This will help to break the large default font (font set) into separately loadable chunk of fonts.  However, it is open to the each native speakers and writers to decide how to define the character equality, since the same Unicode code point may have different language tag thus simple #= comparison may return false.!!WideString methodsFor: 'accessing' stamp: 'eem 2/6/2014 14:38' prior: 0!at: index	"Answer the Character stored in the field of the receiver indexed by the	 argument.  Primitive.  Fail if the index argument is not an Integer or is out	 of bounds.  Essential.  See Object documentation whatIsAPrimitive."	<primitive: 63>	^index isInteger		ifTrue:			[self errorSubscriptBounds: index]		ifFalse:			[index isNumber				ifTrue: [self at: index asInteger]				ifFalse: [self errorNonIntegerIndex]]! !!WideString methodsFor: 'accessing' stamp: 'eem 2/6/2014 14:40' prior: 0!at: index put: aCharacter	"Store the Character into the field of the receiver indicated by the index.	 Primitive.  Fail if the index is not an Integer or is out of bounds, or if the	 argument is not a Character.  Essential.  See Object documentation whatIsAPrimitive."	<primitive: 64>	^aCharacter isCharacter		ifTrue:			[index isInteger				ifTrue: [self errorSubscriptBounds: index]				ifFalse: [self errorNonIntegerIndex]]		ifFalse:			[self errorImproperStore]! !!Character class methodsFor: 'instance creation' stamp: 'eem 9/24/2013 23:43' prior: 0!digitValue: x 	"Answer the Character whose digit value is x. For example,	 answer $9 for x=9, $0 for x=0, $A for x=10, $Z for x=35."	| n |	n := x asInteger.	^self value: (n < 10 ifTrue: [n + 48] ifFalse: [n + 55])! !!Character class methodsFor: 'class initialization' stamp: 'eem 7/8/2014 11:24' prior: 0!initialize	"Create the DigitsValues table."	"Character initialize"	self initializeDigitValues! !!Character class methodsFor: 'instance creation' stamp: 'eem 2/5/2014 12:49' prior: 0!value: anInteger	"Answer the Character whose value is anInteger."	<primitive: 170>	^self primitiveFailed! !!Character methodsFor: 'comparing' stamp: 'eem 10/11/2013 12:55' prior: 0!= aCharacter 	"Primitive. Answer if the receiver and the argument are the	 same object (have the same object pointer). Optional. See	 Object documentation whatIsAPrimitive."	<primitive: 110>	^self == aCharacter! !!Character methodsFor: 'converting' stamp: 'eem 2/5/2014 12:57' prior: 0!asInteger	"Answer the receiver's character code."	<primitive: 171>	^self primitiveFailed! !!Character methodsFor: 'converting' stamp: 'yo 8/16/2004 11:35' prior: 0!asLowercase	"If the receiver is uppercase, answer its matching lowercase Character."	"A tentative implementation.  Eventually this should consult the Unicode table."	| v |	v := self charCode.	(((8r101 <= v and: [v <= 8r132]) or: [16rC0 <= v and: [v <= 16rD6]]) or: [16rD8 <= v and: [v <= 16rDE]])		ifTrue: [^ Character value: self asInteger + 8r40]		ifFalse: [^ self]! !!Character methodsFor: 'converting' stamp: 'nice 12/7/2009 14:39' prior: 0!asUnicode	| table charset v |	self leadingChar = 0 ifTrue: [^ self asInteger].	(charset := EncodedCharSet charsetAt: self leadingChar)		isCharset ifFalse: [^ self charCode].	(table := charset ucsTable)		ifNil: [^ 16rFFFD].	(v := table at: 1 + self charCode)		= -1 ifTrue: [^ 16rFFFD].	^ v.! !!Character methodsFor: 'converting' stamp: 'yo 8/16/2004 11:34' prior: 0!asUppercase	"If the receiver is lowercase, answer its matching uppercase Character."	"A tentative implementation.  Eventually this should consult the Unicode table."		| v |	v := self charCode.	(((8r141 <= v and: [v <= 8r172]) or: [16rE0 <= v and: [v <= 16rF6]]) or: [16rF8 <= v and: [v <= 16rFE]])		ifTrue: [^ Character value: self asInteger - 8r40]		ifFalse: [^ self]! !!Character methodsFor: 'accessing' stamp: 'eem 2/5/2014 12:57' prior: 0!asciiValue	"Answer the receiver's character code.	 This will be ascii for characters with value <= 127,	 and Unicode for those with higher values."	<primitive: 171>	^self primitiveFailed! !!Character methodsFor: 'converting' stamp: 'yo 8/11/2003 21:18' prior: 0!basicSqueakToIso	| asciiValue |	self asInteger < 128 ifTrue: [^ self].	self asInteger > 255 ifTrue: [^ self].	asciiValue := #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 253 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 254 255 256 ) at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'accessing' stamp: 'yo 12/29/2002 10:11' prior: 0!charCode	^ (self asInteger bitAnd: 16r3FFFFF).! !!Character methodsFor: 'copying' stamp: 'eem 2/5/2014 12:52' prior: 0!clone	"Answer the receiver, because Characters are unique."	^self! !!Character methodsFor: 'object fileIn' stamp: 'tk 1/17/2000 11:27' prior: 0!comeFullyUpOnReload: smartRefStream	"Use existing an Character.  Don't use the new copy."	^ self class value: self asInteger! !!Character methodsFor: 'copying' stamp: 'eem 2/5/2014 12:52' prior: 0!copy	"Answer the receiver, because Characters are unique."	^self! !!Character methodsFor: 'copying' stamp: 'eem 2/5/2014 12:52' prior: 0!deepCopy	"Answer the receiver, because Characters are unique."	^self! !!Character methodsFor: 'accessing' stamp: 'nice 3/14/2010 23:42' prior: 0!digitValue	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 	otherwise. This is used to parse literal numbers of radix 2-36."	self asInteger > 16rFF ifTrue: [^(EncodedCharSet charsetAt: self leadingChar) digitValueOf: self].	^DigitValues at: 1 + self asInteger! !!Character methodsFor: 'comparing' stamp: 'eem 2/5/2014 12:55' prior: 0!hash	"Hash is reimplemented because = is implemented.	 Answer the receiver's character code."	<primitive: 171>	^self primitiveFailed! !!Character methodsFor: 'printing' stamp: 'eem 5/21/2010 11:11' prior: 0!hex	^self asInteger printStringBase: 16! !!Character methodsFor: 'comparing' stamp: 'eem 2/5/2014 12:56' prior: 0!identityHash	"Answer the receiver's character code."	<primitive: 171>	^self primitiveFailed! !!Character methodsFor: 'testing' stamp: 'yo 8/27/2002 15:18' prior: 0!isOctetCharacter	^ self asInteger < 256.! !!Character methodsFor: 'testing' stamp: '' prior: 0!isSeparator	"Answer whether the receiver is one of the separator characters--space, 	cr, tab, line feed, or form feed."	self asInteger = 32 ifTrue: [^true].	"space"	self asInteger = 13 ifTrue: [^true].	"cr"	self asInteger = 9 ifTrue: [^true].	"tab"	self asInteger = 10 ifTrue: [^true].	"line feed"	self asInteger = 12 ifTrue: [^true].	"form feed"	^false! !!Character methodsFor: 'accessing' stamp: 'nice 5/1/2011 22:13' prior: 0!leadingChar	"Answer the value of the 8 highest bits which is used to identify the language.	This is mostly used for east asian languages CJKV as a workaround against unicode han-unification."	^ self asInteger bitShift: -22! !!Character methodsFor: 'converting' stamp: 'nice 7/20/2011 17:16' prior: 0!macToSqueak	"Convert the receiver from MacRoman to Squeak encoding"	| asciiValue |	self asInteger < 128 ifTrue: [^ self].	self asInteger > 255 ifTrue: [^ self].	asciiValue := #[		196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232	"80-8F"		234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252	"90-9F"		134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216	"A0-AF"		129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248	"B0-BF"		191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156	"C0-CF"		150 151 147 148 145 146 247 179 255 159 185 164 139 155 188 189	"D0-DF"		135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212	"E0-EF"		190 210 218 219 217 208 136 152 175 215 221 222 184 240 253 254 ]	"F0-FF"			at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'printing' stamp: 'nice 7/14/2011 22:22' prior: 0!printOn: aStream	| name |	(self asInteger > 32 and: [self asInteger ~= 127])		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [ aStream nextPutAll: self class name; nextPutAll: ' value: '; print: self asInteger ] ].! !!Character methodsFor: 'copying' stamp: 'eem 2/5/2014 12:53' prior: 0!shallowCopy	"Answer the receiver, because Characters are unique."	^self! !!Character methodsFor: 'testing' stamp: 'nice 7/14/2011 22:21' prior: 0!shouldBePrintedAsLiteral	^(self asInteger between: 33 and: 255) and: [self asInteger ~= 127]! !!Character methodsFor: 'converting' stamp: 'nice 7/14/2011 22:34' prior: 0!squeakToMac	"Convert the receiver from Squeak to MacRoman encoding."	self asInteger < 128 ifTrue: [^ self].	self asInteger > 255 ifTrue: [^ self].	^ Character value: (#[		173 176 226 196 227 201 160 224 246 228 178 220 206 179 182 183	"80-8F"		184 212 213 210 211 165 208 209 247 170 185 221 207 186 189 217	"90-9F"		202 193 162 163 219 180 195 164 172 169 187 199 194 197 168 248	"A0-AF"		161 177 198 215 171 181 166 225 252 218 188 200 222 223 240 192 	"B0-BF"		203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 	"C0-CF"		245 132 241 238 239 205 133 249 175 244 242 243 134 250 251 167	"D0-DF"		136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149	"E0-EF"		253 150 152 151 153 155 154 214 191 157 156 158 159 254 255 216	"F0-FF"	] at: self asInteger - 127)! !!Character methodsFor: 'printing' stamp: 'ul 12/7/2009 07:16' prior: 0!storeBinaryOn: aStream	"Store the receiver on a binary (file) stream"		self asInteger < 256 		ifTrue: [ aStream basicNextPut: self ]		ifFalse: [ aStream nextInt32Put: self asInteger ]! !!Character methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28' prior: 0!storeOn: aStream	"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value."	| name |	self shouldBePrintedAsLiteral		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [					aStream 						nextPut: $(; nextPutAll: self class name; 						nextPutAll: ' value: '; print: self asInteger; nextPut: $) ] ].! !!Character methodsFor: 'copying' stamp: 'eem 2/5/2014 12:53' prior: 0!veryDeepCopyWith: deepCopier	"Answer the receiver, because Characters are unique."	^self! !WeakRegistry class removeSelector: #migrateOldRegistries!"Collections"!ParseNode subclass: #Encoder	instanceVariableNames: 'scopeTable nTemps supered requestor class selector literalStream selectorSet litIndSet litSet sourceRanges globalSourceRanges addedSelectorAndMethodClassLiterals optimizedSelectors'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!!Encoder commentStamp: '<historical>' prior: 34207082!I encode names and literals into tree nodes with byte codes for the compiler. Byte codes for literals are not assigned until the tree-sizing pass of the compiler, because only then is it known which literals are actually needed. I also keep track of sourceCode ranges during parsing and code generation so I can provide an inverse map for the debugger.!!MethodNode methodsFor: 'code generation' stamp: 'eem 9/13/2011 15:00' prior: 0!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is arbitrary but is typically either the reference	 to the source code that is stored with every CompiledMethod, or an	 encoding of the method's temporary names."	^self generate: trailer using: CompiledMethod! !!MethodNode methodsFor: 'code generation' stamp: 'eem 8/12/2014 09:34' prior: 0!generate: trailer using: aCompiledMethodClass	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.	 The argument, trailer, is arbitrary but is typically either the reference to the source code	 that is stored with every CompiledMethod, or an encoding of the method's temporary names."	| primErrNode blkSize nLits locals literals stack header method |	self generate: trailer		using: aCompiledMethodClass		ifQuick:			[:m |			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.			 m	literalAt: 2 put: encoder associationForClass;				properties: properties.			 ^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	self ensureClosureAnalysisDone.	encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"	blkSize := (block sizeCodeForEvaluatedValue: encoder)				+ (primitive > 0					ifTrue: [encoder sizeCallPrimitive: primitive]					ifFalse: [0])				+ (primErrNode					ifNil: [0]					ifNotNil:						[primErrNode							index: arguments size + temporaries size;							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).	locals := arguments, temporaries, (primErrNode ifNil: [#()] ifNotNil: [{primErrNode}]).	encoder noteBlockExtent: block blockExtent hasLocals: locals.	header := encoder computeMethodHeaderForNumArgs: arguments size					numTemps: locals size					numLits: (nLits := (literals := encoder allLiterals) size)					primitive: primitive.	method := trailer					createMethod: blkSize					class: aCompiledMethodClass					header: header.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	primitive > 0 ifTrue:		[encoder genCallPrimitive: primitive.		 primErrNode ifNotNil:			[primErrNode emitCodeForStore: stack encoder: encoder]].	stack position: method numTemps.	[block emitCodeForEvaluatedValue: stack encoder: encoder]		on: Error "If an attempt is made to write too much code the method will be asked"		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"			ex signalerContext sender method = (CompiledMethod class>>#new:)				ifTrue: [^self error: 'Compiler code size discrepancy']				ifFalse: [ex pass]].	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!MethodNode methodsFor: 'printing' stamp: 'eem 12/1/2008 14:25' prior: 0!printPropertiesOn: aStream	properties ifNil: [^self].	properties propertyKeysAndValuesDo:		[:prop :val|		aStream crtab; nextPut: $<.		prop = #on:in:			ifTrue:				[prop keywords with: val do:					[:k :v | aStream nextPutAll: k; space; nextPutAll: v; space]]			ifFalse:				[prop = #on					ifTrue: [aStream nextPutAll: prop; nextPutAll:': '; nextPutAll: val] 					ifFalse: [aStream nextPutAll: prop; nextPutAll:': '; print: val]]. 		aStream nextPut: $>]! !!Decompiler methodsFor: 'public access' stamp: 'eem 8/10/2014 16:05' prior: 0!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block node |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			lastJumpIfPcStack := OrderedCollection new.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			numLocalTemps := 0.			super method: method pc: method initialPC.			"skip primitive error code store if necessary"			(method primitive ~= 0 and: [self skipCallPrimitive; willStore]) ifTrue:				[pc := pc + (method encoderClass bytecodeSize: self firstByte).				 tempVars := tempVars asOrderedCollection].			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	node := constructor				codeMethod: aSelector				block: block				tempVars: tempVars				primitive: method primitive				class: aClass.	method primitive > 0 ifTrue:		[node removeAndRenameLastTempIfErrorCode].	^node preen! !!BytecodeEncoder methodsFor: 'method generation' stamp: 'eem 8/10/2014 14:11' prior: 0!computeMethodHeaderForNumArgs: numArgs numTemps: numTemps numLits: numLits primitive: primitiveIndex	numArgs > 15 ifTrue:		[^self error: 'Cannot compile -- too many arguments'].	numTemps > 63 ifTrue:		[^self error: 'Cannot compile -- too many temporary variables'].		numLits > 65535 ifTrue:		[^self error: 'Cannot compile -- too many literals'].	^(CompiledMethod headerFlagForEncoder: self)	+ (numArgs bitShift: 24)	+ (numTemps bitShift: 18)	"+ (largeBit bitShift: 17)" "largeBit gets filled in later"	+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])	+ numLits! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 10/23/2012 16:50' prior: 0!sizeCallPrimitive: primitiveIndex	^self sizeOpcodeSelector: #genCallPrimitive: withArguments: {primitiveIndex}! !!EncoderForV3PlusClosures class methodsFor: 'instruction stream support' stamp: 'eem 8/8/2014 08:05' prior: 0!bytecodeSize: bytecode	"Answer the number of bytes in the bytecode."	bytecode <= 125 ifTrue:		[^1].	bytecode >= 176 ifTrue:		[^1].	bytecode >= 160 ifTrue: "long jumps"		[^2].	bytecode >= 144 ifTrue: "short jumps"		[^1].	"extensions"	bytecode >= 128 ifTrue:		[^#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127].	^nil! !!EncoderForV3PlusClosures class methodsFor: 'bytecode decoding' stamp: 'eem 8/8/2014 09:14' prior: 0!callPrimitiveCode	"139	11101111	iiiiiiii jjjjjjjj	Call Primitive #iiiiiiii + (jjjjjjjj * 256)"	^139! !!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 8/8/2014 08:14' prior: 0!genCallPrimitive: primitiveIndex	"139	11101111	iiiiiiii jjjjjjjj	Call Primitive #iiiiiiii + (jjjjjjjj * 256)"	(primitiveIndex < 1 or: [primitiveIndex > 65535]) ifTrue:		[self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 65535].	stream		nextPut: 139;		nextPut: (primitiveIndex bitAnd: 255);		nextPut: (primitiveIndex bitShift: -8)! !"Compiler"!Integer immediateSubclass: #SmallInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!SmallInteger commentStamp: 'eem 8/12/2014 14:54' prior: 29284516!My instances are 31-bit numbers, stored in twos complement form. The allowable range is approximately +- 1 billion (see SmallInteger minVal, maxVal).  My instances are encoded in tagged pointers in the VM, so called immediates, and therefore are pure immutable values.!ByteArray variableByteSubclass: #CompiledMethod	instanceVariableNames: ''	classVariableNames: 'LargeFrame PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'	poolDictionaries: ''	category: 'Kernel-Methods'!!CompiledMethod commentStamp: 'eem 8/12/2014 14:45' prior: 33980576!CompiledMethod instances are methods suitable for interpretation by the virtual machine.  Instances of CompiledMethod and its subclasses are the only objects in the system that have both indexable pointer fields and indexable 8-bit integer fields.  The first part of a CompiledMethod is pointers, the second part is bytes.  CompiledMethod inherits from ByteArray to avoid duplicating some of ByteArray's methods, not because a CompiledMethod is-a ByteArray.Class variables:SmallFrame								- the number of stack slots in a small frame ContextLargeFrame							- the number of stack slots in a large frame ContextPrimaryBytecodeSetEncoderClass		- the encoder class that defines the primary instruction setSecondaryBytecodeSetEncoderClass	- the encoder class that defines the secondary instruction setThe current format of a CompiledMethod is as follows:	header (4 or 8 bytes, SmallInteger)	literals (4 or 8 bytes each, Object, see "The last literal..." below)	bytecodes  (variable, bytes)	trailer (variable, bytes)The header is a 31-bit signed integer (a SmallInteger) in the following format:	(index 0)		16 bits:	number of literals (#numLiterals)	(index 16)		  1 bit:	has primitive	(index 17)		  1 bit:	whether a large frame size is needed (#frameSize => either SmallFrame or LargeFrame)	(index 18)		  6 bits:	number of temporary variables (#numTemps)	(index 24)		  4 bits:	number of arguments to the method (#numArgs)	(index 28)		  2 bits:	reserved for an access modifier (00-unused, 01-private, 10-protected, 11-public), although accessors for bit 29 exist (see #flag).	(index 30/63)	sign bit: 1 selects the Secondary instruction set (e.g. NewsqueakV4, 0 selects the primary instruction set, e.g. SqueakV3PlusClosures) (#signFlag)If the method has a primitive then the first bytecode of the method must be a callPrimitive: bytecode that encodes the primitive index.The trailer is an encoding of an instance of CompiledMethodTrailer.  It is typically used to encode the index into the source files array of the method's source, but may be used to encode other values, e.g. tempNames, source as a string, etc.  See the class CompiledMethodTrailer.The last literal in a CompiledMethod must be its methodClassAssociation, a binding whose value is the class the method is installed in.  The methodClassAssociation is used to implement super sends.  If a method contains no super send then its methodClassAssociation may be left nil (as would be the case for example of methods providing a pool of inst var accessors).  By convention the penultimate literal of a method is either its selector or an instance of AdditionalMethodState.  AdditionalMethodState holds any pragmas and properties of a method, but may also be used to add instance variables to a method, albeit ones held in the method's AdditionalMethodState.  Subclasses of CompiledMethod that want to add state should subclass AdditionalMethodState to add the state they want, and implement methodPropertiesClass on the class side of the CompiledMethod subclass to answer the specialized subclass of AdditionalMethodState.!!Integer class methodsFor: 'class initialization' stamp: 'eem 7/16/2014 15:27' prior: 0!initialize	"Integer initialize"		self initializeLowBitPerByteTable! !!SmallInteger methodsFor: 'converting' stamp: 'eem 9/5/2013 16:49' prior: 0!asCharacter	<primitive: 170>	^self primitiveFailed! !!InstructionStream methodsFor: 'private' stamp: 'eem 8/11/2014 20:30' prior: 0!interpretExtension: offset in: method for: client	^self interpretV3ClosuresExtension: offset in: method for: client! !!InstructionStream methodsFor: 'decoding - private - v3 plus closures' stamp: 'eem 8/8/2014 07:43' prior: 0!interpretV3ClosuresExtension: offset in: method for: client	| type offset2 byte2 byte3 byte4 |	offset <= 6 ifTrue: 		["Extended op codes 128-134"		byte2 := method at: pc. pc := pc + 1.		offset <= 2 ifTrue:			["128-130:  extended pushes and pops"			type := byte2 // 64.			offset2 := byte2 \\ 64.			offset = 0 ifTrue: 				[type = 0 ifTrue: [^client pushReceiverVariable: offset2].				type = 1 ifTrue: [^client pushTemporaryVariable: offset2].				type = 2  ifTrue: [^client pushConstant: (method literalAt: offset2 + 1)].				type = 3 ifTrue: [^client pushLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 1 ifTrue: 				[type = 0 ifTrue: [^client storeIntoReceiverVariable: offset2].				type = 1 ifTrue: [^client storeIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 2 ifTrue: 				[type = 0 ifTrue: [^client popIntoReceiverVariable: offset2].				type = 1 ifTrue: [^client popIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3  ifTrue: [^client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].		"131-134: extended sends"		offset = 3 ifTrue:  "Single extended send"			[^client send: (method literalAt: byte2 \\ 32 + 1)					super: false numArgs: byte2 // 32].		offset = 4 ifTrue:    "Double extended do-anything"			[byte3 := method at: pc. pc := pc + 1.			type := byte2 // 32.			type = 0 ifTrue: [^client send: (method literalAt: byte3 + 1)									super: false numArgs: byte2 \\ 32].			type = 1 ifTrue: [^client send: (method literalAt: byte3 + 1)									super: true numArgs: byte2 \\ 32].			type = 2 ifTrue: [^client pushReceiverVariable: byte3].			type = 3 ifTrue: [^client pushConstant: (method literalAt: byte3 + 1)].			type = 4 ifTrue: [^client pushLiteralVariable: (method literalAt: byte3 + 1)].			type = 5 ifTrue: [^client storeIntoReceiverVariable: byte3].			type = 6 ifTrue: [^client popIntoReceiverVariable: byte3].			type = 7 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].		offset = 5 ifTrue:  "Single extended send to super"			[^client send: (method literalAt: byte2 \\ 32 + 1)					super: true					numArgs: byte2 // 32].		offset = 6 ifTrue:   "Second extended send"			[^client send: (method literalAt: byte2 \\ 64 + 1)					super: false					numArgs: byte2 // 64]].	offset = 7 ifTrue: [^client doPop].	offset = 8 ifTrue: [^client doDup].	offset = 9 ifTrue: [^client pushActiveContext].	byte2 := method at: pc. pc := pc + 1.	offset = 10 ifTrue:		[^byte2 < 128			ifTrue: [client pushNewArrayOfSize: byte2]			ifFalse: [client pushConsArrayWithElements: byte2 - 128]].	byte3 := method at: pc.  pc := pc + 1.	offset = 11 ifTrue: [^client callPrimitive: byte2 + (byte3 bitShift: 8)].	offset = 12 ifTrue: [^client pushRemoteTemp: byte2 inVectorAt: byte3].	offset = 13 ifTrue: [^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].	offset = 14 ifTrue: [^client popIntoRemoteTemp: byte2 inVectorAt: byte3].	"offset = 15"	byte4 := method at: pc.  pc := pc + 1.	^client		pushClosureCopyNumCopiedValues: (byte2 bitShift: -4)		numArgs: (byte2 bitAnd: 16rF)		blockSize: (byte3 * 256) + byte4! !!InstructionStream methodsFor: 'private' stamp: 'eem 5/17/2014 17:21' prior: 0!nextPc: currentByte	"Answer the pc of the next bytecode following the current one, given the current bytecode.."	^pc + (self method encoderClass bytecodeSize: currentByte)! !!InstructionStream methodsFor: 'decoding' stamp: 'eem 8/11/2014 13:22' prior: 0!skipCallPrimitive	"If the receiver's method starts with a callPrimitive: bytecode, skip it."	| method encoderClass callPrimitiveCode |	method := self method.	encoderClass := method  encoderClass.	callPrimitiveCode := encoderClass callPrimitiveCode.	(method byteAt: pc) = callPrimitiveCode ifTrue:		[pc := pc + (encoderClass bytecodeSize: callPrimitiveCode)]! !!CompiledMethod class methodsFor: 'private' stamp: 'eem 8/13/2014 05:52' prior: 0!handleFailingFailingNewMethod: numberOfBytes header: headerWord	"This newMethod:header: gets sent after handleFailingBasicNew: has done a full	 garbage collection and possibly grown memory.  If this basicNew: fails then the	 system really is low on space, so raise the OutOfMemory signal.	 Primitive. Answer an instance of this class with the number of indexable variables	 specified by the argument, headerWord, and the number of bytecodes specified	 by numberOfBytes.  Fail if this if the arguments are not Integers, or if numberOfBytes	 is negative, or if the receiver is not a CompiledMethod class, or if there is not enough	 memory available. Essential. See Object documentation whatIsAPrimitive."	<primitive: 79>	"space must be low."	OutOfMemory signal.	"retry if user proceeds"	^self newMethod: numberOfBytes header: headerWord! !!CompiledMethod class methodsFor: 'private' stamp: 'eem 8/13/2014 05:51' prior: 0!handleFailingNewMethod: numberOfBytes header: headerWord	"This newMethod:header: gets sent after newMethod:header: has failed	 and allowed a scavenging garbage collection to occur.  The scavenging	 collection will have happened as the VM is activating the (failing) basicNew:.	 If handleFailingBasicNew: fails then the scavenge failed to reclaim sufficient	 space and a global garbage collection is required.  Retry after garbage	 collecting and growing memory if necessary.	 Primitive. Answer an instance of this class with the number of indexable variables	 specified by the argument, headerWord, and the number of bytecodes specified	 by numberOfBytes.  Fail if this if the arguments are not Integers, or if numberOfBytes	 is negative, or if the receiver is not a CompiledMethod class, or if there is not enough	 memory available. Essential. See Object documentation whatIsAPrimitive."	<primitive: 79>	| bytesRequested |	bytesRequested := (headerWord bitAnd: 16rFFFF) + 1 * Smalltalk wordSize + numberOfBytes + 16.	Smalltalk garbageCollect < bytesRequested ifTrue:		[Smalltalk growMemoryByAtLeast: bytesRequested].	"retry after global garbage collect and possible grow"	^self handleFailingFailingNewMethod: numberOfBytes header: headerWord! !!CompiledMethod class methodsFor: 'method encoding' stamp: 'eem 8/12/2014 12:39' prior: 0!headerFlagForEncoder: anEncoder	anEncoder class == PrimaryBytecodeSetEncoderClass ifTrue:		[^0].	anEncoder class == SecondaryBytecodeSetEncoderClass ifTrue:		[^SmallInteger minVal].	self error: 'The encoder is not one of the two installed bytecode sets'! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 5/12/2014 17:50' prior: 0!initialize    "CompiledMethod initialize"	"Initialize class variables specifying the size of the temporary frame	needed to run instances of me."	SmallFrame := 16.	"Context range for temps+stack"	LargeFrame := 56.	PrimaryBytecodeSetEncoderClass ifNil:		[PrimaryBytecodeSetEncoderClass := EncoderForV3PlusClosures].	SecondaryBytecodeSetEncoderClass ifNil:		[SecondaryBytecodeSetEncoderClass := EncoderForV3PlusClosures]! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 0!installPrimaryBytecodeSet: aBytecodeEncoderSubclass	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:		[^self].	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].	(self allSubInstances			detect: [:m| m header >= 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]			ifNone: []) ifNotNil:		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].	PrimaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 0!installSecondaryBytecodeSet: aBytecodeEncoderSubclass	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:		[^self].	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].	(self allSubInstances			detect: [:m| m header < 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]			ifNone: []) ifNotNil:		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].	SecondaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 8/10/2014 17:12' prior: 0!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	 arguments. The remaining parts are not as yet determined."	| method pc |	nArgs > 15 ifTrue:		[^self error: 'Cannot compile -- too many arguments'].	nTemps > 63 ifTrue:		[^self error: 'Cannot compile -- too many temporary variables'].		nLits > 65535 ifTrue:		[^self error: 'Cannot compile -- too many literals'].	method := trailer				createMethod: numberOfBytes				class: self				header:    (nArgs bitShift: 24)						+ (nTemps bitShift: 18)						+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])						+ nLits						+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).	primitiveIndex > 0 ifTrue:		[pc := method initialPC.		 method			at: pc + 0 put: method encoderClass callPrimitiveCode;			at: pc + 1 put: (primitiveIndex bitAnd: 16rFF);			at: pc + 2 put: (primitiveIndex bitShift: -8)].	^method! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 8/10/2014 17:13' prior: 0!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex flag: flag	"Answer an instance of me. The header is specified by the message 	 arguments. The remaining parts are not as yet determined."	| method pc |	nArgs > 15 ifTrue:		[^self error: 'Cannot compile -- too many arguments'].	nTemps > 63 ifTrue:		[^self error: 'Cannot compile -- too many temporary variables'].		nLits > 65535 ifTrue:		[^self error: 'Cannot compile -- too many literals'].	method := trailer				createMethod: numberOfBytes				class: self				header:    (nArgs bitShift: 24)						+ (nTemps bitShift: 18)						+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])						+ nLits						+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])						+ (flag ifTrue: [1 bitShift: 29] ifFalse: [0]).	primitiveIndex > 0 ifTrue:		[pc := method initialPC.		 method			at: pc + 0 put: method encoderClass callPrimitiveCode;			at: pc + 1 put: (primitiveIndex bitAnd: 16rFF);			at: pc + 2 put: (primitiveIndex bitShift: -8)].	^method! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 8/13/2014 05:55' prior: 0!newMethod: numberOfBytes header: headerWord	"Primitive. Answer an instance of me. The number of literals (and other 	 information) is specified by the headerWord (see my class comment).	 The first argument specifies the number of fields for bytecodes in the	 method. Fail if either argument is not a SmallInteger, or if numberOfBytes	 is negative, or if memory is low. Once the header of a method is set by	 this primitive, it cannot be changed to change the number of literals.	 Essential. See Object documentation whatIsAPrimitive."	<primitive: 79 error: ec>	ec == #'insufficient object memory' ifTrue:		[^self handleFailingNewMethod: numberOfBytes header: headerWord].	^self primitiveFailed! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 8/10/2014 12:41' prior: 0!toReturnConstant: index trailerBytes: trailer	"Answer an instance of me that is a quick return of the constant	indexed in (true false nil -1 0 1 2)."	^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 256 + index! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 8/10/2014 12:41' prior: 0!toReturnField: field trailerBytes: trailer	"Answer an instance of me that is a quick return of the instance variable 	indexed by the argument, field."	^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 264 + field! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 8/10/2014 12:41' prior: 0!toReturnSelfTrailerBytes: trailer	"Answer an instance of me that is a quick return of the instance (^self)."	^self newBytes: 3 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 2 primitive: 256! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 9/11/2014 12:04' prior: 0!bytecodeSetName	^self encoderClass name copyReplaceAll: 'EncoderFor' with: ''! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 8/5/2014 20:52' prior: 0!encoderClass	"Answer the encoder class that encoded the bytecodes in this method.	 The sign flag bit is used by the VM to select a bytecode set.  This formulation	 may seem odd but this has to be fast, so no property probe unless needed."	^self header >= 0		ifTrue: 			[PrimaryBytecodeSetEncoderClass]		ifFalse:			[PrimaryBytecodeSetEncoderClass == SecondaryBytecodeSetEncoderClass				ifTrue: "Support for testing prior to installing another set"					[(self propertyValueAt: #encoderClass) ifNil: [SecondaryBytecodeSetEncoderClass]]				ifFalse:					[SecondaryBytecodeSetEncoderClass]]! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 9/11/2014 12:12' prior: 0!headerDescription	"Answer a description containing the information about the form of the	 receiver and the form of the context needed to run the receiver."	^(ByteString new: 128) writeStream		print: self header; cr;		nextPutAll: '"primitive: '; print: self primitive; cr;		nextPutAll: ' numArgs: '; print: self numArgs; cr;		nextPutAll: ' numTemps: '; print: self numTemps; cr;		nextPutAll: ' numLiterals: '; print: self numLiterals; cr;		nextPutAll: ' frameSize: '; print: self frameSize; cr;		nextPutAll: ' bytecodeSet: '; nextPutAll: self bytecodeSetName;		nextPut: $"; cr;		contents! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 8/8/2014 15:33' prior: 0!numLiterals	"Answer the number of literals used by the receiver."	^self header bitAnd: 65535! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 8/8/2014 15:32' prior: 0!primitive	"Answer the primitive index associated with the receiver.	 Zero indicates that this is not a primitive method."	| initialPC |	^(self header anyMask: 65536) "Is the hasPrimitive? flag set?"		ifTrue: [(self at: (initialPC := self initialPC) + 1) + ((self at: initialPC + 2) bitShift: 8)]		ifFalse: [0]! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 8/8/2014 07:50' prior: 0!callPrimitive: pimIndex	"V3PlusClosures:	139 10001011	iiiiiiii   jjjjjjjj  Call Primitive #iiiiiiii + (jjjjjjjj * 256)	 NewsqueakV4:		249 11111001	iiiiiiii   jjjjjjjj  Call Primitive #iiiiiiii + (jjjjjjjj * 256)	 SistaV1:			248 11111000 iiiiiiii mjjjjjjj  Call Primitive #iiiiiiii + ( jjjjjjj * 256)							m=1 means inlined primitive, no hard return after execution."! !!MethodContext class methodsFor: 'enumerating' stamp: 'eem 7/24/2014 10:39' prior: 0!allInstances	"Answer all instances of the receiver."	<primitive: 177>	"The primitive can fail because memory is low.  If so, fall back on the old	 enumeration code, which gives the system a chance to GC and/or grow.	 Because aBlock might change the class of inst (for example, using become:),	 it is essential to compute next before aBlock value: inst.	 Only count until thisContext since this context has been created only to	 compute the existing instances."	| inst insts next |	insts := WriteStream on: (Array new: 64).	inst := self someInstance.	[inst == thisContext or: [inst == nil]] whileFalse:		[next := inst nextInstance.		 insts nextPut: inst.		 inst := next].	^insts contents! !!MethodContext class methodsFor: 'private' stamp: 'eem 7/24/2014 10:39' prior: 0!allInstancesDo: aBlock	"Evaluate aBlock with each of the current instances of the receiver."	| instances inst next |	instances := self allInstancesOrNil.	instances ifNotNil:		[instances do: aBlock.		 ^self].	"allInstancesOrNil can fail because memory is low.  If so, fall back on the old	 enumeration code.  Because aBlock might change the class of inst (for example,	 using become:), it is essential to compute next before aBlock value: inst.	 Only count until thisContext since evaluation of aBlock will create new contexts."	inst := self someInstance.	[inst == thisContext or: [inst == nil]] whileFalse:		[next := inst nextInstance.		 aBlock value: inst.		 inst := next]! !!MethodContext methodsFor: 'system simulation' stamp: 'eem 8/11/2014 13:18' prior: 0!failPrimitiveWith: maybePrimFailToken	"The receiver is a freshly-created context on a primitive method.  Skip the callPrimitive:	 bytecode and store the primitive fail code if there is one and the method consumes it."	self skipCallPrimitive.	((self isPrimFailToken: maybePrimFailToken)	  and: [method encoderClass isStoreAt: pc in: method]) ifTrue:		[self at: stackp put: maybePrimFailToken last]! !!ContextPart methodsFor: 'private' stamp: 'eem 8/11/2014 12:28' prior: 0!activateReturn: aContext value: value	"Activate 'aContext return: value' in place of self, so execution will return to aContext's sender"	^MethodContext 		sender: self		receiver: aContext		method: MethodContext theReturnMethod		arguments: {value}! !!ContextPart methodsFor: 'private' stamp: 'eem 8/11/2014 13:38' prior: 0!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver and	 arguments are given as arguments to this message. If successful, push result and return	 resuming context, else ^ {errCode, PrimitiveFailToken}. Any primitive which provokes	 execution needs to be intercepted and simulated to avoid execution running away."	| value |	"Judicious use of primitive 19 (a null primitive that doesn't do anything) prevents	 the debugger from entering various run-away activities such as spawning a new	 process, etc.  Injudicious use results in the debugger not being able to debug	 interesting code, such as the debugger itself.  hence use primitive 19 with care :-)"	"SystemNavigation new browseAllSelect: [:m| m primitive = 19]"	primitiveIndex = 19 ifTrue:		[ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	((primitiveIndex between: 201 and: 222)	 and: [(self objectClass: receiver) includesBehavior: BlockClosure]) ifTrue:		[((primitiveIndex between: 201 and: 205)			 "BlockClosure>>value[:value:...]"		  or: [primitiveIndex between: 221 and: 222]) ifTrue: "BlockClosure>>valueNoContextSwitch[:]"			[^receiver simulateValueWithArguments: arguments caller: self].		 primitiveIndex = 206 ifTrue:						"BlockClosure>>valueWithArguments:"			[^receiver simulateValueWithArguments: arguments first caller: self]].	primitiveIndex = 83 ifTrue: "afr 9/11/1998 19:50" "Object>>perform:[with:...]"		[^self send: arguments first to: receiver with: arguments allButFirst super: false].	primitiveIndex = 84 ifTrue: "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"		[^self send: arguments first to: receiver with: (arguments at: 2) lookupIn: (self objectClass: receiver)].	primitiveIndex = 100 ifTrue: "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"		[^self send: arguments first to: receiver with: (arguments at: 2) lookupIn: (arguments at: 3)].	"Mutex>>primitiveEnterCriticalSection	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSection"	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:		[| active effective |		 active := Processor activeProcess.		 effective := active effectiveProcess.		 "active == effective"		 value := primitiveIndex = 186					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].		 ^(self isPrimFailToken: value)			ifTrue: [value]			ifFalse: [self push: value]].	primitiveIndex = 188 ifTrue: "eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"		[^MethodContext			sender: self			receiver: receiver			method: (arguments at: 2)			arguments: (arguments at: 1)].	"Closure primitives"	(primitiveIndex = 200 and: [self == receiver]) ifTrue:		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"		[^self push: (BlockClosure						outerContext: receiver						startpc: pc + 2						numArgs: arguments first						copiedValues: arguments last)].	primitiveIndex = 118 ifTrue: "tryPrimitive:withArgs:; avoid recursing in the VM"		[(arguments size = 2		 and: [arguments first isInteger		 and: [(self objectClass: arguments last) == Array]]) ifFalse:			[^ContextPart primitiveFailTokenFor: nil].		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].	value := primitiveIndex = 120 "FFI method"				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]				ifFalse:					[primitiveIndex = 117 "named primitives"						ifTrue: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]						ifFalse: [receiver tryPrimitive: primitiveIndex withArgs: arguments]].	^(self isPrimFailToken: value)		ifTrue: [value]		ifFalse: [self push: value]! !!ContextPart methodsFor: 'private' stamp: 'eem 8/11/2014 12:57' prior: 0!isPrimFailToken: anObject	^(self objectClass: anObject) == Array	  and: [anObject size = 2	  and: [anObject first == PrimitiveFailToken]]! !!ContextPart methodsFor: 'controlling' stamp: 'eem 8/11/2014 13:43' prior: 0!send: selector to: rcvr with: arguments lookupIn: lookupClass	"Simulate the action of sending a message with selector and arguments	 to rcvr. The argument, lookupClass, is the class in which to lookup the	 message.  This is the receiver's class for normal messages, but for super	 messages it will be some specific class related to the source method."	| meth primIndex val ctxt |	(meth := lookupClass lookupSelector: selector) ifNil:		[^self send: #doesNotUnderstand:				to: rcvr				with: {Message selector: selector arguments: arguments}				lookupIn: lookupClass].	(primIndex := meth primitive) > 0 ifTrue:		[val := self doPrimitive: primIndex method: meth receiver: rcvr args: arguments.		 (self isPrimFailToken: val) ifFalse:			[^val]].	(selector == #doesNotUnderstand: and: [lookupClass == ProtoObject]) ifTrue:		[^self error: 'Simulated message ', arguments first selector, ' not understood'].	ctxt := MethodContext sender: self receiver: rcvr method: meth arguments: arguments.	primIndex > 0 ifTrue:		[ctxt failPrimitiveWith: val].	^ctxt! !!ContextPart methodsFor: 'controlling' stamp: 'eem 8/11/2014 13:44' prior: 0!send: selector to: rcvr with: arguments super: superFlag 	"Simulate the action of sending a message with selector arguments	 to rcvr. The argument, superFlag, tells whether the receiver of the	 message was specified with 'super' in the source method."	^self send: selector		to: rcvr		with: arguments		lookupIn: (superFlag					ifTrue: [self method methodClassAssociation value superclass]					ifFalse: [self objectClass: rcvr])! !!ContextPart methodsFor: 'private' stamp: 'eem 8/11/2014 13:05' prior: 0!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Invoke the named primitive for aCompiledMethod, answering its result, or,	 if the primiitve fails, answering the error code."	<primitive: 218 error: ec>	ec ifNotNil:		["If ec is an integer other than -1 there was a problem with primitive 218,		  not with the external primitive itself.  -1 indicates a generic failure (where		  ec should be nil) but ec = nil means primitive 218 is not implemented.  So		  interpret -1 to mean the external primitive failed with a nil error code."		 ec isInteger ifTrue:			[ec = -1				ifTrue: [ec := nil]				ifFalse: [self primitiveFailed]]].	^self class primitiveFailTokenFor: ec! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'eem 3/10/2014 19:04' prior: 0!allInstances	"Answer all instances of the receiver."	<primitive: 177>	"The primitive can fail because memory is low.  If so, fall back on the old	 enumeration code, which gives the system a chance to GC and/or grow.	 Because aBlock might change the class of inst (for example, using become:),	 it is essential to compute next before aBlock value: inst."	| inst insts next |	insts := WriteStream on: (Array new: 64).	inst := self someInstance.	[inst == nil] whileFalse:		[next := inst nextInstance.		 (inst == insts or: [inst == insts originalContents]) ifFalse: [insts nextPut: inst].		 inst := next].	^insts contents! !!Behavior methodsFor: 'enumerating' stamp: 'eem 3/10/2014 18:42' prior: 0!allInstancesDo: aBlock	"Evaluate aBlock with each of the current instances of the receiver."	| instances inst next |	instances := self allInstancesOrNil.	instances ifNotNil:		[instances do: aBlock.		 ^self].	"allInstancesOrNil can fail because memory is low.  If so, fall back on the old	 enumeration code.  Because aBlock might change the class of inst (for example,	 using become:), it is essential to compute next before aBlock value: inst."	inst := self someInstance.	[inst == nil] whileFalse:		[next := inst nextInstance.		 aBlock value: inst.		 inst := next]! !!Behavior methodsFor: 'enumerating' stamp: 'eem 3/10/2014 19:04' prior: 0!allInstancesOrNil	"Answer all instances of the receiver, or nil if the primitive	 fails, which it may be due to being out of memory."	<primitive: 177>	^nil! !!Behavior methodsFor: 'instance creation' stamp: 'eem 8/13/2014 06:32' prior: 0!basicNew	"Primitive. Answer an instance of the receiver (which is a class) with no 	 indexable variables. Fail if the class is indexable. Essential. See Object 	 documentation whatIsAPrimitive.		 If the primitive fails because space is low then the scavenger will run	 before the method is activated.  Check that space was low and retry	 via handleFailingBasicNew if so."	<primitive: 70 error: ec>	ec == #'insufficient object memory' ifTrue:		[^self handleFailingBasicNew].	self isVariable ifTrue: [^self basicNew: 0].	self primitiveFailed! !!Behavior methodsFor: 'instance creation' stamp: 'eem 8/13/2014 05:52' prior: 0!basicNew: sizeRequested	"Primitive. Answer an instance of this class with the number of indexable	 variables specified by the argument, sizeRequested.  Fail if this class is not	 indexable or if the argument is not a positive Integer, or if there is not	 enough memory available. Essential. See Object documentation whatIsAPrimitive.		 If the primitive fails because space is low then the scavenger will run before the	 method is activated.  Check args and retry via handleFailingBasicNew: if they're OK."	<primitive: 71 error: ec>	ec == #'insufficient object memory' ifTrue:		[^self handleFailingBasicNew: sizeRequested].	self isVariable ifFalse:		[self error: self printString, ' cannot have variable sized instances'].	self primitiveFailed! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'eem 6/28/2014 17:14' prior: 0!byteSizeOfInstance	"Answer the total memory size of an instance of the receiver."	<primitive: 181 error: ec>	self isVariable ifTrue:		[^self byteSizeOfInstanceOfSize: 0].	self primitiveFailed! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'eem 6/28/2014 17:13' prior: 0!byteSizeOfInstanceOfSize: basicSize	"Answer the total memory size of an instance of the receiver	 with the given number of indexable instance variables."	<primitive: 181 error: ec>	self isVariable		ifTrue: "If the primitive overflowed answer a close approximation"			[(basicSize isInteger			  and: [basicSize >= 16r1000000]) ifTrue:				[^2 * (self byteSizeOfInstanceOfSize: basicSize + 1 // 2)				   - (self byteSizeOfInstanceOfSize: 0)]]		ifFalse:			[basicSize = 0 ifTrue:				[^self byteSizeOfInstance]].	self primitiveFailed! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'eem 2/25/2014 11:25' prior: 0!elementSize	"Answer the size in bytes of an element in the receiver.  The formats are			0	= 0 sized objects (UndefinedObject True False et al)			1	= non-indexable objects with inst vars (Point et al)			2	= indexable objects with no inst vars (Array et al)			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)			4	= weak indexable objects with inst vars (WeakArray et al)			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)			6	= unused			7	= immediates (SmallInteger, Character)			8	= unused			9	= 64-bit indexable		10-11	= 32-bit indexable (Bitmap)		12-15	= 16-bit indexable		16-23	= 8-bit indexable		24-31	= compiled methods (CompiledMethod)"	| instSpec |	instSpec := self instSpec.	instSpec < 9 ifTrue: [^Smalltalk wordSize].	instSpec >= 16 ifTrue: [^1].	instSpec >= 12 ifTrue: [^2].	instSpec >= 10 ifTrue: [^4].	^8! !!Behavior methodsFor: 'private' stamp: 'eem 2/26/2014 07:56' prior: 0!handleFailingBasicNew	"handleFailingBasicNew gets sent after basicNew has failed and allowed	 a scavenging garbage collection to occur.  The scavenging collection	 will have happened as the VM is activating the (failing) basicNew.  If	 handleFailingBasicNew fails then the scavenge failed to reclaim sufficient	 space and a global garbage collection is required.  Retry after garbage	 collecting and growing memory if necessary.	 Primitive. Answer an instance of this class with the number of indexable	 variables specified by the argument, sizeRequested.  Fail if this class is not	 indexable or if the argument is not a positive Integer, or if there is not	 enough memory available. Essential. See Object documentation whatIsAPrimitive."	<primitive: 70>	Smalltalk garbageCollect < 1048576 ifTrue:		[Smalltalk growMemoryByAtLeast: 1048576].	^self handleFailingFailingBasicNew "retry after global garbage collect"! !!Behavior methodsFor: 'private' stamp: 'eem 3/12/2014 10:32' prior: 0!handleFailingBasicNew: sizeRequested	"handleFailingBasicNew: gets sent after basicNew: has failed and allowed	 a scavenging garbage collection to occur.  The scavenging collection	 will have happened as the VM is activating the (failing) basicNew:.  If	 handleFailingBasicNew: fails then the scavenge failed to reclaim sufficient	 space and a global garbage collection is required.  Retry after garbage	 collecting and growing memory if necessary.	 Primitive. Answer an instance of this class with the number of indexable	 variables specified by the argument, sizeRequested.  Fail if this class is not	 indexable or if the argument is not a positive Integer, or if there is not	 enough memory available. Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	| bytesRequested |	bytesRequested := self byteSizeOfInstanceOfSize: sizeRequested.	Smalltalk garbageCollect < bytesRequested ifTrue:		[Smalltalk growMemoryByAtLeast: bytesRequested].	"retry after global garbage collect and possible grow"	^self handleFailingFailingBasicNew: sizeRequested! !!Behavior methodsFor: 'private' stamp: 'eem 2/26/2014 08:00' prior: 0!handleFailingFailingBasicNew	"This basicNew gets sent after handleFailingBasicNew: has done a full	 garbage collection and possibly grown memory.  If this basicNew fails	 then the system really is low on space, so raise the OutOfMemory signal.	 Primitive. Answer an instance of this class with the number of indexable	 variables specified by the argument, sizeRequested.  Fail if this class is not	 indexable or if the argument is not a positive Integer, or if there is not	 enough memory available. Essential. See Object documentation whatIsAPrimitive."	<primitive: 70>	"space must be low"	OutOfMemory signal.	^self basicNew  "retry if user proceeds"! !!Behavior methodsFor: 'private' stamp: 'eem 2/26/2014 08:01' prior: 0!handleFailingFailingBasicNew: sizeRequested	"This basicNew: gets sent after handleFailingBasicNew: has done a full	 garbage collection and possibly grown memory.  If this basicNew: fails	 then the system really is low on space, so raise the OutOfMemory signal.	 Primitive. Answer an instance of this class with the number of indexable	 variables specified by the argument, sizeRequested.  Fail if this class is not	 indexable or if the argument is not a positive Integer, or if there is not	 enough memory available. Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	"space must be low."	OutOfMemory signal.	^self basicNew: sizeRequested  "retry if user proceeds"! !!Behavior methodsFor: 'comparing' stamp: 'eem 2/25/2014 11:32' prior: 0!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 Behavior implements identityHash to allow the VM to use an object representation which	 does not include a direct reference to an object's class in an object.  If the VM is using	 this implementation then classes are held in a class table and instances contain the index	 of their class in the table.  A class's class table index is its identityHash so that an instance	 can be created without searching the table for a class's index.  The VM uses this primitive	 to enter the class into the class table, assigning its identityHash with an as yet unused	 class table index. If this primitive fails it means that the class table is full.  In Spur as of	 2014 there are 22 bits of classTable index and 22 bits of identityHash per object.	 Primitive. Essential. Do not override. See Object documentation whatIsAPrimitive."	<primitive: 175>	self primitiveFailed! !!Behavior methodsFor: 'private' stamp: 'eem 7/31/2014 05:47' prior: 0!indexIfCompact	"Backward compatibility with the Squeak V3 object format.	 Spur does not have a distinction between compact and non-compact classes."	^0! !!Behavior methodsFor: 'testing' stamp: 'eem 9/5/2013 15:53' prior: 0!instSize	"Answer the number of named instance variables	(as opposed to indexed variables) of the receiver.	 Above Cog Spur the class format is		<5 bits inst spec><16 bits inst size>"	^format bitAnd: 16rFFFF! !!Behavior methodsFor: 'testing' stamp: 'eem 2/25/2014 11:24' prior: 0!instSpec	"Answer the instance specification part of the format that defines what kind of object	 an instance of the receiver is.  The formats are			0	= 0 sized objects (UndefinedObject True False et al)			1	= non-indexable objects with inst vars (Point et al)			2	= indexable objects with no inst vars (Array et al)			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)			4	= weak indexable objects with inst vars (WeakArray et al)			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)			6	= unused			7	= immediates (SmallInteger, Character)			8	= unused			9	= 64-bit indexable		10-11	= 32-bit indexable (Bitmap)		12-15	= 16-bit indexable		16-23	= 8-bit indexable		24-31	= compiled methods (CompiledMethod)"	^(format bitShift: -16) bitAnd: 16r1F! !!Behavior methodsFor: 'testing' stamp: 'eem 2/25/2014 11:24' prior: 0!isBits	"Answer whether the receiver contains just bits (not pointers).	 Above Cog Spur the class format is		<5 bits inst spec><16 bits inst size>	 where the 5-bit inst spec is			0	= 0 sized objects (UndefinedObject True False et al)			1	= non-indexable objects with inst vars (Point et al)			2	= indexable objects with no inst vars (Array et al)			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)			4	= weak indexable objects with inst vars (WeakArray et al)			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)			6	= unused			7	= immediates (SmallInteger, Character)			8	= unused			9	= 64-bit indexable		10-11	= 32-bit indexable (Bitmap)		12-15	= 16-bit indexable		16-23	= 8-bit indexable		24-31	= compiled methods (CompiledMethod)"	^self instSpec >= 7! !!Behavior methodsFor: 'testing' stamp: 'eem 2/25/2014 11:24' prior: 0!isBytes	"Answer whether the receiver has 8-bit instance variables.	 Above Cog Spur the class format is		<5 bits inst spec><16 bits inst size>	 where the 5-bit inst spec is			0	= 0 sized objects (UndefinedObject True False et al)			1	= non-indexable objects with inst vars (Point et al)			2	= indexable objects with no inst vars (Array et al)			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)			4	= weak indexable objects with inst vars (WeakArray et al)			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)			6	= unused			7	= immediates (SmallInteger, Character)			8	= unused			9	= 64-bit indexable		10-11	= 32-bit indexable (Bitmap)		12-15	= 16-bit indexable		16-23	= 8-bit indexable		24-31	= compiled methods (CompiledMethod)"	^self instSpec >= 16! !!Behavior methodsFor: 'testing' stamp: 'eem 3/3/2014 17:23' prior: 0!isEphemeronClass	"Answer whether the receiver has ephemeral instance variables.  The garbage collector will	 fire (queue for finalization) any ephemeron whose first instance variable is not referenced	 other than from the transitive closure of references from ephemerons. Hence referring to	 an object from the first inst var of an ephemeron will cause the ephemeron to fire when	 the rest of the system does not refer to the object and that object is ready to be collected.	 Since references from the remaining inst vars of an ephemeron will not prevent the ephemeron	 from firing, ephemerons may act as the associations in weak dictionaries such that the value	 (e.g. properties attached to the key) will not prevent firing when the key is no longer referenced	 other than from ephemerons.  Ephemerons can therefore be used to implement instance-based	 pre-mortem finalization."	^self instSpec = 5! !!Behavior methodsFor: 'testing' stamp: 'eem 3/3/2014 17:23' prior: 0!isImmediateClass	"Answer whether the receiver has immediate instances.  Immediate instances	 store their value in their object pointer, not in an object body.  Hence immediates	 take no space and are immutable.  The immediates are distinguished by tag bits	 in the pointer. They include SmallIntegers and Characters.  Hence in the 32-bit	 system SmallIntegers are 31-bit signed integers and Characters are 30-bit	 unsigned character codes."	^self instSpec = 7! !!Behavior methodsFor: 'testing' stamp: 'eem 3/1/2014 10:19' prior: 0!isVariable	"Answer whether the receiver has indexable variables.	 Above Cog Spur the class format is		<5 bits inst spec><16 bits inst size>	 where the 5-bit inst spec is			0	= 0 sized objects (UndefinedObject True False et al)			1	= non-indexable objects with inst vars (Point et al)			2	= indexable objects with no inst vars (Array et al)			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)			4	= weak indexable objects with inst vars (WeakArray et al)			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)			6	= unused			7	= immediates (SmallInteger, Character)			8	= unused			9	= 64-bit indexable		10-11	= 32-bit indexable (Bitmap)		12-15	= 16-bit indexable		16-23	= 8-bit indexable		24-31	= compiled methods (CompiledMethod)"	| instSpec |	instSpec := self instSpec.	^instSpec >= 2 and: [instSpec <= 4 or: [instSpec >= 9]]! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'eem 3/3/2014 17:23' prior: 0!kindOfSubclass	"Answer a String that is the keyword that describes the receiver's kind of subclass,	 either a regular subclass, a variableSubclass, a variableByteSubclass,	 a variableWordSubclass, a weakSubclass, an ephemeronSubclass or an immediateSubclass.	 c.f. typeOfClass"	^self isVariable		ifTrue:			[self isBits				ifTrue:					[self isBytes						ifTrue: [' variableByteSubclass: ']						ifFalse: [' variableWordSubclass: ']]				ifFalse:					[self isWeak						ifTrue: [' weakSubclass: ']						ifFalse: [' variableSubclass: ']]]		ifFalse:			[self isImmediateClass				ifTrue: [' immediateSubclass: ']				ifFalse:					[self isEphemeronClass						ifTrue: [' ephemeronSubclass: ']						ifFalse: [' subclass: ']]]! !!Behavior methodsFor: 'testing' stamp: 'eem 1/29/2014 16:49' prior: 0!shouldNotBeRedefined	"Answer if the receiver should not be redefined.	 The assumption is that classes in Smalltalk specialObjects and 	 instance-specific Behaviors should not be redefined"	^(Smalltalk specialObjectsArray		identityIndexOf: self		ifAbsent: [(self isKindOf: self) ifTrue: [1] ifFalse: [0]]) ~= 0! !!Behavior methodsFor: 'accessing' stamp: 'eem 3/3/2014 17:23' prior: 0!typeOfClass	"Answer a symbol uniquely describing the type of the receiver. c.f. kindOfSubclass"	self isBytes ifTrue:		[^self instSpec = CompiledMethod instSpec			ifTrue: [#compiledMethod] "Very special!!"			ifFalse: [#bytes]].	(self isWords and: [self isPointers not]) ifTrue:		[^self instSpec = SmallInteger instSpec			ifTrue: [#immediate] "Very special!!"			ifFalse: [#words]].	self isWeak ifTrue: [^#weak].	self isVariable ifTrue: [^#variable].	self isEphemeronClass ifTrue: [^#ephemeron].	^#normal! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 8/10/2014 15:20' prior: 0!callPrimitive: index	"Print the callPrimitive."	self print: 'callPrimtive: ' , index printString! !!Class methodsFor: 'subclass creation' stamp: 'eem 3/3/2014 13:37' prior: 0!immediateSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new	 immediate class as a subclass of an existing class (the receiver)."	^ClassBuilder new		superclass: self		immediateSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!BlockClosure methodsFor: 'system simulation' stamp: 'eem 8/11/2014 13:41' prior: 0!simulateValueWithArguments: anArray caller: aContext	"Simulate the valueWithArguments: primitive. Fail if anArray is not an array of the right arity."	| newContext sz |	newContext := (MethodContext newForMethod: outerContext method)						setSender: aContext						receiver: outerContext receiver						method: outerContext method						closure: self						startpc: startpc.	((newContext objectClass: anArray) ~~ Array	 or: [numArgs ~= anArray size]) ifTrue:		[^ContextPart primitiveFailTokenFor: nil].	sz := self basicSize.	newContext stackp: sz + numArgs.	1 to: numArgs do:		[:i| newContext at: i put: (anArray at: i)].	1 to: sz do:		[:i| newContext at: i + numArgs put: (self at: i)].	^newContext! !!ProtoObject methodsFor: 'comparing' stamp: 'eem 9/6/2013 14:31' prior: 0!scaledIdentityHash	"For identityHash values returned by primitive 75, answer	 such values times 2^8.  Otherwise, match the existing	 identityHash implementation"	^self identityHash * 256 "bitShift: 8"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'eem 5/27/2014 11:08' prior: 0!updateMethodBindingsTo: aBinding	"ClassBuilder support for maintaining valid method bindings."	methodDict do: [:method| method methodClassAssociation: aBinding]! !!ClassBuilder methodsFor: 'class format' stamp: 'eem 3/3/2014 18:17' prior: 0!computeFormat: type instSize: newInstSize forSuper: newSuper ccIndex: ccIndex	"Compute the new format for making oldClass a subclass of newSuper.	 Answer the format or nil if there is any problem."	| instSize isVar isWords isPointers isWeak |	type == #compiledMethod ifTrue:		[newInstSize > 0 ifTrue:			[self error: 'A compiled method class cannot have named instance variables'.			^nil].		^CompiledMethod format].	instSize := newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize]).	instSize > 65535 ifTrue:		[self error: 'Class has too many instance variables (', instSize printString,')'.		^nil].	type == #normal ifTrue:[isVar := isWeak := false. isWords := isPointers := true].	type == #bytes ifTrue:[isVar := true. isWords := isPointers := isWeak := false].	type == #words ifTrue:[isVar := isWords := true. isPointers := isWeak := false].	type == #variable ifTrue:[isVar := isPointers := isWords := true. isWeak := false].	type == #weak ifTrue:[isVar := isWeak := isWords := isPointers := true].	type == #ephemeron ifTrue:[isVar := false. isWeak := isWords := isPointers := true].	type == #immediate ifTrue:[isVar := isWeak := isPointers := false. isWords := true].	(isPointers not and: [instSize > 0]) ifTrue:		[self error: 'A non-pointer class cannot have named instance variables'.		^nil].	^self format: instSize variable: isVar words: isWords pointers: isPointers weak: isWeak! !!ClassBuilder methodsFor: 'class format' stamp: 'eem 8/28/2014 15:07' prior: 0!format: nInstVars variable: isVar words: is32BitWords pointers: isPointers weak: isWeak	"Compute the format for the given instance specfication.	 Above Cog Spur the class format is		<5 bits inst spec><16 bits inst size>	 where the 5-bit inst spec is			0	= 0 sized objects (UndefinedObject True False et al)			1	= non-indexable objects with inst vars (Point et al)			2	= indexable objects with no inst vars (Array et al)			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)			4	= weak indexable objects with inst vars (WeakArray et al)			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)			6	= unused			7	= immediates (SmallInteger, Character)			8	= unused			9	= reserved for 64-bit indexable		10-11	= 32-bit indexable (Bitmap)		12-15	= 16-bit indexable		16-23	= 8-bit indexable		24-31	= compiled methods (CompiledMethod)"	| instSpec |	instSpec := isWeak					ifTrue:						[isVar							ifTrue: [4]							ifFalse: [5]]					ifFalse:						[isPointers							ifTrue:								[isVar									ifTrue: [nInstVars > 0 ifTrue: [3] ifFalse: [2]]									ifFalse: [nInstVars > 0 ifTrue: [1] ifFalse: [0]]]							ifFalse:								[isVar									ifTrue: [is32BitWords ifTrue: [10] ifFalse: [16]]									ifFalse: [7]]].	^(instSpec bitShift: 16) + nInstVars! !!ClassBuilder methodsFor: 'public' stamp: 'eem 3/3/2014 17:09' prior: 0!superclass: aClass	immediateSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a	 new immediate class as a subclass of an existing class."	| env |	aClass instSize > 0		ifTrue: [^self error: 'cannot make an immediate subclass of a class with named fields'].	aClass isVariable		ifTrue: [^self error: 'cannot make an immediate subclass of a class with indexed instance variables'].	aClass isPointers		ifFalse: [^self error: 'cannot make an immediate subclass of a class without pointer fields'].	"Cope with pre-environment and environment versions. Simplify asap."	env := (Smalltalk classNamed: #EnvironmentRequest)				ifNil: [aClass environment]				ifNotNil: [:erc| erc signal ifNil: [aClass environment]].	^self 		name: t		inEnvironment: env		subclassOf: aClass		type: #immediate		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'class mutation' stamp: 'eem 5/31/2014 07:32' prior: 0!update: oldClass to: newClass	"Convert oldClass, all its instances and possibly its meta class into newClass,	 instances of newClass and possibly its meta class. The process is surprisingly	 simple in its implementation and surprisingly complex in its nuances and potentially	 bad side effects.	 We can rely on two assumptions (which are critical):		#1: The method #updateInstancesFrom: will not create any lasting pointers to			 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do			 a become of the old vs. the new instances and therefore it will not create			 pointers to *new* instances before the #become: which are *old* afterwards)		#2: The non-preemptive execution of the critical piece of code guarantees that			 nobody can get a hold by 'other means' (such as process interruption and			 reflection) on the old instances.	 Given the above two, we know that after #updateInstancesFrom: there are no pointers	 to any old instances. After the forwarding become there will be no pointers to the old	 class or meta class either.	 Andreas Raab, 2/27/2003 23:42"	| meta |	meta := oldClass isMeta.	"Note: Everything from here on will run without the ability to get interrupted	to prevent any other process to create new instances of the old class."	["Note: The following removal may look somewhat obscure and needs an explanation.	  When we mutate the class hierarchy we create new classes for any existing subclass.	  So it may look as if we don't have to remove the old class from its superclass. However,	  at the top of the hierarchy (the first class we reshape) that superclass itself is not newly	  created so therefore it will hold both the oldClass and newClass in its (obsolete or not)	  subclasses. Since the #become: below will transparently replace the pointers to oldClass	  with newClass the superclass would have newClass in its subclasses TWICE. With rather	  unclear effects if we consider that we may convert the meta-class hierarchy itself (which	  is derived from the non-meta class hierarchy).	  Due to this problem ALL classes are removed from their superclass just prior to converting	  them. Here, breaking the superclass/subclass invariant really doesn't matter since we will	  effectively remove the oldClass (becomeForward:) just a few lines below."		oldClass superclass removeSubclass: oldClass.		oldClass superclass removeObsoleteSubclass: oldClass.		"make sure that the VM cache is clean"		oldClass methodDict do: [:cm | cm flushCache].				"Convert the instances of oldClass into instances of newClass"		newClass updateInstancesFrom: oldClass.		meta			ifTrue:				[oldClass becomeForward: newClass.				 oldClass updateMethodBindingsTo: oldClass binding]			ifFalse:				[{oldClass. oldClass class} elementsForwardIdentityTo: {newClass. newClass class}.				 oldClass updateMethodBindingsTo: oldClass binding.				 oldClass class updateMethodBindingsTo: oldClass class binding].		"eem 5/31/2014 07:22 At this point there used to be a garbage collect whose purpose was		 to ensure no old instances existed after the becomeForward:.  Without the GC it was possible		 to resurrect old instances using e.g. allInstancesDo:.  This was because the becomeForward:		 updated references from the old objects to new objects but didn't destroy the old objects.		 But as of late 2013/early 2014 becomeForward: has been modified to free all the old objects."]			valueUnpreemptively! !"Kernel"!!SystemDictionary methodsFor: 'memory space' stamp: 'eem 3/19/2014 14:08' prior: 0!growMemoryByAtLeast: numBytes	"Grow memory by at least the requested number of bytes.	 Primitive.  Fail if no memory is available.  Essential."	<primitive: 180>	^(numBytes isInteger and: [numBytes > 0])		ifTrue: [OutOfMemory signal]		ifFalse: [self primitiveFailed]! !!SystemDictionary methodsFor: 'system attributes' stamp: 'eem 9/5/2013 17:10' prior: 0!maxIdentityHash	"Answer the maximum identityHash value supported by the VM."	<primitive: 176>	^self primitiveFailed! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'eem 9/21/2013 07:39' prior: 0!setGCParameters	"Adjust the VM's default GC parameters to avoid too much tenuring.	 Maybe this should be left to the VM?"	| proportion edenSize survivorSize averageObjectSize numObjects |	proportion := 0.9. "tenure when 90% of pastSpace is full"	edenSize := SmalltalkImage current vmParameterAt: 44.	survivorSize := edenSize / 5.0. "David's paper uses 140Kb eden + 2 x 28kb survivor spaces; Spur uses the same ratios :-)"	averageObjectSize := 8 * self wordSize. "a good approximation"	numObjects := (proportion * survivorSize / averageObjectSize) rounded.	SmalltalkImage current vmParameterAt: 6 put: numObjects  "tenure when more than this many objects survive the GC"! !!SpaceTally methodsFor: 'instance size' stamp: 'eem 3/12/2014 10:31' prior: 0!spaceForInstancesOf: aClass	"Answer a pair of the number of bytes consumed by all instances of the	 given class, including their object headers, and the number of instances."	| instances total |	instances := aClass allInstances.	instances isEmpty ifTrue: [^#(0 0)].	total := 0.	aClass isVariable		ifTrue:			[instances do:				[:i| total := total + (aClass byteSizeOfInstanceOfSize: i basicSize)]]		ifFalse:			[total := instances size * aClass byteSizeOfInstance].	^{ total. instances size }! !!SystemNavigation methodsFor: 'query' stamp: 'eem 3/10/2014 19:05' prior: 0!allObjects	"Answer an Array of all objects in the system.  Fail if	 there isn't enough memory to instantiate the result."	<primitive: 178>	^self primitiveFailed! !!SystemNavigation methodsFor: 'query' stamp: 'eem 3/11/2014 13:59' prior: 0!allObjectsDo: aBlock 	"Evaluate the argument, aBlock, for each object in the system, excluding immediates	 such as SmallInteger and Character."	self allObjectsOrNil		ifNotNil: [:allObjects| allObjects do: aBlock]		ifNil:			["Fall back on the old single object primitive code.  With closures, this needs			  to use an end marker (lastObject) since activation of the block will create			  new contexts and cause an infinite loop.  The lastObject must be created			  before calling someObject, so that the VM can settle the enumeration (e.g.			  by flushing new space) as a side effect of  someObject"			| object lastObject |			lastObject := Object new.			object := self someObject.			[lastObject == object or: [0 == object]] whileFalse:				[aBlock value: object.				 object := object nextObject]]! !!SystemNavigation methodsFor: 'query' stamp: 'eem 3/11/2014 13:56' prior: 0!allObjectsOrNil	"Answer an Array of all objects in the system.  Fail if there isn't	 enough memory to instantiate the result and answer nil."	<primitive: 178>	^nil! !!SmalltalkImage methodsFor: 'special objects' stamp: 'eem 3/5/2014 14:53' prior: 0!compactClassesArray	"Smalltalk compactClassesArray"	"Backward-compatibility support.  Spur does not have compact classes."	^{}! !!SmalltalkImage methodsFor: 'memory space' stamp: 'eem 3/19/2014 13:51' prior: 0!growMemoryByAtLeast: numBytes	"Grow memory by at least the requested number of bytes.	 Primitive.  Essential. Fail if no memory is available."	<primitive: 180>	(numBytes isInteger and: [numBytes > 0]) ifTrue:		[OutOfMemory signal].	^self primitiveFailed! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 9/5/2013 17:10' prior: 0!maxIdentityHash	"Answer the maximum identityHash value supported by the VM."	<primitive: 176>	^self primitiveFailed! !!SmalltalkImage methodsFor: 'special objects' stamp: 'eem 9/11/2014 09:21' prior: 0!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 60.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self specialObjectsArray at: 4) "(self bindingOf: #Processor) but it answers an Alias".	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: (self globals at: #MethodContext ifAbsent: [self globals at: #Context]).	newArray at: 12 put: nil. "was BlockContext."	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it.	 This is nil in Spur, which has immediate Characters."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers; an empty array in Spur"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization"	newArray at: 32 put: nil. "was the prototype Float"	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"	newArray at: 34 put: nil. "was the prototype Point"	newArray at: 35 put: #cannotInterpret:.	newArray at: 36 put: nil. "was the prototype MethodContext"	newArray at: 37 put: BlockClosure.	newArray at: 38 put: nil. "was the prototype BlockContext"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"external semaphores"	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	newArray at: 51 put: #attemptToAssign:withIndex:.	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move' #'resource limit exceeded'							#'object is pinned' #'primitive write beyond end of object').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."	newArray at: 56 put: nil.	"reserved for foreign callback process"	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).	newArray at: 58 put: #unusedBytecode.	"59 reserved for Sista counter tripped message"	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.	"60 reserved for Sista class trap message"	newArray at: 60 put: #classTrapFor:.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray becomeForward: newArray! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'eem 9/21/2013 07:39' prior: 0!setGCParameters	"Adjust the VM's default GC parameters to avoid too much tenuring.	 Maybe this should be left to the VM?"	| proportion edenSize survivorSize averageObjectSize numObjects |	proportion := 0.9. "tenure when 90% of pastSpace is full"	edenSize := SmalltalkImage current vmParameterAt: 44.	survivorSize := edenSize / 5.0. "David's paper uses 140Kb eden + 2 x 28kb survivor spaces; Spur uses the same ratios :-)"	averageObjectSize := 8 * self wordSize. "a good approximation"	numObjects := (proportion * survivorSize / averageObjectSize) rounded.	SmalltalkImage current vmParameterAt: 6 put: numObjects  "tenure when more than this many objects survive the GC"! !"System"!----QUIT----{11 September 2014 . 3:27:16 pm} Squeak4.3.1-spur.image priorSource: 2914925!----STARTUP----{28 September 2014 . 2:41:53 pm} as /Users/rmacnak/Code/Newspeak/nsboot/Squeak4.3/Squeak4.3.1-spur.image!| packageCache |packageCache := MCCacheRepository default.#('Collections.spur' 'Compiler.spur' 'Kernel.spur' 'System.spur') do:	[:package| | versionName version |	versionName := (packageCache versionNamesForPackageNamed: package) first.	version := packageCache versionNamed: versionName.	[version load]		on: Error, Warning		do: [:ex|			"ugh, the Decompiler gets confused by the null bytes at the end of e.g. Character>>setValue:.  Hack it for now"			"Monticello warnis about dirty packages."			({	MCVersionLoader>>#warnAboutLosingChangesTo:.				Decompiler>>#decompile:in:method:using: }					identityIncludes: ex signalerContext sender method) ifTrue:				[ex resumeUnchecked: nil].			ex pass]].Smalltalk snapshot: true andQuit: true!----End fileIn of a stream----!Object subclass: #A	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!Object subclass: #B	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!a := A new.b := B new.Transcript show: {A. A allInstances. B. B allInstances.}.{A. a} elementsForwardIdentityTo: {B. b} copyHash: true.Transcript show: {A. A allInstances. B. B allInstances.} .!----QUIT/NOSAVE----{28 September 2014 . 2:53:15 pm} Squeak4.3.1-spur.image priorSource: 3001731!
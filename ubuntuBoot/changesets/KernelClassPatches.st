"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From nsboot-2008-06-13.00 of 13 June 2008 [latest update: #0] on 16 June 2008 at 7:43:11 pm'!"Patches to Kernel-Classes to support NsMultilanguage/NewsqueakBase. - modify class recompilation to avoid recompiling ``hidden'' (uncategorised) methods.- modify the various Behavior>>xClass methods to answer classes correspnding to a class's Language.  - modify definition display to use the indirect through the class's language (so sometime we can support dedining a class in a language other than St80).- modify lass removal to clean-up Language's LangMap table."!!ClassBuilder methodsFor: 'class definition' stamp: 'eem 3/13/2007 14:37'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	 If unsafe is true do not run any validation checks.	 This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory | 	environ := env.	instVars := Scanner new scanFieldNames: instVarString.	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass := env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse: [oldClass := nil]  "Already checked in #validateClassName:"		ifTrue: [			copyOfOldClass := oldClass copy.			copyOfOldClass superclass addSubclass: copyOfOldClass].			[unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass"	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.	needNew == nil ifTrue:[^nil]. "some error"	(needNew and:[unsafe not]) ifTrue:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.		].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined. \Proceed to store over it.' withCRs]].	needNew ifTrue:[		"Create the new class"		newClass := self 			newSubclassOf: newSuper 			type: type 			instanceVariables: instVars			from: oldClass.		newClass == nil ifTrue:[^nil]. "Some error"		newClass setName: className.	] ifFalse:[		"Reuse the old class"		newClass := oldClass.	].	"Install the class variables and pool dictionaries... "	force := (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	newCategory := category asSymbol.	organization := environ ifNotNil:[environ organization].	oldClass isNil ifFalse: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].	organization classify: newClass name under: newCategory.	newClass environment: environ.	"... recompile ..."	newClass := self recompile: force from: oldClass to: newClass mutate: false.	oldClass == nil ifTrue:		["Create accessors etc for new language classes."		 newClass language processDefinitionOf: newClass].	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		[environ at: newClass name put: newClass]			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].		Smalltalk flushClassNameCache.	].	newClass doneCompiling.	"... notify interested clients ..."	oldClass isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.		^ newClass].	newCategory ~= oldCategory 		ifTrue: [SystemChangeNotifier uniqueInstance class: newClass recategorizedFrom: oldCategory to: category]		ifFalse: [SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.].] ensure: 		[copyOfOldClass ifNotNil: [copyOfOldClass superclass removeSubclass: copyOfOldClass].		Behavior flushObsoleteSubclasses.		].	^newClass! !!ClassBuilder methodsFor: 'class mutation' stamp: 'eem 3/12/2007 15:04'!mutate: oldClass to: newClass	"Mutate the old class and subclasses into newClass and subclasses.	Note: This method is slightly different from: #mutate:toSuper: since	here we are at the root of reshaping and have two distinct roots."	| newSubclass |	self showProgressFor: oldClass.		"Create accessors etc for new language classes."	newClass language processDefinitionOf: newClass.	"Convert the subclasses"	oldClass subclasses do:[:oldSubclass| 		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.		self mutate: oldSubclass to: newSubclass.	].	"And any obsolete ones"	oldClass obsoleteSubclasses do:[:oldSubclass|		oldSubclass ifNotNil:[			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.			self mutate: oldSubclass to: newSubclass.		].	].	self update: oldClass to: newClass.	^newClass! !!ClassBuilder methodsFor: 'private' stamp: 'eem 3/22/2007 12:44'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta := newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta := oldClass class.	newMeta := oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: MethodDictionary new		format: (self computeFormat: oldMeta typeOfClass 					instSize: oldMeta instVarNames size 					forSuper: newSuperMeta					ccIndex: 0);		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta copyCompileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!ClassDescription methodsFor: 'compiling' stamp: 'eem 3/12/2007 14:34'!compileAllFrom: oldClass	"Compile all the methods in the receiver's organization.	This validates sourceCode and variable references and forces	all methods to use the current bytecode set"	"ar 7/10/1999: Use oldClass selectors not self selectors"	"eem 2007/3/12 use categorizedSelectorsDo: top eliminate uncategorized/hidden methods."		oldClass categorizedSelectorsDo: [:sel | self recompile: sel from: oldClass].	self environment currentProjectDo: [:proj | proj compileAllIsolated: self from: oldClass]! !!ClassDescription methodsFor: 'compiling' stamp: 'eem 3/22/2007 12:43'!copyCompileAllFrom: oldClass	"Copy (compiling) all the methods in the receiver's method dictionary..	This validates sourceCode and variable references and forces	all methods to use the current bytecode set.  Unlike compileAllFrom:	this copys all methods, rater tan all categorized methods.  This is intended	to be used by the ClassBuilder to create new metaclasses."		^super compileAllFrom: oldClass! !!ClassDescription methodsFor: 'compiling' stamp: 'GB 11/8/2007 15:12'!reformatMethodAt: selector	| newCodeString method |	newCodeString := self prettyPrinterClass new				format: (self sourceCodeAt: selector)				in: self				notifying: nil				decorated: false.	method := self compiledMethodAt: selector.	method 		putSource: newCodeString		fromParseNode: nil		class: self		category: (self organization categoryOfElement: selector)		inFile: 2		priorMethod: method! !!Behavior methodsFor: 'accessing' stamp: 'yk 1/29/2007 15:48'!compilerClass	"Answer a compiler class appropriate for source methods of this class.	 Note that the classes and their metaclasses can have different compilers."	^self language compiler! !!Behavior methodsFor: 'compiling' stamp: 'GB 11/8/2007 15:18'!decompilerClass	"Answer a decompiler class appropriate for compiled methods of this class."	^ self compilerClass new decompilerClass! !!Behavior methodsFor: 'accessing' stamp: 'yk 1/19/2007 12:28'!evaluatorClass	"Answer an evaluator class appropriate for evaluating expressions in the 	  context of this class."	^self compilerClass! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'eem 3/27/2007 13:45'!definition	"Answer the definition of the class in whatever language it prefers."	 ^[self language definitionForClass: self]		on: Error		do: [:ex| ex return: self definitionST80]	"Was:"	"Answer a String that defines the receiver in good old ST-80."	"^ self definitionST80"! !!Compiler methodsFor: 'evaluating' stamp: 'GB 11/8/2007 15:06'!evaluate: textOrString for: anObject notifying: aController logged: logFlag	"Compile and execute the argument, textOrString with respect to the class 	of anObject. If a compilation error occurs, notify aController. If both 	compilation and execution are successful then, if logFlag is true, log 	(write) the text onto a system changes file so that it can be replayed if 	necessary."	^ self 				evaluate: textOrString				in: nil				to: anObject				notifying: aController				ifFail: [^nil]				logged: logFlag.! !!Compiler methodsFor: 'evaluating' stamp: 'GB 11/8/2007 15:06'!evaluate: textOrString notifying: aController logged: logFlag 	"See Compiler|evaluate:for:notifying:logged:. Compilation is carried out 	with respect to nil, i.e., no object."	^self evaluate: textOrString for: nil notifying: aController logged: logFlag! !!Compiler methodsFor: 'as yet unclassified' stamp: 'GB 11/8/2007 15:17'!decompilerClass	^Decompiler! !!Behavior methodsFor: 'adding/removing methods' stamp: 'Ahe 6/16/2008 19:11'!basicAddSelector: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary.	Do this without sending system change notifications"	| oldMethodOrNil |	oldMethodOrNil _ self lookupSelector: selector.	self methodDict at: selector put: compiledMethod.	compiledMethod methodClass: (SystemMetadata definingClassOrSelfOf: self).	compiledMethod selector: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethodOrNil == nil ifFalse: [oldMethodOrNil flushCache].	selector flushCache.! !
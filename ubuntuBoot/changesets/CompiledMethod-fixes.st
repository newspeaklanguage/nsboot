"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From nsboot-2008-05-23.01 of 23 May 2008 [latest update: #0] on 27 May 2008 at 6:28:01 am'!!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 5/1/2007 11:22'!parserClass	^self methodClass compilerClass new parserClass! !!CompiledMethod methodsFor: 'source code management' stamp: 'Ahe 5/5/2008 13:53'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| source flagByte |	flagByte := self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue: ["No source pointer -- decompile without temp names"		^ self decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((self decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	nil = (class organization categoryOfElement: selector) ifTrue: [		"Synthetic method, e.g. getter or setter in NS"		Transcript cr;			nextPutAll: 'Synthetic method with bad trailer: ';			nextPutAll: class name;			nextPutAll: '>>';			nextPutAll: selector;			flush.		^self decompileString].	"Situation normal;  read the sourceCode from the file"		[source := self getSourceFromFile] on: Error do: [ :ex |		"An error can happen here if, for example, the changes file has been truncated by an aborted download.  The present solution is to ignore the error and fall back on the decompiler.  A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling into this error case, random source code will get returned."		source := nil ].		^nil = source		ifTrue: [self decompileString] "Something really wrong -- decompile blind (no temps)"		ifFalse: [source]! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 5/1/2007 11:22'!sourceClass	"DEPRECATED!!!! Use methodClass"	"Get my receiver class (method class) from the preamble of my source.  Return nil if not found."	^ [(Compiler evaluate: (self sourceFileStream backChunk "blank"; backChunk "preamble")) theClass] on: Error do: [nil]! !!CompiledMethod methodsFor: 'source code management' stamp: 'Ahe 10/26/2007 17:30'!qCompress: string firstTry: firstTry	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble.	Normal call is with firstTry == true."	| charTable odd ix oddNibble names shorterStr maybe str temps |	 str := string isOctetString				ifTrue: [string]				ifFalse: [temps := string findTokens: ' '.					String						streamContents: [:stream | 1								to: temps size								do: [:index | 									stream nextPut: $t.									stream nextPutAll: index asString.									stream space]]].	charTable :=  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd := true.  "Flag for odd or even nibble out"		oddNibble := nil.		str do:			[:char | ix := (charTable indexOf: char ifAbsent: [^nil]) - 1.			(ix <= 12 ifTrue: [Array with: ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd := odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble := nibble]]].		strm position > 251 ifTrue:			["Only values 1...251 are available for the flag byte			that signals compressed temps. See the logic in endPC."			"Before giving up completely, we attempt to encode most of			the temps, but with the last few shortened to tNN-style names."			firstTry ifFalse: [^ nil "already tried --give up now"].			names := str findTokens: ' '.			names size < 8 ifTrue: [^ nil  "weird case -- give up now"].			4 to: names size//2 by: 4 do:				[:i | shorterStr := String streamContents:					[:s |					1 to: names size - i do: [:j | s nextPutAll: (names at: j); space].					1 to: i do: [:j | s nextPutAll: 't' , j printString; space]].				(maybe := self qCompress: shorterStr firstTry: false) ifNotNil: [^ maybe]].			^ nil].		strm nextPut: strm position]"  | m s |  m := CompiledMethod new.s := 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!CompiledMethod methodsFor: 'decompiling' stamp: 'GB 11/8/2007 15:19'!decompilerClass	^ self isClosureCompiled			ifTrue: [self compilerClass closureDecompilerClass] 			ifFalse: [self compilerClass new decompilerClass]! !!CompiledMethod methodsFor: 'decompiling' stamp: 'GB 11/8/2007 15:13'!methodNodeFormattedAndDecorated: decorate	"Answer a method node made from pretty-printed (and colorized, if decorate is true) 	 source text."	| class source node  |		source := self getSourceFromFile.	class := self methodClass ifNil: [self sourceClass].	source ifNil: [^self decompile].	source := class prettyPrinterClass new				format: source				in: class				notifying: nil				decorated: decorate.	node := class parserClass new parse: source class: class.	node sourceText: source.	^node! !!CompiledMethod methodsFor: 'decompiling' stamp: 'Ahe 5/27/2008 06:27'!methodNode	"Return the parse tree that represents self"	| source |	^(self isSynthetic or: [(source := self getSourceFromFile) isEmptyOrNil])		ifTrue: [self decompile]		ifFalse: [self parserClass new 					parse: source 					class: (self methodClass ifNil: [self sourceClass])]! !!CompiledMethod methodsFor: 'source code management' stamp: 'Ahe 3/20/2008 19:39'!getRemoteStringSourceFromFile	"Read the source code from file, determining source file index and	file position from the last 3 bytes of this method."	| position |	(position := self filePosition) = 0 ifTrue: [^ nil].	^ (RemoteString newFileNumber: self fileIndex position: position)! !!CompiledMethod methodsFor: 'source code management' stamp: 'bobw 4/3/2008 10:46'!getSourceFromFile	"Read the source code from file, determining source file index and	file position from the last 3 bytes of this method.  Clients are prepared	to handle nil if it is returned."		^self getRemoteStringSourceFromFile ifNotNil: [:remoteString| remoteString text]! !CompiledMethod removeSelector: #replace:with:in:!
"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From nsboot-2008-04-15.00 of 15 April 2008 [latest update: #0] on 18 April 2008 at 4:20:12 pm'!!Object methodsFor: 'accessing' stamp: 'eem 7/13/2007 13:21'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue:				[(index >= 1 and: [index <= self size])					ifTrue:						[self isImmutable ifTrue:							[^NoModificationError								signal: self								message: (Message											selector: #at:put:											arguments: {index. value})].						self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'eem 7/25/2007 12:57'!basicAt: index put: value 	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[(index >= 1 and: [index <= self basicSize])			ifTrue:				[self isImmutable ifTrue:					[^NoModificationError						signal: self						message: (Message									selector: #basicAt:put:									arguments: {index. value})].				self errorImproperStore]			ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'error handling' stamp: 'eem 7/13/2007 13:22'!attemptToAssign: value withIndex: anIndex	"The VM sends this message when an attempt is made	 to assign an inst var of an immutable object.  Respond	 by signalling a NoModificationError."	^NoModificationError		signal: self		message: (Message						selector: #instVarAt:put:						arguments: {anIndex. value})! !!Object methodsFor: 'system primitives' stamp: 'eem 6/28/2007 15:59'!beMutableWhile: aBlock	"Evaluate aBlock while the receiver is mutable.	Restore its immutablility state if is was mutable	and answer the result of evaluating aBlock."	| wasImmutable |	wasImmutable := self isImmutable: false.	^aBlock ensure: [self isImmutable: wasImmutable]! !!Object methodsFor: 'system primitives' stamp: 'eem 7/13/2007 13:22'!instVarAt: integerIndex put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	(integerIndex isInteger and: [integerIndex > 0 and: [integerIndex <= self class instSize and: [self isImmutable]]]) ifTrue:		[^NoModificationError			signal: self			message: (Message						selector: #instVarAt:put:						arguments: {integerIndex. anObject})].	"Access beyond fixed fields"	^self basicAt: integerIndex - self class instSize put: anObject! !!Object methodsFor: 'system primitives' stamp: 'eem 7/13/2007 14:20'!primitiveChangeClassTo: anObject	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have, or if the receiver is immutable.	Note: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."	<primitive: 115 error: ec>	ec == #'no modification' ifTrue:		[^NoModificationError			signal: self			message: (Message						selector: #primitiveChangeClassTo:						arguments: {anObject})].	self primitiveFailed! !!ClassBuilder methodsFor: 'class mutation' stamp: 'eem 7/24/2007 15:20'!update: oldClass to: newClass	"Convert oldClass, all its instances and possibly its meta class into newClass, instances of newClass and possibly its meta class. The process is surprisingly simple in its implementation and surprisingly complex in its nuances and potentially bad side effects. 	We can rely on two assumptions (which are critical):		#1: The method #updateInstancesFrom: will not create any lasting pointers to 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do a become of the old vs. the new instances and therefore it will not create pointers to *new* instances before the #become: which are *old* afterwards)		#2: The non-preemptive execution of the critical piece of code guarantees that nobody can get a hold by 'other means' (such as process interruption and reflection) on the old instances.	Given the above two, we know that after #updateInstancesFrom: there are no pointers to any old instances. After the forwarding become there will be no pointers to the old class or meta class either. Meaning that if we throw in a nice fat GC at the end of the critical block, everything will be gone (but see the comment right there). There's no need to worry.	"	| meta |	meta := oldClass isMeta.	"Note: Everything from here on will run without the ability to get interrupted	to prevent any other process to create new instances of the old class."	[		"Note: The following removal may look somewhat obscure and needs an explanation. When we mutate the class hierarchy we create new classes for any existing subclass. So it may look as if we don't have to remove the old class from its superclass. However, at the top of the hierarchy (the first class we reshape) that superclass itself is not newly created so therefore it will hold both the oldClass and newClass in its (obsolete or not) subclasses. Since the #become: below will transparently replace the pointers to oldClass with newClass the superclass would have newClass in its subclasses TWICE. With rather unclear effects if we consider that we may convert the meta-class hierarchy itself (which is derived from the non-meta class hierarchy).		Due to this problem ALL classes are removed from their superclass just prior to converting them. Here, breaking the superclass/subclass invariant really doesn't matter since we will effectively remove the oldClass (become+GC) just a few lines below."		oldClass superclass removeSubclass: oldClass.		oldClass superclass removeObsoleteSubclass: oldClass.		"Convert the instances of oldClass into instances of newClass"		newClass updateInstancesFrom: oldClass.		"Preserve any immutability state."		newClass setImmutabilityStateFrom: oldClass.		meta			ifTrue:[oldClass becomeForward: newClass]			ifFalse:[(Array with: oldClass with: oldClass class)						elementsForwardIdentityTo:							(Array with: newClass with: newClass class)].		Smalltalk garbageCollect.		"Warning: Read this before you even think about removing the GC. Yes, it slows us down. Quite heavily if you have a large image. However, there's no good and simple alternative here, since unfortunately, #become: does change class pointers. What happens is that after the above become all of the instances of the old class will have a class pointer identifying them as instances of newClass. If we get our hands on any of these instances we will break immediately since their expected instance layout (that of its class, e.g., newClass) will not match their actual instance layout (that of oldClass). And getting your hands on any of those instances is really simple - just reshaping one class two times in rapid succession will do it. Reflection techniques, interrupts, etc. will only add to this problem. In the case of Metaclass things get even worse since when we recompile the entire class hierarchy we will recompile both, Metaclass and its instances (and some of its instances will have the old and some the new layout).		The only easy solution to this problem would be to 'fix up' the class pointers of the old instances to point to the old class (using primitiveChangeClassTo:). But this won't work either - as we do a one-way become we would have to search the entire object memory for the oldClass and couldn't even clearly identify it unless we give it some 'special token' which sounds quite error-prone. If you really need to get rid of the GC here are some alternatives:		On the image level, one could create a copy of the oldClass before becoming it into the new class and, after becoming it, 'fix up' the old instances. That would certainly work but it sounds quite complex, as we need to make sure we're not breaking any of the superclass/subclass meta/non-meta class variants.		Alternatively, fix up #becomeForward on the VM-level to 'dump the source objects' of #become. This would be quite doable (just 'convert' them into a well known special class such as bitmap) yet it has problems if (accidentally or not) one of the objects in #become: appears on 'both sides of the fence' (right now, this will work ... in a way ... even though the consequences are unclear).		Another alternative is to provide a dedicated primitive for this (instead of using it implicitly in become) which would allow us to dump all the existing instances right here. This is equivalent to a more general primitiveChangeClassTo: and might be worthwhile but it would likely have to keep in mind the differences between bits and pointer thingies etc.		Since all of the alternatives seem rather complex and magical compared to a straight-forward GC it seems best to stick with the GC solution for now. If someone has a real need to fix this problem, that person will likely be motivated enough to check out the alternatives. Personally I'd probably go for #1 (copy the old class and remap the instances to it) since it's a solution that could be easily reverted from within the image if there's any problem with it."	] valueUnpreemptively.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'eem 7/30/2007 15:37'!updateInstances: oldInstances from: oldClass isMeta: isMeta	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary. Return the array of old instances (none of which should be pointed to legally by anyone but the array)."	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."	| map variable instSize newInstances |	oldInstances isEmpty ifTrue:[^#()]. "no instances to convert"	isMeta ifTrue: [		oldInstances size = 1 ifFalse:[^self error:'Metaclasses can only have one instance'].		self soleInstance class == self ifTrue:[			^self error:'Metaclasses can only have one instance']].	map := self instVarMappingFrom: oldClass.	variable := self isVariable.	instSize := self instSize.	newInstances := Array new: oldInstances size.	1 to: oldInstances size do:[:i|		newInstances at: i put:			(self newInstanceFrom: (oldInstances at: i) variable: variable size: instSize map: map)].	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWithEvenIfImmutable: newInstances.	^newInstances "which are now old"! !!ClassDescription methodsFor: 'private' stamp: 'eem 7/30/2007 15:35'!newInstanceFrom: oldInstance variable: variable size: instSize map: map	"Create a new instance of the receiver based on the given old instance.	The supplied map contains a mapping of the old instVar names into	the receiver's instVars"	| newInstance |	newInstance := variable				ifTrue: [self basicNew: oldInstance basicSize]				ifFalse: [self basicNew].	1 to: instSize do: 		[:offset |  (map at: offset) > 0 ifTrue:			[newInstance				instVarAt: offset				put: (oldInstance instVarAt: (map at: offset))]].	variable  ifTrue:		[1 to: oldInstance basicSize do: 			[:offset |			newInstance basicAt: offset put: (oldInstance basicAt: offset)]].	oldInstance isImmutable ifTrue:		[newInstance isImmutable: true].	^newInstance! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'eem 7/30/2007 15:35'!newInstanceFrom: oldInstance variable: variable size: instSize map: map	"Create a new instance of the receiver based on the given old instance.	The supplied map contains a mapping of the old instVar names into	the receiver's instVars"	| newInstance |	newInstance := self newFrom: oldInstance.	1 to: instSize do: 		[:offset |  (map at: offset) > 0 ifTrue:			[newInstance				instVarAt: offset				put: (oldInstance instVarAt: (map at: offset))]].	oldInstance isImmutable ifTrue:		[newInstance isImmutable: true].	^newInstance! !!ContextPart methodsFor: 'controlling' stamp: 'eem 7/5/2007 11:18'!sendAttemptToAssign: value to: assignee withIndex: index	self push: assignee.	self push: value.	self push: index.	^self send: #attemptToAssign:withIndex: super: false numArgs: 2! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 7/5/2007 11:19'!popIntoLiteralVariable: litVar 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into a literal variable of my method."	litVar isImmutable ifTrue:		[^self sendAttemptToAssign: self pop to: litVar withIndex: 2].	litVar value: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 7/5/2007 11:19'!popIntoReceiverVariable: offset 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into an instance variable of my receiver."	self receiver isImmutable ifTrue:		[^self sendAttemptToAssign: self pop to: self receiver withIndex: offset + 1].	self receiver instVarAt: offset + 1 put: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 7/5/2007 11:19'!storeIntoReceiverVariable: offset 	"Simulate the action of bytecode that stores the top of the stack into an 	instance variable of my receiver."	self receiver isImmutable ifTrue:		[^self sendAttemptToAssign: self top to: self receiver withIndex: offset + 1].	self receiver instVarAt: offset + 1 put: self top! !!SmalltalkImage class methodsFor: 'utilities' stamp: 'eem 6/27/2007 11:01'!systemAttributes	"Answer a Dictionary of all of the system attributes which can be obtained from	SmalltalkImage>>getSystemAttribute:"	"SmalltalkImage systemAttributes"	"OSProcess systemAttributes keys asSortedCollection"	"SmalltalkImage current getSystemAttribute: 1000"	| curr getAttrs args idx a |	curr := self current.	args := Dictionary new.	getAttrs := [:start|				idx := start.				[(curr getSystemAttribute: idx) isNil and: [idx - start < 10]] whileTrue:					[idx := idx + 1].				[a := curr getSystemAttribute: idx.				a notNil] whileTrue:					[a notEmpty ifTrue: [args at: idx put: a].					 idx := idx + 1]].	idx := -1.	[a := curr getSystemAttribute: idx.	a notNil and: [a size > 0]]		whileTrue: [args at: idx put: a. idx := idx - 1].	getAttrs value: 0.	getAttrs value: 1000.	getAttrs value: 1200.	^ args! !!SystemDictionary methodsFor: 'special objects' stamp: 'eem 4/18/2008 14:48'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	 Squeak virtual machine. Its contents are critical and unchecked, so	 don't even think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 55.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray		at: 4		put: (self associationAt: #Processor).	"Numerous classes below used for type checking and	instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray		at: 18		put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	"The process that signaled the low space semaphore."	newArray at: 23 put: nil.	"An array of the 32 selectors that are compiled as special	bytecodes, paired alternately with the number of arguments	each takes."	newArray at: 24 put: #(#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1 #* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0 #blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order."	newArray		at: 25		put: ((0 to: 255)				collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have	compact headers"	newArray at: 29 put: self compactClassesArray.	newArray		at: 30		put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray		at: 31		put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray		at: 32		put: (Float new: 2).	newArray		at: 33		put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context	prototypes"	newArray		at: 36		put: (self specialObjectsArray at: 36).	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 37 put: nil.	newArray		at: 38		put: (self specialObjectsArray at: 38).	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 39 put: Array new.	"array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"finalization Semaphore"	newArray		at: 42		put: ((self specialObjectsArray at: 42)				ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	Note: Written so that one can actually completely remove the	FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	newArray at: 51 put: #attemptToAssign:withIndex:.	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found').	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Now replace the interpreter's reference in one atomic	operation"	self specialObjectsArray become: newArray! !!ClassDescription methodsFor: 'initialize-release' stamp: 'eem 9/12/2007 14:50'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	[self isImmutable: false] on: Error do: [:ex| self flag: #BOGUS].	self organization: nil.	super obsolete.! !!Class methodsFor: 'initialize-release' stamp: 'eem 9/12/2007 14:49'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	[self isImmutable: false] on: Error do: [:ex| self flag: #BOGUS].	self setName: 'AnObsolete' , self name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !NoModificationError initialize!"Postscript:Add attemptToAssign:index: to the specialObjectsArray"Smalltalk recreateSpecialObjectsArray!
"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From nsboot-2008-04-29.00 of 29 April 2008 [latest update: #0] on 29 April 2008 at 8:17:49 pm'!!CompiledMethod methodsFor: 'printing' stamp: 'eem 7/13/2007 17:13'!primitiveErrorVariableName	"Just answer the first.  Where should we validate that there's only one error name?"	self properties pragmas do:		[:pragma| | kws |		kws := pragma keyword keywords.		(kws size >= 2		 and: [kws first = 'primitive:'		 and: [kws second = 'error:']]) ifTrue:			[^pragma argumentAt: 2]].	^nil! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 7/13/2007 17:10'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex := self primitive.	primIndex = 0 ifTrue:[^self].	primIndex = 120 ifTrue:"External call spec"		[^aStream print: (self literalAt: 1); cr].	aStream nextPutAll: '<primitive: '.	primIndex = 117		ifTrue:			[primDecl := self literalAt: 1.			 aStream nextPut: $'; nextPutAll: (primDecl at: 2); nextPut: $']		ifFalse: [aStream print: primIndex].	self primitiveErrorVariableName notNil ifTrue:		[aStream nextPutAll: ' error: '; nextPutAll: self primitiveErrorVariableName].	primIndex = 117 ifTrue:		 [primDecl first notNil ifTrue:			[aStream				nextPutAll: ' module:';				nextPut: $';				nextPutAll: primDecl first;				nextPut: $']].	aStream nextPut: $>; cr! !!Decompiler methodsFor: 'private' stamp: 'eem 7/13/2007 17:09'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block node |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			super method: method pc: method initialPC.			"skip primitive error code store if necessary"			(method primitive ~= 0 and: [self willStore]) ifTrue:				[pc := pc + 2.				 tempVars := tempVars asOrderedCollection].			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	node := constructor		codeMethod: aSelector		block: block		tempVars: tempVars		primitive: method primitive		class: aClass.	method primitive > 0 ifTrue:		[node removeAndRenameLastTempIfErrorCode].	^node! !!Encoder methodsFor: 'temps' stamp: 'eem 7/13/2007 14:15'!fixTemp: name	| node |	node := scopeTable at: name ifAbsent: [].	node class ~~ TempVariableNode ifTrue:		[self error: 'can only fix a floating temp var'].	node code: (node code: nTemps type: LdTempType).	nTemps := nTemps + 1.	^node! !!Encoder methodsFor: 'temps' stamp: 'eem 7/13/2007 14:13'!floatTemp: node	(node ~~ (scopeTable at: node name ifAbsent: [])	or: [node class ~~ TempVariableNode	or: [node code ~= (node code: nTemps - 1 type: LdTempType)]]) ifTrue:		[self error: 'can only float the last allocated temp var'].	nTemps := nTemps - 1! !!Encoder methodsFor: 'temps' stamp: 'eem 7/13/2007 13:50'!floatingTemp: name	^scopeTable		at: name		put: (TempVariableNode new				name: name				index: nil				type: LdTempType				scope: 0)! !!MethodNode methodsFor: 'accessing' stamp: 'eem 7/9/2007 16:49'!primitiveErrorVariableName	"Just answer the first.  Where should we validate that there's only one error name?"	(primitive notNil and: [primitive > 0]) ifTrue:		[properties pragmas do:			[:pragma| | kws |			kws := pragma keyword keywords.			(kws size >= 2			 and: [kws first = 'primitive:'			 and: [kws second = 'error:']]) ifTrue:				[^pragma argumentAt: 2]]].	^nil	"(Parser new parse: (MethodNode sourceCodeAt: #primitiveErrorVariableName) class: Parser) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: ''foo''> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: foo> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: foo> self primitiveFailed' class: Object) generate"! !!MethodNode methodsFor: 'code generation' stamp: 'eem 7/13/2007 14:00'!generateWith: trailer using: aCompiledMethodClass	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize method nArgs nLits primErrNode stack strm |	self generate: trailer ifQuick: 		[:m |  method := m.		method properties: properties.		^ method].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	nArgs := arguments size.	blkSize := (block sizeForEvaluatedValue: encoder)				+ (primErrNode ifNil: [0] ifNotNil: [2 "We force store-long (129)"]).	literals := encoder allLiterals.	nLits := literals size.	method := aCompiledMethodClass	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm := ReadWriteStream with: method.	strm position: method initialPC - 1.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitStore: stack on: strm].	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method properties: properties.	^ method! !!MethodNode methodsFor: 'printing' stamp: 'eem 1/2/2008 18:11'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '|'.			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].				aStream nextPutAll: ' |'].	properties ifNotNil: [ 		properties pragmas do: [ :each |			"Don't decompile basic primitives that return self, i-vars, etc."			each keyword keywords first = 'primitive:'				ifFalse: [ aStream crtab: 1. each printOn: aStream ]				ifTrue: [					((each argumentAt: 1) isInteger					 and: [(each argumentAt: 1) between: 255 and: 519])						ifFalse: [ aStream crtab: 1. self printPrimitiveOn: aStream ] ] ] ].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'printing' stamp: 'eem 7/13/2007 16:50'!printPrimitiveOn: aStream 	"Print the primitive on aStream"	| primIndex primDecl |	primIndex := primitive.	primIndex = 0 ifTrue: [^ self].	primIndex = 120 ifTrue: "External call spec"		[^ aStream print: encoder literals first].	aStream nextPutAll: '<primitive: '.	primIndex = 117		ifTrue:			[primDecl := encoder literals at: 1.			 aStream nextPut: $'; nextPutAll: (primDecl at: 2); nextPut: $']		ifFalse: [aStream print: primIndex].	self primitiveErrorVariableName notNil ifTrue:		[aStream nextPutAll: ' error: '; nextPutAll: self primitiveErrorVariableName].	primIndex = 117 ifTrue:		 [primDecl first notNil ifTrue:			[aStream				nextPutAll: ' module:';				nextPut: $';				nextPutAll: primDecl first;				nextPut: $']].	aStream nextPut: $>.	Smalltalk at: #Interpreter ifPresent:[:cls|		aStream nextPutAll: ' "'				, ((cls classPool at: #PrimitiveTable)						at: primIndex + 1) , '" ']! !!MethodNode methodsFor: 'primitive error codes' stamp: 'eem 7/13/2007 17:08'!removeAndRenameLastTempIfErrorCode	self primitiveErrorVariableName ifNotNil:		[temporaries last name: self primitiveErrorVariableName.		 temporaries removeLast].! !!Parser methodsFor: 'pragmas' stamp: 'eem 7/9/2007 16:20'!pragmaLiteral: selectorSoFar	"Read a pragma literal.  As a nicety we allow a variable name (rather	 than a literal string) as the second argument to primitive:error:"	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	((selectorSoFar = 'primitive:error:') and: [hereType == #word]) ifTrue:		[^self advance].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'eem 7/9/2007 16:20'!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: (self pragmaLiteral: selector) ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'primitives' stamp: 'eem 7/9/2007 16:48'!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ self primitive: anIntegerOrString error: nil! !!Parser methodsFor: 'primitives' stamp: 'eem 7/13/2007 14:17'!primitive: anIntegerOrString error: errorCodeVariableOrNil	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue:			[errorCodeVariableOrNil ifNotNil:				[encoder floatTemp: (encoder bindTemp: errorCodeVariableOrNil) nowHasDef].			 anIntegerOrString]		ifFalse:			[anIntegerOrString isString				ifTrue: [self primitive: anIntegerOrString error: errorCodeVariableOrNil module: nil]				ifFalse: [self expected: 'Indexed primitive']]! !!Parser methodsFor: 'primitives' stamp: 'eem 7/13/2007 14:17'!primitive: aNameString error: errorCodeVariableOrNil module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	errorCodeVariableOrNil ifNotNil:		[encoder floatTemp: (encoder bindTemp: errorCodeVariableOrNil) nowHasDef].	^ 117! !!Parser methodsFor: 'primitives' stamp: 'eem 7/9/2007 16:47'!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	^self primitive: aNameString error: nil module: aModuleStringOrNil! !!Pragma methodsFor: 'accessing-pragma' stamp: 'eem 7/9/2007 15:41'!keyword	"Answer the keyword of the recieving pragma. For a pragma defined as <key1: val1 key2: val2> this will answer #key1:key2:."		^ keyword! !!SystemDictionary methodsFor: 'special objects' stamp: 'eem 4/18/2008 14:48'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	 Squeak virtual machine. Its contents are critical and unchecked, so	 don't even think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 55.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray		at: 4		put: (self associationAt: #Processor).	"Numerous classes below used for type checking and	instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray		at: 18		put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	"The process that signaled the low space semaphore."	newArray at: 23 put: nil.	"An array of the 32 selectors that are compiled as special	bytecodes, paired alternately with the number of arguments	each takes."	newArray at: 24 put: #(#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1 #* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0 #blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order."	newArray		at: 25		put: ((0 to: 255)				collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have	compact headers"	newArray at: 29 put: self compactClassesArray.	newArray		at: 30		put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray		at: 31		put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray		at: 32		put: (Float new: 2).	newArray		at: 33		put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context	prototypes"	newArray		at: 36		put: (self specialObjectsArray at: 36).	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 37 put: nil.	newArray		at: 38		put: (self specialObjectsArray at: 38).	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 39 put: Array new.	"array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"finalization Semaphore"	newArray		at: 42		put: ((self specialObjectsArray at: 42)				ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	Note: Written so that one can actually completely remove the	FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	newArray at: 51 put: #attemptToAssign:withIndex:.	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found').	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Now replace the interpreter's reference in one atomic	operation"	self specialObjectsArray become: newArray! !Parser removeSelector: #pragmaLiteral!CompiledMethod removeSelector: #primitiveNode!PrimitiveNode removeFromSystem!
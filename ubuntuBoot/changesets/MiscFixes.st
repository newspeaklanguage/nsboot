"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From nsboot-2008-04-08.00 of 8 April 2008 [latest update: #0] on 9 April 2008 at 10:50:57 am'!!SystemNavigation methodsFor: 'query' stamp: 'eem 3/22/2007 11:53'!allSelect: aBlock 	"Answer a SortedCollection of each method that, when used	 as the block argument to aBlock, gives a true result."	| aCollection |	aCollection := SortedCollection new.	Cursor execute showWhile:		[self allBehaviorsDo:			[:class |			class selectorsDo:				[:sel |				(aBlock value: (class compiledMethodAt: sel)) ifTrue:					[aCollection add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!Preference methodsFor: 'debugging' stamp: 'eem 8/8/2007 16:51'!printOn: aStream	"Print a string decribing the receiver to the given stream"	super printOn: aStream.	aStream space; store: name; space; store: value! !!Categorizer methodsFor: 'accessing' stamp: 'GB 6/20/2007 12:49'!numberOfCategoryOfElement: element 	"Answer the index of the category with which the argument, element, is 	associated."	| categoryIndex elementIndex |	categoryIndex := 1.	elementIndex := 0.	[(elementIndex := elementIndex + 1) <= elementArray size]		whileTrue: 			["point to correct category"			[elementIndex > (categoryStops at: categoryIndex ifAbsent:[^0])]				whileTrue: [categoryIndex := categoryIndex + 1].			"see if this is element"			element = (elementArray at: elementIndex) ifTrue: [^categoryIndex]].	^0! !!Categorizer methodsFor: 'private' stamp: 'GB 6/20/2007 12:54'!basicRemoveElement: element 	"Remove the selector, element, from all categories."	| categoryIndex elementIndex nextStop newElements |	categoryIndex := 1.	elementIndex := 0.	nextStop := 0.	"nextStop keeps track of the stops in the new element array"	newElements := WriteStream on: (Array new: elementArray size).	[(elementIndex := elementIndex + 1) <= elementArray size]		whileTrue: 			[[elementIndex > (categoryStops at: categoryIndex ifAbsent:[^self])]				whileTrue: 					[categoryStops at: categoryIndex put: nextStop.					categoryIndex := categoryIndex + 1].			(elementArray at: elementIndex) = element				ifFalse: 					[nextStop := nextStop + 1.					newElements nextPut: (elementArray at: elementIndex)]].	[categoryIndex <= categoryStops size]		whileTrue: 			[categoryStops at: categoryIndex put: nextStop.			categoryIndex := categoryIndex + 1].	elementArray := newElements contents.	self assertInvariant.! !
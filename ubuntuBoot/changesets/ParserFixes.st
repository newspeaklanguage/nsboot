"
   Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.squeak.org/SqueakLicense/
"!
'From Squeak3.9 of 7 November 2006 [latest update: #7067] on 1 May 2007 at 11:59:57 am'!"NOTE: THE FILE-OUT IS HAND-EDITED TO HAVE THE FOLLOWING METHOD FILE IN FIRST." !!Parser methodsFor: 'private' stamp: 'vb 5/1/2007 11:59'!parseBinarySelector	"Because a vertical bar parses as a token of its own and not a binary selector, a binary selector that contains a vertical bar will parse as a sequence of binaries and vertical bars. We need to allow for that and have that sequence coalesce into a single selector. Note that per classic ST-80 interpretation a minus is not a valid component of a multi-character selector."	| selector |	selector := self advance asOctetString.	[(hereType == #binary and: [here ~= #-]) or: [hereType == #verticalBar]]		whileTrue: [selector := selector, self advance asOctetString].	^selector asSymbol! !!Parser methodsFor: 'expression types' stamp: 'vb 5/1/2007 10:59'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart |	[receiver := parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start := self startOfNextToken.			selector := WriteStream on: (String new: 32).			args := OrderedCollection new.			words := OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart := self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])				ifFalse: [ selector := self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence := 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start := self startOfNextToken.					selector := self parseBinarySelector.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args := Array with: parseNode.					precedence := 2]				ifFalse: [hereType == #word						ifTrue: 							[start := self startOfNextToken.							selector := self advance.							args := #().							words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])								ifFalse: [ selector := self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence := 1]						ifFalse: [^args notNil]]].	parseNode := MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!Parser methodsFor: 'expression types' stamp: 'vb 5/1/2007 11:20'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>  	{selector, arguments, precedence}."	| args selector |	doitFlag := fromDoit.	fromDoit ifTrue:			[ctxt == nil				ifTrue: [^ {#DoIt. {}. 1}]				ifFalse: [^ {#DoItIn:. {encoder encodeVariable: 'homeContext'}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector := self parseBinarySelector.			args := Array with: (encoder bindArg: self argumentName).			^ {selector. args. 2}].	hereType == #keyword		ifTrue: 			[selector := WriteStream on: (String new: 32).			args := OrderedCollection new.			[hereType == #keyword] whileTrue:[				selector nextPutAll: self advance.				args addLast: (encoder bindArg: self argumentName).			].			^ {selector contents asSymbol. args. 3}].	^ self expected: 'Message pattern'! !!Compiler methodsFor: 'public access' stamp: 'GB 8/17/2007 13:12'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value toLog itsSelectionString itsSelection |	class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	method selector ifNil: [method selector: (aContext isNil ifTrue: [#DoIt] ifFalse: [#DoItIn:])].	"self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ]."	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  and:			[(itsSelection := requestor selection) notNil] and:			[(itsSelectionString := itsSelection asString) isEmptyOrNil not] )			ifTrue: 				[itsSelectionString]			ifFalse:				[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext ].	^ value.! !!Encoder methodsFor: 'temps' stamp: 'GB 3/29/2007 10:58'!bindTemp: name in: methodSelector	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp or:[requestor interactive])			ifTrue:[^self notify:'Name ', name, ' is already defined']			ifFalse:[Transcript 				show: '(', name, ' is shadowed in "' , class printString , '>>' , methodSelector printString , '")']].	^self reallyBind: name! !!Encoder methodsFor: 'temps' stamp: 'GB 6/12/2007 14:20'!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node := scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [self notify: 'Name already used in a Pool or Global'].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name ', name, ' already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name ', name, ' already used in this class'].	^node! !!Encoder methodsFor: 'temps' stamp: 'GB 6/12/2007 14:19'!bindBlockTemp: name 	"Declare a temporary block variable; complain if it's not a field or class variable."	| node |	node := scopeTable at: name ifAbsent: [^self reallyBind: name].	node isTemp		ifTrue: [			node scope >= 0 ifTrue: [^ self notify: 'Name ', name, ' already used in this method'].			node scope: 0]		ifFalse: [^self notify: 'Name ', name, ' already used in this class'].	^node! !!Encoder methodsFor: 'temps' stamp: 'GB 6/12/2007 14:19'!bindTemp: name 	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp or:[requestor interactive])			ifTrue:[^self notify:'Name ', name, ' is already defined']			ifFalse:[Transcript 				show: '(', name, ' is shadowed in "' , class printString, '")']].	^self reallyBind: name! !!Scanner methodsFor: 'public access' stamp: 'AHE 7/20/2007 11:24'!scanFieldNames: stringOrArray	"Answer an Array of Strings that are the identifiers in the input string, 	stringOrArray. If passed an Array, just answer with that Array, i.e., 	assume it has already been scanned."	(stringOrArray isMemberOf: Array)		ifTrue: [^stringOrArray].	^(stringOrArray findTokens: Character separators) asArray.		"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )"! !!Parser methodsFor: 'error handling' stamp: 'eem 3/9/2007 12:17'!notify: string at: location	requestor isNil		ifTrue: [(encoder == self or: [encoder isNil]) ifTrue: [^ self fail  "failure setting up syntax error"].				SyntaxErrorNotification					inClass: encoder classEncoding					category: encoder classEncoding theNonMetaClass category					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !"NOTE: THE FILE-OUT IS HAND-EDITED TO HAVE THE FOLLOWING pasrserClass/defaultParserClass methods FILE IN IN THIS PARTICULAR ORDER." !!Compiler class methodsFor: 'accessing' stamp: 'Ahe 8/23/2007 15:20'!defaultParserClass	"Return a parser class to use for parsing method headers."	^Parser! !!Compiler class methodsFor: 'accessing' stamp: 'Ahe 8/23/2007 15:21'!new	^ super new parserClass: self defaultParserClass! !!Behavior methodsFor: 'compiling' stamp: 'Ahe 8/23/2007 15:21'!parserClass	"Answer a parser class to use for parsing method headers."	^self compilerClass new parserClass! !!PseudoClass methodsFor: 'private' stamp: 'Ahe 8/23/2007 15:22'!parserClass	^ Compiler defaultParserClass! !!UndefinedObject methodsFor: 'compiling' stamp: 'eem 9/12/2007 14:51'!parserClass	self halt. "We think this is superfluous.  No news is good news..."	self flag: #BOGUS.	^Compiler defaultParserClass! !(Smalltalk includesKey: #LanguageCompiler) ifTrue:	[(Smalltalk at: #LanguageCompiler) class removeSelector: #parserClass]!Compiler class removeSelector: #parserClass!
'From Squeak4.3 of 22 December 2011 [latest update: #11860] on 15 March 2013 at 2:49:35 pm'!!PackageInfo methodsFor: 'testing' stamp: 'bootstrapping 3/15/2013 14:49'!changeRecordForOverriddenMethod: aMethodReference	| method position file prevPos prevFileIndex chunk stamp methodCategory tokens |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	method fileIndex = 0 ifTrue: [^ nil].	file := CurrentReadOnlySourceFiles at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := SourceFiles fileIndexFromSourcePointer: prevPos.						prevPos := SourceFiles filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		(self isOverrideCategory: methodCategory) ifFalse: [^nil].		position := prevPos.		prevPos notNil ifTrue:			[file := CurrentReadOnlySourceFiles at: prevFileIndex]].		^ nil	! !
'From Squeak4.2 of 4 February 2011 [latest update: #10966] on 22 June 2011 at 9:38:22 am'!DebuggerMethodMap subclass: #DebuggerMethodMapForNewspeak	instanceVariableNames: 'debugInfo'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!LookupKey commentStamp: '<historical>' prior: 0!I represent a key for looking up entries in a data structure. Subclasses of me, such as Association, typically represent dictionary entries.!Object subclass: #MethodProperties	instanceVariableNames: 'properties pragmas selector'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!MethodProperties commentStamp: 'lr 2/6/2006 19:31' prior: 0!I am class holding state for compiled methods. All my instance variables should be actually part of the CompiledMethod itself, but the current implementation of the VM doesn't allow this.I am a compact class and optimized for size and speed, since every CompiledMethod points onto an instance of myself. I am mostly polymorphic to the protocol of an identity-dictionary, so that key-value pairs can be easily stored and retreived without the need to add new variables. However keep in mind that instantiating a dictionary consumes much more memory than adding an instance-variable, so it might be clever to add a new variable if the property is going to be used by every compiled method.!!RemoteString commentStamp: '<historical>' prior: 0!My instances provide an external file reference to a piece of text.  It may be the sourceCode of a method, or the class comments of a class.The changes file or file-in file usually has a chunk that is just the source string of a method:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!I can return either a String or a Text.  Some a chunk is followed by a second chunk (beginning with ]style[) containing style information.  The encoding is like this:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!]style[(14 50 312)f1,f1b,f1LInteger +;i!!Allowed TextAttributes are TextFontChange, TextEmphasis, TextColor, TextDoIt, TextKern, TextLink, TextURL.  TextFontReference and TextAnchor are not supported.See PositionableStream nextChunkText and RunArray class scanFrom:.!]style[(748 32 5 24 1)f1,f1LPositionableStream nextChunkText;,f1,f1LRunArray class scanFrom:;,f1!!Object methodsFor: 'error handling' stamp: 'ryan 6/17/2011 15:06'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given	  message to the receiver but the receiver does not understand	  this message (typically sent from the machine when a message	 is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	| exception resumeValue |	(Preferences autoAccessors	 and: [self tryToDefineVariableAccess: aMessage]) ifTrue:		[^aMessage sentTo: self].		(aMessage selector startsWith: 'initializer`') ifTrue: [ 		"Coerce NS3 name-managled instance initializer to un-managled NS2 couterpart so NS3 can subclass NS2."		aMessage setSelector: (aMessage selector allButFirst: 12) asSymbol.		^aMessage sentTo: self.	].	(exception := MessageNotUnderstood new)		message: aMessage;		receiver: self.	resumeValue := exception signal.	^exception reachedDefaultHandler		ifTrue: [aMessage sentTo: self]		ifFalse: [resumeValue]! !!Object methodsFor: 'printing' stamp: 'ryan 6/17/2011 16:18'!out	Transcript cr; show: self printString! !!Object methodsFor: 'testing' stamp: 'ryan 6/21/2011 09:39'!isKindOfCharacter	^false! !!Object methodsFor: 'testing' stamp: 'ryan 6/21/2011 09:39'!isKindOfCollection	^false! !!Object methodsFor: 'testing' stamp: 'ryan 6/21/2011 09:40'!isKindOfCombinatorialParser	^false! !!ClassBuilder methodsFor: 'private' stamp: 'ryan 6/17/2011 13:23'!informUserOfActivity: activity "<String>" during: aBlock	^aBlock value! !!ClassDescription methodsFor: 'instance variables' stamp: 'ryan 6/17/2011 12:55'!instVarIndexFor: instVarName	"Answer the index of the named instance variable."	| index |	index := instanceVariables == nil 		ifTrue: [0]		ifFalse: [instanceVariables indexOf: instVarName].	index == 0 ifTrue: 		[^superclass == nil 			ifTrue: [0]			ifFalse: [superclass instVarIndexFor: instVarName]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!ClassDescription methodsFor: 'instance variables' stamp: 'ryan 6/17/2011 12:55'!instVarIndexFor: instVarName ifAbsent: aBlock	"Answer the index of the named instance variable."	| index |	index := instanceVariables == nil 		ifTrue: [0]		ifFalse: [instanceVariables indexOf: instVarName].	index == 0 ifTrue: 		[^superclass == nil 			ifTrue: [aBlock value]			ifFalse: [superclass instVarIndexFor: instVarName ifAbsent: aBlock]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ryan 6/17/2011 12:56'!weakSubclassesDo: block "<[Class]>"	^nil = metadata		ifFalse: [metadata weakSubclassesOf: self do: block]! !!Class methodsFor: 'organization' stamp: 'ryan 6/17/2011 14:10'!basicCategory	^category! !!Class methodsFor: 'organization' stamp: 'ryan 6/17/2011 14:10'!basicCategory: aSymbol	category := aSymbol! !!ClassOrganizer methodsFor: 'accessing' stamp: 'ryan 6/17/2011 15:57'!quietlyClassify: element under: heading	| oldCat newCat |	oldCat := self categoryOfElement: element.	SystemChangeNotifier uniqueInstance doSilently: [		super classify: element under: heading suppressIfDefault: true].	newCat := self categoryOfElement: element.! !!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'ryan 6/21/2011 10:19'!forMethod: aMethod "<CompiledMethod>" methodNode: methodNode "<MethodNode>"	"Uncached instance creation method for private use or for tests.	 Please consider using forMethod: instead."		|	implementationClass	|		([aMethod methodClass language isNewspeakLanguage3] ifError: [false]) ifTrue: [		implementationClass := DebuggerMethodMapForNewspeak.	] ifFalse: [		implementationClass := aMethod isBlueBookCompiled ifTrue: [			DebuggerMethodMapForBlueBookMethods		] ifFalse: [			DebuggerMethodMapForClosureCompiledMethods		]	].		^implementationClass new		forMethod: aMethod		methodNode: methodNode! !!DebuggerMethodMapForNewspeak methodsFor: 'as yet unclassified' stamp: 'ryan 6/21/2011 10:21'!forMethod: aMethod "<CompiledMethod>" methodNode: aMethodNode "<MethodNode>"	|	mixinMirror	lowLevelMethodMirror	|	super forMethod: aMethod methodNode: aMethodNode.	mixinMirror := Platform nsPlatform mirrors MixinMirror reflecting: self method methodClass mixin.	lowLevelMethodMirror := Platform nsPlatform mirrors compiler compileMethodSource: self method getSource readStream within: mixinMirror declaration.	debugInfo := lowLevelMethodMirror debugInfo.	! !!DebuggerMethodMapForNewspeak methodsFor: 'accessing' stamp: 'ryan 6/21/2011 10:11'!namedTempAt: index in: aContext	|	mapper	names	|	mapper := debugInfo mapperForContext: aContext.	names := mapper localNames.	^[mapper getValueOf: (names at: index)] ifError: ['<could not retrieve>'].		! !!DebuggerMethodMapForNewspeak methodsFor: 'accessing' stamp: 'ryan 6/21/2011 10:06'!tempNamesForContext: aContext	
	^(debugInfo mapperForContext: aContext ) localNames! !!DebuggerMethodMapForNewspeak methodsFor: 'source mapping' stamp: 'ryan 6/21/2011 10:16'!rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext	^debugInfo sourceMapping at: contextsConcretePC ifAbsent: [1 to: 2]! !!Dictionary methodsFor: 'enumerating' stamp: 'ul 9/30/2009 14:14'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."		| newCollection |	newCollection := self species new: self size.	self associationsDo: [ :each |		newCollection at: each key put: (aBlock value: each value) ].	^newCollection! !!Exception methodsFor: 'printing' stamp: 'ryan 6/22/2011 09:37'!kind	^self class name asString! !!LookupKey methodsFor: 'accessing' stamp: 'ajh 9/12/2002 12:04'!canAssign	^ true! !!LookupKey methodsFor: 'accessing'!key	"Answer the lookup key of the receiver."	^key! !!LookupKey methodsFor: 'accessing'!key: anObject 	"Store the argument, anObject, as the lookup key of the receiver."	key _ anObject! !!LookupKey methodsFor: 'accessing' stamp: 'ajh 3/24/2003 21:14'!name	^ self key isString		ifTrue: [self key]		ifFalse: [self key printString]! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:59'!beBindingOfType: aClass announcing: aBool	"Make the receiver a global binding of the given type"	| old new |	(Smalltalk associationAt: self key) == self		ifFalse:[^self error:'Not a global variable binding'].	self class == aClass ifTrue:[^self].	old _ self.	new _ aClass key: self key value: self value.	old become: new.	"NOTE: Now self == read-only (e.g., the new binding)"	^self recompileBindingsAnnouncing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadOnlyBinding	"Make the receiver (a global read-write binding) be a read-only binding"	^self beReadOnlyBindingAnnouncing: true! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadOnlyBindingAnnouncing: aBool	"Make the receiver (a global read-write binding) be a read-only binding"	^self beBindingOfType: ReadOnlyVariableBinding announcing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadWriteBinding	"Make the receiver (a global read-only binding) be a read-write binding"	^self beReadWriteBindingAnnouncing: true! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:51'!beReadWriteBindingAnnouncing: aBool	"Make the receiver (a global read-write binding) be a read-write binding"	^self beBindingOfType: Association announcing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'dvf 8/23/2003 11:50'!recompileBindingsAnnouncing: aBool 	"Make the receiver (a global read-write binding) be a read-only binding"	aBool 		ifTrue: 			[Utilities informUserDuring: 					[:bar | 					(self systemNavigation allCallsOn: self) do: 							[:mref | 							bar value: 'Recompiling ' , mref asStringOrText.							mref actualClass recompile: mref methodSymbol]]]		ifFalse: 			[(self systemNavigation allCallsOn: self) 				do: [:mref | mref actualClass recompile: mref methodSymbol]]! !!LookupKey methodsFor: 'comparing'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^key < aLookupKey key! !!LookupKey methodsFor: 'comparing'!= aLookupKey	self species = aLookupKey species		ifTrue: [^key = aLookupKey key]		ifFalse: [^false]! !!LookupKey methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^key hash! !!LookupKey methodsFor: 'comparing'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^key hashMappedBy: map! !!LookupKey methodsFor: 'comparing' stamp: 'di 9/27/97 20:45'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ key identityHashMappedBy: map! !!LookupKey methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 02:35'!writeOnFilterStream: aStream	aStream write:key.! !!LookupKey methodsFor: 'printing'!printOn: aStream	key printOn: aStream! !!LookupKey methodsFor: 'testing' stamp: 'ar 8/14/2001 22:39'!isVariableBinding	"Return true if I represent a literal variable binding"	^true! !!LookupKey class methodsFor: 'instance creation' stamp: 'md 6/29/2005 16:34'!key: aKey 	"Answer an instance of me with the argument as the lookup up."	^self basicNew key: aKey! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ryan 6/20/2011 09:25'!snapshot	| packageInfo definitions categories |	packageInfo := self packageInfo.	definitions := OrderedCollection new.	categories := packageInfo systemCategories.	categories isEmpty ifFalse: [ definitions add: (MCOrganizationDefinition categories: categories) ].	(packageInfo methods		reject: [:ea | [ea methodClass language isNewspeakLanguage3]ifError:[false]])		do: [:ea | definitions add: ea asMethodDefinition] displayingProgress: 'Snapshotting methods...'.	(packageInfo respondsTo: #overriddenMethods) ifTrue:		[packageInfo overriddenMethods			do: [:ea | definitions add:					(packageInfo changeRecordForOverriddenMethod: ea) asMethodDefinition]			displayingProgress: 'Searching for overrides...'].	packageInfo classes do: [:ea | definitions addAll: ea classDefinitions] displayingProgress: 'Snapshotting classes...'.	(packageInfo respondsTo: #hasPreamble) ifTrue: [		packageInfo hasPreamble ifTrue: [definitions add: (MCPreambleDefinition from: packageInfo)].		packageInfo hasPostscript ifTrue: [definitions add: (MCPostscriptDefinition from: packageInfo)].		packageInfo hasPreambleOfRemoval ifTrue: [definitions add: (MCRemovalPreambleDefinition from: packageInfo)].		packageInfo hasPostscriptOfRemoval ifTrue: [definitions add: (MCRemovalPostscriptDefinition from: packageInfo)]]. 	^ MCSnapshot fromDefinitions: definitions! !!MethodProperties methodsFor: 'accessing' stamp: 'lr 2/6/2006 19:11'!pragmas	^ pragmas! !!MethodProperties methodsFor: 'accessing' stamp: 'md 2/16/2006 17:50'!selector	^selector! !!MethodProperties methodsFor: 'accessing' stamp: 'md 2/16/2006 17:50'!selector: aSymbol	selector := aSymbol! !!MethodProperties methodsFor: 'initialization' stamp: 'lr 2/6/2006 19:12'!initialize	super initialize.	pragmas := #().! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:04'!at: aKey	"Answer the property value associated with aKey."		^ self at: aKey ifAbsent: [ self error: 'Property not found' ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:07'!at: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		properties isNil ifTrue: [ ^ aBlock value ].	^ properties at: aKey ifAbsent: aBlock.! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 20:47'!at: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self at: aKey ifAbsent: [ self at: aKey put: aBlock value ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:06'!at: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	properties ifNil: [ properties :=  IdentityDictionary new ].	^ properties at: aKey put: anObject.! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:11'!includesKey: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 20:48'!removeKey: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeKey: aKey ifAbsent: [ self error: 'Property not found' ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:07'!removeKey: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer.! !!MethodProperties methodsFor: 'private' stamp: 'lr 2/6/2006 20:36'!addPragma: aPragma	pragmas := pragmas copyWith: aPragma.! !!MethodProperties methodsFor: 'testing' stamp: 'ryan 6/17/2011 15:49'!isEmpty	^true "just a selector"! !!MethodProperties methodsFor: 'testing' stamp: 'md 2/19/2006 11:24'!isMethodProperties	^true! !!MethodProperties methodsFor: 'copying' stamp: 'md 3/1/2006 15:30'!postCopy	properties := properties copy.	pragmas := pragmas copy.! !!MethodReference methodsFor: 'testing' stamp: 'ryan 6/20/2011 09:27'!isValid	"Answer whether the receiver represents a current selector or Comment"	| aClass |	methodSymbol isDoIt ifTrue: [^ false].	(aClass := self actualClass) ifNil: [^ false].	([self compiledMethod isSynthetic] ifError: [false]) ifTrue: [^false].	^ (aClass includesSelector: methodSymbol) or:		[methodSymbol == #Comment]! !!Number methodsFor: 'arithmetic' stamp: 'ryan 6/17/2011 15:08'!** n	^self raisedToInteger: n! !!PackageInfo methodsFor: 'listing' stamp: 'ryan 6/20/2011 09:23'!classes				^ (self systemCategories gather: [ :cat |	(SystemOrganization listAtCategoryNamed: cat)		gather: [ :className | | classes |			classes := OrderedCollection new.			Smalltalk at: className ifPresent: [ :c | classes add: c]. 			classes		]	]) sortBy: [:a :b | a className <= b className].! !!Project methodsFor: 'accessing' stamp: 'ryan 6/20/2011 11:15'!uiManager: m	uiManager := m! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ajh 9/12/2002 12:06'!canAssign	^ false! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/14/2001 23:09'!value	^value! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/17/2001 18:03'!value: aValue	(AttemptToWriteReadOnlyGlobal signal: 'Cannot store into read-only bindings') == true ifTrue:[		value _ aValue.	].! !!ReadOnlyVariableBinding methodsFor: 'testing' stamp: 'ar 8/14/2001 23:08'!isSpecialWriteBinding	"Return true if this variable binding is write protected, e.g., should not be accessed primitively but rather by sending #value: messages"	^true! !!ReadOnlyVariableBinding methodsFor: 'private' stamp: 'ar 8/14/2001 23:11'!privateSetKey: aKey value: aValue	key _ aKey.	value _ aValue! !!ReadOnlyVariableBinding methodsFor: 'printing' stamp: 'GB 5/8/2007 10:44'!printOn: aStream 	super printOn: aStream. 	aStream nextPutAll: '->'.	value printOn: aStream! !!ReadOnlyVariableBinding class methodsFor: 'instance creation' stamp: 'ar 8/14/2001 23:11'!key: key value: aValue	^self new privateSetKey: key value: aValue! !!RemoteString methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:32'!fileStream 	"Answer the file stream with position set at the beginning of my string"	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile := SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile! !!RemoteString methodsFor: 'accessing' stamp: 'nk 11/26/2002 12:05'!last	^self string ifNotNilDo: [ :s | s last ]! !!RemoteString methodsFor: 'accessing'!position 	"Answer the location of the string on a file."	^ filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:31'!setSourcePointer: aSourcePointer	sourceFileNumber := SourceFiles fileIndexFromSourcePointer: aSourcePointer.	filePositionHi := SourceFiles filePositionFromSourcePointer: aSourcePointer! !!RemoteString methodsFor: 'accessing'!sourceFileNumber	"Answer the index of the file on which the string is stored."	^sourceFileNumber! !!RemoteString methodsFor: 'accessing' stamp: 'hmm 4/26/2000 20:47'!sourcePointer	sourceFileNumber ifNil: [^ 0].	^SourceFiles sourcePointerFromFileIndex: sourceFileNumber andPosition: filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:31'!string 	"Answer the receiver's string if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^''].	theFile := SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunk! !!RemoteString methodsFor: 'accessing' stamp: 'ls 9/4/2003 12:37'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	theFile position > theFile size ifTrue: [		self error: 'RemoteString past end of file' ].	^ theFile nextChunkText! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:31'!checkSum: aString	"Construct a checksum of the string.  A three byte number represented as Base64 characters."| sum shift bytes ss bb |sum := aString size.shift := 0.aString do: [:char |	(shift := shift + 7) > 16 ifTrue: [shift := shift - 17].		"shift by 7 to keep a change of adjacent chars from xoring to same value"	sum := sum bitXor: (char asInteger bitShift: shift)].bytes := ByteArray new: 3.sum := sum + 16r10000000000.1 to: 3 do: [:ind | bytes at: ind put: (sum digitAt: ind)].ss := ReadWriteStream on: (ByteArray new: 3).ss nextPutAll: bytes.bb := Base64MimeConverter mimeEncode: ss.^ bb contents! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:32'!fileNumber: fileNumber position: position 	sourceFileNumber := fileNumber.	filePositionHi := position! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:31'!makeNewTextAttVersion	"Create a new TextAttributes version because some inst var has changed.  If no change, don't make a new one."	"Don't delete this method even though it has no callers!!!!!!!!!!"| obj cls struct tag |"Note that TextFontReference and TextAnchor are forbidden."obj := #(RunArray TextDoIt TextLink TextURL TextColor TextEmphasis TextFontChange TextKern TextLinkToImplementors 3 'a string') collect: [:each | 		cls := Smalltalk at: each ifAbsent: [nil].		cls ifNil: [each] ifNotNil: [cls new]].struct := (SmartRefStream on: (RWBinaryOrTextStream on: String new)) instVarInfo: obj.tag := self checkSum: struct printString.TextAttributeStructureVersions ifNil: [TextAttributeStructureVersions := Dictionary new].(struct = CurrentTextAttStructure) & (tag = CurrentTextAttVersion) 	ifTrue: [^ false].CurrentTextAttStructure := struct.CurrentTextAttVersion := tag.TextAttributeStructureVersions at: tag put: struct.^ true! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:32'!string: aString onFileNumber: fileNumber	"Store this as my string if source files exist."	| theFile |	(SourceFiles at: fileNumber) == nil ifFalse: 		[theFile := SourceFiles at: fileNumber.		theFile setToEnd; cr.		self string: aString onFileNumber: fileNumber toFile: theFile]! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:31'!string: aStringOrText onFileNumber: fileNumber toFile: aFileStream 	"Store this as the receiver's text if source files exist. If aStringOrText is a Text, store a marker with the string part, and then store the runs of TextAttributes in the next chunk."	| position |	position := aFileStream position.	self fileNumber: fileNumber position: position.	aFileStream nextChunkPutWithStyle: aStringOrText	"^ self		(important)"! !!RemoteString class methodsFor: 'as yet unclassified' stamp: 'tk 12/12/97 11:46'!currentTextAttVersion	"The current configuration of the TextAttributes classes has a structures array describing the inst vars of the classes (SmartRefStream instVarInfo:).  Return tag that indexes the TextAttributeStructureVersions dictionary (4 random characters)."	^ CurrentTextAttVersion	"Be sure to run makeNewTextAttVersion when any TextAttributes class changes inst vars"! !!RemoteString class methodsFor: 'as yet unclassified' stamp: 'tk 12/11/97 10:35'!initialize	"Derive the current TextAttributes classes object structure"	self new makeNewTextAttVersion! !!RemoteString class methodsFor: 'as yet unclassified'!newFileNumber: sourceIndex position: anInteger 	"Answer an instance of me fora file indexed by sourceIndex, at the 	position anInteger. Assume that the string is already stored on the file 	and the instance will be used to access it."	^self new fileNumber: sourceIndex position: anInteger! !!RemoteString class methodsFor: 'as yet unclassified'!newString: aString onFileNumber: sourceIndex 	"Answer an instance of me for string, aString, on file indexed by 	sourceIndex. Put the string on the file and create the remote reference."	^self new string: aString onFileNumber: sourceIndex! !!RemoteString class methodsFor: 'as yet unclassified'!newString: aString onFileNumber: sourceIndex toFile: aFileStream	"Answer an instance of me for string, aString, on file indexed by 	sourceIndex. Put the string on the file, aFileStream, and create the 	remote reference. Assume that the index corresponds properly to 	aFileStream."	^self new string: aString onFileNumber: sourceIndex toFile: aFileStream! !!RemoteString class methodsFor: 'as yet unclassified' stamp: 'tk 12/13/97 13:36'!structureAt: styleVersion	^ TextAttributeStructureVersions at: styleVersion ifAbsent: [nil]! !!SequenceableCollection methodsFor: 'testing' stamp: 'ryan 6/17/2011 14:12'!endsWith: aSequenceableCollection	| start |	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	start _ self size - aSequenceableCollection size.	aSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].	^true! !!SequenceableCollection methodsFor: 'testing' stamp: 'ryan 6/17/2011 14:12'!startsWith: start 	| comp |	self size < start size ifTrue: [^ false].	comp := true.	(self first: start size) with: start		do: [:ea :ea2 | ea = ea2 ifFalse: [comp := false]].	^ comp! !!Array methodsFor: 'converting' stamp: 'ryan 6/17/2011 15:56'!elementsForwardIdentityToEvenIfImmutable: otherArray	"This primitive performs a bulk mutation, causing all pointers to the	 elements of this array to be replaced by pointers to the corresponding	 elements of otherArray.  The identityHashes remain with the pointers	 rather than with the objects so that the objects in this array should	 still be properly indexed in any existing hashed structures after the	 mutation.  This version will succeed, even if any element of the receiver	 or otherArray is immutable.  See elementsForwardIdentityWith: for a	 more cautious approach."	<primitive: 161 error: ec>	"Backward compatibility.  If the VM doesnt implement this primitive	 then it doesnt support immutability.  So invoke the older version of	 the primitive."	^self elementsForwardIdentityTo: otherArray! !!CompiledMethod methodsFor: 'printing' stamp: 'ryan 6/20/2011 10:28'!methodClass: aClassOrNil	"set the class binding in the last literal to aClass"	self literalAt: self numLiterals put: (aClassOrNil ifNotNil: [aClassOrNil binding])! !!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ryan 6/17/2011 13:50'!associations	^globals associations! !!UIManager class methodsFor: 'class initialization' stamp: 'ryan 6/20/2011 11:15'!default: d	^ Project current uiManager: d! !!UUID class methodsFor: 'instance creation' stamp: 'ryan 6/17/2011 12:54'!fromString: aString	| object |	(aString includes: $@) ifTrue: [		^self fromString: (aString copyFrom: (aString indexOf: $')+1 to: (aString lastIndexOf: $')-1)	].	aString size ~= 36 ifTrue: [Error signal].	object := self nilUUID. 	object asUUID: aString.	^object! !RemoteString initialize!
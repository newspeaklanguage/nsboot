'From Squeak4.2 of 4 February 2011 [latest update: #10966] on 1 August 2011 at 8:55:56 am'!DebuggerMethodMap subclass: #DebuggerMethodMapForNewspeak	instanceVariableNames: 'debugInfo'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!LookupKey commentStamp: '<historical>' prior: 0!I represent a key for looking up entries in a data structure. Subclasses of me, such as Association, typically represent dictionary entries.!Object subclass: #MethodProperties	instanceVariableNames: 'properties pragmas selector'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!MethodProperties commentStamp: 'lr 2/6/2006 19:31' prior: 0!I am class holding state for compiled methods. All my instance variables should be actually part of the CompiledMethod itself, but the current implementation of the VM doesn't allow this.I am a compact class and optimized for size and speed, since every CompiledMethod points onto an instance of myself. I am mostly polymorphic to the protocol of an identity-dictionary, so that key-value pairs can be easily stored and retreived without the need to add new variables. However keep in mind that instantiating a dictionary consumes much more memory than adding an instance-variable, so it might be clever to add a new variable if the property is going to be used by every compiled method.!!RemoteString commentStamp: '<historical>' prior: 0!My instances provide an external file reference to a piece of text.  It may be the sourceCode of a method, or the class comments of a class.The changes file or file-in file usually has a chunk that is just the source string of a method:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!I can return either a String or a Text.  Some a chunk is followed by a second chunk (beginning with ]style[) containing style information.  The encoding is like this:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!]style[(14 50 312)f1,f1b,f1LInteger +;i!!Allowed TextAttributes are TextFontChange, TextEmphasis, TextColor, TextDoIt, TextKern, TextLink, TextURL.  TextFontReference and TextAnchor are not supported.See PositionableStream nextChunkText and RunArray class scanFrom:.!]style[(748 32 5 24 1)f1,f1LPositionableStream nextChunkText;,f1,f1LRunArray class scanFrom:;,f1!!Object methodsFor: 'error handling' stamp: 'ryan 6/17/2011 15:06'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given	  message to the receiver but the receiver does not understand	  this message (typically sent from the machine when a message	 is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	| exception resumeValue |	(Preferences autoAccessors	 and: [self tryToDefineVariableAccess: aMessage]) ifTrue:		[^aMessage sentTo: self].		(aMessage selector startsWith: 'initializer`') ifTrue: [ 		"Coerce NS3 name-managled instance initializer to un-managled NS2 couterpart so NS3 can subclass NS2."		aMessage setSelector: (aMessage selector allButFirst: 12) asSymbol.		^aMessage sentTo: self.	].	(exception := MessageNotUnderstood new)		message: aMessage;		receiver: self.	resumeValue := exception signal.	^exception reachedDefaultHandler		ifTrue: [aMessage sentTo: self]		ifFalse: [resumeValue]! !!Object methodsFor: 'printing' stamp: 'ryan 6/17/2011 16:18'!out	Transcript cr; show: self printString! !!Object methodsFor: 'testing' stamp: 'ryan 6/21/2011 09:39'!isKindOfCharacter	^false! !!Object methodsFor: 'testing' stamp: 'ryan 6/21/2011 09:39'!isKindOfCollection	^false! !!Object methodsFor: 'testing' stamp: 'ryan 6/21/2011 09:40'!isKindOfCombinatorialParser	^false! !!ClassBuilder methodsFor: 'private' stamp: 'ryan 6/17/2011 13:23'!informUserOfActivity: activity "<String>" during: aBlock	^aBlock value! !!ClassDescription methodsFor: 'instance variables' stamp: 'ryan 6/17/2011 12:55'!instVarIndexFor: instVarName	"Answer the index of the named instance variable."	| index |	index := instanceVariables == nil 		ifTrue: [0]		ifFalse: [instanceVariables indexOf: instVarName].	index == 0 ifTrue: 		[^superclass == nil 			ifTrue: [0]			ifFalse: [superclass instVarIndexFor: instVarName]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!ClassDescription methodsFor: 'instance variables' stamp: 'ryan 6/17/2011 12:55'!instVarIndexFor: instVarName ifAbsent: aBlock	"Answer the index of the named instance variable."	| index |	index := instanceVariables == nil 		ifTrue: [0]		ifFalse: [instanceVariables indexOf: instVarName].	index == 0 ifTrue: 		[^superclass == nil 			ifTrue: [aBlock value]			ifFalse: [superclass instVarIndexFor: instVarName ifAbsent: aBlock]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ryan 6/17/2011 12:56'!weakSubclassesDo: block "<[Class]>"	^nil = metadata		ifFalse: [metadata weakSubclassesOf: self do: block]! !!Class methodsFor: 'organization' stamp: 'ryan 6/17/2011 14:10'!basicCategory	^category! !!Class methodsFor: 'organization' stamp: 'ryan 6/17/2011 14:10'!basicCategory: aSymbol	category := aSymbol! !!Class methodsFor: 'NsSystem' stamp: 'ryan 7/6/2011 16:26'!mixinApply: superklass	| application |	application := self mixin apply: superklass.	application instVarAt:  5 put: (self instVarAt: 5).	application class instVarAt:  5 put: (self class instVarAt: 5).	^application! !!ClassOrganizer methodsFor: 'accessing' stamp: 'ryan 6/17/2011 15:57'!quietlyClassify: element under: heading	| oldCat newCat |	oldCat := self categoryOfElement: element.	SystemChangeNotifier uniqueInstance doSilently: [		super classify: element under: heading suppressIfDefault: true].	newCat := self categoryOfElement: element.! !!Collection methodsFor: 'testing' stamp: 'ryan 6/27/2011 13:42'!isKindOfCollection	^true! !!Color methodsFor: 'conversions' stamp: 'ryan 6/27/2011 12:44'!asColorref	"Convert the receiver into a colorref"	^(self red * 255) asInteger + ((self green * 255) asInteger << 8) + ((self blue * 255) asInteger << 16)! !!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'ryan 6/21/2011 10:19'!forMethod: aMethod "<CompiledMethod>" methodNode: methodNode "<MethodNode>"	"Uncached instance creation method for private use or for tests.	 Please consider using forMethod: instead."		|	implementationClass	|		([aMethod methodClass language isNewspeakLanguage3] ifError: [false]) ifTrue: [		implementationClass := DebuggerMethodMapForNewspeak.	] ifFalse: [		implementationClass := aMethod isBlueBookCompiled ifTrue: [			DebuggerMethodMapForBlueBookMethods		] ifFalse: [			DebuggerMethodMapForClosureCompiledMethods		]	].		^implementationClass new		forMethod: aMethod		methodNode: methodNode! !!DebuggerMethodMapForNewspeak methodsFor: 'as yet unclassified' stamp: 'ryan 6/21/2011 10:21'!forMethod: aMethod "<CompiledMethod>" methodNode: aMethodNode "<MethodNode>"	|	mixinMirror	lowLevelMethodMirror	|	super forMethod: aMethod methodNode: aMethodNode.	mixinMirror := Platform nsPlatform mirrors MixinMirror reflecting: self method methodClass mixin.	lowLevelMethodMirror := Platform nsPlatform mirrors compiler compileMethodSource: self method getSource readStream within: mixinMirror declaration.	debugInfo := lowLevelMethodMirror debugInfo.	! !!DebuggerMethodMapForNewspeak methodsFor: 'accessing' stamp: 'ryan 6/21/2011 10:11'!namedTempAt: index in: aContext	|	mapper	names	|	mapper := debugInfo mapperForContext: aContext.	names := mapper localNames.	^[mapper getValueOf: (names at: index)] ifError: ['<could not retrieve>'].		! !!DebuggerMethodMapForNewspeak methodsFor: 'accessing' stamp: 'ryan 6/21/2011 10:06'!tempNamesForContext: aContext	
	^(debugInfo mapperForContext: aContext ) localNames! !!DebuggerMethodMapForNewspeak methodsFor: 'source mapping' stamp: 'ryan 6/21/2011 10:16'!rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext	^debugInfo sourceMapping at: contextsConcretePC ifAbsent: [1 to: 2]! !!Dictionary methodsFor: 'enumerating' stamp: 'ul 9/30/2009 14:14'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."		| newCollection |	newCollection := self species new: self size.	self associationsDo: [ :each |		newCollection at: each key put: (aBlock value: each value) ].	^newCollection! !!Exception methodsFor: 'printing' stamp: 'ryan 6/22/2011 09:37'!kind	^self class name asString! !!FileDirectory class methodsFor: 'name utilities' stamp: 'ryan 6/28/2011 08:48'!startUp	"Establish the platform-specific FileDirectory subclass. Do any platform-specific startup."	self setDefaultDirectoryClass.	self setDefaultDirectory: (self dirPathFor: SmalltalkImage current imageName).	Preferences startInUntrustedDirectory 		ifTrue:[	"The SecurityManager may override the default directory to prevent unwanted write access etc."				self setDefaultDirectory: SecurityManager default untrustedUserDirectory.				"Make sure we have a place to go to"				DefaultDirectory assureExistence].	(Preferences inPackagedImage and: [SourceFiles isNil]) ifFalse:		[SmalltalkImage current openSourceFiles].! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 7/4/2011 19:50'!pushImplicitReceiverForMessage: selector	"Push Implicit Receiver for Selector bytecode."! !!InstructionStream methodsFor: 'private' stamp: 'eem 6/22/2011 18:42'!nextPc: currentByte	"Answer the pc of the next bytecode following the current one, given the current bytecode.."	| type |	type := currentByte // 16.	^type = 7		ifTrue:			[pc + (#(1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 2) at: currentByte \\ 16 + 1)]		ifFalse:			[type = 8 "extensions"					ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 2 3 3 3 4) at: currentByte \\ 16 + 1)]					ifFalse: [type = 10 "long jumps"								ifTrue: [pc + 2]								ifFalse: [pc + 1]]]! !!ContextPart methodsFor: 'debugger access' stamp: 'ryan 8/1/2011 08:55'!errorReportOn: strm        "Write a detailed error report on the stack (above me) on a stream.  For both the error file, and emailing a bug report.  Suppress any errors while getting printStrings.  Limit the length."        | cnt aContext startPos |        strm print: Date today; space; print: Time now; cr.        strm cr.        strm nextPutAll: 'VM: ';                nextPutAll:  SmalltalkImage current platformName asString;                nextPutAll: ' version ';                nextPutAll: SmalltalkImage current osVersion;                nextPutAll: ' - ';                nextPutAll: SmalltalkImage current asString;                cr.        strm nextPutAll: 'VM Name: ';                nextPutAll:  SmalltalkImage current vmVersion;                cr.        strm nextPutAll: 'Image: ';                nextPutAll:  SystemVersion current version asString;                nextPutAll: ' [';                nextPutAll: SmalltalkImage current lastUpdateString asString;                nextPutAll: ']';                cr.        strm cr.        SecurityManager default printStateOn: strm.                "Note: The following is an open-coded version of ContextPart>>stackOfSize: since this method may be called during a low space condition and we might run out of space for allocating the full stack."        cnt := 0.  startPos := strm position.        aContext := self.        [aContext notNil and: [(cnt := cnt + 1) < 20]] whileTrue:                [aContext printDetails: strm.   "variable values"                strm cr.                aContext := aContext sender].        strm cr; nextPutAll: '--- The full stack ---'; cr.        aContext := self.        cnt := 0.        [aContext == nil] whileFalse:                [cnt := cnt + 1.                cnt = 20 ifTrue: [strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; cr].                strm print: aContext; cr.  "just class>>selector"                       strm position > (startPos+40000) ifTrue: [strm nextPutAll: '...etc...'.                        ^ self].        "exit early"                cnt > 60 ifTrue: [strm nextPutAll: '-- and more not shown --'.  ^ self].                aContext := aContext sender].! !!LookupKey methodsFor: 'accessing' stamp: 'ajh 9/12/2002 12:04'!canAssign	^ true! !!LookupKey methodsFor: 'accessing'!key	"Answer the lookup key of the receiver."	^key! !!LookupKey methodsFor: 'accessing'!key: anObject 	"Store the argument, anObject, as the lookup key of the receiver."	key _ anObject! !!LookupKey methodsFor: 'accessing' stamp: 'ajh 3/24/2003 21:14'!name	^ self key isString		ifTrue: [self key]		ifFalse: [self key printString]! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:59'!beBindingOfType: aClass announcing: aBool	"Make the receiver a global binding of the given type"	| old new |	(Smalltalk associationAt: self key) == self		ifFalse:[^self error:'Not a global variable binding'].	self class == aClass ifTrue:[^self].	old _ self.	new _ aClass key: self key value: self value.	old become: new.	"NOTE: Now self == read-only (e.g., the new binding)"	^self recompileBindingsAnnouncing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadOnlyBinding	"Make the receiver (a global read-write binding) be a read-only binding"	^self beReadOnlyBindingAnnouncing: true! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadOnlyBindingAnnouncing: aBool	"Make the receiver (a global read-write binding) be a read-only binding"	^self beBindingOfType: ReadOnlyVariableBinding announcing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:50'!beReadWriteBinding	"Make the receiver (a global read-only binding) be a read-write binding"	^self beReadWriteBindingAnnouncing: true! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:51'!beReadWriteBindingAnnouncing: aBool	"Make the receiver (a global read-write binding) be a read-write binding"	^self beBindingOfType: Association announcing: aBool! !!LookupKey methodsFor: 'bindings' stamp: 'dvf 8/23/2003 11:50'!recompileBindingsAnnouncing: aBool 	"Make the receiver (a global read-write binding) be a read-only binding"	aBool 		ifTrue: 			[Utilities informUserDuring: 					[:bar | 					(self systemNavigation allCallsOn: self) do: 							[:mref | 							bar value: 'Recompiling ' , mref asStringOrText.							mref actualClass recompile: mref methodSymbol]]]		ifFalse: 			[(self systemNavigation allCallsOn: self) 				do: [:mref | mref actualClass recompile: mref methodSymbol]]! !!LookupKey methodsFor: 'comparing'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^key < aLookupKey key! !!LookupKey methodsFor: 'comparing'!= aLookupKey	self species = aLookupKey species		ifTrue: [^key = aLookupKey key]		ifFalse: [^false]! !!LookupKey methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^key hash! !!LookupKey methodsFor: 'comparing'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^key hashMappedBy: map! !!LookupKey methodsFor: 'comparing' stamp: 'di 9/27/97 20:45'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ key identityHashMappedBy: map! !!LookupKey methodsFor: 'filter streaming' stamp: 'MPW 1/1/1901 02:35'!writeOnFilterStream: aStream	aStream write:key.! !!LookupKey methodsFor: 'printing'!printOn: aStream	key printOn: aStream! !!LookupKey methodsFor: 'testing' stamp: 'ar 8/14/2001 22:39'!isVariableBinding	"Return true if I represent a literal variable binding"	^true! !!LookupKey class methodsFor: 'instance creation' stamp: 'md 6/29/2005 16:34'!key: aKey 	"Answer an instance of me with the argument as the lookup up."	^self basicNew key: aKey! !!MCPackage methodsFor: 'as yet unclassified' stamp: 'ryan 6/20/2011 09:25'!snapshot	| packageInfo definitions categories |	packageInfo := self packageInfo.	definitions := OrderedCollection new.	categories := packageInfo systemCategories.	categories isEmpty ifFalse: [ definitions add: (MCOrganizationDefinition categories: categories) ].	(packageInfo methods		reject: [:ea | [ea methodClass language isNewspeakLanguage3]ifError:[false]])		do: [:ea | definitions add: ea asMethodDefinition] displayingProgress: 'Snapshotting methods...'.	(packageInfo respondsTo: #overriddenMethods) ifTrue:		[packageInfo overriddenMethods			do: [:ea | definitions add:					(packageInfo changeRecordForOverriddenMethod: ea) asMethodDefinition]			displayingProgress: 'Searching for overrides...'].	packageInfo classes do: [:ea | definitions addAll: ea classDefinitions] displayingProgress: 'Snapshotting classes...'.	(packageInfo respondsTo: #hasPreamble) ifTrue: [		packageInfo hasPreamble ifTrue: [definitions add: (MCPreambleDefinition from: packageInfo)].		packageInfo hasPostscript ifTrue: [definitions add: (MCPostscriptDefinition from: packageInfo)].		packageInfo hasPreambleOfRemoval ifTrue: [definitions add: (MCRemovalPreambleDefinition from: packageInfo)].		packageInfo hasPostscriptOfRemoval ifTrue: [definitions add: (MCRemovalPostscriptDefinition from: packageInfo)]]. 	^ MCSnapshot fromDefinitions: definitions! !!MethodProperties methodsFor: 'accessing' stamp: 'lr 2/6/2006 19:11'!pragmas	^ pragmas! !!MethodProperties methodsFor: 'accessing' stamp: 'md 2/16/2006 17:50'!selector	^selector! !!MethodProperties methodsFor: 'accessing' stamp: 'md 2/16/2006 17:50'!selector: aSymbol	selector := aSymbol! !!MethodProperties methodsFor: 'initialization' stamp: 'lr 2/6/2006 19:12'!initialize	super initialize.	pragmas := #().! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:04'!at: aKey	"Answer the property value associated with aKey."		^ self at: aKey ifAbsent: [ self error: 'Property not found' ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:07'!at: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		properties isNil ifTrue: [ ^ aBlock value ].	^ properties at: aKey ifAbsent: aBlock.! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 20:47'!at: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self at: aKey ifAbsent: [ self at: aKey put: aBlock value ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:06'!at: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	properties ifNil: [ properties :=  IdentityDictionary new ].	^ properties at: aKey put: anObject.! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:11'!includesKey: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 20:48'!removeKey: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeKey: aKey ifAbsent: [ self error: 'Property not found' ].! !!MethodProperties methodsFor: 'properties' stamp: 'lr 2/6/2006 19:07'!removeKey: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer.! !!MethodProperties methodsFor: 'private' stamp: 'lr 2/6/2006 20:36'!addPragma: aPragma	pragmas := pragmas copyWith: aPragma.! !!MethodProperties methodsFor: 'testing' stamp: 'ryan 6/17/2011 15:49'!isEmpty	^true "just a selector"! !!MethodProperties methodsFor: 'testing' stamp: 'md 2/19/2006 11:24'!isMethodProperties	^true! !!MethodProperties methodsFor: 'copying' stamp: 'md 3/1/2006 15:30'!postCopy	properties := properties copy.	pragmas := pragmas copy.! !!MethodReference methodsFor: '*Kernel-Traits' stamp: 'ryan 6/22/2011 15:00'!actualClass 	| actualClass |	"This won't return a valid class if classSymbol references a mixin application. This is on purpose to eliminate the need to filter out duplicate method references later on. Not sure whether this is the right approach, though."	actualClass := [(Smalltalk at: #SystemMetadata) classNamed: classSymbol inNamespace: Smalltalk]		on: Error		do: [actualClass := Smalltalk at: classSymbol ifAbsent: [^nil]].	classIsMeta ifTrue: [^actualClass classSide].	^actualClass! !!MethodReference methodsFor: 'testing' stamp: 'ryan 6/20/2011 09:27'!isValid	"Answer whether the receiver represents a current selector or Comment"	| aClass |	methodSymbol isDoIt ifTrue: [^ false].	(aClass := self actualClass) ifNil: [^ false].	([self compiledMethod isSynthetic] ifError: [false]) ifTrue: [^false].	^ (aClass includesSelector: methodSymbol) or:		[methodSymbol == #Comment]! !!Morph methodsFor: 'event handling' stamp: 'ryan 6/28/2011 08:58'!yellowButtonActivity: shiftState 	"Find me or my outermost owner that has items to add to a  	yellow button menu.  	shiftState is true if the shift was pressed.  	Otherwise, build a menu that contains the contributions from  	myself and my interested submorphs,  	and present it to the user."	| menu |	self isWorldMorph		ifFalse: [| outerOwner | 			outerOwner := self outermostOwnerWithYellowButtonMenu.			outerOwner				ifNil: [^ self].			outerOwner == self				ifFalse: [^ outerOwner yellowButtonActivity: shiftState]].	Preferences inPackagedImage ifTrue:		[^self].	menu := self buildYellowButtonMenu: ActiveHand.	menu		addTitle: self externalName		icon: (self iconOrThumbnailOfSize: (Preferences tinyDisplay ifTrue: [16] ifFalse: [28])).	menu popUpInWorld: self currentWorld! !!Morph methodsFor: 'halos and balloon help' stamp: 'ryan 6/28/2011 08:57'!addHalo: evt	| halo prospectiveHaloClass |	^Preferences inPackagedImage ifFalse:		[prospectiveHaloClass := Smalltalk at: self haloClass ifAbsent: [HaloMorph].		halo := prospectiveHaloClass new bounds: self worldBoundsForHalo.		halo popUpFor: self event: evt.		halo]! !!Morph methodsFor: 'meta-actions' stamp: 'ryan 6/28/2011 08:57'!invokeMetaMenu: evt	| menu |	Preferences inPackagedImage ifFalse:		[menu := self buildMetaMenu: evt.		menu addTitle: self externalName.		self world ifNotNil: [menu popUpEvent: evt in: self world]]! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'ryan 8/1/2011 08:12'!tabHitWithEvent: anEvent! !!MultiByteBinaryOrTextStream methodsFor: 'accessing' stamp: 'ryan 6/22/2011 11:39'!collection	^collection! !!Number methodsFor: 'arithmetic' stamp: 'ryan 6/17/2011 15:08'!** n	^self raisedToInteger: n! !!PackageInfo methodsFor: 'dependencies' stamp: 'ryan 7/25/2011 14:05'!externalClassesAndMetaclasses	| myClasses |	myClasses := self classesAndMetaClasses.	^ Array streamContents:		[:s |		Class rootsOfTheWorld do:			[:root |			 root withAllSubclassesDo:				[:class |				class isMeta ifFalse:					[(myClasses includes: class) ifFalse:						[s nextPut: class; nextPut: class class]]]]]! !!PackageInfo methodsFor: 'dependencies' stamp: 'ryan 7/25/2011 14:06'!externalRefsSelect: selBlock thenCollect: colBlock	| pkgMethods dependents extMethods otherClasses otherMethods classNames |	classNames := self classes collect: [:c | c name].	extMethods := self extensionMethods collect: [:mr | mr methodSymbol].	otherClasses := self externalClassesAndMetaclasses difference: self externalSubclasses.	otherMethods :=  otherClasses gather: [:c | c selectors].	pkgMethods := self methods asSet collect: [:mr | mr methodSymbol].	pkgMethods removeAllFoundIn: otherMethods.	dependents := Set new.	otherClasses do: [:c |		c selectorsAndMethodsDo:			[:sel :compiled |			| refs |			(extMethods includes: sel) ifFalse: 				[refs := compiled literals select: selBlock thenCollect: colBlock.				refs do: [:ea |					((classNames includes: ea) or: [pkgMethods includes: ea])							ifTrue: [dependents add: (self referenceForMethod: sel ofClass: c) -> ea]]]]].	^ dependents! !!PackageInfo methodsFor: 'listing' stamp: 'ryan 6/20/2011 09:23'!classes				^ (self systemCategories gather: [ :cat |	(SystemOrganization listAtCategoryNamed: cat)		gather: [ :className | | classes |			classes := OrderedCollection new.			Smalltalk at: className ifPresent: [ :c | classes add: c]. 			classes		]	]) sortBy: [:a :b | a className <= b className].! !!PackageInfo methodsFor: 'modifying' stamp: 'ryan 7/25/2011 14:06'!externalBehaviors	^self externalClassesAndMetaclasses , self externalTraits! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'ryan 6/28/2011 08:56'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down"	Preferences inPackagedImage ifTrue:		[^self yellowButtonNoviceMenu].	^ SelectionMenu fromArray: StringHolder shiftedYellowButtonMenuItems! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'ryan 6/28/2011 08:56'!yellowButtonMenu	^(Preferences noviceMode or: [Preferences inPackagedImage])		ifTrue: [self yellowButtonNoviceMenu]		ifFalse: [self yellowButtonExpertMenu]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ryan 6/28/2011 08:59'!putUpNewMorphMenu	"Put up the New Morph menu in the world"	Preferences inPackagedImage ifFalse:		[TheWorldMenu new adaptToWorld: self; newMorph]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ryan 6/28/2011 09:00'!putUpWorldMenuFromEscapeKey	(Preferences noviceMode or: [Preferences inPackagedImage]) ifFalse:		[self putUpWorldMenu: ActiveEvent]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ryan 6/28/2011 09:00'!putUpWorldMenu: evt	"Put up a menu in response to a click on the desktop, triggered by evt."	| menu |	self bringTopmostsToFront.	evt isMouse ifTrue:		[evt yellowButtonPressed ifTrue:			[^self yellowButtonClickOnDesktopWithEvent: evt].		evt shiftPressed ifTrue:			[Preferences inPackagedImage ifTrue:				[^self].			 ^self findWindow: evt]].	Preferences inPackagedImage ifTrue:		[^self].	"put up screen menu"	menu := self buildWorldMenu: evt.	menu addTitle: Preferences desktopMenuTitle translated.	menu popUpEvent: evt in: self.	^ menu! !!Preferences class methodsFor: 'standard queries' stamp: 'ryan 6/28/2011 08:45'!inPackagedImage	^ self		valueOfFlag: #inPackagedImage		ifAbsent: [false]! !!Project methodsFor: 'accessing' stamp: 'ryan 6/20/2011 11:15'!uiManager: m	uiManager := m! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ajh 9/12/2002 12:06'!canAssign	^ false! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/14/2001 23:09'!value	^value! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/17/2001 18:03'!value: aValue	(AttemptToWriteReadOnlyGlobal signal: 'Cannot store into read-only bindings') == true ifTrue:[		value _ aValue.	].! !!ReadOnlyVariableBinding methodsFor: 'testing' stamp: 'ar 8/14/2001 23:08'!isSpecialWriteBinding	"Return true if this variable binding is write protected, e.g., should not be accessed primitively but rather by sending #value: messages"	^true! !!ReadOnlyVariableBinding methodsFor: 'private' stamp: 'ar 8/14/2001 23:11'!privateSetKey: aKey value: aValue	key _ aKey.	value _ aValue! !!ReadOnlyVariableBinding methodsFor: 'printing' stamp: 'GB 5/8/2007 10:44'!printOn: aStream 	super printOn: aStream. 	aStream nextPutAll: '->'.	value printOn: aStream! !!ReadOnlyVariableBinding class methodsFor: 'instance creation' stamp: 'ar 8/14/2001 23:11'!key: key value: aValue	^self new privateSetKey: key value: aValue! !!RemoteString methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:32'!fileStream 	"Answer the file stream with position set at the beginning of my string"	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile := SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile! !!RemoteString methodsFor: 'accessing' stamp: 'nk 11/26/2002 12:05'!last	^self string ifNotNilDo: [ :s | s last ]! !!RemoteString methodsFor: 'accessing'!position 	"Answer the location of the string on a file."	^ filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:31'!setSourcePointer: aSourcePointer	sourceFileNumber := SourceFiles fileIndexFromSourcePointer: aSourcePointer.	filePositionHi := SourceFiles filePositionFromSourcePointer: aSourcePointer! !!RemoteString methodsFor: 'accessing'!sourceFileNumber	"Answer the index of the file on which the string is stored."	^sourceFileNumber! !!RemoteString methodsFor: 'accessing' stamp: 'hmm 4/26/2000 20:47'!sourcePointer	sourceFileNumber ifNil: [^ 0].	^SourceFiles sourcePointerFromFileIndex: sourceFileNumber andPosition: filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:31'!string 	"Answer the receiver's string if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^''].	theFile := SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunk! !!RemoteString methodsFor: 'accessing' stamp: 'ls 9/4/2003 12:37'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	theFile position > theFile size ifTrue: [		self error: 'RemoteString past end of file' ].	^ theFile nextChunkText! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:31'!checkSum: aString	"Construct a checksum of the string.  A three byte number represented as Base64 characters."| sum shift bytes ss bb |sum := aString size.shift := 0.aString do: [:char |	(shift := shift + 7) > 16 ifTrue: [shift := shift - 17].		"shift by 7 to keep a change of adjacent chars from xoring to same value"	sum := sum bitXor: (char asInteger bitShift: shift)].bytes := ByteArray new: 3.sum := sum + 16r10000000000.1 to: 3 do: [:ind | bytes at: ind put: (sum digitAt: ind)].ss := ReadWriteStream on: (ByteArray new: 3).ss nextPutAll: bytes.bb := Base64MimeConverter mimeEncode: ss.^ bb contents! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:32'!fileNumber: fileNumber position: position 	sourceFileNumber := fileNumber.	filePositionHi := position! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:31'!makeNewTextAttVersion	"Create a new TextAttributes version because some inst var has changed.  If no change, don't make a new one."	"Don't delete this method even though it has no callers!!!!!!!!!!"| obj cls struct tag |"Note that TextFontReference and TextAnchor are forbidden."obj := #(RunArray TextDoIt TextLink TextURL TextColor TextEmphasis TextFontChange TextKern TextLinkToImplementors 3 'a string') collect: [:each | 		cls := Smalltalk at: each ifAbsent: [nil].		cls ifNil: [each] ifNotNil: [cls new]].struct := (SmartRefStream on: (RWBinaryOrTextStream on: String new)) instVarInfo: obj.tag := self checkSum: struct printString.TextAttributeStructureVersions ifNil: [TextAttributeStructureVersions := Dictionary new].(struct = CurrentTextAttStructure) & (tag = CurrentTextAttVersion) 	ifTrue: [^ false].CurrentTextAttStructure := struct.CurrentTextAttVersion := tag.TextAttributeStructureVersions at: tag put: struct.^ true! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:32'!string: aString onFileNumber: fileNumber	"Store this as my string if source files exist."	| theFile |	(SourceFiles at: fileNumber) == nil ifFalse: 		[theFile := SourceFiles at: fileNumber.		theFile setToEnd; cr.		self string: aString onFileNumber: fileNumber toFile: theFile]! !!RemoteString methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:31'!string: aStringOrText onFileNumber: fileNumber toFile: aFileStream 	"Store this as the receiver's text if source files exist. If aStringOrText is a Text, store a marker with the string part, and then store the runs of TextAttributes in the next chunk."	| position |	position := aFileStream position.	self fileNumber: fileNumber position: position.	aFileStream nextChunkPutWithStyle: aStringOrText	"^ self		(important)"! !!RemoteString class methodsFor: 'as yet unclassified' stamp: 'tk 12/12/97 11:46'!currentTextAttVersion	"The current configuration of the TextAttributes classes has a structures array describing the inst vars of the classes (SmartRefStream instVarInfo:).  Return tag that indexes the TextAttributeStructureVersions dictionary (4 random characters)."	^ CurrentTextAttVersion	"Be sure to run makeNewTextAttVersion when any TextAttributes class changes inst vars"! !!RemoteString class methodsFor: 'as yet unclassified' stamp: 'tk 12/11/97 10:35'!initialize	"Derive the current TextAttributes classes object structure"	self new makeNewTextAttVersion! !!RemoteString class methodsFor: 'as yet unclassified'!newFileNumber: sourceIndex position: anInteger 	"Answer an instance of me fora file indexed by sourceIndex, at the 	position anInteger. Assume that the string is already stored on the file 	and the instance will be used to access it."	^self new fileNumber: sourceIndex position: anInteger! !!RemoteString class methodsFor: 'as yet unclassified'!newString: aString onFileNumber: sourceIndex 	"Answer an instance of me for string, aString, on file indexed by 	sourceIndex. Put the string on the file and create the remote reference."	^self new string: aString onFileNumber: sourceIndex! !!RemoteString class methodsFor: 'as yet unclassified'!newString: aString onFileNumber: sourceIndex toFile: aFileStream	"Answer an instance of me for string, aString, on file indexed by 	sourceIndex. Put the string on the file, aFileStream, and create the 	remote reference. Assume that the index corresponds properly to 	aFileStream."	^self new string: aString onFileNumber: sourceIndex toFile: aFileStream! !!RemoteString class methodsFor: 'as yet unclassified' stamp: 'tk 12/13/97 13:36'!structureAt: styleVersion	^ TextAttributeStructureVersions at: styleVersion ifAbsent: [nil]! !!SequenceableCollection methodsFor: 'testing' stamp: 'ryan 6/17/2011 14:12'!endsWith: aSequenceableCollection	| start |	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	start _ self size - aSequenceableCollection size.	aSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].	^true! !!SequenceableCollection methodsFor: 'testing' stamp: 'ryan 6/17/2011 14:12'!startsWith: start 	| comp |	self size < start size ifTrue: [^ false].	comp := true.	(self first: start size) with: start		do: [:ea :ea2 | ea = ea2 ifFalse: [comp := false]].	^ comp! !!Array methodsFor: 'converting' stamp: 'ryan 6/17/2011 15:56'!elementsForwardIdentityToEvenIfImmutable: otherArray	"This primitive performs a bulk mutation, causing all pointers to the	 elements of this array to be replaced by pointers to the corresponding	 elements of otherArray.  The identityHashes remain with the pointers	 rather than with the objects so that the objects in this array should	 still be properly indexed in any existing hashed structures after the	 mutation.  This version will succeed, even if any element of the receiver	 or otherArray is immutable.  See elementsForwardIdentityWith: for a	 more cautious approach."	<primitive: 161 error: ec>	"Backward compatibility.  If the VM doesnt implement this primitive	 then it doesnt support immutability.  So invoke the older version of	 the primitive."	^self elementsForwardIdentityTo: otherArray! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ryan 7/1/2011 08:09'!methodNode	"Return the parse tree that represents self. If parsing fails, decompile the method."	| aClass source |	(self properties includesKey: #methodNode)		ifTrue: [^self properties at: #methodNode].	aClass := self methodClass.	source := self				getSourceFor: (self selector ifNil: [self defaultSelector])				in: aClass.	^[(aClass parserClass new		encoderClass: (self isBlueBookCompiled						ifTrue: [EncoderForV3]						ifFalse: [EncoderForV3PlusClosures]);		parse: source class: aClass)			sourceText: source;			yourself]		on: SyntaxErrorNotification		do: [:ex | ex return: self decompile].! !!CompiledMethod methodsFor: 'printing' stamp: 'ryan 6/20/2011 10:28'!methodClass: aClassOrNil	"set the class binding in the last literal to aClass"	self literalAt: self numLiterals put: (aClassOrNil ifNotNil: [aClassOrNil binding])! !!CompiledMethod methodsFor: 'source code management' stamp: 'ryan 7/1/2011 08:08'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| trailer source |	(self properties includesKey: #source) ifTrue:		[^self properties at: #source].	trailer := self trailer.	trailer tempNames ifNotNil: [:namesString | 		"Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: namesString)				decompile: selector in: class method: self)			decompileString].		trailer sourceCode ifNotNil: [:code | ^ code ].		trailer hasSourcePointer ifFalse: [		"No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"	source := [self getSourceFromFileAt: trailer sourcePointer]				on: Error		"An error can happen here if, for example, the changes file has been truncated by an aborted download.  The present solution is to ignore the error and fall back on the decompiler.  A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling into this error case, random source code will get returned."				do: [ :ex | ex return: nil].			^source ifNil: [			"Something really wrong -- decompile blind (no temps)"			 (class decompilerClass new decompile: selector in: class method: self)				decompileString]! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ryan 6/22/2011 16:24'!condenseChanges	"Move all the changes onto a compacted sources file."	"Smalltalk condenseChanges"	| f oldChanges count |	f := FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.		'Condensing Changes File...'		displayProgressAt: Sensor cursorPoint		from: 0		to: self classNames size		during: [:bar | 			count := 0.			self				allClassesDo: [:cls | 					bar value: (count := count + 1).					self copySourcesOf: cls into: f.]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges := SourceFiles at: 2.	oldChanges close.	FileDirectory default deleteFileNamed: oldChanges name , '.old';		 rename: oldChanges name toBe: oldChanges name , '.old';		 rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles		at: 2		put: (StandardFileStream oldFileNamed: oldChanges name)! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ryan 6/22/2011 16:24'!copySourcesOf: cls into: f	cls moveChangesTo: f.	cls putClassCommentToCondensedChangesFile: f.	cls classSide moveChangesTo: f.					cls language isNewspeakLanguage3 ifTrue: [		(DefiningClassMetadata of: cls) nestedClasses			do: [:inner | self copySourcesOf: inner into: f]].! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'ryan 7/26/2011 14:09'!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: '----';			nextPutAll: (save ifTrue: [ quit ifTrue: [ 'QUIT' ] ifFalse: [ 'SNAPSHOT' ] ]							ifFalse: [quit ifTrue: [ 'QUIT/NOSAVE' ] ifFalse: [ 'NOP' ]]);			nextPutAll: '----';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: ' priorSource: ';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [[				resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				"resuming can be:					true if we are starting from a saved image.					false if we are continuing after saving an image.					nil if the snapsnot primitive failed"							] valueUnpreemptively.				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	Project current wakeUpTopWindow.	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'ryan 6/28/2011 09:02'!openSourceFiles	Preferences inPackagedImage ifTrue: [^self].	self imageName = LastImageName ifFalse:		["Reset the author initials to blank when the image gets moved"		LastImageName := self imageName.		Utilities setAuthorInitials: ''].	FileDirectory		openSources: self sourcesName		andChanges: self changesName		forImage: LastImageName.	SourceFileArray install! !!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ryan 6/17/2011 13:50'!associations	^globals associations! !!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ryan 6/22/2011 11:38'!values	^globals values! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ryan 6/22/2011 12:46'!buildPatchSequenceKeepCr	"Newer versions of TextDiffBuilder drop CRs from the result"	^Array streamContents: [ :stream |		self 			patchSequenceDoIfMatch: [ :string |				stream nextPut: #match -> string]			ifInsert: [ :string | 				stream nextPut: #insert -> string ]			ifRemove: [ :string | 				stream nextPut: #remove -> string]]! !!TextEditor methodsFor: 'menu messages' stamp: 'ryan 7/5/2011 10:09'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol := self selectedSymbol) isNil ifTrue: [^ morph flash].	aSymbol first isUppercase		ifTrue:			[anEntry := (Smalltalk				at: aSymbol				ifAbsent:					[ self systemNavigation browseAllImplementorsOf: aSymbol.					^ nil]).			anEntry isNil ifTrue: [^ morph flash].			(anEntry isKindOf: Class)				ifFalse:	[anEntry := anEntry class].			ToolSet browse: anEntry selector: nil]		ifFalse:			[self systemNavigation browseAllImplementorsOf: aSymbol]! !!UIManager class methodsFor: 'class initialization' stamp: 'ryan 6/20/2011 11:15'!default: d	^ Project current uiManager: d! !!UUID class methodsFor: 'instance creation' stamp: 'ryan 6/17/2011 12:54'!fromString: aString	| object |	(aString includes: $@) ifTrue: [		^self fromString: (aString copyFrom: (aString indexOf: $')+1 to: (aString lastIndexOf: $')-1)	].	aString size ~= 36 ifTrue: [Error signal].	object := self nilUUID. 	object asUUID: aString.	^object! !!Utilities class methodsFor: 'identification' stamp: 'ryan 6/28/2011 09:02'!setAuthorInitials: aString	(aString isEmpty and: [ Preferences inPackagedImage ]) ifTrue: [^self].		AuthorInitials := aString.	"Case of being reset due to, eg, copy of image."	aString isEmpty ifTrue: [AuthorName := '']! !!Warning methodsFor: 'exceptionDescription' stamp: 'ryan 6/28/2011 08:46'!defaultAction	"The user should be notified of the occurrence of an exceptional occurrence and given an option of continuing or aborting the computation. The description of the occurrence should include any text specified as the argument of the #signal: message."		Preferences inPackagedImage ifTrue:		[Transcript cr; show: self messageText.		self resume].		ToolSet		debugContext: thisContext		label: 'Warning'		contents: self messageText, '\\Select Proceed to continue, or close this window to cancel the operation.' withCRs.	self resume.! !RemoteString initialize!PackageInfo removeSelector: #externalClasses!!Class reorganize!('initialize-release' deactivate declare: obsolete removeFromSystem removeFromSystemUnlogged removeFromSystem: sharing: superclass:methodDictionary:format: superclass:methodDict:format:name:organization:instVarNames:classPool:sharedPools: unload)('accessing' classPool classPoolFrom: classPool: name)('accessing class hierarchy' addSubclass: removeSubclass: subclasses subclassesDoGently: subclassesDo: weakSubclassesDo:)('testing' hasMethods isObsolete isSystemDefined officialClass)('class name' externalName nameForViewer rename:)('class variables' addClassVarName: allClassVarNames classVarNames ensureClassPool removeClassVarName:)('compiling' binding bindingOf: canFindWithoutEnvironment: compileAll compileAllFrom: possibleVariablesFor:continuedFrom:)('copying' copy)('fileIn/Out' fileOut fileOutAsHtml: fileOutInitializerOn: fileOutOn:moveSource:toFile: fileOutOn:moveSource:toFile:initializing: fileOutPool:onFileStream: fileOutSharedPoolsOn: objectForDataStream: reformatAll removeFromChanges shouldFileOutPools shouldFileOutPool: storeDataOn: withClassVersion:)('instance variables' addInstVarName: removeInstVarName:)('organization' basicCategory basicCategory: category category: environment environment:)('pool variables' addSharedPool: allSharedPools removeSharedPool: sharedPools sharedPools:)('subclass creation' newSubclass subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: subclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: variableByteSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: variableSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: variableWordSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category: weakSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: weakSubclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category:)('private' setName: spaceUsed)('*monticello' asClassDefinition classDefinitions poolDictionaryNames)('*Etoys-class name' uniqueNameForReference)('*HelpSystem-Core' asHelpTopic)('NsSystem' mixinApply:)('*NsSystem')!